/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

void clearWeaponData(void);
void clearItemData(void);
int __cdecl addWeapon(int weaponID, int weaponMaxAmmo); // idb
int __cdecl loseWeapon(int lostWeapon); // idb
signed int __cdecl tradeWeapon(int lostWeapon, int newWeapon, int newWeaponMaxAmmo); // idb
signed int __cdecl addItemData(int itemCode); // idb
signed int __cdecl subItemData(int itemCode); // idb
int moveInventoryCursor();
void drawInventoryWindow();
signed int inventoryLoop();
signed int __cdecl checkForItem(int item); // idb
signed int __cdecl checkForWeapon(int checkedWeapon); // idb
signed int __cdecl useAmmo(int ammoToRemove); // idb
int __cdecl addAmmo(int addedAmmo);
void __cdecl fillWeaponAmmo();
weapons switchWeaponForward();
weapons switchWeaponBackwards();
void resetSelectedWeapon();
signed int __cdecl initBackground(char *stageName, int Mode); // idb
void __cdecl updateBackground();
void __cdecl drawBackground(signed int cameraXPos, signed int cameraYPos);
void __cdecl drawForeground(signed int cameraXPos, signed int cameraYPos);
signed int __cdecl checkStarblockBreak(int blockXPos, int blockYPos, Bullet *bullet); // idb
int __cdecl solidTileTwoStageFilterThing(int a1, int a2, _BYTE *a3, Bullet *a4); // idb
void __cdecl makeSoundAndEffectOnHitWall(Bullet *bullet); // idb
signed int __cdecl bulletTileCollisionRoofSlope1(int a1, int a2, Bullet *bullet); // idb
signed int __cdecl bulletTileCollisionRoofSlope2(int a1, int a2, Bullet *bullet); // idb
signed int __cdecl bulletTileCollisionRoofSlope3(int a1, int a2, Bullet *bullet); // idb
signed int __cdecl bulletTileCollisionRoofSlope4(int a1, int a2, Bullet *bullet); // idb
signed int __cdecl bulletTileCollisionFloorSlope1(int a1, int a2, Bullet *bullet); // idb
signed int __cdecl bulletTileCollisionFloorSlope2(int a1, int a2, Bullet *bullet); // idb
signed int __cdecl bulletTileCollisionFloorSlope3(int a1, int a2, Bullet *bullet); // idb
signed int __cdecl bulletTileCollisionFloorSlope4(int a1, int a2, Bullet *bullet); // idb
void bulletTileCollisionAlgorithm();
int resetWeapons();
int __cdecl countBullets(bullets weaponID); // idb
int __cdecl countShots(int ShotID); // idb
int __cdecl deleteBullet(int bulletID); // idb
void __cdecl resetBullets();
int __cdecl renderBullets(signed int cameraXPos, signed int cameraYPos); // idb
void __cdecl createBullet(bullets BulletID, int XPos, int YPos, Directions Direction);
void __cdecl bullet1_Level1Snake(Bullet *bullet);
void __cdecl bullet2_3_SnakeLevel2_3(Bullet *bullet, int level);
void __cdecl bullet4_5_6_PolarStar(Bullet *Bullet, int Level);
void __cdecl bullet7_8_9_Fireball(Bullet *Bullet, int Level); // idb
void __cdecl bulletA_B_C_MachineGun(Bullet *Bullet, int Level); // idb
void __cdecl bulletD_E_F_MissileLauncher(Bullet *bullet, int level); // idb
Bullet *__cdecl bullet10_11_12_MissileExplosion(Bullet *bullet, int level); // idb
void __cdecl bullet13_BubblerLevel1(Bullet *bullet); // idb
void __cdecl bullet14_BubllerLevel2(Bullet *bullet); // idb
void __cdecl bullet15_BubblerLevel3(Bullet *bullet); // idb
void __cdecl bullet16_BubblerSpurs(Bullet *bullet); // idb
void __cdecl bullet19_BladeLevel1(Bullet *bullet); // idb
void __cdecl bullet1A_BladeLevel2(Bullet *bullet); // idb
void __cdecl bullet1B_BladeLevel3(Bullet *bullet);
void __cdecl bullet17_BladeSlash(Bullet *bullet);
void __cdecl bullet18_Unused(Bullet *npc);
void __cdecl bullet1C_1D_1E_SuperMissileLauncher(Bullet *bullet, int level);
Bullet *__cdecl bullet1F_20_21(Bullet *bullet, int level); // idb
void __cdecl bullet22_23_24_2B_Nemesis(Bullet *bullet, int level); // idb
void __cdecl bullet25_26_27_ChargelessSpur(Bullet *bullet, int level);
void __cdecl bullet28_29_2A_NonMovingSpur(Bullet *bullet, int level);
void __cdecl bullet2C_SpurLevel2(Bullet *bullet);
void __cdecl bullet2D_SpurLevel3(Bullet *bullet);
void __cdecl runBulletCode();
signed int isSomeBulletActive();
void __cdecl initEffects();
// void __cdecl effect0_Nothing(Effect *bullet);
void __cdecl effect1_RandomFountainPulsingDiscParticles(Effect *effect);
void __cdecl effect2_RisingDiscAndExplodingDiamond(Effect *Effect_Vars);
void __cdecl effect3_Star(Effect *effect);
void __cdecl effect4_FireballImpact(Effect *effect);
void __cdecl effect5_ZzZ(Effect *effect);
void __cdecl effect6_BoosterSmoke(Effect *effect);
void __cdecl effect7_DrownedQuote(Effect *effect);
void __cdecl effect8_ExclamationMark(Effect *effect);
void __cdecl effect9_LevelUpOrDown(Effect *effect);
void __cdecl effect10_RedDamageRings(Effect *effect);
void __cdecl effect11_BigExplosion(Effect *effect);
void __cdecl effect12_HeadbumpSparks(Effect *effect);
void __cdecl effect13_UnknownUnused(Effect *effect);
void __cdecl effect14_SmallWhiteExplosionDisc(Effect *effect);
void __cdecl effect15_Nothing(Effect *effect);
void __cdecl effect16_PushJumpKey(Effect *effect);
void __cdecl updateEffects();
void __cdecl drawEffects(signed int cameraXPos, signed int cameraYPos);
void __cdecl createEffect(int XPos, int YPos, EffectNames effectID, Directions effectDirection);
int __cdecl loadConfigData(configDataFile *config); // idb
void __cdecl setDefaultConfigData(configDataFile *config);
signed int __stdcall aboutDialog(HWND windowHandle, UINT message, WPARAM wParam, LPARAM lParam); // idb
signed int __stdcall muteButton(HWND windowHandle, UINT message, WPARAM wParam, LPARAM lParam); // idb
signed int __stdcall debugSaveButton(HWND windowHandle, UINT message, WPARAM wParam, LPARAM lParam); // idb
signed int __stdcall yesNoDialog(HWND windowHandle, int message, WPARAM wParam, const CHAR *lpString);
void __cdecl changeScreenOffsets(int newScreenOffsetY, int newScreenOffsetX);
int __cdecl drawWindow(HWND windowHandle); // idb
void __cdecl initDirectDraw(HWND windowHandle, int mode, int bitsPerPixel);
void __cdecl deleteDirectDraw(HWND windowHandle);
void __cdecl destroyBitmapObjectsMaybe(int a1);
int __cdecl makeSurfaceFromResource(char *ptrGraphic, int graphicID); // idb
int __cdecl makeSurfaceFromFile(char *surfaceName, int destination); // idb
int __cdecl loadBMPFromResourceOntoExistingSurface(char *, int); // idb
int __cdecl reloadBitmapFromFile(char *surfaceName, int destination); // idb
signed int __cdecl makeBlankSurface(int a1, int a2, signed int a3, int a4); // idb
int __cdecl backupSurface(int DstRect, RECT *rect); // idb
void __cdecl drawBitmapWithTransparency(RECT *rectView, int XPos, int YPos, RECT *rect, int GraphicsID);
int __cdecl drawSpriteNoTransparency(RECT *Dst_Rects, int X_Position, int Y_Position, RECT *Src_Rects, int);
int __cdecl drawSpriteOntoSurface(LONG a1, LONG a2, RECT *a3, int a4, int a5); // idb
int __cdecl makeRGB(COLORREF color);
void __cdecl drawColorFill(RECT *rect, int Mask_Color);
void __cdecl drawColorFillOntoSurface(RECT *rect, int column, int surface);
signed int return1();
int regenerateSurfaces();
void __cdecl initFontObject(LPCSTR a1);
int __cdecl Draw_String(int a1, int a2, const char *String, COLORREF String_Color);
int __cdecl drawStringOntoSurface(int XPos, int YPos, char *string, COLORREF color, int DDrawThingy); // idb
// bool deleteFontObject();
int scrollCreditsText();
int drawFromSlot0x25CreditsTextMaybe();
int __cdecl Print_Text_Maybe(int, int, char *, int); // idb
int drawsSomeText();
int slideCreditsPicture();
void drawCreditsImage();
void __cdecl loadCreditsIllustration(int illustrationNumber);
void __cdecl initCreditScript();
void deleteCreditScript();
signed int startCreditsScript();
void creditsRelatedMaybe();
void Credits_Related_2_Maybe();
int __cdecl Credits_Related_3_Maybe(int a1);
void __cdecl setCreditIllustration(int num);
void cutCreditIllustration();
int __cdecl sceneIslandCrash(HWND hWnd, int mode); // idb
int __cdecl callOnEscape(HWND hWnd); // idb
void __cdecl initFade();
// void __cdecl setFadeMask(); idb
void resetFadeVars();
void __cdecl startFadeOut(char Direction);
void __cdecl startFadeIn(char Direction);
void __cdecl processFade();
void drawFadeOutIn();
bool getFadeMode();
void *clearEventFlags();
void *__cdecl initSkipFlags();
void __cdecl Set_NPC_Flag(signed int Flag_Num);
void __cdecl unsetNPCFlag(signed int Flag_To_Unset);
bool __cdecl getNPCFlag(signed int Flag_hashtag);
void __cdecl setSkipFlag(signed int Flag_To_Set);
int __cdecl unsetSkipFlag(signed int Flag_To_Unset);
bool __cdecl getSkipFlag(signed int a1);
// void __cdecl initFlash();
void __cdecl startFlash(int X_Pos, int Y_Pos, int mode);
int __cdecl updateBossExplosion(int a1, int a2);
int TSC_FLA_Handler();
int __cdecl mainWhiteScreenHandler(int a1, int a2);
void drawBossExplosion();
// void resetFlash();
void __cdecl updateCamera();
void __cdecl getCameraPosition(int *XPosDest, int *YPosDest);
int __cdecl cameraUpdate(signed int a1, int arg4);
void __cdecl setCameraQuote();
void __cdecl setCameraTargetQuote(int Ticks);
void __cdecl setCameraMoveTicks(int event, int Move_Ticks);
void __cdecl TSC_FOB(int BossNum, int moveTicks);
void __cdecl setQuake(int Duration);
void __cdecl setHardQuakeDuration(int Duration);
void resetQuake();
int __cdecl random(signed int Minimum, signed int Maximum); // idb
void __cdecl drawNumbers(int XPos, int YPos, int numberToDisplay, int numberOfDigits); // idb
int __cdecl gameModeSelector(HWND hWnd); // idb
signed int gameModeOpeningCutscene();
signed int gameModeTitleScreen();
signed int __cdecl gameModeMainGame(HWND hWnd);
int __cdecl getBuildData(int *a1, _DWORD *a2, int *a3); // idb
int __cdecl getVersionNumber(int *, int *, int *, int *);
bool __cdecl openSndVol32(HWND windowHandle); // idb
BOOL deleteDebugTxt();
signed int __cdecl debugPrint(int a1, int a2, int a3, int a4);
int __cdecl getDateLimit(PSCOPETABLE_ENTRY *System_Time_1, int); // idb
signed int __cdecl doesFileExist(const char *fileName); // idb
int __cdecl getFileSize(char *path);
int __cdecl logError(char *Error_String, int Error_Number);
bool __cdecl isShiftJIS(unsigned __int8 a1);
BOOL __cdecl centerWindow(HWND Window_Handle);
int __cdecl Load_Window_Rects(HWND Window_Handle, int, int); // idb
int __cdecl saveWindowRectFile(HWND hWnd, const char *fileName); // idb
BOOL __cdecl isEnableBitmap(char *filename);
signed int loadInitialResources();
int activateDirectInput();
signed int __cdecl releaseDirectInput(int a1);
bool __cdecl initDirectInput(HINSTANCE currentInstance, HWND windowHandle); // idb
signed int __cdecl directInputSomething(HWND windowHandle); // idb
signed int __stdcall enumDevicesCallback(int a1, int a2);
signed int __cdecl getJoystickStatus(int a1);
signed int ResetJoystickStatus();
void __cdecl getKeys();
BOOL __cdecl setWindowTitle(HWND hWnd);
void displayFPSCounter();
int countFPS();
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd); // idb
void windowFocusLost();
void windowFocusGained();
signed int __cdecl loadDroppedProfile(int a1, HDROP a2);
LRESULT __stdcall windowProcedure(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam); // idb
signed int messageQueue(void); // idb
signed int joyStickProcedure();
signed int initMapData();
signed int __cdecl loadMapData(char *path_map); // idb
signed int __cdecl loadAttributeData(char *stageName); // idb
void deleteMapData();
// void destroyBitmapObject2();
void __cdecl getMapData(unsigned __int8 **data, __int16 *Map_Width, __int16 *Map_Height);
unsigned __int8 __cdecl getTileAttributes(signed int X_Pos, signed int Y_Pos); // idb
void __cdecl deleteTile(int XPos, int YPos);
void __cdecl shiftMapParts(int X_Pos, int Y_pos);
signed int __cdecl changeMapParts(int X_Pos, int Y_Pos, unsigned __int8 New_NPC); // idb
void __cdecl drawStageBackground(signed int Camera_X, signed int Camera_Y);
void __cdecl drawStageForeground(signed int Camera_X, signed int Camera_Y);
void __cdecl drawMapDataVector(signed int Camera_X, signed int Camera_Y);
void __cdecl readyMapName(char *_name);
void __cdecl drawMapName(int bMini); // idb
void startMapName();
int redrawRoomTextToSurface();
void __cdecl Render_Map_System_Green_Stuff(LONG a1);
signed int gameLoopMap();
bool checkMapFlag();
void *clearMapFlagArray();
void __cdecl setMapFlag(int mapID);
void *setQuoteinitialValues();
void __cdecl doPlayerAnimation(int bKey);
void __cdecl showHidePlayer(int show);
void __cdecl drawQuoteAndGun(signed int a1, signed int a2);
int __cdecl playerPhysics(bool a1);
int __cdecl Quote_Movement(bool a1); // idb
int __cdecl Player_Related_Maybe(bool a1); // idb
void Quote_Air();
void __cdecl getQuotePos(int *XPos, int *YPos);
void __cdecl setQuotePosition(int X_Pos, int Y_Pos); // idb
void __cdecl setXAndYPos(int newXPos, int newYPos);
// void makeQuoteXVel0();
BOOL isInFishBattle();
void __cdecl setPlayerDirection(unsigned __int8 New_Direction); // idb
void __cdecl changeUniverse(unsigned __int8 newUniverse);
void __cdecl moveQuote4000UnitsDown();
void __cdecl equipItem(int Item_To_Equip, bool Unequip);
void __cdecl andQuoteFlagsMinus2();
void __cdecl setNoise(int Num, int Frequency);
void __cdecl cutNoise();
void playEnvironmentalSounds();
void playStreamNoiseAndHelicopterBlades();
// void resetQuoteCollisionFlags();
signed int __cdecl Quote_Collision_Block(int X_Pos, int Y_Pos); // idb
void Put_Bump_Stars();
signed int __cdecl Quote_Collision_Roof_Slope_1(int X_Pos, int Y_Pos); // idb
signed int __cdecl Quote_Collision_Roof_Slope_2(int X_Pos, int Y_Pos); // idb
signed int __cdecl Quote_Collision_Roof_Slope_3(int X_Pos, int Y_Pos); // idb
signed int __cdecl Quote_Collision_Roof_Slope_4(int X_Pos, int Y_Pos); // idb
signed int __cdecl Quote_Collision_Floor_Slope_1(int X_Pos, int Y_Pos); // idb
signed int __cdecl Quote_Collision_Floor_Slope_2(int X_Pos, int Y_Pos); // idb
signed int __cdecl Quote_Collision_Floor_Slope_3(int X_Pos, int Y_Pos); // idb
signed int __cdecl Quote_Collision_Floor_Slope_4(int X_Pos, int Y_Pos); // idb
signed int __cdecl Quote_Collision_Water(int X_Pos, int Y_Pos); // idb
signed int __cdecl Quote_Collision_Spike(int X_Pos, int Y_Pos); // idb
signed int __cdecl Quote_Collision_Spike_Water(int X_Pos, int Y_Pos); // idb
signed int __cdecl Quote_Collision_Wind_Left(int X_Pos, int Y_Pos); // idb
signed int __cdecl Quote_Collision_Wind_Up(int X_Pos, int Y_Pos); // idb
signed int __cdecl Quote_Collision_Wind_Right(int X_Pos, int Y_Pos); // idb
signed int __cdecl Quote_Collision_Wind_Down(int X_Pos, int Y_Pos); // idb
void __cdecl doCollisionCheckPlayerMap();
signed int __cdecl Entity_Collision_Solid(NPC *npc); // idb
unsigned __int8 __cdecl Entity_Collision_NonSolid(NPC *npc);
signed int __cdecl Entity_Collision_SpecialSolid(NPC *npc);
void doCollisionCheckPlayerNPCs();
void doCollisionCheckPlayerBosses();
void __cdecl Add_Weapon_EXP(int EXP_To_Add);
void resetSelectedWeaponLevel(void);
bool Check_Weapon_MAX(void);
void __cdecl damagePlayer(int damage);
int resetAllWeaponEXP();
void __cdecl Add_Rocket_Ammo(int Num, int Ammo_To_Refill);
void __cdecl addLifePlayer(int Health_To_Restore);
void __cdecl addMaxLifePlayer(int Life_To_Add);
void __cdecl drawEXPBarAndMisc(int a1);
int drawHUDWeaponIcons();
void __cdecl drawHealthBar(int); // idb
void __cdecl drawUnderwaterTimer(int XPos, int YPos); // idb
void __cdecl drawNikamaruTimer(int X_Pos, int Y_Pos); // idb
signed int saveHellCounter();
int getHellTime();
signed int __cdecl makeSoundObject(char *wavep, char track, char pipi); // idb
void __cdecl changeOrganFrequency(unsigned __int8 frequencyTableIndex, char organBufferIndex, int frequency);
void __cdecl changeOrganPan(unsigned __int8 key, unsigned __int8 pan, char organBufferIndex);
void __cdecl changeOrganVolume(int no, __int32 volume, char organBufferIndex);
void __cdecl playOrganyaObject(unsigned __int8 key, int mode, char organBufferIndex, DWORD freq);
void __cdecl releaseOrganyaObject(char organBufferIndex);
BOOL initWaveData100(void);
BOOL __cdecl makeOrganyaWave(char track, char wave_num, char pipi);
void __cdecl changeDrumFrequency(unsigned __int8 frequency, char drumBufferIndex);
void __cdecl changeDrumPan(unsigned __int8 pan, char drumBufferIndex);
void __cdecl changeDrumVolume(__int32 volume, char drumBufferIndex);
void __cdecl playDrumObject(unsigned __int8 key, int mode, char drumBufferIndex);
OrgData *__thiscall OrgData::OrgData(OrgData *this);
void __thiscall OrgData::InitOrgData(OrgData *this);
BOOL __thiscall OrgData::SetMusicInfo(OrgData *this, MUSICINFO *mi, unsigned __int32 flag);
BOOL __thiscall OrgData::NoteAlloc(OrgData *this, unsigned __int16 alloc);
void __thiscall OrgData::ReleaseNote(OrgData *this);
signed int __thiscall OrgData::loadOrgFile(OrgData *this, char *musicName);
void __thiscall OrgData::GetMusicInfo(OrgData *this, MUSICINFO *mi);
bool initMMTimer();
int __cdecl startTimer(DWORD dwTimer); // idb
TIMECALLBACK timerCallbackOrganya;
signed int quitMMTimer();
void __thiscall OrgData::PlayData(OrgData *this);
void __thiscall OrgData::SetPlayPointer(OrgData *this, __int32 position);
signed int startOrganya();
int __cdecl loadOrganya(char *musicName); // idb
void __cdecl setOrganyaPosition(int position); // idb
__int32 getOrganyaPosition();
int startOrganyaPlayback();
signed int __cdecl changeOrganyaVolume(signed int volume); // idb
void stopOrganyaMusic();
// void fadeMusic();
void deleteOrganya();
void MakeWaveTables();
signed int __cdecl MakePixelWaveData(int a1, int a2);
bool checkForProfileDat(void);
signed int __cdecl saveProfile(const char *name); // idb
signed int __cdecl loadProfileDat(const char *path); // idb
int __cdecl initialiseGame(HWND hWnd); // idb
void *clearUnlockedStages();
signed int __cdecl addPermitStage(int index, int event); // idb
signed int __cdecl Remove_Unlocked_Stage(int a1);
void __cdecl moveStageSelectCursor();
void drawTeleporterMenu();
signed int __cdecl gameLoopStageSelect(_DWORD *p_event); // idb
void __cdecl shootSnake(int Level);
void __cdecl shootPolarStar(int Level);
void __cdecl shootFireball(int a1);
void __cdecl shootMachineGun(int Level);
void __cdecl shootMissileLauncher(int level, bool isSuper); // idb
void shootBubblerLevel1();
void __cdecl shootBubblerLevel2_3(int Level);
void __cdecl shootBlade(int level); // idb
void __cdecl shootNemesis(int Bullet_Level);
void resetSpurCharge();
void __cdecl shootSpur(int level); // idb
void shootBullet();
BOOL __cdecl initDirectSound(HWND hwnd);
void __cdecl deleteDirectSound();
signed int __cdecl loadWAVFile(LPCSTR resourceName, int bufferIndex); // idb
BOOL __cdecl loadSoundObject(char *fileName, int num);
void __cdecl playSoundEffect(soundEffects bufferIndex, int mode);
void __cdecl changeSoundFrequency(int bufferIndex, DWORD frequency);
void __cdecl changeSoundVolume(int bufferIndex, int volume);
void __cdecl changeSoundPan(int bufferIndex, int pan);
size_t __cdecl makePixtoneObject(int *ptrSound, int channel, int bufferIndex);
signed int __cdecl changeStage(int number, int event, int XPos, int YPos); // idb
void __cdecl changeMusic(musics musicID);
void __cdecl recallMusic();
void __cdecl initWhimsicalStar();
int doWhimsicalStar();
void __cdecl drawWhimsicalStar(signed int a1, signed int a2);
void __cdecl initTSC();
void deleteTSC();
void __cdecl decryptTSCScript(unsigned __int8 *TSCData, signed int dataSize);
int __cdecl loadSpecialTSC(char *); // idb
signed int __cdecl loadTSCScript(char *scriptName);
// void __cdecl getTextScriptPath(char *destination); idb
int __cdecl getTSCNumber(int num); // idb
signed int __cdecl startTSCEvent(int event); // idb
signed int __cdecl changeEvent(int newEvent); // idb
void __cdecl stopTSC();
void __cdecl checkNewLine();
void __cdecl printNumber(int index);
void __cdecl clearTextLine();
void drawTextBox();
int TSCParser(void); // idb
int drawTextToTextBoxSurfaces();
void initTriangleTable();
int __cdecl getSin(unsigned __int8 degree); // idb
int __cdecl getCos(unsigned __int8 deg); // idb
unsigned __int8 __cdecl getArcTan(int XPos, int YPos);
void __cdecl callCallCos(float a1);
void __cdecl callCos(float degree);
void __cdecl callCallSin(float a1);
void __cdecl callSin(float a1);
void clearValueView(void);
int __cdecl setValueView(__int32, __int32, __int32); // idb
int actValueView();
int __cdecl putValueView(int cameraXPos, int cameraYPos); // idb
void __cdecl NPC0_Nothing(NPC *npc);
void __cdecl NPC1_WeaponEnergy(NPC *npc);
void __cdecl NPC2_EnemyBehemoth(NPC *npc);
void __cdecl NPC3_DeletesItself(NPC *npc);
void __cdecl NPC4_Smoke(NPC *npc);
void __cdecl NPC5_EnemyCritterHoppingGreen(NPC *npc);
void __cdecl NPC6_EnemyBeetleHorizontalGreen(NPC *npc);
void __cdecl NPC7_EnemyBasil(NPC *npc);
void __cdecl NPC8_EnemyBeetleFollow1(NPC *npc);
void __cdecl NPC9_BalrogDropIn(NPC *npc);
void __cdecl NPC10_BossBalrogShooting(NPC *npc);
void __cdecl NPC11_ProjectileBalrogEnergyBounce(NPC *npc);
void __cdecl NPC12_BalrogCutscene(NPC *npc);
void __cdecl NPC13_Forcefield(NPC *npc);
void __cdecl NPC14_SantasKey(NPC *npc);
void __cdecl NPC15_TreasureChestClosed(NPC *npc);
void __cdecl NPC16_SavePoint(NPC *npc);
void __cdecl NPC17_HealthAmmoRefill(NPC *npc);
void __cdecl NPC18_Door(NPC *npc);
void __cdecl NPC19_BalrogBustsIn(NPC *npc);
void __cdecl NPC20_Computer(NPC *npc);
void __cdecl NPC21_TreasureChestOpen(NPC *npc);
void __cdecl NPC22_Teleporter(NPC *npc);
void __cdecl NPC23_TeleporterLights(NPC *npc);
void __cdecl NPC24_PowerCritter(NPC *npc);
void __cdecl NPC25_LiftPlatform(NPC *npc);
void __cdecl NPC26_EnemyBatBlackCircling(NPC *npc);
void __cdecl NPC27_Deathtrap(NPC *npc);
void __cdecl NPC28_EnemyCritterFlying(NPC *npc);
void __cdecl NPC29_Cthulhu(NPC *npc);
void __cdecl NPC30_HermitGunsmith(NPC *npc);
void __cdecl NPC31_EnemyBatBlackHanging(NPC *npc);
void __cdecl NPC32_LifeCapsule(NPC *npc);
void __cdecl NPC33_ProjectileBalrogEnergyBounce(NPC *npc);
void __cdecl NPC34_Bed(NPC *npc);
void __cdecl NPC35_EnemyMannan(NPC *npc);
void __cdecl NPC36_BossBalrogHovering(NPC *npc);
void __cdecl NPC37_Signpost(NPC *npc);
void __cdecl NPC38_FireplaceFire(NPC *npc);
void __cdecl NPC39(NPC *npc);
void __cdecl NPC40(NPC *npc);
void __cdecl NPC41(NPC *npc);
void __cdecl NPC42(NPC *npc);
void __cdecl NPC43(NPC *npc);
void __cdecl NPC44(NPC *npc);
void __cdecl NPC45(NPC *npc);
void __cdecl NPC46(NPC *npc);
void __cdecl NPC47(NPC *npc);
void __cdecl NPC48(NPC *npc);
void __cdecl NPC49(NPC *npc);
void __cdecl NPC50(NPC *npc);
void __cdecl NPC51(NPC *npc);
void __cdecl NPC52_Sitting_Blue_Bot(NPC *npc);
void __cdecl NPC53(NPC *npc);
void __cdecl NPC54(NPC *npc);
void __cdecl NPC55(NPC *npc);
void __cdecl NPC56(NPC *npc);
void __cdecl NPC57(NPC *npc);
void __cdecl NPC58(NPC *npc);
void __cdecl NPC59(NPC *npc);
void __cdecl NPC60(NPC *npc);
void __cdecl NPC61(NPC *npc);
void __cdecl NPC62(NPC *npc);
void __cdecl NPC63(NPC *npc);
void __cdecl NPC64(NPC *npc);
void __cdecl NPC65(NPC *npc);
void __cdecl NPC66(NPC *npc);
void __cdecl NPC67(NPC *npc);
void __cdecl NPC68(NPC *npc);
void __cdecl NPC69(NPC *npc);
void __cdecl NPC70(NPC *npc);
void __cdecl NPC71(NPC *NPC);
void __cdecl NPC72(NPC *NPC);
void __cdecl NPC73(NPC *NPC);
void __cdecl NPC74(NPC *NPC);
void __cdecl NPC75(NPC *NPC);
void __cdecl NPC76(NPC *NPC);
void __cdecl NPC77_Sandaim_the_Farmer(NPC *NPC);
void __cdecl NPC78_Pot(NPC *NPC);
void __cdecl NPC79(NPC *NPC);
void __cdecl NPC80(NPC *NPC);
void __cdecl NPC81(NPC *NPC);
void __cdecl NPC82(NPC *NPC);
void __cdecl NPC83(NPC *NPC);
void __cdecl NPC84(NPC *NPC);
void __cdecl NPC85(NPC *NPC);
void __cdecl NPC86(NPC *NPC);
void __cdecl NPC87(NPC *NPC);
void __cdecl NPC88(NPC *NPC);
void __cdecl NPC89(NPC *NPC);
void __cdecl NPC90(NPC *NPC);
signed int __cdecl NPC91(int a1);
int __cdecl NPC92(int a1);
int __cdecl NPC93(int a1);
int *__cdecl NPC94_Giant_Jelly(int a1);
int *__cdecl NPC95(int a1);
int __cdecl NPC96(int a1);
int *__cdecl NPC97(int a1);
int __cdecl NPC98(int a1);
int *__cdecl NPC99(int a1);
signed int __cdecl NPC100(int a1);
int __cdecl NPC101(int a1);
int *__cdecl NPC102(int a1);
void __cdecl NPC103(int a1);
int *__cdecl NPC104(int a1);
int *__cdecl NPC105(int a1);
int __cdecl NPC106(int a1);
int __cdecl NPC107(int a1);
int __cdecl NPC108(int a1);
int *__cdecl NPC109(int a1);
int __cdecl NPC110(int a1);
int __cdecl NPC111(int a1);
int __cdecl NPC112(int a1);
int __cdecl NPC113(int a1);
int *__cdecl NPC114(int a1);
int __cdecl NPC115(int a1);
_DWORD *__cdecl NPC116(int a1);
int __cdecl NPC117(int a1);
int __cdecl NPC118(int a1);
_DWORD *__cdecl NPC119(int a1);
signed int __cdecl NPC120(int a1);
void __cdecl NPC121(int a1);
int *__cdecl NPC122(int a1);
int __cdecl NPC123(int a1);
int __cdecl NPC124(int a1);
_DWORD *__cdecl NPC125(int a1);
int *__cdecl NPC126(int a1);
int __cdecl NPC127(int a1);
int __cdecl NPC128(int a1);
int *__cdecl NPC129(int a1);
int __cdecl NPC130(int a1);
int __cdecl NPC131(int a1);
int *__cdecl NPC132(int a1);
int *__cdecl NPC133(int a1);
int *__cdecl NPC134(int a1);
int __cdecl NPC135(int a1);
int *__cdecl NPC136(int a1);
_DWORD *__cdecl NPC137(int a1);
int __cdecl NPC138(int a1);
int __cdecl NPC139(int a1);
void __cdecl NPC140(NPC *npc);
int __cdecl NPC141(int a1);
int *__cdecl NPC142(int a1);
int __cdecl NPC143(int a1);
int __cdecl NPC144(int a1);
LONG __cdecl NPC145(NPC *npc);
int __cdecl NPC146(int a1);
int __cdecl NPC147(int a1);
void __cdecl NPC148(int a1);
signed int __cdecl NPC149(int a1);
void __cdecl NPC150(NPC *npc);
int *__cdecl NPC151(int a1);
int __cdecl NPC152(int a1);
int __cdecl NPC153(int a1);
_DWORD *__cdecl NPC154(int NPC_Vars_Pointer);
_DWORD *__cdecl NPC155(int a1);
void __cdecl NPC156(int a1);
signed int __cdecl NPC157(int a1);
int __cdecl NPC158(int a1);
void __cdecl NPC159(int a1);
int *__cdecl NPC160(int a1);
int *__cdecl NPC161(int a1);
int __cdecl NPC162(int a1);
int *__cdecl NPC163(int a1);
int *__cdecl NPC164(int a1);
int __cdecl NPC165(int a1);
int __cdecl NPC166(int a1);
int *__cdecl NPC167(int a1);
signed int __cdecl NPC168(int a1);
int __cdecl NPC169(int a1);
void __cdecl NPC170(void *Frame_1_A_4);
int __cdecl NPC171(int a1);
void __cdecl NPC172(void *npc);
void __cdecl NPC173(int a1);
int __cdecl NPC174(int a1);
int __cdecl NPC175(void *); // idb
int __cdecl NPC176(void *); // idb
void __cdecl NPC177(int a1);
void __cdecl NPC178(void *a1);
void __cdecl NPC179(void *a1);
RECT *__cdecl NPC180(NPC *a1);
int __cdecl NPC181(int a1);
int __cdecl NPC182(int a1);
int __cdecl NPC183(int a1);
int __cdecl NPC184(int a1);
_DWORD *__cdecl NPC185(int a1);
int __cdecl NPC186(int a1);
RECT *__cdecl NPC187(NPC *a1);
int *__cdecl NPC188(int a1);
int __cdecl NPC189(int a1);
int *__cdecl NPC190(int a1);
int __cdecl NPC191(int a1, int a2, int a3, int a4);
int __cdecl NPC192(int a1);
_DWORD *__cdecl NPC193(int a1);
signed int __cdecl NPC194(int a1);
_DWORD *__cdecl NPC195(int a1);
signed int __cdecl NPC196(int a1);
int __cdecl NPC197(void *); // idb
void __cdecl NPC198(int a1);
int *__cdecl NPC199(int a1);
int __cdecl NPC200(int a1);
int __cdecl NPC201(int a1);
void __cdecl NPC202(int a1);
int *__cdecl NPC203(int a1);
int *__cdecl NPC204(int a1);
void __cdecl NPC205(int a1);
int __cdecl NPC206(int a1);
int __cdecl NPC207(int a1);
int *__cdecl NPC208(int a1);
void __cdecl NPC209(int a1);
int __cdecl NPC210(int a1);
int *__cdecl NPC211(int a1);
NPC *__cdecl NPC212(NPC *a1);
int *__cdecl NPC213(int a1);
int __cdecl NPC214(int Entity_Vars);
int __cdecl NPC215(int a1);
void __cdecl NPC216_Debug_Cat(NPC *npc);
int *__cdecl NPC217(int a1);
int __cdecl NPC218(int a1);
int __cdecl NPC219(int a1);
void __cdecl NPC220(NPC *npc);
int __cdecl NPC221(int a1);
signed int __cdecl NPC222(int a1);
int __cdecl NPC223(int a1);
int *__cdecl NPC224(int a1);
int *__cdecl NPC225(int a1);
int __cdecl NPC226(int a1);
void __cdecl NPC227_Bucket(NPC *npc);
int __cdecl NPC228(int a1);
signed int __cdecl NPC229(int a1);
signed int __cdecl NPC230(int a1);
int __cdecl NPC231(int a1);
LONG __cdecl NPC232(NPC *a1);
void __cdecl NPC233(NPC *npc);
signed int __cdecl NPC234(int a1);
int __cdecl NPC235(int a1);
int *__cdecl NPC236(int a1);
void __cdecl NPC237(int a1);
int __cdecl NPC238(int a1);
_DWORD *__cdecl NPC239(int a1);
int __cdecl NPC240(int a1);
int __cdecl NPC241(int a1);
void __cdecl NPC242(void *npc);
void __cdecl NPC243(int a1);
signed int __cdecl NPC244(signed int a1);
int __cdecl NPC245(int a1);
int __cdecl NPC246(int a1);
void __cdecl NPC247(NPC *npc);
void __cdecl NPC248(int a1);
int __cdecl NPC249(int a1);
void __cdecl NPC250(int a1);
int __cdecl NPC251(int a1);
int *__cdecl NPC252(int a1);
int *__cdecl NPC253(int a1);
signed int __cdecl NPC254(NPC *a1);
int __cdecl NPC255(int a1);
int __cdecl NPC256(int a1);
int __cdecl NPC257(int a1);
_DWORD *__cdecl NPC258(int a1);
void __cdecl NPC259(void *a1);
int *__cdecl NPC260(int a1);
int __cdecl NPC261(int a1);
int __cdecl NPC262(int a1);
void __cdecl NPC263(NPC *NPC);
void __cdecl NPC264(void *a1);
int __cdecl NPC265(int a1);
void __cdecl NPC266(void *a1);
void __cdecl NPC267(NPC *npc);
int __cdecl NPC268(int a1);
int *__cdecl NPC269(int a1);
int *__cdecl NPC270(int a1);
void __cdecl NPC271(void *a1);
void __cdecl NPC272(int a1);
void __cdecl NPC273(void *npc);
int __cdecl NPC274(int a1);
int *__cdecl NPC275(int a1);
int __cdecl NPC276(int a1);
void __cdecl NPC277(void *npc);
int __cdecl NPC278(int a1);
int __cdecl NPC279(int a1);
int __cdecl NPC280(int a1);
RECT *__cdecl NPC281(NPC *a1);
int __cdecl NPC282(int a1);
void __cdecl NPC283(NPC *npc);
void __cdecl NPC284(NPC *npc);
void __cdecl NPC285(void *npc);
int __cdecl NPC286(int a1);
int *__cdecl NPC287(int a1);
int *__cdecl NPC288(int a1);
void __cdecl NPC289(void *npc);
void __cdecl NPC290(void *npc);
int __cdecl NPC291(int a1);
void NPC292();
int __cdecl NPC293(int a1);
int __cdecl NPC294(int a1);
int *__cdecl NPC295(int a1);
void __cdecl NPC296(int a1);
signed int __cdecl NPC297(int a1);
int *__cdecl NPC298(int a1);
int __cdecl NPC299(int a1);
signed int __cdecl NPC300(int a1);
int __cdecl NPC301(int a1);
void __cdecl NPC302(NPC *npc);
int __cdecl NPC303(int a1);
int __cdecl NPC304(int a1);
int __cdecl NPC305(int a1);
int *__cdecl NPC306(int a1);
int __cdecl NPC307(int a1);
int __cdecl NPC308(int a1);
int __cdecl NPC309(int a1);
int __cdecl NPC310(int a1);
int __cdecl NPC311(int a1);
int __cdecl NPC312(int a1);
void __cdecl NPC313(NPC *npc);
int __cdecl NPC314(int a1);
void __cdecl NPC315(void *npc);
int __cdecl NPC316(int a1);
NPC *__cdecl NPC317(NPC *a1);
int __cdecl NPC318(int a1);
void __cdecl NPC319(int a1);
RECT *__cdecl NPC320(NPC *a1);
int __cdecl NPC321(int a1);
int __cdecl NPC322(int a1);
int *__cdecl NPC323(int a1);
void __cdecl NPC324(int a1);
int __cdecl NPC325(int a1);
RECT *__cdecl NPC326(NPC *a1);
int __cdecl NPC327(int a1);
_DWORD *__cdecl NPC328(int a1);
signed int __cdecl NPC329(int a1);
int *__cdecl NPC330(int a1);
int __cdecl NPC331(int a1);
int *__cdecl NPC332(int a1);
int __cdecl NPC333(int a1);
int __cdecl NPC334(int a1);
int __cdecl NPC335(int a1);
void __cdecl NPC336(int a1);
int __cdecl NPC337(int a1);
void __cdecl NPC338(void *a1);
void __cdecl NPC339(int a1);
void __cdecl NPC340(NPC *npc);
void __cdecl NPC341(NPC *npc);
void __cdecl NPC342(void *a1);
int __cdecl NPC343(int a1);
int __cdecl NPC344(int a1);
int __cdecl NPC345(int a1);
_DWORD *__cdecl NPC346(int a1);
int __cdecl NPC347(int a1);
int __cdecl NPC348(int a1);
signed int __cdecl NPC349(int a1);
void __cdecl NPC350(void *npc);
int *__cdecl NPC351(int a1);
LONG __cdecl NPC352(NPC *a1);
int *__cdecl NPC353(int a1);
int __cdecl NPC354(int a1);
int *__cdecl NPC355(int a1);
RECT *__cdecl NPC356(NPC *a1);
void __cdecl NPC357(int a1);
int __cdecl NPC358(int a1);
void __cdecl NPC359(int a1);
signed int __cdecl NPC360_Thank_You(int a1);
void __cdecl initNPCs();
signed int __cdecl Load_Event(char *path_event); // idb
void __cdecl Set_Unique_Parameter(NPC *npc);
void __cdecl createNPC(NPCNames NPC_Num, int X_Pos, int Y_Pos, int X_Vel, int Y_Vel, Directions Direction, NPC *Parent_NPC, int Start_Index);
void __cdecl createDustClouds(int X_Pos, int Y_Pos, signed int Range, int Num); // idb
void __cdecl createDustCloudsUp(int X_Pos, int Y_Pos, signed int Range, int Num); // idb
void __cdecl Spawn_Exp(int X_Position, int Y_Position, signed int EXP_Amount); // idb
signed int __cdecl Spawn_Missiles(int a1, int a2, int a3);
signed int __cdecl Spawn_HP(int a1, int a2, int a3);
void __cdecl Vanish_NPC(NPC *npc);
void __cdecl drawNPCs(signed int Camera_X, signed int Camera_Y); // idb
void __cdecl updateNPCs();
void __cdecl spawnNPC(int Entity_Eve_Num, int Entity_Type, int Direction);
void __cdecl changeCheckableNPCByEvent(int Entity_Eve_Num, int Entity_Type, char Direction);
void __cdecl setNPCState(int Entity_Eve_Num, int NPC_State, int Direction);
void __cdecl moveNPC(int Entity_Eve_Num, int X_Pos, int Y_Pos, char Direction);
void __cdecl backStepPlayer(int Entity_Eve_Num);
void __cdecl deleteNPCEvent(int Entity_Eve_Num);
void __cdecl killNPC(int Number, int bSmoke);
void __cdecl getNPCPosition(int *destXPos, int *destYPos, int NPCObjectsIndex);
signed int __cdecl isNPCType(int entityType); // idb
bool __cdecl checkNPCAlive(int code_event); // idb
int Count_Live_NPCs();
void __cdecl NPC_Collision_Block(NPC *npc, int X_Pos, int Y_Pos);
void __cdecl NPC_Collision_Triangle_A(NPC *npc, int X_Pos, int Y_Pos);
void __cdecl NPC_Collision_Triangle_B(NPC *npc, int X_Pos, int Y_Pos);
void __cdecl NPC_Collision_Triangle_C(NPC *npc, int X_Pos, int Y_Pos);
void __cdecl NPC_Collision_Triangle_D(NPC *npc, int X_Pos, int Y_Pos);
void __cdecl NPC_Collision_Triangle_E(NPC *npc, int X_Pos, int Y_Pos);
void __cdecl NPC_Collision_Triangle_F(NPC *npc, int X_Pos, int Y_Pos);
void __cdecl NPC_Collision_Triangle_G(NPC *npc, int X_Pos, int Y_Pos);
void __cdecl NPC_Collision_Triangle_H(NPC *npc, int X_Pos, int Y_Pos);
void __cdecl NPC_Collision_Water(NPC *npc, int X_Pos, int Y_Pos);
void doCollisionCheckNPCsMap();
void __cdecl NPC_Death_Maybe(void *Is_NPC_Alive, int a2);
int entityBulletCollision();
int __cdecl loadNPCTable(char *path); // idb
void deleteNPCTable();
void __cdecl initRoomBoss(int bossNumber);
void __cdecl drawBoss(signed int Camera_X, signed int Camera_Y); // idb
void __cdecl setBossScriptState(int newState);
void __cdecl doCollisionCheckBossesBullets();
// void boss0_NoSpecialBoss();
void __cdecl updateBoss();
void __cdecl doCollisionCheckBossesMap();
void __cdecl coreSubNPCFace(NPC *npc);
void __cdecl coreSubNPCTail(NPC *npc);
void __cdecl coreSubNPCMini(NPC *npc);
void __cdecl coreSubNPCHit(NPC *npc);
void boss4_Core();
void boss7_UndeadCore();
void __cdecl undeadSubNPCHead(NPC *npc);
void __cdecl undeadSubNPCTail(NPC *npc);
void __cdecl undeadSubNPCFace(NPC *npc);
void __cdecl undeadSubNPCMini(NPC *npc);
void __cdecl undeadSubNPCHit(NPC *npc);
void __cdecl boss9_BallosBall();
int __cdecl ballosSubNPCEye(NPC *npc);
int __cdecl ballosSubNPCBody(NPC *npc);
int __cdecl ballosSubNPCHITAI(NPC *npc);
int __cdecl ballosSubNPCHARA(NPC *npc);
void boss2_Balfrog();
void __cdecl balfrogSubNPC1();
void __cdecl balfrogSubNPC2();
RECT *Boss_5_Ironhead();
// void initBossLife();
signed int __cdecl startBossLife(int Entity_Eve_Num); // idb
signed int startBossLife2();
void drawBossHealth();
void Boss_1_Omega();
void __cdecl Omega_Sub_NPC_2();
void __cdecl Omega_Sub_NPC_1();
void __cdecl Omega_Sub_NPC_3();
RECT *Boss_8_Heavy_Press();
int Boss_6_Dragon_Sisters();
int __cdecl Sisters_Sub_NPC_Dragon_Body(int a1);
int *__cdecl Sisters_Sub_NPC_Dragon_Head(int a1);
void __cdecl boss3_MonsterX();
void __cdecl monsterXSubNPC1(NPC *npc);
void __cdecl monsterXSubNPCFishMissiles(NPC *npc);
void __cdecl monsterXSubNPC3(NPC *npc);
void __cdecl monsterXSubNPC4(NPC *npc);
void __cdecl monsterXSubNPCHead(NPC *npc);
// HRESULT __stdcall DirectDrawCreate(GUID *lpGUID, LPDIRECTDRAW *lplpDD, IUnknown *pUnkOuter); idb
// HRESULT __stdcall DirectInputCreateA(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTA *ppDI, LPUNKNOWN punkOuter); idb
// HRESULT __stdcall DirectSoundCreate(LPGUID, LPDIRECTSOUND *, LPUNKNOWN); idb
// void *__cdecl memset(void *dest, int value, size_t count); idb
signed int report_failure_Return_1();
void report_failure_sub_480DB1();
// void __thiscall report_failure(void *this);
// int __cdecl fclose_nolock(FILE *stream);
// int __cdecl fclose(FILE *stream);
// size_t __cdecl fread_nolock(void *buffer, size_t elementSize, size_t count, FILE *stream);
size_t __cdecl fread(void *buffer, size_t elementSize, size_t count, FILE *stream);
// FILE *__cdecl _fsopen(const _TSCHAR *file, const _TSCHAR *mode, int shflag);
// int __usercall fsopen_sub_480FF3@<eax>(int a1@<ebp>);
// FILE *__cdecl fopen(const _TSCHAR *file, const _TSCHAR *mode);
// int sprintf(char *string, const char *format, ...);
// int __cdecl strcmp(const char *src, const char *dest); idb
// void __cdecl strcpy(char *dst, const char *src); idb
// char *__cdecl strcat(char *dst, const char *src); idb
// size_t __cdecl strlen(const char *string); idb
// void __cdecl free(void *pBlock);
// void unlock_4();
// void *__cdecl heap_alloc(size_t size);
// void __usercall _heap_alloc_sub_48136B(int a1@<ebp>);
// void _heap_alloc_call__unlock();
// void *__cdecl malloc_base(size_t size, int newmode);
// void *__cdecl malloc(size_t size); idb
// void *__cdecl memcpy(void *dst, void *src, size_t count);
// void __cdecl srand(unsigned int seed);
// int __cdecl rand();
// int __cdecl memcmp(const void *buf1, const void *buf2, size_t count);
// int sscanf(char *string, const char *format, ...);
// int fprintf(FILE *str, FILE *_stream, ...);
// int __usercall fprintf_unlock_str@<eax>(int a1@<ebp>);
// size_t __cdecl fwrite_nolock(const void *buffer, size_t size, size_t num, FILE *stream);
size_t __cdecl fwrite(const void *buffer, size_t size, size_t count, FILE *stream);
// int __cdecl fseek_nolock(FILE *stream, __int32 offset, int whence);
// int __cdecl fseek(int whence, FILE *stream, __int32 offset);
// int __usercall fseek_unlock_str@<eax>(int a1@<ebp>);
void Just_Return();
// int (__cdecl *_cfltcvt_init())(int, int, int, int, int);
// void __cdecl _fpmath(int initPrecision);
// void __usercall _CIsin(double x@<st0>);
// double __cdecl sin(double angle_rad); idb
// unsigned int __usercall _ftol2@<eax>(long double a1@<st0>);
// double __cdecl cos(double angle_rad); idb
// void __cdecl __noreturn _amsg_exit(int rterrnum);
// void __cdecl __noreturn static fast_error_exit(int rterrnum);
// int WinMainCRTStartup();
// void __cdecl __security_init_cookie();
// void __cdecl __noreturn _security_error_handler(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21);
signed int __security_error_handler_return_1();
int __cdecl __security_error_handler(int, int); // idb
// void __cdecl VALIDATE_RETURN(int a1, int a2);
// int __stdcall _SEH_epilog(_DWORD, _DWORD); weak
// int __usercall _except_handler3@<eax>(int a1@<ebp>, int a2, PVOID TargetFrame, int a4);
// signed int __cdecl close_nolock(signed int fh); idb
// int __cdecl _close(int fh);
// int close_call___unlock_fhandle(void); weak
// void __cdecl _freebuf(FILE *stream);
// int __cdecl _flush(FILE *stream);
// int __cdecl fflush_nolock(FILE *str);
// int __cdecl static flsall(int flushflag);
// int __usercall flsall_sub_482475@<eax>(int a1@<esi>);
void flsall_sub_4824A1();
int __cdecl flushall();
// int __initstdio(void);
// void __cdecl __endstdio();
// void __cdecl lock_str(FILE *file);
// _DWORD __cdecl _lock_file2(_DWORD, _DWORD); weak
// void __cdecl _unlock_file(FILE *a1); idb
// _DWORD __cdecl _unlock_file2(_DWORD, _DWORD); weak
// int __cdecl _filbuf(FILE *stream); idb
// int __cdecl read_nolock(int fh, void *inputbuf, unsigned int cnt);
// int __cdecl _read(int fh, void *buf, unsigned int cnt);
// void call_unlock_fh();
// FILE *__cdecl _openfile(const char *filename, const int *mode, int shflag, FILE *str); idb
// int _errno(void); weak
// int __doserrno(void); weak
// int __cdecl _dosmaperr(_DWORD); weak
// int _getstream(void); weak
// int __cdecl _flsbuf(int, _SYSTEMTIME *); idb
// int __cdecl output_l(_SYSTEMTIME *, int, int); idb
// _DWORD __cdecl _heap_init(_DWORD); weak
// void __cdecl _unlock(int locknum); idb
// signed int __cdecl _mtinitlocknum(int a1, int a2);
// int mtinitlocknum_sub_4837E0(void); weak
// void __cdecl mlock(int a1);
// char *__cdecl __sbh_find_block(int a1);
// _DWORD __cdecl __sbh_free_block(_DWORD, _DWORD); weak
// _DWORD __cdecl __sbh_resize_block(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl __sbh_alloc_block(_DWORD); weak
// bool __cdecl _callnewh(size_t size);
// _tiddata *__cdecl _getptd();
// int __usercall freefls@<eax>(int a1@<ebp>);
// int freefls(void); weak
// int _mtinit(void); weak
// int __fastcall _inc(_DWORD, _DWORD); weak
// int __cdecl _input(_SYSTEMTIME *stream, int a2, int a3, int a4);
// int __cdecl _stbuf(int); idb
// int __cdecl _ftbuf(int, int); idb
// int __cdecl _write_lk(int, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite); idb
// int __cdecl _write(int file, const void *data, unsigned int NumberOfBytesToWrite); idb
// int __cdecl _lseek_lk(int, LONG lDistanceToMove, DWORD dwMoveMethod); idb
// __int32 __cdecl _lseek(int file_ptr, __int32 distanceToMove, int initial_pos); idb
// _DWORD __cdecl _ftell_lk(_DWORD); weak
// int __cdecl _forcdecpt(int); weak
// int __cdecl _cropzeros(int); weak
// int __cdecl _positive(int); weak
// int __cdecl _fassign(int, int, int); idb
// int __cdecl _cfltcvt(int, int, int, int, int); weak
// int _setdefaultprecision(void); weak
// int _ms_p5_mp_test_fdiv(void); weak
// double _convertTOStoQNaN(void); weak
// double __fastcall _fload_withFB(_DWORD, _DWORD); weak
// int __cdecl _checkTOS_withFB(int, int); idb
// long double __usercall _startOneArgErrorHandling@<st0>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, long double a4@<st0>, int a5, int a6, int a7, int a8);
// void __cdecl __noreturn __crtExitProcess(UINT uExitCode);
// _DWORD __cdecl _initterm(_DWORD); weak
// int __cdecl _cinit(int a1);
// void __cdecl doexit(UINT uExitCode, int a2, int a3);
// void __cdecl __noreturn exit(int status);
// void _cexit(void); idb
// int __cdecl _NMSG_WRITE(DWORD NumberOfBytesWritten); idb
// int _FF_MSGBANNER(void); weak
// int twincmdln(void); weak
// int _setenvp(void); weak
// int _setargv(void); weak
// _DWORD __thiscall GetEnvironmentStringsT(LPSTR MultiByte); weak
// int _ioinit(void); weak
void CrtSetCheckCount();
void On_Exit_Function(void); // idb
// int __cdecl __crtMessageBoxA(const char *lpText, const char *lpCaption, unsigned int uType); idb
// int __cdecl _global_unwind2(PVOID TargetFrame); idb
// void __cdecl _local_unwind2(int xr, int stop); idb
// _DWORD __stdcall _NLG_Notify(_DWORD); weak
// _DWORD __cdecl _ValidateEH3RN(_DWORD); weak
// _DWORD __cdecl _free_osfhnd(_DWORD); weak
// __int32 __cdecl _get_osfhandle(int file_descriptor); idb
// _DWORD __cdecl lock_fh(_DWORD); weak
// void __cdecl unlock_fh(signed int a1);
// int __usercall Very_Strange_Shit@<eax>(int a1@<ebp>);
// int _alloc_osfhnd_sub_4875A2(void); weak
void _alloc_osfhnd_sub_48763C();
// int __cdecl _commit(int a1, int file_descriptor);
void commit_call___unlock_fhandle();
// int __cdecl calloc(int a1, size_t num, size_t size);
// int __thiscall calloc_sub_4877AB(_DWORD); weak
// int _fcloseall(void); idb
void _fcloseall_sub_48784E();
// _DWORD __cdecl _getbuf(_DWORD); weak
// int __cdecl _sopen(const char *filename, int oflag, int shflag, int pmode); idb
// int __stdcall __crtInitCritSecNoSpinCount(LPCRITICAL_SECTION lpCriticalSection, int); idb
// int __cdecl __crtInitCritSecAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, int); idb
// int __cdecl isdigit(int); idb
// int __cdecl isxdigit(int); idb
// int __cdecl isspace(int CharType); idb
// int __cdecl ungetc(int character, _SYSTEMTIME *stream); idb
// int __cdecl mbtowc(wchar_t *pwc, const char *pmb, size_t max); idb
// _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD); weak
int __cdecl _ld12cvt_wrapper(int ld12cut_arg_1, int ld12cut_arg_2); // idb
int __cdecl _fassign_sub_sub_488F5F(int a1, int a2);
int __cdecl _fassign_sub_488F75(int ld12cut_arg_2, int a2);
int __cdecl _fassign_sub_488FB2(int a1, int a2);
// int __cdecl _87except(int a1, int a2, __int16 *a3);
// int __cdecl atexit(void (*func)(void)); idb
// signed int __cdecl x_ismbbtype(unsigned __int8 a1, int a2, unsigned __int8 a3);
// int __cdecl _chsize_lk(int, LONG lDistanceToMove); idb
// _DWORD __cdecl __addl(_DWORD, _DWORD, _DWORD); weak
// int __cdecl __shl_12(int a1);
// _DWORD __cdecl __shr_12(_DWORD); weak
// _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _raise_exc(DWORD Arguments, int, DWORD dwExceptionCode, int, int, int); idb
// _DWORD __cdecl _handle_exc(_DWORD, _DWORD, char); weak
// int __cdecl _set_errno(int Value); idb
int Return_0();
// _DWORD __cdecl _ctrlfp(_DWORD, _DWORD); weak
// int __cdecl realloc(int a1, void *ptr, size_t size);
// int __usercall realloc_sub_48AF52@<eax>(int a1@<ebp>);
// int realloc_sub_48AF5A(void); weak
// _DWORD __cdecl _setmode_lk(_DWORD, _DWORD); weak
// int __cdecl __ascii_stricmp(_BYTE *a1, _BYTE *a2);
// __int32 __cdecl atol(const char *str); idb
// char __usercall xtoa@<al>(unsigned int a1@<eax>, char *a2@<ecx>, unsigned int a3, int a4);
// char *__cdecl _itoa(int value, char *str, int base); idb
// __int32 __cdecl __ansicp(LCID Locale);
// int __cdecl __convertcp(UINT CodePage, int a2, LPCSTR lpMultiByteStr, int a4, int MultiByte, int MultiByteCount, int MultiByteCounta);
// int __cdecl __ld12mul(int a1, int a2);
// double __cdecl _set_exp(double, _DWORD); weak
// long double __cdecl _decomp(double a1, int *a2);
// int __cdecl __ascii_strnicmp(char *first, char *last, unsigned int count);
// char *__cdecl strchr(const char *string, int chr); idb
// BOOL __stdcall VerQueryValueA(const LPVOID pBlock, LPSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen); idb
// bool __stdcall GetFileVersionInfoA(LPSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
// DWORD __stdcall GetFileVersionInfoSizeA(LPSTR lptstrFilename, LPDWORD lpdwHandle); idb
// BOOL __stdcall ImmReleaseContext(HWND, HIMC); idb
// BOOL __stdcall ImmSetOpenStatus(HIMC, BOOL); idb
// HIMC __stdcall ImmGetContext(HWND); idb
OrgData *Init_OrgData();
// HRESULT __stdcall DirectDrawCreate(GUID *lpGUID, LPDIRECTDRAW *lplpDD, IUnknown *pUnkOuter); idb
// HRESULT __stdcall DirectInputCreateA(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTA *ppDI, LPUNKNOWN punkOuter); idb
// HRESULT __stdcall DirectSoundCreate(LPGUID, LPDIRECTSOUND *, LPUNKNOWN); idb
// BOOL __stdcall StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD); idb
// int __stdcall SetBkMode(HDC, int); idb
// HGDIOBJ __stdcall SelectObject(HDC, HGDIOBJ); idb
// HGDIOBJ __stdcall GetStockObject(int); idb
// BOOL __stdcall DeleteDC(HDC); idb
// COLORREF __stdcall SetTextColor(HDC, COLORREF); idb
// BOOL __stdcall TextOutA(HDC, int, int, LPCSTR, int); idb
// HFONT __stdcall CreateFontA(int, int, int, int, int, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPCSTR); idb
// COLORREF __stdcall GetPixel(HDC, int, int); idb
// COLORREF __stdcall SetPixel(HDC, int, int, COLORREF); idb
// BOOL __stdcall DeleteObject(HGDIOBJ); idb
// int __stdcall GetObjectA(HGDIOBJ, int, LPVOID); idb
// HDC __stdcall CreateCompatibleDC(HDC); idb
// int __stdcall GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR PointerData, int DataCount); idb
// BOOL __stdcall SetEndOfFile(HANDLE hFile); idb
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cchMultiByte, LPWSTR lpWideCharStr, int cchWideChar); idb
// BOOL __stdcall GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo); idb
// void __stdcall InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection); idb
// BOOL __stdcall FlushFileBuffers(HANDLE hFile); idb
// HRSRC __stdcall FindResourceA(HMODULE hModule, LPCSTR lpName, LPCSTR lpType); idb
// HGLOBAL __stdcall LoadResource(HMODULE hModule, HRSRC hResInfo); idb
// LPVOID __stdcall LockResource(HGLOBAL hResData); idb
// HANDLE __stdcall OpenMutexA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName); idb
// HANDLE __stdcall CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName); idb
// BOOL __stdcall ReleaseMutex(HANDLE hMutex); idb
// void __stdcall OutputDebugStringA(LPCSTR lpOutputString); idb
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile); idb
// DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh); idb
// BOOL __stdcall CloseHandle(HANDLE hObject); idb
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD Flags, LPCWSTR WideChar, int WideCharCount, LPSTR MultiByte, int MultiByteCount, LPCSTR DefaultChar, LPBOOL UsedDefaultChar); idb
// void __stdcall GetSystemTime(LPSYSTEMTIME lpSystemTime); idb
// BOOL __stdcall SystemTimeToFileTime(PSCOPETABLE_ENTRY *lpSystemTime, LPFILETIME lpFileTime); idb
// LONG __stdcall CompareFileTime(EH3_EXCEPTION_REGISTRATION *lpFileTime1, EH3_EXCEPTION_REGISTRATION *lpFileTime2); idb
// BOOL __stdcall DeleteFileA(LPCSTR lpFileName); idb
// UINT __stdcall GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize); idb
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize); idb
// HANDLE GetCurrentProcess(void); idb
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode); idb
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName); idb
// void __stdcall Sleep(DWORD dwMilliseconds); idb
// DWORD GetTickCount(void); idb
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName); idb
// void __stdcall ExitProcess(UINT uExitCode); idb
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem); idb
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, DWORD dwBytes); idb
// void __stdcall GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo); idb
// LPSTR GetCommandLineA(void); idb
// BOOL __stdcall GetVersionExA(LPOSVERSIONINFOA lpVersionInformation); idb
// BOOL __stdcall QueryPerformanceCounter(FILE *lpPerformanceCount); idb
// DWORD GetCurrentThreadId(void); idb
// DWORD GetCurrentProcessId(void); idb
// void __stdcall GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime); idb
// DWORD GetLastError(void); idb
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection); idb
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection); idb
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped); idb
// LPVOID __stdcall HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, DWORD dwBytes); idb
// void __stdcall SetLastError(DWORD dwErrCode); idb
// void __stdcall DragFinish(HDROP); idb
// UINT __stdcall DragQueryFileA(HDROP, UINT, LPSTR, UINT); idb
// HINSTANCE __stdcall ShellExecuteA(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd); idb
// BOOL __stdcall PathRemoveFileSpecA(LPSTR pszPath); idb
// BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect); idb
// BOOL __stdcall CheckDlgButton(HWND hDlg, int nIDButton, UINT uCheck); idb
// HANDLE __stdcall LoadImageA(HINSTANCE, LPCSTR, UINT, int, int, UINT); idb
// int __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType); idb
// BOOL __stdcall SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags); idb
// HWND __stdcall GetParent(HWND hWnd); idb
// UINT __stdcall IsDlgButtonChecked(HWND hDlg, int nIDButton); idb
// BOOL __stdcall SetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPCSTR lpString); idb
// BOOL __stdcall EndDialog(HWND hDlg, int nResult); idb
// UINT __stdcall GetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPSTR lpString, int nMaxCount); idb
// BOOL __stdcall PeekMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg); idb
// BOOL __stdcall GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax); idb
// BOOL __stdcall TranslateMessage(_STARTUPINFOA *lpMsg); idb
// LONG __stdcall DispatchMessageA(_STARTUPINFOA *lpMsg); idb
// BOOL __stdcall DeleteMenu(HMENU hMenu, UINT uPosition, UINT uFlags); idb
// BOOL __stdcall DrawMenuBar(HWND hWnd); idb
// LRESULT __stdcall DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam); idb
// int __stdcall DialogBoxParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam); idb
// BOOL __stdcall PostMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam); idb
// void __stdcall PostQuitMessage(int nExitCode); idb
// HCURSOR __stdcall LoadCursorA(HINSTANCE hInstance, LPCSTR lpCursorName); idb
// HICON __stdcall LoadIconA(HINSTANCE hInstance, LPCSTR lpIconName); idb
// ATOM __stdcall RegisterClassExA(WNDCLASSEXA *);
// HWND __stdcall CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam); idb
// HMENU __stdcall GetMenu(HWND hWnd); idb
// int __stdcall ShowCursor(BOOL bShow); idb
// BOOL __stdcall SetWindowTextA(HWND hWnd, LPCSTR lpString); idb
// BOOL __stdcall GetWindowPlacement(HWND hWnd, RECT *lpwndpl); idb
// int __stdcall GetSystemMetrics(int nIndex); idb
// BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint); idb
// BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow); idb
// BOOL __stdcall SystemParametersInfoA(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni); idb
// BOOL __stdcall GetFileVersionInfoA(LPSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData); idb
// MMRESULT __stdcall timeBeginPeriod(UINT uPeriod); idb
// MMRESULT __stdcall timeGetDevCaps(LPTIMECAPS ptc, UINT cbtc); idb
// MMRESULT __stdcall timeSetEvent(UINT uDelay, UINT uResolution, LPTIMECALLBACK fptc, DWORD dwUser, UINT fuEvent); idb
// DWORD timeGetTime(void); idb
// MMRESULT __stdcall timeEndPeriod(UINT uPeriod); idb
// MMRESULT __stdcall timeKillEvent(UINT uTimerID); idb

//-------------------------------------------------------------------------
// Data declarations

char byte_480D10 = '\x18'; // weak
char byte_48C42C[] = { '\\' }; // idb
FILE stream =
{
  (char *)0x252C7325,
  2660,
  (char *)0x255C7325,
  115,
  25202,
  626815781,
  115,
  (char *)0x6277
}; // idb
char iconName[] = { '0' }; // idb
char aGGkgebGarTsv[] = "{\x81[\x90"; // idb
char aVcdy_Dest[14] = "DY.\x11DEST"; // weak
_SCOPETABLE_ENTRY stru_48CA78 = { 4294967295, NULL, &loc_480F97 }; // weak
_SCOPETABLE_ENTRY stru_48CAC8 = { 4294967295, NULL, &loc_4819C3 }; // weak
int weaponIconXOffset = 16; // idb
WeaponData weaponDataDamage[] = { { '\0', '\0', "", 0, 0, 0, 0, 0, 0, { 0, 0, 0, 0 } } };
effectData effectDataViewLeft[] =
{
  { 0, 0 },
  { 2048, 2048 },
  { 4096, 4096 },
  { 4096, 4096 },
  { 4096, 4096 },
  { 2048, 2048 },
  { 4096, 4096 },
  { 2048, 2048 },
  { 4096, 4096 },
  { 4096, 4096 },
  { 14336, 4096 },
  { 2048, 2048 },
  { 8192, 8192 },
  { 2048, 2048 },
  { 10240, 10240 },
  { 2048, 2048 },
  { 10240, 2048 },
  { 26624, 2048 }
};
EffectFunction effectFunctionTable[18] =
{
  &effect0_Nothing,
  &effect1_RandomFountainPulsingDiscParticles,
  &effect2_RisingDiscAndExplodingDiamond,
  &effect3_Star,
  &effect4_FireballImpact,
  &effect5_ZzZ,
  &effect4_FireballImpact,
  &effect6_BoosterSmoke,
  &effect7_DrownedQuote,
  &effect8_ExclamationMark,
  &effect9_LevelUpOrDown,
  &effect10_RedDamageRings,
  &effect11_BigExplosion,
  &effect12_HeadbumpSparks,
  &effect13_UnknownUnused,
  &effect14_SmallWhiteExplosionDisc,
  &effect15_Nothing,
  &effect16_PushJumpKey
};
char *DOUKUTSU20041206 = "DOUKUTSU20041206"; // idb
const char *configDat = "Config.dat";
char *versionString = "version.%d.%d.%d.%d\r\n2004/12/20 - %04d/%02d/%02d\r\nStudio Pixel"; // idb
int graphicScale = 1; // weak
char *off_48F918 = "credit.tsc"; // weak
RECT gameRect = { 0, 0, 320, 240 }; // idb
RECT rect = { 0, 0, 320, 240 }; // idb
char *Image_Tag = "(C)Pixel"; // idb
int Snd_Data_Table = 1; // idb
int Ptr_Sound = 1; // idb
int dword_48FB00 = 1; // idb
int dword_48FBE0 = 1; // idb
int dword_48FC50 = 1; // idb
int dword_48FCC0 = 1; // idb
int dword_48FD30 = 1; // idb
int dword_48FE10 = 1; // idb
int dword_48FEF0 = 1; // idb
int dword_48FFD0 = 1; // idb
int dword_4900B0 = 1; // idb
int dword_490190 = 1; // idb
int dword_490350 = 1; // idb
int dword_490430 = 1; // idb
int dword_490580 = 1; // idb
int dword_490660 = 1; // idb
int dword_4906D0 = 1; // idb
int dword_490740 = 1; // idb
int dword_4907B0 = 1; // idb
int dword_490820 = 1; // idb
int dword_490890 = 1; // idb
int dword_490900 = 1; // idb
int dword_4909E0 = 1; // idb
int dword_490A50 = 1; // idb
int dword_490B30 = 1; // idb
int dword_490C10 = 1; // idb
int dword_490C80 = 1; // idb
int dword_490D60 = 1; // idb
int dword_490E40 = 1; // idb
int dword_490EB0 = 1; // idb
int dword_491000 = 1; // idb
int dword_4910E0 = 1; // idb
int dword_4911C0 = 1; // idb
int dword_491230 = 1; // idb
int dword_491310 = 1; // idb
int dword_491380 = 1; // idb
int dword_4913F0 = 1; // idb
int dword_491460 = 1; // idb
int dword_4915B0 = 1; // idb
int dword_491620 = 1; // idb
int dword_491700 = 1; // idb
int dword_491770 = 1; // idb
int unk_4917E0 = 1; // idb
int dword_4918C0 = 1; // idb
int dword_491930 = 1; // idb
int dword_491A80 = 1; // idb
int dword_491B60 = 1; // idb
int dword_491C40 = 1; // idb
int dword_491CB0 = 1; // idb
int dword_491D20 = 1; // idb
int dword_491D90 = 1; // idb
int dword_491E70 = 1; // idb
int dword_491EE0 = 1; // idb
int dword_491F50 = 1; // idb
int dword_491FC0 = 1; // idb
int dword_492030 = 1; // idb
int dword_4920A0 = 1; // idb
int dword_492110 = 1; // idb
int dword_492180 = 1; // idb
int dword_4921F0 = 1; // idb
int dword_4922D0 = 1; // idb
int dword_4923B0 = 1; // idb
int dword_492490 = 1; // idb
int dword_492500 = 1; // idb
int dword_492570 = 1; // idb
int dword_492650 = 1; // idb
int dword_492730 = 1; // idb
int dword_492810 = 1; // idb
int unk_4928F0 = 1; // idb
int dword_4929D0 = 1; // idb
int dword_492AB0 = 1; // idb
int dword_492C00 = 1; // idb
int dword_492C70 = 1; // idb
int dword_492DC0 = 1; // idb
int dword_492EA0 = 1; // idb
int dword_492F80 = 1; // idb
int dword_493060 = 1; // idb
int dword_4930D0 = 1; // idb
int dword_493140 = 1; // idb
int dword_4931B0 = 1; // idb
int dword_493290 = 1; // idb
int dword_493370 = 1; // idb
int dword_493450 = 1; // idb
int dword_4934C0 = 1; // idb
int dword_493530 = 1; // idb
int dword_4935A0 = 1; // idb
int keyJump = 64; // weak
int keyShoot = 32; // weak
int keyNextWeapon = 128; // weak
int keyPreviousWeapon = 256; // weak
int keyMenu = 4096; // weak
int keyForMap = 16; // weak
int keyOk = 64; // weak
int keyCancel = 32; // weak
int keyLeft = 1; // weak
int keyUp = 4; // weak
int keyRight = 2; // weak
int keyDown = 8; // weak
char *windowName = "Cave Story ~ Doukutsu Monogatari";
int dword_493644 = 1; // weak
const char *pDoukutsu = "Doukutsu";
void *PXM = &aPxm; // idb
RECT stru_493650 = { 0, 0, 160, 12 }; // idb
WeaponEXPValues Weapon_Level_Table[14] =
{
  { { 0, 0, 100 } },
  { { 30, 40, 16 } },
  { { 10, 20, 10 } },
  { { 10, 20, 20 } },
  { { 30, 40, 10 } },
  { { 10, 20, 10 } },
  { { 10, 20, 30 } },
  { { 10, 20, 5 } },
  { { 10, 20, 100 } },
  { { 30, 60, 0 } },
  { { 30, 60, 10 } },
  { { 10, 20, 100 } },
  { { 1, 1, 1 } },
  { { 40, 60, 200 } }
};
OCTWAVE oct_wave[8] =
{
  { 256, 1, 4 },
  { 256, 2, 8 },
  { 128, 4, 12 },
  { 128, 8, 16 },
  { 64, 16, 20 },
  { 32, 32, 24 },
  { 16, 64, 28 },
  { 8, 128, 32 }
};
BYTE format_tbl2[] =
{
  1u,
  0u,
  1u,
  0u,
  34u,
  86u,
  0u,
  0u,
  34u,
  86u,
  0u,
  0u,
  1u,
  0u,
  8u,
  0u,
  0u,
  0u,
  0u,
  0u
};
__int16 frequencyTable[12] = { 262, 277, 294, 311, 330, 349, 370, 392, 415, 440, 466, 494 };
__int16 panTable[13] = { 0, 43, 86, 129, 172, 215, 256, 297, 340, 383, 426, 469, 512 };
unsigned __int8 old_key[16] =
{
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
};
UINT ExactTime = 13u; // idb
int musicVolume = 100;
char *defaultProfileName = "Profile.dat";
void *pProfileCheck = &Profile_dat_Check; // idb
MapHeader mapHeaders[] =
{
  {
    {
      '0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0',
      '\0'
    },
    "0",
    4,
    "bk0",
    "Guest",
    "0",
    '\0',
    "Null"
  }
};
char *songNames[42] =
{
  "XXXX",
  "WANPAKU",
  "ANZEN",
  "GAMEOVER",
  "GRAVITY",
  "WEED",
  "MDOWN2",
  "FIREEYE",
  "VIVI",
  "MURA",
  "FANFALE1",
  "GINSUKE",
  "CEMETERY",
  "PLANT",
  "KODOU",
  "FANFALE3",
  "FANFALE2",
  "DR",
  "ESCAPE",
  "JENKA",
  "MAZE",
  "ACCESS",
  "IRONH",
  "GRAND",
  "Curly",
  "OSIDE",
  "REQUIEM",
  "WANPAK2",
  "QUIET",
  "LASTCAVE",
  "BALCONY",
  "LASTBTL",
  "LASTBT3",
  "ENDING",
  "ZONBIE",
  "BDOWN",
  "HELL",
  "JENKA2",
  "MARINE",
  "BALLOS",
  "TOROKO",
  "WHITE"
};
RECT unk_498290 = { 0, 0, 216, 16 }; // idb
int unk_498298 = 216; // idb
int unk_49829C = 16; // idb
_UNKNOWN unk_4982A0; // weak
_UNKNOWN unk_4983F0; // weak
void (__cdecl *NPC_Function_Table[361])(NPC *a1) =
{
  &NPC0_Nothing,
  &NPC1_WeaponEnergy,
  &NPC2_EnemyBehemoth,
  &NPC3_DeletesItself,
  &NPC4_Smoke,
  &NPC5_EnemyCritterHoppingGreen,
  &NPC6_EnemyBeetleHorizontalGreen,
  &NPC7_EnemyBasil,
  &NPC8_EnemyBeetleFollow1,
  &NPC9_BalrogDropIn,
  &NPC10_BossBalrogShooting,
  &NPC11_ProjectileBalrogEnergyBounce,
  &NPC12_BalrogCutscene,
  &NPC13_Forcefield,
  &NPC14_SantasKey,
  &NPC15_TreasureChestClosed,
  &NPC16_SavePoint,
  &NPC17_HealthAmmoRefill,
  &NPC18_Door,
  &NPC19_BalrogBustsIn,
  &NPC20_Computer,
  &NPC21_TreasureChestOpen,
  &NPC22_Teleporter,
  &NPC23_TeleporterLights,
  &NPC24_PowerCritter,
  &NPC25_LiftPlatform,
  &NPC26_EnemyBatBlackCircling,
  &NPC27_Deathtrap,
  &NPC28_EnemyCritterFlying,
  &NPC29_Cthulhu,
  &NPC30_HermitGunsmith,
  &NPC31_EnemyBatBlackHanging,
  &NPC32_LifeCapsule,
  &NPC33_ProjectileBalrogEnergyBounce,
  &NPC34_Bed,
  &NPC35_EnemyMannan,
  &NPC36_BossBalrogHovering,
  &NPC37_Signpost,
  &NPC38_FireplaceFire,
  &NPC39,
  &NPC40,
  &NPC41,
  &NPC42,
  &NPC43,
  &NPC44,
  &NPC45,
  &NPC46,
  &NPC47,
  &NPC48,
  &NPC49,
  &NPC50,
  &NPC51,
  &NPC52_Sitting_Blue_Bot,
  &NPC53,
  &NPC54,
  &NPC55,
  &NPC56,
  &NPC57,
  &NPC58,
  &NPC59,
  &NPC60,
  &NPC61,
  &NPC62,
  &NPC63,
  &NPC64,
  &NPC65,
  &NPC66,
  &NPC67,
  &NPC68,
  &NPC69,
  &NPC70,
  &NPC71,
  &NPC72,
  &NPC73,
  &NPC74,
  &NPC75,
  &NPC76,
  &NPC77_Sandaim_the_Farmer,
  &NPC78_Pot,
  &NPC79,
  &NPC80,
  &NPC81,
  &NPC82,
  &NPC83,
  &NPC84,
  &NPC85,
  &NPC86,
  &NPC87,
  &NPC88,
  &NPC89,
  &NPC90,
  &NPC91,
  &NPC92,
  &NPC93,
  &NPC94_Giant_Jelly,
  &NPC95,
  &NPC96,
  &NPC97,
  &NPC98,
  &NPC99,
  &NPC100,
  &NPC101,
  &NPC102,
  &NPC103,
  &NPC104,
  &NPC105,
  &NPC106,
  &NPC107,
  &NPC108,
  &NPC109,
  &NPC110,
  &NPC111,
  &NPC112,
  &NPC113,
  &NPC114,
  &NPC115,
  &NPC116,
  &NPC117,
  &NPC118,
  &NPC119,
  &NPC120,
  &NPC121,
  &NPC122,
  &NPC123,
  &NPC124,
  &NPC125,
  &NPC126,
  &NPC127,
  &NPC128,
  &NPC129,
  &NPC130,
  &NPC131,
  &NPC132,
  &NPC133,
  &NPC134,
  &NPC135,
  &NPC136,
  &NPC137,
  &NPC138,
  &NPC139,
  &NPC140,
  &NPC141,
  &NPC142,
  &NPC143,
  &NPC144,
  &NPC145,
  &NPC146,
  &NPC147,
  &NPC148,
  &NPC149,
  &NPC150,
  &NPC151,
  &NPC152,
  &NPC153,
  &NPC154,
  &NPC155,
  &NPC156,
  &NPC157,
  &NPC158,
  &NPC159,
  &NPC160,
  &NPC161,
  &NPC162,
  &NPC163,
  &NPC164,
  &NPC165,
  &NPC166,
  &NPC167,
  &NPC168,
  &NPC169,
  &NPC170,
  &NPC171,
  &NPC172,
  &NPC173,
  &NPC174,
  &NPC175,
  &NPC176,
  &NPC177,
  &NPC178,
  &NPC179,
  &NPC180,
  &NPC181,
  &NPC182,
  &NPC183,
  &NPC184,
  &NPC185,
  &NPC186,
  &NPC187,
  &NPC188,
  &NPC189,
  &NPC190,
  &NPC191,
  &NPC192,
  &NPC193,
  &NPC194,
  &NPC195,
  &NPC196,
  &NPC197,
  &NPC198,
  &NPC199,
  &NPC200,
  &NPC201,
  &NPC202,
  &NPC203,
  &NPC204,
  &NPC205,
  &NPC206,
  &NPC207,
  &NPC208,
  &NPC209,
  &NPC210,
  &NPC211,
  &NPC212,
  &NPC213,
  &NPC214,
  &NPC215,
  &NPC216_Debug_Cat,
  &NPC217,
  &NPC218,
  &NPC219,
  &NPC220,
  &NPC221,
  &NPC222,
  &NPC223,
  &NPC224,
  &NPC225,
  &NPC226,
  &NPC227_Bucket,
  &NPC228,
  &NPC229,
  &NPC230,
  &NPC231,
  &NPC232,
  &NPC233,
  &NPC234,
  &NPC235,
  &NPC236,
  &NPC237,
  &NPC238,
  &NPC239,
  &NPC240,
  &NPC241,
  &NPC242,
  &NPC243,
  &NPC244,
  &NPC245,
  &NPC246,
  &NPC247,
  &NPC248,
  &NPC249,
  &NPC250,
  &NPC251,
  &NPC252,
  &NPC253,
  &NPC254,
  &NPC255,
  &NPC256,
  &NPC257,
  &NPC258,
  &NPC259,
  &NPC260,
  &NPC261,
  &NPC262,
  &NPC263,
  &NPC264,
  &NPC265,
  &NPC266,
  &NPC267,
  &NPC268,
  &NPC269,
  &NPC270,
  &NPC271,
  &NPC272,
  &NPC273,
  &NPC274,
  &NPC275,
  &NPC276,
  &NPC277,
  &NPC278,
  &NPC279,
  &NPC280,
  &NPC281,
  &NPC282,
  &NPC283,
  &NPC284,
  &NPC285,
  &NPC286,
  &NPC287,
  &NPC288,
  &NPC289,
  &NPC290,
  &NPC291,
  &NPC292,
  &NPC293,
  &NPC294,
  &NPC295,
  &NPC296,
  &NPC297,
  &NPC298,
  &NPC299,
  &NPC300,
  &NPC301,
  &NPC302,
  &NPC303,
  &NPC304,
  &NPC305,
  &NPC306,
  &NPC307,
  &NPC308,
  &NPC309,
  &NPC310,
  &NPC311,
  &NPC312,
  &NPC313,
  &NPC314,
  &NPC315,
  &NPC316,
  &NPC317,
  &NPC318,
  &NPC319,
  &NPC320,
  &NPC321,
  &NPC322,
  &NPC323,
  &NPC324,
  &NPC325,
  &NPC326,
  &NPC327,
  &NPC328,
  &NPC329,
  &NPC330,
  &NPC331,
  &NPC332,
  &NPC333,
  &NPC334,
  &NPC335,
  &NPC336,
  &NPC337,
  &NPC338,
  &NPC339,
  &NPC340,
  &NPC341,
  &NPC342,
  &NPC343,
  &NPC344,
  &NPC345,
  &NPC346,
  &NPC347,
  &NPC348,
  &NPC349,
  &NPC350,
  &NPC351,
  &NPC352,
  &NPC353,
  &NPC354,
  &NPC355,
  &NPC356,
  &NPC357,
  &NPC358,
  &NPC359,
  &NPC360_Thank_You
};
int (__cdecl *Boss_Function_Table[13])(_DWORD) =
{
  &boss0_NoSpecialBoss,
  &Boss_1_Omega,
  &boss2_Balfrog,
  &boss3_MonsterX,
  &boss4_Core,
  &Boss_5_Ironhead,
  &Boss_6_Dragon_Sisters,
  &boss7_UndeadCore,
  &Boss_8_Heavy_Press,
  &boss9_BallosBall,
  NULL,
  NULL,
  NULL
}; // idb
int dword_4994F0 = 1024; // weak
_UNKNOWN unk_499508; // weak
int quoteInventoryMinus1[] = { 0 }; // weak
ItemData quoteInventory[32] =
{
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 },
  { 0 }
};
int inventoryActive = 0; // weak
int inventoryLabelPosition = 0; // idb
Weapon gWeapons[8] =
{
  { 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0 }
};
int selectedWeapon = 0; // weak
int selectedItem = 0; // weak
unsigned int menuRectFlash = 0u;
Background currentBackground =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }
};
int globalWaterDepth = 0; // weak
int color_black = 0; // weak
Bullet bulletObjects[64] =
{
  {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0u,
    { 0, 0, 0, 0 },
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    { 0, 0, 0, 0 }
  },
  {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0u,
    { 0, 0, 0, 0 },
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    { 0, 0, 0, 0 }
  },
  {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0u,
    { 0, 0, 0, 0 },
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    { 0, 0, 0, 0 }
  },
  {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0u,
    { 0, 0, 0, 0 },
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    { 0, 0, 0, 0 }
  },
  {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0u,
    { 0, 0, 0, 0 },
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    { 0, 0, 0, 0 }
  },
  {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0u,
    { 0, 0, 0, 0 },
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    { 0, 0, 0, 0 }
  },
  {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0u,
    { 0, 0, 0, 0 },
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    
  }
};
int dword_49BC98; // weak
int dword_49BC9C; // weak
int dword_49BCA0; // weak
Effect effectObjects[40];
int screenOffsetX; // weak
_DWORD screenOffsetY;
RECT windowIdk;
int directDrawIsFullscreen; // weak
LPDIRECTDRAWCLIPPER clipListMaybe;
char namesThingy[];
int dword_49CDDC[]; // idb
int dword_49CDE0[]; // idb
int dword_49CDE4[]; // idb
int dword_49CDE8[351]; // idb
HGDIOBJ fontHandle[];
int fullscreenSurfaceHeight; // weak
int windowSurfaceWidth; // weak
LPDIRECTDRAW directDrawObject;
LPDIRECTDRAWSURFACE directDrawFinalScreenSurface;
LPDIRECTDRAWSURFACE directDrawScreenSurface;
LPDIRECTDRAWSURFACE imageResSurface[];
RECT finalScreenDistRects;
unsigned int previousTickCount;
int currentTickCount; // weak
RECT RECT_ScreenCopy;
DDBLTFX DDBLTFX_ScreenCopy;
RECT finalDestinationRect1;
RECT rectWork;
RECT Final_Dst_Rect_2;
RECT Final_Src_Rect_2;
RECT Final_Dst_Rect_3;
RECT Final_Src_Rect_3;
RECT Dest_Rect;
void Draw_Colour_Fill_DDBLTFX[]; // idb
char Draw_Colour_Fill_DDBLTFX_dxFillColor[20]; // weak
RECT Final_Dst_Rect_5;
void Draw_Colour_Fill_Onto_Surface_DDBLTFX[]; // idb
char Draw_Colour_Fill_Onto_Surface_DDBLTFX_dxFillColor[24]; // weak
Illustration creditPicture;
TSCStruct creditScript;
TextObject textObjectArray[16];
int Mask_Color; // idb
FadeVars fadeObject;
_BYTE skipFlags[8];
_BYTE eventFlags[1000];
FlashAnimation Flash;
int FlashColor; // idb
Camera gCamera;
bool cursorPosition;
int gameFlags; // weak
int gameTime; // weak
LPDIRECTINPUTA DirectInputObj; // idb
int dword_49E1F4; // weak
int dword_49E1F8; // weak
int dword_49E1FC; // weak
int dword_49E200; // weak
int dword_49E204; // weak
int dword_49E208; // weak
int dword_49E20C; // weak
int keyHeld; // weak
int keyPressed; // weak
int lastKeyHeld; // weak
char dataPath[]; // idb
char exePath[]; // idb
int joystickButtonTable[]; // weak
HINSTANCE appInstance; // idb
int windowWidth; // weak
int windowHeight; // weak
HWND appWinHandle; // idb
int useJoystick; // weak
int isFullscreen; // weak
int FPSCounterEnabled; // weak
int canAcceptInput; // weak
int Timer1000Time; // weak
int Timer1000Elapsed; // weak
int Timer1000Ticks; // weak
HANDLE hMutex; // idb
HANDLE hObject; // idb
MapData currentMap;
char Draw_Map_Data_Vector::count; // weak
MapName Map_Name;
char mapFlagArray[128];
Player quote;
int Noise_Num; // weak
DWORD Noise_Frequency; // idb
int Nikumaru_Counter; // weak
char byte_49E6F8; // weak
char wave_data[25600];
__int32 playPosition;
NOTELIST *np[16];
LPDIRECTSOUNDBUFFER organBuffer[8][8][2];
int mute[16];
unsigned __int8 key_on[16];
unsigned __int8 key_twin[16];
UINT TimerID; // idb
int IsTimerActive; // weak
__int32 Note_Lengths[8];
int Track_Volume[16];
int musicFadeFlagMaybe; // weak
OrgData orgDataObject; // idb
char byte_4A4F00[]; // weak
int dword_4A54F8[]; // weak
int dword_4A54FC[]; // weak
PermitStageStruct unlockedStages[8];
int teleporterYPos; // idb
int selectedSurface; // weak
int dword_4A5548; // weak
int emptyEffectTimer; // weak
int dword_4A5550; // weak
int Machine_Gun_Reload_Timer; // weak
int Bubbler_Lvl_1_Refill_Timer; // weak
int dword_4A555C; // weak
int dword_4A5560; // weak
int dword_4A5564; // weak
LPDIRECTSOUNDBUFFER secondaryBuffer[150];
LPDIRECTSOUNDBUFFER drumBuffer[8];
LPDIRECTSOUND lpDS; // idb
LPDIRECTSOUNDBUFFER lpPRIMARYBUFFER;
int currentStageNumber; // weak
int currentSongNumber; // weak
int oldSongPosition; // weak
int oldSongNumber; // weak
Effect whimsicalStars[3];
int CurrentStarID; // weak
MapData2 textBuffer;
size_t size; // idb
__int8 *scriptBuffer;
char byte_4A5ADC; // weak
char byte_4A5ADD; // weak
int scriptPosition; // idb
int textColumn; // weak
DWORD dword_4A5AE8[5];
int dword_4A5AEC[]; // weak
int dword_4A5AFC; // weak
int dword_4A5B00; // weak
int dword_4A5B04; // weak
char byte_4A5B08; // weak
int faceNumber; // weak
int dword_4A5B10; // weak
int dword_4A5B14; // weak
int textBoxRelatedYPos; // idb
RECT rcView;
int dword_4A5B2C; // weak
char byte_4A5B30; // weak
int numberTextScript[4];
int sinTable[]; // weak
__int16 gTan[]; // weak
int eventIndex; // weak
void eventInUse; // idb
int eventCollision[]; // weak
int eventXPos[]; // weak
int eventYPos[]; // weak
int eventXVel[]; // weak
int eventYVel[]; // weak
int eventAltXVel[]; // weak
int eventAltYVel[]; // weak
int eventUnknown1[]; // weak
int eventUnknown2[]; // weak
int dword_4A6218; // weak
NPC NPCObjects[512];
int curlyShootWait; // weak
int curlyShootX; // weak
int curlyShootY; // weak
int superXPos; // weak
int superYPos; // weak
NPCInfo *NPCTable;
_UNKNOWN NPCStruct_Tileset; // weak
_UNKNOWN npcStructDeathSound; // weak
_UNKNOWN NPCStructExp; // weak
_UNKNOWN NPCStructDamage; // weak
unsigned __int8 byte_4BBA41[3]; // idb
Boss bossThing;
NPC bossObjects[20];
char byte_4BC7C8; // weak
char byte_4BC7C9; // weak
int dword_4BD034; // weak


//----- (00401000) --------------------------------------------------------
// Clear Weapons
void clearWeaponData(void)
{
  weaponIconXOffset = 32;
  memset(gWeapons, 0, 0xA0u);
}

//----- (00401030) --------------------------------------------------------
// Clear Inventory
void clearItemData(void)
{
  memset(quoteInventory, 0, 0x80u);
}

//----- (00401050) --------------------------------------------------------
// TSC Give Weapon [AM+]
int __cdecl addWeapon(int weaponID, int weaponMaxAmmo)
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 8 && gWeapons[i].weaponID != weaponID && gWeapons[i].weaponID; ++i )
    ;
  if ( i == 8 )
    return 0;
  if ( gWeapons[i].weaponID == 0 )
  {
    memset(&gWeapons[i], 0, 0x14u);
    gWeapons[i].level = 1;
  }
  gWeapons[i].weaponID = weaponID;
  gWeapons[i].maxAmmo += weaponMaxAmmo;
  gWeapons[i].ammo += weaponMaxAmmo;
  if ( gWeapons[i].ammo > gWeapons[i].maxAmmo )
    gWeapons[i].ammo = gWeapons[i].maxAmmo;
  return 1;
}

//----- (00401160) --------------------------------------------------------
// TSC Lose Weapon [AM-]
int __cdecl loseWeapon(int lostWeapon)
{
  Weapon *v2; // edx
  Weapon *v3; // eax
  signed int i; // [esp+0h] [ebp-4h]
  int j; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 8 && gWeapons[i].weaponID != lostWeapon; ++i )
    ;
  if ( i == 32 )
    return 0;
  for ( j = i + 1; j < 8; ++j )
  {
    v2 = &gWeapons[j];
    v3 = &gWeapons[j - 1];
    v3->weaponID = v2->weaponID;
    v3->level = v2->level;
    v3->EXP = v2->EXP;
    v3->maxAmmo = v2->maxAmmo;
    v3->ammo = v2->ammo;
  }
  gWeapons[j - 1].weaponID = 0;
  selectedWeapon = 0;
  return 1;
}
// 499C68: using guessed type int selectedWeapon;

//----- (00401220) --------------------------------------------------------
// TSC Trade Weapon [TAM]
signed int __cdecl tradeWeapon(int lostWeapon, int newWeapon, int newWeaponMaxAmmo)
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 8 && gWeapons[i].weaponID != lostWeapon; ++i )
    ;
  if ( i == 8 )
    return 0;
  gWeapons[i].level = 1;
  gWeapons[i].weaponID = newWeapon;
  gWeapons[i].maxAmmo += newWeaponMaxAmmo;
  gWeapons[i].ammo += newWeaponMaxAmmo;
  gWeapons[i].EXP = 0;
  return 1;
}

//----- (004012D0) --------------------------------------------------------
signed int __cdecl addItemData(int itemCode)
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 32 && quoteInventory[i].code != itemCode && quoteInventory[i].code; ++i )
    ;
  if ( i == 32 )
    return 0;
  quoteInventory[i].code = itemCode;
  return 1;
}

//----- (00401330) --------------------------------------------------------
signed int __cdecl subItemData(int itemCode)
{
  signed int i; // [esp+0h] [ebp-4h]
  int j; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 32 && quoteInventory[i].code != itemCode; ++i )
    ;
  if ( i == 32 )
    return 0;
  for ( j = i + 1; j < 32; ++j )
    quoteInventoryMinus1[j] = quoteInventory[j].code;
  quoteInventoryMinus1[j] = 0;
  selectedItem = 0;
  return 1;
}
// 499B3C: using guessed type int quoteInventoryMinus1[];
// 499C6C: using guessed type int selectedItem;

//----- (004013C0) --------------------------------------------------------
// Manage Inventory Cursor
int moveInventoryCursor()
{
  int result; // eax
  signed int v1; // [esp+0h] [ebp-Ch]
  int v2; // [esp+4h] [ebp-8h]
  int v3; // [esp+8h] [ebp-4h]

  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    result = 20 * v2;
    if ( gWeapons[v2].weaponID == 0 )
      break;
    ++v2;
  }
  while ( quoteInventory[v3].code )
    result = v3++ + 1;
  if ( v2 || v3 )
  {
    v1 = 0;
    if ( inventoryActive )
    {
      if ( keyLeft & keyPressed )
      {
        if ( selectedItem % 6 )
          --selectedItem;
        else
          selectedItem += 5;
        v1 = 1;
      }
      if ( keyRight & keyPressed )
      {
        if ( selectedItem == v3 - 1 )
        {
          selectedItem = 6 * (selectedItem / 6);
        }
        else if ( selectedItem % 6 == 5 )
        {
          selectedItem -= 5;
        }
        else
        {
          ++selectedItem;
        }
        v1 = 1;
      }
      if ( keyUp & keyPressed )
      {
        if ( selectedItem / 6 )
          selectedItem -= 6;
        else
          inventoryActive = 0;
        v1 = 1;
      }
      if ( keyDown & keyPressed )
      {
        if ( selectedItem / 6 == (v3 - 1) / 6 )
          inventoryActive = 0;
        else
          selectedItem += 6;
        v1 = 1;
      }
      result = selectedItem;
      if ( selectedItem >= v3 )
        selectedItem = v3 - 1;
      if ( inventoryActive && keyOk & keyPressed )
        result = startTSCEvent(quoteInventory[selectedItem].code + 6000);
    }
    else
    {
      if ( keyLeft & keyPressed )
      {
        --selectedWeapon;
        v1 = 1;
      }
      result = keyRight & keyPressed;
      if ( keyRight & keyPressed )
      {
        ++selectedWeapon;
        v1 = 1;
      }
      if ( keyPressed & (keyDown | keyUp) )
      {
        if ( v3 )
          inventoryActive = 1;
        v1 = 1;
      }
      if ( selectedWeapon < 0 )
      {
        result = v2 - 1;
        selectedWeapon = v2 - 1;
      }
      if ( selectedWeapon > v2 - 1 )
        selectedWeapon = 0;
    }
    if ( v1 )
    {
      if ( inventoryActive )
      {
        playSoundEffect(SFXYNChangeChoice, 1);
        if ( v3 )
          result = startTSCEvent(quoteInventory[selectedItem].code + 5000);
        else
          result = startTSCEvent(5000);
      }
      else
      {
        playSoundEffect(SFXSwitchWeapon, 1);
        if ( v2 )
          result = startTSCEvent(gWeapons[selectedWeapon].weaponID + 1000);
        else
          result = startTSCEvent(1000);
      }
    }
  }
  return result;
}
// 493628: using guessed type int keyOk;
// 493630: using guessed type int keyLeft;
// 493634: using guessed type int keyUp;
// 493638: using guessed type int keyRight;
// 49363C: using guessed type int keyDown;
// 499BC0: using guessed type int inventoryActive;
// 499C68: using guessed type int selectedWeapon;
// 499C6C: using guessed type int selectedItem;
// 49E214: using guessed type int keyPressed;

//----- (004016F0) --------------------------------------------------------
void drawInventoryWindow()
{
  RECT rectNone; // [esp+0h] [ebp-F4h]
  RECT rectView; // [esp+10h] [ebp-E4h]
  RECT rectBoxBottom; // [esp+20h] [ebp-D4h]
  RECT rectItem; // [esp+30h] [ebp-C4h]
  RECT rectCursor2[2]; // [esp+40h] [ebp-B4h]
  RECT rectPer; // [esp+60h] [ebp-94h]
  RECT rectWeapon; // [esp+70h] [ebp-84h]
  RECT rectLevel; // [esp+80h] [ebp-74h]
  RECT rectCursor1[2]; // [esp+90h] [ebp-64h]
  RECT rectTitle1; // [esp+B0h] [ebp-44h]
  int i; // [esp+C0h] [ebp-34h]
  RECT rectBoxBody; // [esp+C4h] [ebp-30h]
  RECT rectBoxTop; // [esp+D4h] [ebp-20h]
  RECT rectTitle2; // [esp+E4h] [ebp-10h]

  rectPer.left = 72;
  rectPer.top = 48;
  rectPer.right = 80;
  rectPer.bottom = 56;
  rectNone.left = 80;
  rectNone.top = 48;
  rectNone.right = 96;
  rectNone.bottom = 56;
  rectLevel.left = 80;
  rectLevel.top = 80;
  rectLevel.right = 96;
  rectLevel.bottom = 88;
  rectView.left = 0;
  rectView.top = 0;
  rectView.right = 320;
  rectView.bottom = 240;
  rectCursor1[0].left = 0;
  rectCursor1[0].top = 88;
  rectCursor1[0].right = 40;
  rectCursor1[0].bottom = 128;
  rectCursor1[1].left = 40;
  rectCursor1[1].top = 88;
  rectCursor1[1].right = 80;
  rectCursor1[1].bottom = 128;
  rectCursor2[0].left = 80;
  rectCursor2[0].top = 88;
  rectCursor2[0].right = 112;
  rectCursor2[0].bottom = 104;
  rectCursor2[1].left = 80;
  rectCursor2[1].top = 104;
  rectCursor2[1].right = 112;
  rectCursor2[1].bottom = 120;
  rectTitle1.left = 80;
  rectTitle1.top = 48;
  rectTitle1.right = 144;
  rectTitle1.bottom = 56;
  rectTitle2.left = 80;
  rectTitle2.top = 56;
  rectTitle2.right = 144;
  rectTitle2.bottom = 64;
  rectBoxTop.left = 0;
  rectBoxTop.top = 0;
  rectBoxTop.right = 244;
  rectBoxTop.bottom = 8;
  rectBoxBody.left = 0;
  rectBoxBody.top = 8;
  rectBoxBody.right = 244;
  rectBoxBody.bottom = 16;
  rectBoxBottom.left = 0;
  rectBoxBottom.top = 16;
  rectBoxBottom.right = 244;
  rectBoxBottom.bottom = 24;
  drawBitmapWithTransparency(&rectView, 38, 8, &rectBoxTop, 26);
  for ( i = 1; i < 18; ++i )
    drawBitmapWithTransparency(&rectView, 38, 8 * i + 8, &rectBoxBody, 26);
  drawBitmapWithTransparency(&rectView, 38, 8 * i + 8, &rectBoxBottom, 26);
  if ( inventoryLabelPosition > 16 )
    --inventoryLabelPosition;
  drawBitmapWithTransparency(&rectView, 48, inventoryLabelPosition, &rectTitle1, 26);
  drawBitmapWithTransparency(&rectView, 48, inventoryLabelPosition + 52, &rectTitle2, 26);
  ++menuRectFlash;
  if ( inventoryActive )
    drawBitmapWithTransparency(&rectView, 40 * selectedWeapon + 48, 24, &rectCursor1[1], 26);
  else
    drawBitmapWithTransparency(&rectView, 40 * selectedWeapon + 48, 24, &rectCursor1[(menuRectFlash >> 1) % 2], 26);
  for ( i = 0; i < 8 && gWeapons[i].weaponID; ++i )
  {
    rectWeapon.left = 16 * (gWeapons[i].weaponID % 16);
    rectWeapon.right = rectWeapon.left + 16;
    rectWeapon.top = 16 * (gWeapons[i].weaponID / 16);
    rectWeapon.bottom = rectWeapon.top + 16;
    drawBitmapWithTransparency(&rectView, 40 * i + 48, 24, &rectWeapon, 12);
    drawBitmapWithTransparency(&rectView, 40 * i + 48, 56, &rectPer, 26);
    drawBitmapWithTransparency(&rectView, 40 * i + 48, 40, &rectLevel, 26);
    drawNumbers(40 * i + 48, 40, gWeapons[i].level, 0);
    if ( gWeapons[i].maxAmmo )
    {
      drawNumbers(40 * i + 48, 48, gWeapons[i].ammo, 0);
      drawNumbers(40 * i + 48, 56, gWeapons[i].maxAmmo, 0);
    }
    else
    {
      drawBitmapWithTransparency(&rectView, 40 * i + 64, 48, &rectNone, 26);
      drawBitmapWithTransparency(&rectView, 40 * i + 64, 56, &rectNone, 26);
    }
  }
  if ( inventoryActive == 1 )
    drawBitmapWithTransparency(
      &rectView,
      32 * (selectedItem % 6) + 48,
      16 * (selectedItem / 6) + 76,
      &rectCursor2[(menuRectFlash >> 1) % 2],
      26);
  else
    drawBitmapWithTransparency(
      &rectView,
      32 * (selectedItem % 6) + 48,
      16 * (selectedItem / 6) + 76,
      &rectCursor2[1],
      26);
  for ( i = 0; i < 32 && quoteInventory[i].code; ++i )
  {
    rectItem.left = 32 * (quoteInventory[i].code % 8);
    rectItem.right = rectItem.left + 32;
    rectItem.top = 16 * (quoteInventory[i].code / 8);
    rectItem.bottom = rectItem.top + 16;
    drawBitmapWithTransparency(&rectView, 32 * (i % 6) + 48, 16 * (i / 6) + 76, &rectItem, 8);
  }
}
// 499BC0: using guessed type int inventoryActive;
// 499C68: using guessed type int selectedWeapon;
// 499C6C: using guessed type int selectedItem;

//----- (00401D10) --------------------------------------------------------
signed int inventoryLoop()
{
  int retTSCParser; // [esp+0h] [ebp-128h]
  int retCallOnEscape; // [esp+4h] [ebp-124h]
  char oldScriptPath[260]; // [esp+8h] [ebp-120h]
  RECT rectView; // [esp+114h] [ebp-14h]
  int i; // [esp+124h] [ebp-4h]

  rectView.left = 0;
  rectView.top = 0;
  rectView.right = 320;
  rectView.bottom = 240;
  getTextScriptPath(oldScriptPath);
  loadSpecialTSC("ArmsItem.tsc");
  inventoryLabelPosition = 24;
  inventoryActive = 0;
  selectedItem = 0;
  for ( i = 0; gWeapons[i].weaponID; ++i )
    ;
  if ( i )
    startTSCEvent(gWeapons[selectedWeapon].weaponID + 1000);
  else
    startTSCEvent(quoteInventory[selectedItem].code + 5000);
  while ( 1 )
  {
    getKeys();
    if ( keyPressed & 0x8000 )
    {
      retCallOnEscape = callOnEscape(appWinHandle);
      if ( !retCallOnEscape )
        return 0;
      if ( retCallOnEscape == 2 )
        return 2;
    }
    if ( gameFlags & 2 )
      moveInventoryCursor();
    retTSCParser = TSCParser();
    if ( !retTSCParser )
      return 0;
    if ( retTSCParser == 2 )
      return 2;
    drawSpriteNoTransparency(&rectView, 0, 0, &rectView, 10);
    drawInventoryWindow();
    drawTextBox();
    displayFPSCounter();
    if ( !inventoryActive )
      break;
    if ( gameFlags & 2 && keyPressed & (keyMenu | keyCancel) )
    {
      stopTSC();
      goto LABEL_30;
    }
LABEL_27:
    if ( !drawWindow(appWinHandle) )
      return 0;
  }
  if ( !(keyPressed & (keyMenu | keyCancel | keyOk)) )
    goto LABEL_27;
  stopTSC();
LABEL_30:
  loadTSCScript(oldScriptPath);
  weaponIconXOffset = 32;
  return 1;
}
// 493620: using guessed type int keyMenu;
// 493628: using guessed type int keyOk;
// 49362C: using guessed type int keyCancel;
// 499BC0: using guessed type int inventoryActive;
// 499C68: using guessed type int selectedWeapon;
// 499C6C: using guessed type int selectedItem;
// 49E1E8: using guessed type int gameFlags;
// 49E214: using guessed type int keyPressed;

//----- (00401F20) --------------------------------------------------------
// Check If Has Item
signed int __cdecl checkForItem(int item)
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 32; ++i )
  {
    if ( quoteInventory[i].code == item )
      return 1;
  }
  return 0;
}

//----- (00401F60) --------------------------------------------------------
// Check If Has Weapon
signed int __cdecl checkForWeapon(int checkedWeapon)
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 8; ++i )
  {
    if ( gWeapons[i].weaponID == checkedWeapon )
      return 1;
  }
  return 0;
}

//----- (00401FA0) --------------------------------------------------------
signed int __cdecl useAmmo(int ammoToRemove)
{
  if ( !gWeapons[selectedWeapon].maxAmmo )
    return 1;
  if ( !gWeapons[selectedWeapon].ammo )
    return 0;
  gWeapons[selectedWeapon].ammo -= ammoToRemove;
  if ( gWeapons[selectedWeapon].ammo < 0 )
    gWeapons[selectedWeapon].ammo = 0;
  return 1;
}
// 499C68: using guessed type int selectedWeapon;

//----- (00402020) --------------------------------------------------------
// Add Ammo To Weapon
int __cdecl addAmmo(int addedAmmo)
{
  gWeapons[selectedWeapon].ammo += addedAmmo;
  if ( gWeapons[selectedWeapon].ammo > gWeapons[selectedWeapon].maxAmmo )
    gWeapons[selectedWeapon].ammo = gWeapons[selectedWeapon].maxAmmo;
  return 1;
}
// 499C68: using guessed type int selectedWeapon;

//----- (00402090) --------------------------------------------------------
// TSC Fill All Weapon Ammo [AE+]
void __cdecl fillWeaponAmmo()
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 8; ++i )
  {
    if ( gWeapons[i].weaponID )
      gWeapons[i].ammo = gWeapons[i].maxAmmo;
  }
}

//----- (004020E0) --------------------------------------------------------
// Switch to Next Weapon
weapons switchWeaponForward()
{
  int weaponNumber; // [esp+0h] [ebp-4h]

  for ( weaponNumber = 0; gWeapons[weaponNumber].weaponID; ++weaponNumber )
    ;
  if ( !weaponNumber )
    return 0;
  resetSpurCharge();
  ++selectedWeapon;
  while ( selectedWeapon < weaponNumber && gWeapons[selectedWeapon].weaponID == 0 )
    ++selectedWeapon;
  if ( selectedWeapon == weaponNumber )
    selectedWeapon = 0;
  weaponIconXOffset = 32;
  playSoundEffect(SFXSwitchWeapon, 1);
  return gWeapons[selectedWeapon].weaponID;
}
// 499C68: using guessed type int selectedWeapon;

//----- (00402190) --------------------------------------------------------
// Switch to Previous Weapon
weapons switchWeaponBackwards()
{
  int Weapon_Num; // [esp+0h] [ebp-4h]

  for ( Weapon_Num = 0; gWeapons[Weapon_Num].weaponID; ++Weapon_Num )
    ;
  if ( !Weapon_Num )
    return 0;
  resetSpurCharge();
  if ( --selectedWeapon < 0 )
    selectedWeapon = Weapon_Num - 1;
  while ( selectedWeapon < Weapon_Num && gWeapons[selectedWeapon].weaponID == 0 )
    --selectedWeapon;
  weaponIconXOffset = 0;
  playSoundEffect(SFXSwitchWeapon, 1);
  return gWeapons[selectedWeapon].weaponID;
}
// 499C68: using guessed type int selectedWeapon;

//----- (00402240) --------------------------------------------------------
// Change weapon to first weapon
void resetSelectedWeapon()
{
  selectedWeapon = 0;
  weaponIconXOffset = 32;
  playSoundEffect(SFXSwitchWeapon, 1);
}
// 499C68: using guessed type int selectedWeapon;

//----- (00402270) --------------------------------------------------------
signed int __cdecl initBackground(char *stageName, int Mode)
{
  char path[268]; // [esp+0h] [ebp-148h]
  char buffer[14]; // [esp+10Ch] [ebp-3Ch]
  FILE *stream; // [esp+11Ch] [ebp-2Ch]
  Background background; // [esp+120h] [ebp-28h]

  color_black = makeRGB(0x100000u);
  sprintf(path, "%s\\%s.pbm", dataPath, stageName);
  stream = fopen(path, "rb");
  if ( !stream )
    return 0;
  fread(buffer, 14u, 1u, stream);
  if ( *(unsigned __int16 *)buffer != 19778 )
    return 0;
  fread(&background, 0x28u, 1u, stream);
  fclose(stream);
  currentBackground.tileWidth = background.tileWidth;
  currentBackground.tileHeight = background.tileHeight;
  currentBackground.flag = 1;
  if ( !reloadBitmapFromFile(stageName, 28) )
    return 0;
  currentBackground.mode = Mode;
  globalWaterDepth = 0x1E0000;
  return 1;
}
// 499C90: using guessed type int globalWaterDepth;
// 499C94: using guessed type int color_black;

//----- (00402370) --------------------------------------------------------
// Background Modes?
void __cdecl updateBackground()
{
  if ( currentBackground.mode == 5 )
  {
    currentBackground._fx += 3072;
  }
  else if ( currentBackground.mode > 5 && currentBackground.mode <= 7 )
  {
    ++currentBackground._fx;
    currentBackground._fx %= 640;
  }
}

//----- (004023D0) --------------------------------------------------------
// Background Code
void __cdecl drawBackground(signed int cameraXPos, signed int cameraYPos)
{
  signed int XPos; // [esp+4h] [ebp-18h]
  int XPosa; // [esp+4h] [ebp-18h]
  int XPosb; // [esp+4h] [ebp-18h]
  int XPosc; // [esp+4h] [ebp-18h]
  signed int bitmapRenderYPos; // [esp+8h] [ebp-14h]
  int YPosa; // [esp+8h] [ebp-14h]
  int YPosb; // [esp+8h] [ebp-14h]
  int YPosc; // [esp+8h] [ebp-14h]
  RECT rect; // [esp+Ch] [ebp-10h]

  rect.left = 0;
  rect.top = 0;
  rect.right = currentBackground.tileWidth;
  rect.bottom = currentBackground.tileHeight;
  switch ( currentBackground.mode )
  {
    case 0:
      for ( bitmapRenderYPos = 0; bitmapRenderYPos < 240; bitmapRenderYPos += currentBackground.tileHeight )
      {
        for ( XPos = 0; XPos < 320; XPos += currentBackground.tileWidth )
          drawSpriteNoTransparency(&gameRect, XPos, bitmapRenderYPos, &rect, 28);
      }
      break;
    case 1:
      for ( YPosa = -(cameraYPos / 2 / 512 % currentBackground.tileHeight);
            YPosa < 240;
            YPosa += currentBackground.tileHeight )
      {
        for ( XPosa = -(cameraXPos / 2 / 512 % currentBackground.tileWidth);
              XPosa < 320;
              XPosa += currentBackground.tileWidth )
        {
          drawSpriteNoTransparency(&gameRect, XPosa, YPosa, &rect, 28);
        }
      }
      break;
    case 2:
      for ( YPosb = -(cameraYPos / 512 % currentBackground.tileHeight); YPosb < 240; YPosb += currentBackground.tileHeight )
      {
        for ( XPosb = -(cameraXPos / 512 % currentBackground.tileWidth); XPosb < 320; XPosb += currentBackground.tileWidth )
          drawSpriteNoTransparency(&gameRect, XPosb, YPosb, &rect, 28);
      }
      break;
    case 5:
      for ( YPosc = -currentBackground.tileHeight; YPosc < 240; YPosc += currentBackground.tileHeight )
      {
        for ( XPosc = -(currentBackground._fx / 512 % currentBackground.tileWidth);
              XPosc < 320;
              XPosc += currentBackground.tileWidth )
        {
          drawSpriteNoTransparency(&gameRect, XPosc, YPosc, &rect, 28);
        }
      }
      break;
    case 6:
    case 7:
      rect.top = 0;
      rect.bottom = 88;
      rect.left = 0;
      rect.right = 320;
      drawSpriteNoTransparency(&gameRect, 0, 0, &rect, 28);
      rect.top = 88;
      rect.bottom = 123;
      rect.left = currentBackground._fx / 2;
      rect.right = 320;
      drawSpriteNoTransparency(&gameRect, 0, 88, &rect, 28);
      rect.left = 0;
      drawSpriteNoTransparency(&gameRect, 320 - currentBackground._fx / 2 % 320, 88, &rect, 28);
      rect.top = 123;
      rect.bottom = 146;
      rect.left = currentBackground._fx % 320;
      rect.right = 320;
      drawSpriteNoTransparency(&gameRect, 0, 123, &rect, 28);
      rect.left = 0;
      drawSpriteNoTransparency(&gameRect, 320 - currentBackground._fx % 320, 123, &rect, 28);
      rect.top = 146;
      rect.bottom = 176;
      rect.left = 2 * currentBackground._fx % 320;
      rect.right = 320;
      drawSpriteNoTransparency(&gameRect, 0, 146, &rect, 28);
      rect.left = 0;
      drawSpriteNoTransparency(&gameRect, 320 - 2 * currentBackground._fx % 320, 146, &rect, 28);
      rect.top = 176;
      rect.bottom = 240;
      rect.left = 4 * currentBackground._fx % 320;
      rect.right = 320;
      drawSpriteNoTransparency(&gameRect, 0, 176, &rect, 28);
      rect.left = 0;
      drawSpriteNoTransparency(&gameRect, 320 - 4 * currentBackground._fx % 320, 176, &rect, 28);
      break;
    default:
      return;
  }
}

//----- (00402830) --------------------------------------------------------
// Render Map Background (BackgroundMode 3 only) (May be related to drawing water ?)
void __cdecl drawForeground(signed int cameraXPos, signed int cameraYPos)
{
  int XPos; // [esp+4h] [ebp-40h]
  RECT waterRects[2]; // [esp+Ch] [ebp-38h]
  int YPos; // [esp+2Ch] [ebp-18h]
  int X1; // [esp+30h] [ebp-14h]
  int X2; // [esp+34h] [ebp-10h]
  int X; // [esp+38h] [ebp-Ch]
  int Y; // [esp+3Ch] [ebp-8h]
  int Y1; // [esp+40h] [ebp-4h]

  waterRects[0].left = 0;
  waterRects[0].top = 0;
  waterRects[0].right = 32;
  waterRects[0].bottom = 16;
  waterRects[1].left = 0;
  waterRects[1].top = 16;
  waterRects[1].right = 32;
  waterRects[1].bottom = 48;
  if ( currentBackground.mode == 3 )
  {
    X1 = cameraXPos / 0x4000;
    X2 = cameraXPos / 0x4000 + 11;
    Y1 = 0;
    for ( Y = 0; Y < 32; ++Y )
    {
      YPos = globalWaterDepth / 512 + (Y << 14) / 512 - cameraYPos / 512;
      if ( YPos >= -32 )
      {
        if ( YPos > 240 )
          return;
        for ( X = X1; X < X2; ++X )
        {
          XPos = (X << 14) / 512 - cameraXPos / 512;
          drawBitmapWithTransparency(&gameRect, XPos, YPos, &waterRects[1], 28);
          if ( !Y )
            drawBitmapWithTransparency(&gameRect, XPos, YPos, waterRects, 28);
        }
      }
    }
  }
}
// 499C90: using guessed type int globalWaterDepth;

//----- (004029B0) --------------------------------------------------------
// Check for whether a bullet can break a starblock
signed int __cdecl checkStarblockBreak(int blockXPos, int blockYPos, Bullet *bullet)
{
  int v3; // ST10_4
  int v4; // eax
  signed int v6; // [esp+0h] [ebp-8h]
  signed int i; // [esp+4h] [ebp-4h]

  v6 = 0;
  if ( bullet->XPos - bullet->collisionX < (16 * blockXPos + 8) << 9
    && bullet->collisionX + bullet->XPos > (16 * blockXPos - 8) << 9
    && bullet->YPos - bullet->collisionY < (16 * blockYPos + 8) << 9
    && bullet->collisionY + bullet->YPos > (16 * blockYPos - 8) << 9 )
  {
    v6 = 512;
  }
  if ( v6 && bullet->flags & 0x60 && getTileAttributes(blockXPos, blockYPos) == 67 )
  {
    if ( !(bullet->flags & 0x40) )
      bullet->isAlive = 0;
    createEffect(bullet->XPos, bullet->YPos, effectRisingDisc, 0);
    playSoundEffect(SFXDestroyBreakableBlock, 1);
    for ( i = 0; i < 4; ++i )
    {
      v3 = random(-512, 512);
      v4 = random(-512, 512);
      createNPC(NPCSmoke, blockXPos << 13, blockYPos << 13, v4, v3, 0, 0, 256);
    }
    shiftMapParts(blockXPos, blockYPos);
  }
  return v6;
}

//----- (00402B30) --------------------------------------------------------
// Solid tile -> Two stage filter for blocks that bullets are s'posta collide with
int __cdecl solidTileTwoStageFilterThing(int a1, int a2, _BYTE *a3, Bullet *a4)
{
  int v5; // [esp+0h] [ebp-20h]
  int v6; // [esp+4h] [ebp-1Ch]
  int v7; // [esp+8h] [ebp-18h]
  int v8; // [esp+Ch] [ebp-14h]
  int v9; // [esp+10h] [ebp-10h]
  int v10; // [esp+14h] [ebp-Ch]
  int i; // [esp+18h] [ebp-8h]
  int v12; // [esp+1Ch] [ebp-4h]

  v10 = 0;
  if ( a4->flags & 0x40 )
  {
    for ( i = 0; i < 4; ++i )
    {
      *(&v5 + i) = *a3 == 65 || *a3 == 97;
      ++a3;
    }
  }
  else
  {
    for ( i = 0; i < 4; ++i )
    {
      *(&v5 + i) = *a3 == 65 || *a3 == 67 || *a3 == 97;
      ++a3;
    }
  }
  v9 = (16 * a1 + 8) << 9;
  v12 = (16 * a2 + 8) << 9;
  if ( v5 && v7 )
  {
    if ( a4->XPos - a4->collisionX < v9 )
      v10 |= 1u;
  }
  else if ( !v5 || v7 )
  {
    if ( !v5 && v7 && a4->XPos - a4->collisionX < v9 && a4->collisionY + a4->YPos > v12 + 1536 )
      v10 |= 1u;
  }
  else if ( a4->XPos - a4->collisionX < v9 && a4->YPos - a4->collisionY < v12 - 1536 )
  {
    v10 |= 1u;
  }
  if ( v6 && v8 )
  {
    if ( a4->collisionX + a4->XPos > v9 )
      v10 |= 4u;
  }
  else if ( !v6 || v8 )
  {
    if ( !v6 && v8 && a4->collisionX + a4->XPos > v9 && a4->collisionY + a4->YPos > v12 + 1536 )
      v10 |= 4u;
  }
  else if ( a4->collisionX + a4->XPos > v9 && a4->YPos - a4->collisionY < v12 - 1536 )
  {
    v10 |= 4u;
  }
  if ( v5 && v6 )
  {
    if ( a4->YPos - a4->collisionY < v12 )
      v10 |= 2u;
  }
  else if ( !v5 || v6 )
  {
    if ( !v5 && v6 && a4->YPos - a4->collisionY < v12 && a4->collisionX + a4->XPos > v9 + 1536 )
      v10 |= 2u;
  }
  else if ( a4->YPos - a4->collisionY < v12 && a4->XPos - a4->collisionX < v9 - 1536 )
  {
    v10 |= 2u;
  }
  if ( v7 && v8 )
  {
    if ( a4->collisionY + a4->YPos > v12 )
      v10 |= 8u;
  }
  else if ( !v7 || v8 )
  {
    if ( !v7 && v8 && a4->collisionY + a4->YPos > v12 && a4->collisionX + a4->XPos > v9 + 1536 )
      v10 |= 8u;
  }
  else if ( a4->collisionY + a4->YPos > v12 && a4->XPos - a4->collisionX < v9 - 1536 )
  {
    v10 |= 8u;
  }
  if ( a4->flags & 8 )
  {
    if ( v10 & 1 )
    {
      a4->XPos = a4->collisionX + v9;
    }
    else if ( v10 & 4 )
    {
      a4->XPos = v9 - a4->collisionX;
    }
    else if ( v10 & 2 )
    {
      a4->YPos = a4->collisionY + v12;
    }
    else if ( v10 & 8 )
    {
      a4->YPos = v12 - a4->collisionY;
    }
  }
  else if ( v10 & 0xF )
  {
    makeSoundAndEffectOnHitWall(a4);
  }
  return v10;
}

//----- (00402F50) --------------------------------------------------------
// Generate effect, sound when Bullet hits wall
void __cdecl makeSoundAndEffectOnHitWall(Bullet *bullet)
{
  if ( bullet->bulletID != 37 && bullet->bulletID != 38 && bullet->bulletID != 39 )
    playSoundEffect(SFXShotHitWall, 1);
  else
    createEffect(bullet->XPos, bullet->YPos, effectRisingDisc, up);
  bullet->isAlive = 0;
  createEffect(bullet->XPos, bullet->YPos, effectRisingDisc, right);
}

//----- (00402FC0) --------------------------------------------------------
signed int __cdecl bulletTileCollisionRoofSlope1(int a1, int a2, Bullet *bullet)
{
  signed int v4; // [esp+0h] [ebp-4h]

  v4 = 0;
  if ( bullet->XPos < (16 * a1 + 8) << 9
    && bullet->XPos > (16 * a1 - 8) << 9
    && bullet->YPos - 1024 < (a2 << 13) - (bullet->XPos - (a1 << 13)) / 2 + 2048
    && bullet->YPos + 1024 > (16 * a2 - 8) << 9 )
  {
    if ( bullet->flags & 8 )
      bullet->YPos = (a2 << 13) - (bullet->XPos - (a1 << 13)) / 2 + 3072;
    else
      makeSoundAndEffectOnHitWall(bullet);
    v4 = 130;
  }
  return v4;
}

//----- (004030B0) --------------------------------------------------------
signed int __cdecl bulletTileCollisionRoofSlope2(int a1, int a2, Bullet *bullet)
{
  signed int v4; // [esp+0h] [ebp-4h]

  v4 = 0;
  if ( bullet->XPos < (16 * a1 + 8) << 9
    && bullet->XPos > (16 * a1 - 8) << 9
    && bullet->YPos - 1024 < (a2 << 13) - (bullet->XPos - (a1 << 13)) / 2 - 2048
    && bullet->YPos + 1024 > (16 * a2 - 8) << 9 )
  {
    if ( bullet->flags & 8 )
      bullet->YPos = (a2 << 13) - (bullet->XPos - (a1 << 13)) / 2 - 1024;
    else
      makeSoundAndEffectOnHitWall(bullet);
    v4 = 130;
  }
  return v4;
}

//----- (004031A0) --------------------------------------------------------
signed int __cdecl bulletTileCollisionRoofSlope3(int a1, int a2, Bullet *bullet)
{
  signed int v4; // [esp+0h] [ebp-4h]

  v4 = 0;
  if ( bullet->XPos < (16 * a1 + 8) << 9
    && bullet->XPos > (16 * a1 - 8) << 9
    && bullet->YPos - 1024 < (a2 << 13) + (bullet->XPos - (a1 << 13)) / 2 - 2048
    && bullet->YPos + 1024 > (16 * a2 - 8) << 9 )
  {
    if ( bullet->flags & 8 )
      bullet->YPos = (a2 << 13) + (bullet->XPos - (a1 << 13)) / 2 - 1024;
    else
      makeSoundAndEffectOnHitWall(bullet);
    v4 = 66;
  }
  return v4;
}

//----- (00403290) --------------------------------------------------------
signed int __cdecl bulletTileCollisionRoofSlope4(int a1, int a2, Bullet *bullet)
{
  signed int v4; // [esp+0h] [ebp-4h]

  v4 = 0;
  if ( bullet->XPos < (16 * a1 + 8) << 9
    && bullet->XPos > (16 * a1 - 8) << 9
    && bullet->YPos - 1024 < (a2 << 13) + (bullet->XPos - (a1 << 13)) / 2 + 2048
    && bullet->YPos + 1024 > (16 * a2 - 8) << 9 )
  {
    if ( bullet->flags & 8 )
      bullet->YPos = (a2 << 13) + (bullet->XPos - (a1 << 13)) / 2 + 3072;
    else
      makeSoundAndEffectOnHitWall(bullet);
    v4 = 66;
  }
  return v4;
}

//----- (00403380) --------------------------------------------------------
signed int __cdecl bulletTileCollisionFloorSlope1(int a1, int a2, Bullet *bullet)
{
  signed int v4; // [esp+0h] [ebp-4h]

  v4 = 0;
  if ( bullet->XPos < (16 * a1 + 8) << 9
    && bullet->XPos - 512 > (16 * a1 - 8) << 9
    && bullet->YPos + 1024 > (a2 << 13) + (bullet->XPos - (a1 << 13)) / 2 - 2048
    && bullet->YPos - 1024 < (16 * a2 + 8) << 9 )
  {
    if ( bullet->flags & 8 )
      bullet->YPos = (a2 << 13) + (bullet->XPos - (a1 << 13)) / 2 - 3072;
    else
      makeSoundAndEffectOnHitWall(bullet);
    v4 = 40;
  }
  return v4;
}

//----- (00403470) --------------------------------------------------------
signed int __cdecl bulletTileCollisionFloorSlope2(int a1, int a2, Bullet *bullet)
{
  signed int v4; // [esp+0h] [ebp-4h]

  v4 = 0;
  if ( bullet->XPos < (16 * a1 + 8) << 9
    && bullet->XPos > (16 * a1 - 8) << 9
    && bullet->YPos + 1024 > (a2 << 13) + (bullet->XPos - (a1 << 13)) / 2 + 2048
    && bullet->YPos - 1024 < (16 * a2 + 8) << 9 )
  {
    if ( bullet->flags & 8 )
      bullet->YPos = (a2 << 13) + (bullet->XPos - (a1 << 13)) / 2 + 1024;
    else
      makeSoundAndEffectOnHitWall(bullet);
    v4 = 40;
  }
  return v4;
}

//----- (00403560) --------------------------------------------------------
signed int __cdecl bulletTileCollisionFloorSlope3(int a1, int a2, Bullet *bullet)
{
  signed int v4; // [esp+0h] [ebp-4h]

  v4 = 0;
  if ( bullet->XPos < (16 * a1 + 8) << 9
    && bullet->XPos > (16 * a1 - 8) << 9
    && bullet->YPos + 1024 > (a2 << 13) - (bullet->XPos - (a1 << 13)) / 2 + 2048
    && bullet->YPos - 1024 < (16 * a2 + 8) << 9 )
  {
    if ( bullet->flags & 8 )
      bullet->YPos = (a2 << 13) - (bullet->XPos - (a1 << 13)) / 2 + 1024;
    else
      makeSoundAndEffectOnHitWall(bullet);
    v4 = 24;
  }
  return v4;
}

//----- (00403650) --------------------------------------------------------
signed int __cdecl bulletTileCollisionFloorSlope4(int a1, int a2, Bullet *bullet)
{
  signed int v4; // [esp+0h] [ebp-4h]

  v4 = 0;
  if ( bullet->XPos < (16 * a1 + 8) << 9
    && bullet->XPos > (16 * a1 - 8) << 9
    && bullet->YPos + 1024 > (a2 << 13) - (bullet->XPos - (a1 << 13)) / 2 - 2048
    && bullet->YPos - 1024 < (16 * a2 + 8) << 9 )
  {
    if ( bullet->flags & 8 )
      bullet->YPos = (a2 << 13) - (bullet->XPos - (a1 << 13)) / 2 - 3072;
    else
      makeSoundAndEffectOnHitWall(bullet);
    v4 = 24;
  }
  return v4;
}

//----- (00403740) --------------------------------------------------------
// Bullet tile collision algorithm
void bulletTileCollisionAlgorithm()
{
  int v0; // esi
  signed int v1; // eax
  int v2; // esi
  signed int v3; // eax
  int v4; // esi
  signed int v5; // eax
  int v6; // esi
  signed int v7; // eax
  int v8; // esi
  signed int v9; // eax
  int v10; // esi
  signed int v11; // eax
  int v12; // esi
  signed int v13; // eax
  int v14; // esi
  signed int v15; // eax
  int v16; // esi
  signed int v17; // eax
  int v18; // esi
  int v19; // eax
  int v20; // [esp+4h] [ebp-34h]
  int v21; // [esp+8h] [ebp-30h]
  int v22; // [esp+Ch] [ebp-2Ch]
  int v23; // [esp+10h] [ebp-28h]
  int v24; // [esp+14h] [ebp-24h]
  int v25; // [esp+18h] [ebp-20h]
  int v26; // [esp+1Ch] [ebp-1Ch]
  int v27; // [esp+20h] [ebp-18h]
  int i; // [esp+24h] [ebp-14h]
  unsigned __int8 v29; // [esp+28h] [ebp-10h]
  unsigned __int8 v30; // [esp+29h] [ebp-Fh]
  unsigned __int8 v31; // [esp+2Ah] [ebp-Eh]
  unsigned __int8 v32; // [esp+2Bh] [ebp-Dh]
  int j; // [esp+2Ch] [ebp-Ch]
  int v34; // [esp+30h] [ebp-8h]
  int v35; // [esp+34h] [ebp-4h]

  for ( j = 0; j < 64; ++j )
  {
    if ( bulletObjects[j].isAlive & 0x80 )
    {
      v34 = bulletObjects[j].XPos / 16 / 512;
      v35 = bulletObjects[j].YPos / 16 / 512;
      v20 = 0;
      v21 = 1;
      v22 = 0;
      v23 = 1;
      v24 = 0;
      v25 = 0;
      v26 = 1;
      v27 = 1;
      v29 = getTileAttributes(v34, v35);
      v30 = getTileAttributes(v34 + 1, v35);
      v31 = getTileAttributes(v34, v35 + 1);
      v32 = getTileAttributes(v34 + 1, v35 + 1);
      bulletObjects[j].isUsed = 0;
      if ( !(bulletObjects[j].flags & 4) )
      {
        for ( i = 0; i < 4; ++i )
        {
          if ( bulletObjects[j].isAlive & 0x80 )
          {
            switch ( *(&v29 + i) )
            {
              case 0x41u:
              case 0x43u:
              case 0x44u:
              case 0x61u:
              case 0x64u:
                v0 = j << 7;
                v1 = checkStarblockBreak(*(&v20 + i) + v34, *(&v24 + i) + v35, &bulletObjects[j]);
                bulletObjects[j].isUsed = *(int *)((char *)&bulletObjects[0].isUsed + v0) | v1;
                break;
              case 0x50u:
              case 0x70u:
                v2 = j << 7;
                v3 = bulletTileCollisionRoofSlope1(*(&v20 + i) + v34, *(&v24 + i) + v35, &bulletObjects[j]);
                bulletObjects[j].isUsed = *(int *)((char *)&bulletObjects[0].isUsed + v2) | v3;
                break;
              case 0x51u:
              case 0x71u:
                v4 = j << 7;
                v5 = bulletTileCollisionRoofSlope2(*(&v20 + i) + v34, *(&v24 + i) + v35, &bulletObjects[j]);
                bulletObjects[j].isUsed = *(int *)((char *)&bulletObjects[0].isUsed + v4) | v5;
                break;
              case 0x52u:
              case 0x72u:
                v6 = j << 7;
                v7 = bulletTileCollisionRoofSlope3(*(&v20 + i) + v34, *(&v24 + i) + v35, &bulletObjects[j]);
                bulletObjects[j].isUsed = *(int *)((char *)&bulletObjects[0].isUsed + v6) | v7;
                break;
              case 0x53u:
              case 0x73u:
                v8 = j << 7;
                v9 = bulletTileCollisionRoofSlope4(*(&v20 + i) + v34, *(&v24 + i) + v35, &bulletObjects[j]);
                bulletObjects[j].isUsed = *(int *)((char *)&bulletObjects[0].isUsed + v8) | v9;
                break;
              case 0x54u:
              case 0x74u:
                v10 = j << 7;
                v11 = bulletTileCollisionFloorSlope1(*(&v20 + i) + v34, *(&v24 + i) + v35, &bulletObjects[j]);
                bulletObjects[j].isUsed = *(int *)((char *)&bulletObjects[0].isUsed + v10) | v11;
                break;
              case 0x55u:
              case 0x75u:
                v12 = j << 7;
                v13 = bulletTileCollisionFloorSlope2(*(&v20 + i) + v34, *(&v24 + i) + v35, &bulletObjects[j]);
                bulletObjects[j].isUsed = *(int *)((char *)&bulletObjects[0].isUsed + v12) | v13;
                break;
              case 0x56u:
              case 0x76u:
                v14 = j << 7;
                v15 = bulletTileCollisionFloorSlope3(*(&v20 + i) + v34, *(&v24 + i) + v35, &bulletObjects[j]);
                bulletObjects[j].isUsed = *(int *)((char *)&bulletObjects[0].isUsed + v14) | v15;
                break;
              case 0x57u:
              case 0x77u:
                v16 = j << 7;
                v17 = bulletTileCollisionFloorSlope4(*(&v20 + i) + v34, *(&v24 + i) + v35, &bulletObjects[j]);
                bulletObjects[j].isUsed = *(int *)((char *)&bulletObjects[0].isUsed + v16) | v17;
                break;
              default:
                continue;
            }
          }
        }
        v18 = j << 7;
        v19 = solidTileTwoStageFilterThing(v34, v35, &v29, &bulletObjects[j]);
        bulletObjects[j].isUsed = *(int *)((char *)&bulletObjects[0].isUsed + v18) | v19;
      }
    }
  }
}

//----- (00403C00) --------------------------------------------------------
int resetWeapons()
{
  int result; // eax
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 64; ++i )
  {
    bulletObjects[i].isAlive = 0;
    result = i + 1;
  }
  return result;
}

//----- (00403C40) --------------------------------------------------------
int __cdecl countBullets(bullets weaponID)
{
  signed int i; // [esp+0h] [ebp-8h]
  int bulletCount; // [esp+4h] [ebp-4h]

  bulletCount = 0;
  for ( i = 0; i < 64; ++i )
  {
    if ( bulletObjects[i].isAlive & 0x80 )
    {
      if ( (bulletObjects[i].bulletID + 2) / 3 == weaponID )
        ++bulletCount;
    }
  }
  return bulletCount;
}

//----- (00403CB0) --------------------------------------------------------
int __cdecl countShots(int ShotID)
{
  signed int i; // [esp+0h] [ebp-8h]
  int shotCount; // [esp+4h] [ebp-4h]

  shotCount = 0;
  for ( i = 0; i < 64; ++i )
  {
    if ( bulletObjects[i].isAlive & 0x80 )
    {
      if ( bulletObjects[i].bulletID == ShotID )
        ++shotCount;
    }
  }
  return shotCount;
}

//----- (00403D10) --------------------------------------------------------
// Unused
int __cdecl deleteBullet(int bulletID)
{
  int result; // eax
  signed int i; // [esp+0h] [ebp-8h]

  for ( i = 0; i < 64; ++i )
  {
    if ( bulletObjects[i].isAlive & 0x80 )
    {
      if ( (bulletObjects[i].bulletID + 2) / 3 == bulletID )
        bulletObjects[i].isAlive = 0;
    }
    result = i + 1;
  }
  return result;
}

//----- (00403D80) --------------------------------------------------------
void __cdecl resetBullets()
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 64; ++i )
    bulletObjects[i].isAlive = 0;
}

//----- (00403DC0) --------------------------------------------------------
int __cdecl renderBullets(signed int cameraXPos, signed int cameraYPos)
{
  int result; // eax
  signed int i; // [esp+4h] [ebp-Ch]
  int v4; // [esp+8h] [ebp-8h]
  int v5; // [esp+Ch] [ebp-4h]

  for ( i = 0; i < 64; ++i )
  {
    if ( bulletObjects[i].isAlive & 0x80 )
    {
      switch ( bulletObjects[i].direction )
      {
        case 0u:
          v4 = bulletObjects[i].XPos - bulletObjects[i].view.front;
          v5 = bulletObjects[i].YPos - bulletObjects[i].view.top;
          break;
        case 1u:
          v4 = bulletObjects[i].XPos - bulletObjects[i].view.top;
          v5 = bulletObjects[i].YPos - bulletObjects[i].view.front;
          break;
        case 2u:
          v4 = bulletObjects[i].XPos - bulletObjects[i].view.back;
          v5 = bulletObjects[i].YPos - bulletObjects[i].view.top;
          break;
        case 3u:
          v4 = bulletObjects[i].XPos - bulletObjects[i].view.top;
          v5 = bulletObjects[i].YPos - bulletObjects[i].view.back;
          break;
        default:
          break;
      }
      drawBitmapWithTransparency(
        &gameRect,
        v4 / 512 - cameraXPos / 512,
        v5 / 512 - cameraYPos / 512,
        &bulletObjects[i].displayRect,
        17);
    }
    result = i + 1;
  }
  return result;
}

//----- (00403F80) --------------------------------------------------------
void __cdecl createBullet(bullets BulletID, int XPos, int YPos, Directions Direction)
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 64 && bulletObjects[i].isAlive & 0x80; ++i )
    ;
  if ( i < 64 )
  {
    memset(&bulletObjects[i], 0, 0x80u);
    bulletObjects[i].bulletID = BulletID;
    bulletObjects[i].isAlive = 128;
    bulletObjects[i].direction = Direction;
    bulletObjects[i].damage = weaponDataDamage[BulletID].damage;
    bulletObjects[i].numberImpacts = weaponDataDamage[BulletID].numberImpacts;
    bulletObjects[i].maxDistance = weaponDataDamage[BulletID].maxDistance;
    bulletObjects[i].flags = weaponDataDamage[BulletID].flags;
    bulletObjects[i].sizeWidth = weaponDataDamage[BulletID].sizeWidth << 9;
    bulletObjects[i].sizeHeight = weaponDataDamage[BulletID].sizeHeight << 9;
    bulletObjects[i].collisionX = weaponDataDamage[BulletID].collisionX << 9;
    bulletObjects[i].collisionY = weaponDataDamage[BulletID].collisionY << 9;
    bulletObjects[i].view.back = weaponDataDamage[BulletID].collisionFlags.back << 9;
    bulletObjects[i].view.front = weaponDataDamage[BulletID].collisionFlags.front << 9;
    bulletObjects[i].view.top = weaponDataDamage[BulletID].collisionFlags.top << 9;
    bulletObjects[i].view.bottom = weaponDataDamage[BulletID].collisionFlags.bottom << 9;
    bulletObjects[i].XPos = XPos;
    bulletObjects[i].YPos = YPos;
  }
}

//----- (00404160) --------------------------------------------------------
void __cdecl bullet1_Level1Snake(Bullet *bullet)
{
  RECT *v1; // edx
  RECT rcRight[4]; // [esp+4h] [ebp-80h]
  RECT rcLeft[4]; // [esp+44h] [ebp-40h]

  if ( ++bullet->count1 <= bullet->maxDistance )
  {
    if ( bullet->currentState )
    {
      bullet->XPos += bullet->XVel;
      bullet->YPos += bullet->YVel;
    }
    else
    {
      bullet->animationNum = random(0, 2);
      bullet->currentState = 1;
      switch ( bullet->direction )
      {
        case 0u:
          bullet->XVel = -1536;
          break;
        case 1u:
          bullet->YVel = -1536;
          break;
        case 2u:
          bullet->XVel = 1536;
          break;
        case 3u:
          bullet->YVel = 1536;
          break;
        default:
          break;
      }
    }
    if ( ++bullet->frameTimer > 0 )
    {
      bullet->frameTimer = 0;
      ++bullet->animationNum;
    }
    if ( bullet->animationNum > 3 )
      bullet->animationNum = 0;
    rcLeft[0].left = 136;
    rcLeft[0].top = 80;
    rcLeft[0].right = 152;
    rcLeft[0].bottom = 80;
    rcLeft[1].left = 120;
    rcLeft[1].top = 80;
    rcLeft[1].right = 136;
    rcLeft[1].bottom = 96;
    rcLeft[2].left = 136;
    rcLeft[2].top = 64;
    rcLeft[2].right = 152;
    rcLeft[2].bottom = 80;
    rcLeft[3].left = 120;
    rcLeft[3].top = 64;
    rcLeft[3].right = 136;
    rcLeft[3].bottom = 80;
    rcRight[0].left = 120;
    rcRight[0].top = 64;
    rcRight[0].right = 136;
    rcRight[0].bottom = 80;
    rcRight[1].left = 136;
    rcRight[1].top = 64;
    rcRight[1].right = 152;
    rcRight[1].bottom = 80;
    rcRight[2].left = 120;
    rcRight[2].top = 80;
    rcRight[2].right = 136;
    rcRight[2].bottom = 96;
    rcRight[3].left = 136;
    rcRight[3].top = 80;
    rcRight[3].right = 152;
    rcRight[3].bottom = 80;
    if ( bullet->direction )
      v1 = &rcRight[bullet->animationNum];
    else
      v1 = &rcLeft[bullet->animationNum];
    bullet->displayRect = *v1;
  }
  else
  {
    bullet->isAlive = 0;
    createEffect(bullet->XPos, bullet->YPos, effectStar, left);
  }
}

//----- (004043F0) --------------------------------------------------------
void __cdecl bullet2_3_SnakeLevel2_3(Bullet *bullet, int level)
{
  RECT rcBullet[3]; // [esp+10h] [ebp-30h]

  if ( ++bullet->count1 <= bullet->maxDistance )
  {
    if ( bullet->currentState )
    {
      switch ( bullet->direction )
      {
        case 0u:
          bullet->XVel -= 128;
          break;
        case 1u:
          bullet->YVel -= 128;
          break;
        case 2u:
          bullet->XVel += 128;
          break;
        case 3u:
          bullet->YVel += 128;
          break;
        default:
          break;
      }
      switch ( bullet->direction )
      {
        case 0u:
        case 2u:
          if ( bullet->count1 % 5 == 2 )
          {
            if ( bullet->YVel >= 0 )
              bullet->YVel = -1024;
            else
              bullet->YVel = 1024;
          }
          break;
        case 1u:
        case 3u:
          if ( bullet->count1 % 5 == 2 )
          {
            if ( bullet->XVel >= 0 )
              bullet->XVel = -1024;
            else
              bullet->XVel = 1024;
          }
          break;
        default:
          break;
      }
      bullet->XPos += bullet->XVel;
      bullet->YPos += bullet->YVel;
    }
    else
    {
      bullet->animationNum = random(0, 2);
      bullet->currentState = 1;
      switch ( bullet->direction )
      {
        case 0u:
          bullet->XVel = -512;
          break;
        case 1u:
          bullet->YVel = -512;
          break;
        case 2u:
          bullet->XVel = 512;
          break;
        case 3u:
          bullet->YVel = 512;
          break;
        default:
          break;
      }
      ++dword_49BC98;
      switch ( bullet->direction )
      {
        case 0u:
        case 2u:
          if ( dword_49BC98 % 2u )
            bullet->YVel = 1024;
          else
            bullet->YVel = -1024;
          break;
        case 1u:
        case 3u:
          if ( dword_49BC98 % 2u )
            bullet->XVel = 1024;
          else
            bullet->XVel = -1024;
          break;
        default:
          break;
      }
    }
    if ( ++bullet->frameTimer > 0 )
    {
      bullet->frameTimer = 0;
      ++bullet->animationNum;
    }
    if ( bullet->animationNum > 2 )
      bullet->animationNum = 0;
    rcBullet[0].left = 192;
    rcBullet[0].top = 16;
    rcBullet[0].right = 208;
    rcBullet[0].bottom = 32;
    rcBullet[1].left = 208;
    rcBullet[1].top = 16;
    rcBullet[1].right = 224;
    rcBullet[1].bottom = 32;
    rcBullet[2].left = 224;
    rcBullet[2].top = 16;
    rcBullet[2].right = 240;
    rcBullet[2].bottom = 32;
    bullet->displayRect = rcBullet[bullet->animationNum];
    if ( level == 2 )
      createNPC((NPCNames)129, bullet->XPos, bullet->YPos, 0, -512, (Directions)bullet->animationNum, 0, 256);
    else
      createNPC((NPCNames)129, bullet->XPos, bullet->YPos, 0, -512, (Directions)(bullet->animationNum + 3), 0, 256);
  }
  else
  {
    bullet->isAlive = 0;
    createEffect(bullet->XPos, bullet->YPos, effectStar, 0);
  }
}
// 49BC98: using guessed type int dword_49BC98;

//----- (004047B0) --------------------------------------------------------
// Polar Star (all levels)
void __cdecl bullet4_5_6_PolarStar(Bullet *Bullet, int Level)
{
  RECT *Bullet_Rect; // eax MAPDST

  if ( ++Bullet->count1 <= Bullet->maxDistance )//  has bullet reached max distance?
  {
    // Begin bullet code
    if ( Bullet->currentState )
    {
      Bullet->XPos += Bullet->XVel;
      Bullet->YPos += Bullet->YVel;
    }
    else
    {
      // Set up bullet
      Bullet->currentState = 1;
      switch ( Bullet->direction )
      {
        case 0u:
          Bullet->XVel = -4096;
          break;
        case 1u:
          Bullet->YVel = -4096;
          break;
        case 2u:
          Bullet->XVel = 4096;
          break;
        case 3u:
          Bullet->YVel = 4096;
          break;
        default:
          break;
      }
      if ( Level == 1 )
      {
        switch ( Bullet->direction )
        {
          case 0u:
            Bullet->sizeHeight = 1024;
            break;
          case 1u:
            Bullet->sizeWidth = 1024;
            break;
          case 2u:
            Bullet->sizeHeight = 1024;
            break;
          case 3u:
            Bullet->sizeWidth = 1024;
            break;
          default:
            break;
        }
      }
      else if ( Level == 2 )
      {
        switch ( Bullet->direction )
        {
          case 0u:
            Bullet->sizeHeight = 2048;
            break;
          case 1u:
            Bullet->sizeWidth = 2048;
            break;
          case 2u:
            Bullet->sizeHeight = 2048;
            break;
          case 3u:
            Bullet->sizeWidth = 2048;
            break;
          default:
            break;
        }
      }
    }
    switch ( Level )
    {
      case 1:
        if ( Bullet->direction != 1 && Bullet->direction != 3 )
        {
          Bullet_Rect = &Bullet->displayRect;
          Bullet_Rect->left = 128;
          Bullet_Rect->top = 32;
          Bullet_Rect->right = 144;
          Bullet_Rect->bottom = 48;
        }
        else
        {
          Bullet_Rect = &Bullet->displayRect;
          Bullet_Rect->left = 144;
          Bullet_Rect->top = 32;
          Bullet_Rect->right = 160;
          Bullet_Rect->bottom = 48;
        }
        break;
      case 2:
        if ( Bullet->direction != 1 && Bullet->direction != 3 )
        {
          Bullet_Rect = &Bullet->displayRect;
          Bullet_Rect->left = 160;
          Bullet_Rect->top = 32;
          Bullet_Rect->right = 176;
          Bullet_Rect->bottom = 48;
        }
        else
        {
          Bullet_Rect = &Bullet->displayRect;
          Bullet_Rect->left = 176;
          Bullet_Rect->top = 32;
          Bullet_Rect->right = 192;
          Bullet_Rect->bottom = 48;
        }
        break;
      case 3:
        if ( Bullet->direction != 1 && Bullet->direction != 3 )
        {
          Bullet_Rect = &Bullet->displayRect;
          Bullet_Rect->left = 128;
          Bullet_Rect->top = 48;
          Bullet_Rect->right = 144;
          Bullet_Rect->bottom = 64;
        }
        else
        {
          Bullet_Rect = &Bullet->displayRect;
          Bullet_Rect->left = 144;
          Bullet_Rect->top = 48;
          Bullet_Rect->right = 160;
          Bullet_Rect->bottom = 64;
        }
        break;
    }
  }
  else
  {
    Bullet->isAlive = 0;                        // Kill bullet
    createEffect(Bullet->XPos, Bullet->YPos, effectStar, 0);// Spawn star at bullet's position
  }
}

//----- (00404B30) --------------------------------------------------------
// Fireball (all levels)
void __cdecl bullet7_8_9_Fireball(Bullet *Bullet, int Level)
{
  int v2; // eax
  RECT *v3; // eax
  RECT *v4; // ecx
  RECT Rects_Right_Level_1[4]; // [esp+4h] [ebp-E8h]
  RECT Rects_Left_Level_1[4]; // [esp+44h] [ebp-A8h]
  RECT Rects_Right_Level_2_3[3]; // [esp+88h] [ebp-64h]
  int v8; // [esp+B8h] [ebp-34h]
  RECT Rects_Left_Level_2_3[3]; // [esp+BCh] [ebp-30h]

  if ( ++Bullet->count1 <= Bullet->maxDistance )
  {
    v8 = 0;
    if ( Bullet->isUsed & 2 && Bullet->isUsed & 8 )
      v8 = 1;
    if ( Bullet->isUsed & 1 && Bullet->isUsed & 4 )
      v8 = 1;
    if ( !Bullet->direction && Bullet->isUsed & 1 )
      Bullet->direction = 2;
    if ( Bullet->direction == 2 && Bullet->isUsed & 4 )
      Bullet->direction = 0;
    if ( v8 )
    {
      Bullet->isAlive = 0;
      createEffect(Bullet->XPos, Bullet->YPos, effectRisingDisc, 0);
      playSoundEffect(SFXShotHitWall, 1);
    }
    else
    {
      if ( Bullet->currentState )
      {
        if ( Bullet->isUsed & 8 )
        {
          Bullet->YVel = -1024;
        }
        else if ( Bullet->isUsed & 1 )
        {
          Bullet->XVel = 1024;
        }
        else if ( Bullet->isUsed & 4 )
        {
          Bullet->XVel = -1024;
        }
        // Do angle thing
        Bullet->YVel += 85;
        if ( Bullet->YVel > 0x3FF )             // Max downward speed of fireball
          Bullet->YVel = 0x3FF;
        Bullet->XPos += Bullet->XVel;
        Bullet->YPos += Bullet->YVel;
        if ( Bullet->isUsed & 0xD )
          playSoundEffect(SFXFireballBounce, 1);
      }
      else
      {
        Bullet->currentState = 1;
        switch ( Bullet->direction )
        {
          case 0u:
            Bullet->XVel = -1024;
            break;
          case 1u:
            Bullet->XVel = quote.XVel;
            if ( quote.XVel >= 0 )
              Bullet->direction = 2;
            else
              Bullet->direction = 0;
            if ( quote.direction )
              v2 = Bullet->XVel + 0x80;
            else
              v2 = Bullet->XVel - 0x80;
            Bullet->XVel = v2;
            Bullet->YVel = -0x5FFu;
            break;
          case 2u:
            Bullet->XVel = 1024;
            break;
          case 3u:
            Bullet->XVel = quote.XVel;
            if ( quote.XVel >= 0 )
              Bullet->direction = 2;
            else
              Bullet->direction = 0;
            Bullet->YVel = 0x5FF;
            break;
          default:
            break;
        }
      }
      Rects_Left_Level_1[0].left = 128;
      Rects_Left_Level_1[0].top = 0;
      Rects_Left_Level_1[0].right = 144;
      Rects_Left_Level_1[0].bottom = 16;
      Rects_Left_Level_1[1].left = 144;
      Rects_Left_Level_1[1].top = 0;
      Rects_Left_Level_1[1].right = 160;
      Rects_Left_Level_1[1].bottom = 16;
      Rects_Left_Level_1[2].left = 160;
      Rects_Left_Level_1[2].top = 0;
      Rects_Left_Level_1[2].right = 176;
      Rects_Left_Level_1[2].bottom = 16;
      Rects_Left_Level_1[3].left = 176;
      Rects_Left_Level_1[3].top = 0;
      Rects_Left_Level_1[3].right = 192;
      Rects_Left_Level_1[3].bottom = 16;
      Rects_Right_Level_1[0].left = 128;
      Rects_Right_Level_1[0].top = 16;
      Rects_Right_Level_1[0].right = 144;
      Rects_Right_Level_1[0].bottom = 32;
      Rects_Right_Level_1[1].left = 144;
      Rects_Right_Level_1[1].top = 16;
      Rects_Right_Level_1[1].right = 160;
      Rects_Right_Level_1[1].bottom = 32;
      Rects_Right_Level_1[2].left = 160;
      Rects_Right_Level_1[2].top = 16;
      Rects_Right_Level_1[2].right = 176;
      Rects_Right_Level_1[2].bottom = 32;
      Rects_Right_Level_1[3].left = 176;
      Rects_Right_Level_1[3].top = 16;
      Rects_Right_Level_1[3].right = 192;
      Rects_Right_Level_1[3].bottom = 32;
      Rects_Left_Level_2_3[0].left = 192;
      Rects_Left_Level_2_3[0].top = 16;
      Rects_Left_Level_2_3[0].right = 208;
      Rects_Left_Level_2_3[0].bottom = 32;
      Rects_Left_Level_2_3[1].left = 208;
      Rects_Left_Level_2_3[1].top = 16;
      Rects_Left_Level_2_3[1].right = 224;
      Rects_Left_Level_2_3[1].bottom = 32;
      Rects_Left_Level_2_3[2].left = 224;
      Rects_Left_Level_2_3[2].top = 16;
      Rects_Left_Level_2_3[2].right = 240;
      Rects_Left_Level_2_3[2].bottom = 32;
      Rects_Right_Level_2_3[0].left = 224;
      Rects_Right_Level_2_3[0].top = 16;
      Rects_Right_Level_2_3[0].right = 240;
      Rects_Right_Level_2_3[0].bottom = 32;
      Rects_Right_Level_2_3[1].left = 208;
      Rects_Right_Level_2_3[1].top = 16;
      Rects_Right_Level_2_3[1].right = 224;
      Rects_Right_Level_2_3[1].bottom = 32;
      Rects_Right_Level_2_3[2].left = 192;
      Rects_Right_Level_2_3[2].top = 16;
      Rects_Right_Level_2_3[2].right = 208;
      Rects_Right_Level_2_3[2].bottom = 32;
      ++Bullet->animationNum;
      if ( Level == 1 )
      {
        if ( Bullet->animationNum > 3 )
          Bullet->animationNum = 0;
        if ( Bullet->direction )
          v3 = &Rects_Right_Level_1[Bullet->animationNum];
        else
          v3 = &Rects_Left_Level_1[Bullet->animationNum];
        Bullet->displayRect = *v3;
      }
      else
      {
        if ( Bullet->animationNum > 2 )
          Bullet->animationNum = 0;
        if ( Bullet->direction )
          v4 = &Rects_Right_Level_2_3[Bullet->animationNum];
        else
          v4 = &Rects_Left_Level_2_3[Bullet->animationNum];
        Bullet->displayRect = *v4;
        if ( Level == 2 )
          createNPC((NPCNames)129, Bullet->XPos, Bullet->YPos, 0, -512, (Directions)Bullet->animationNum, 0, 256);
        else
          createNPC((NPCNames)129, Bullet->XPos, Bullet->YPos, 0, -512, (Directions)(Bullet->animationNum + 3), 0, 256);
      }
    }
  }
  else
  {
    // Kill bullet
    Bullet->isAlive = 0;
    createEffect(Bullet->XPos, Bullet->YPos, effectStar, 0);
  }
}

//----- (00405120) --------------------------------------------------------
// Machine Gun (all levels)
void __cdecl bulletA_B_C_MachineGun(Bullet *Bullet, int Level)
{
  RECT rcLevel2[4]; // [esp+Ch] [ebp-C8h]
  int bulletXVel; // [esp+50h] [ebp-84h]
  RECT rcLevel3[4]; // [esp+54h] [ebp-80h]
  RECT rcLevel1[4]; // [esp+94h] [ebp-40h]

  rcLevel1[0].left = 64;
  rcLevel1[0].top = 0;
  rcLevel1[0].right = 80;
  rcLevel1[0].bottom = 16;
  rcLevel1[1].left = 80;
  rcLevel1[1].top = 0;
  rcLevel1[1].right = 96;
  rcLevel1[1].bottom = 16;
  rcLevel1[2].left = 96;
  rcLevel1[2].top = 0;
  rcLevel1[2].right = 112;
  rcLevel1[2].bottom = 16;
  rcLevel1[3].left = 112;
  rcLevel1[3].top = 0;
  rcLevel1[3].right = 128;
  rcLevel1[3].bottom = 16;
  rcLevel2[0].left = 64;
  rcLevel2[0].top = 16;
  rcLevel2[0].right = 80;
  rcLevel2[0].bottom = 32;
  rcLevel2[1].left = 80;
  rcLevel2[1].top = 16;
  rcLevel2[1].right = 96;
  rcLevel2[1].bottom = 32;
  rcLevel2[2].left = 96;
  rcLevel2[2].top = 16;
  rcLevel2[2].right = 112;
  rcLevel2[2].bottom = 32;
  rcLevel2[3].left = 112;
  rcLevel2[3].top = 16;
  rcLevel2[3].right = 128;
  rcLevel2[3].bottom = 32;
  rcLevel3[0].left = 64;
  rcLevel3[0].top = 32;
  rcLevel3[0].right = 80;
  rcLevel3[0].bottom = 48;
  rcLevel3[1].left = 80;
  rcLevel3[1].top = 32;
  rcLevel3[1].right = 96;
  rcLevel3[1].bottom = 48;
  rcLevel3[2].left = 96;
  rcLevel3[2].top = 32;
  rcLevel3[2].right = 112;
  rcLevel3[2].bottom = 48;
  rcLevel3[3].left = 112;
  rcLevel3[3].top = 32;
  rcLevel3[3].right = 128;
  rcLevel3[3].bottom = 48;
  if ( ++Bullet->count1 <= Bullet->maxDistance )
  {
    if ( Bullet->currentState )
    {
      Bullet->XPos += Bullet->XVel;
      Bullet->YPos += Bullet->YVel;
      switch ( Level )
      {
        case 1:
          Bullet->displayRect = rcLevel1[Bullet->direction];
          break;
        case 2:
          Bullet->displayRect = rcLevel2[Bullet->direction];
          if ( Bullet->direction != up && Bullet->direction != down )
            createNPC(NPCTreasureChestClosed|0x70, Bullet->XPos, Bullet->YPos, 0, 0, left, 0, 256);
          else
            createNPC(NPCTreasureChestClosed|0x70, Bullet->XPos, Bullet->YPos, 0, 0, up, 0, 256);
          break;
        case 3:
          Bullet->displayRect = rcLevel3[Bullet->direction];
          createNPC((NPCNames)128, Bullet->XPos, Bullet->YPos, 0, 0, (Directions)Bullet->direction, 0, 256);
          break;
      }
    }
    else
    {
      switch ( Level )
      {
        case 1:
          bulletXVel = 4096;
          break;
        case 2:
          bulletXVel = 4096;
          break;
        case 3:
          bulletXVel = 4096;
          break;
      }
      Bullet->currentState = 1;
      switch ( Bullet->direction )
      {
        case 0u:
          Bullet->XVel = -bulletXVel;
          Bullet->YVel = random(-170, 170);
          break;
        case 1u:
          Bullet->YVel = -bulletXVel;
          Bullet->XVel = random(-170, 170);
          break;
        case 2u:
          Bullet->XVel = bulletXVel;
          Bullet->YVel = random(-170, 170);
          break;
        case 3u:
          Bullet->YVel = bulletXVel;
          Bullet->XVel = random(-170, 170);
          break;
        default:
          return;
      }
    }
  }
  else
  {
    Bullet->isAlive = 0;
    createEffect(Bullet->XPos, Bullet->YPos, effectStar, 0);
  }
}

//----- (004055A0) --------------------------------------------------------
void __cdecl bulletD_E_F_MissileLauncher(Bullet *bullet, int level)
{
  int v2; // edx
  int v3; // edx
  unsigned int v4; // [esp+10h] [ebp-D8h]
  int v5; // [esp+1Ch] [ebp-CCh]
  RECT rcLevel2[4]; // [esp+20h] [ebp-C8h]
  RECT rcLevel3[4]; // [esp+60h] [ebp-88h]
  RECT rcLevel1[4]; // [esp+A0h] [ebp-48h]
  int v9; // [esp+E4h] [ebp-4h]

  if ( ++bullet->count1 > bullet->maxDistance )
  {
    bullet->isAlive = 0;
    createEffect(bullet->XPos, bullet->YPos, effectStar, 0);
    return;
  }
  v9 = 0;
  if ( bullet->numberImpacts != 10 )
    v9 = 1;
  if ( !bullet->direction && bullet->isUsed & 1 )
    v9 = 1;
  if ( bullet->direction == 2 && bullet->isUsed & 4 )
    v9 = 1;
  if ( bullet->direction == 1 && bullet->isUsed & 2 )
    v9 = 1;
  if ( bullet->direction == 3 && bullet->isUsed & 8 )
    v9 = 1;
  if ( !bullet->direction && bullet->isUsed & 0x80 )
    v9 = 1;
  if ( !bullet->direction && bullet->isUsed & 0x20 )
    v9 = 1;
  if ( bullet->direction == 2 && bullet->isUsed & 0x40 )
    v9 = 1;
  if ( bullet->direction == 2 && bullet->isUsed & 0x10 )
    v9 = 1;
  if ( v9 )
  {
    createBullet((bullets)(level + bulletMissileLauncherLevel3), bullet->XPos, bullet->YPos, 0);
    bullet->isAlive = 0;
  }
  v5 = bullet->currentState;
  if ( !v5 )
  {
    bullet->currentState = 1;
    switch ( bullet->direction )
    {
      case 0u:
      case 2u:
        bullet->targetY = bullet->YPos;
        break;
      case 1u:
      case 3u:
        bullet->targetX = bullet->XPos;
        break;
      default:
        break;
    }
    if ( level == 3 )
    {
      switch ( bullet->direction )
      {
        case 0u:
        case 2u:
          if ( bullet->YPos <= quote.YPos )
            bullet->YVel = -256;
          else
            bullet->YVel = 256;
          bullet->XVel = random(-512, 512);
          break;
        case 1u:
        case 3u:
          if ( bullet->XPos <= quote.XPos )
            bullet->XVel = -256;
          else
            bullet->XVel = 256;
          bullet->YVel = random(-512, 512);
          break;
        default:
          break;
      }
      v4 = ++dword_49BC9C % 3u;
      if ( dword_49BC9C % 3u )
      {
        if ( v4 == 1 )
        {
          bullet->animationNum = 64;
        }
        else if ( v4 == 2 )
        {
          bullet->animationNum = 51;
        }
      }
      else
      {
        bullet->animationNum = 128;
      }
    }
    else
    {
      bullet->animationNum = 128;
    }
    goto LABEL_56;
  }
  if ( v5 == 1 )
  {
LABEL_56:
    switch ( bullet->direction )
    {
      case 0u:
        bullet->XVel -= bullet->animationNum;
        break;
      case 1u:
        bullet->YVel -= bullet->animationNum;
        break;
      case 2u:
        bullet->XVel += bullet->animationNum;
        break;
      case 3u:
        bullet->YVel += bullet->animationNum;
        break;
      default:
        break;
    }
    if ( level == 3 )
    {
      switch ( bullet->direction )
      {
        case 0u:
        case 2u:
          if ( bullet->YPos >= bullet->targetY )
            v2 = bullet->YVel - 32;
          else
            v2 = bullet->YVel + 32;
          bullet->YVel = v2;
          break;
        case 1u:
        case 3u:
          if ( bullet->XPos >= bullet->targetX )
            v3 = bullet->XVel - 32;
          else
            v3 = bullet->XVel + 32;
          bullet->XVel = v3;
          break;
        default:
          break;
      }
    }
    if ( bullet->XVel < -2560 )
      bullet->XVel = -2560;
    if ( bullet->XVel > 2560 )
      bullet->XVel = 2560;
    if ( bullet->YVel < -2560 )
      bullet->YVel = -2560;
    if ( bullet->YVel > 2560 )
      bullet->YVel = 2560;
    bullet->XPos += bullet->XVel;
    bullet->YPos += bullet->YVel;
  }
  if ( ++bullet->count2 > 2 )
  {
    bullet->count2 = 0;
    switch ( bullet->direction )
    {
      case 0u:
        createEffect(bullet->XPos + 4096, bullet->YPos, effectDrownedQuote, right);
        break;
      case 1u:
        createEffect(bullet->XPos, bullet->YPos + 4096, effectDrownedQuote, down);
        break;
      case 2u:
        createEffect(bullet->XPos - 4096, bullet->YPos, effectDrownedQuote, 0);
        break;
      case 3u:
        createEffect(bullet->XPos, bullet->YPos - 4096, effectDrownedQuote, up);
        break;
      default:
        break;
    }
  }
  rcLevel1[0].left = 0;
  rcLevel1[0].top = 0;
  rcLevel1[0].right = 16;
  rcLevel1[0].bottom = 16;
  rcLevel1[1].left = 16;
  rcLevel1[1].top = 0;
  rcLevel1[1].right = 32;
  rcLevel1[1].bottom = 16;
  rcLevel1[2].left = 32;
  rcLevel1[2].top = 0;
  rcLevel1[2].right = 48;
  rcLevel1[2].bottom = 16;
  rcLevel1[3].left = 48;
  rcLevel1[3].top = 0;
  rcLevel1[3].right = 64;
  rcLevel1[3].bottom = 16;
  rcLevel2[0].left = 0;
  rcLevel2[0].top = 16;
  rcLevel2[0].right = 16;
  rcLevel2[0].bottom = 32;
  rcLevel2[1].left = 16;
  rcLevel2[1].top = 16;
  rcLevel2[1].right = 32;
  rcLevel2[1].bottom = 32;
  rcLevel2[2].left = 32;
  rcLevel2[2].top = 16;
  rcLevel2[2].right = 48;
  rcLevel2[2].bottom = 32;
  rcLevel2[3].left = 48;
  rcLevel2[3].top = 16;
  rcLevel2[3].right = 64;
  rcLevel2[3].bottom = 32;
  rcLevel3[0].left = 0;
  rcLevel3[0].top = 32;
  rcLevel3[0].right = 16;
  rcLevel3[0].bottom = 48;
  rcLevel3[1].left = 16;
  rcLevel3[1].top = 32;
  rcLevel3[1].right = 32;
  rcLevel3[1].bottom = 48;
  rcLevel3[2].left = 32;
  rcLevel3[2].top = 32;
  rcLevel3[2].right = 48;
  rcLevel3[2].bottom = 48;
  rcLevel3[3].left = 48;
  rcLevel3[3].top = 32;
  rcLevel3[3].right = 64;
  rcLevel3[3].bottom = 48;
  switch ( level )
  {
    case 1:
      bullet->displayRect = rcLevel1[bullet->direction];
      break;
    case 2:
      bullet->displayRect = rcLevel2[bullet->direction];
      break;
    case 3:
      bullet->displayRect = rcLevel3[bullet->direction];
      break;
  }
}
// 49BC9C: using guessed type int dword_49BC9C;

//----- (00405D80) --------------------------------------------------------
Bullet *__cdecl bullet10_11_12_MissileExplosion(Bullet *bullet, int level)
{
  Bullet *result; // eax
  int v3; // ST0C_4
  int v4; // ST08_4
  int v5; // eax
  int v6; // ST0C_4
  int v7; // ST08_4
  int v8; // eax
  int v9; // ST0C_4
  int v10; // ST08_4
  int v11; // eax
  int v12; // [esp+8h] [ebp-4h]

  result = bullet;
  v12 = bullet->currentState;
  if ( v12 )
  {
    if ( v12 != 1 )
      return result;
  }
  else
  {
    bullet->currentState = 1;
    switch ( level )
    {
      case 1:
        bullet->act_wait = 10;
        break;
      case 2:
        bullet->act_wait = 15;
        break;
      case 3:
        bullet->act_wait = 5;
        break;
    }
    playSoundEffect(SFXMissileImpact, 1);
  }
  if ( level == 1 )
  {
    if ( !(bullet->act_wait % 3) )
    {
      v3 = bullet->sizeWidth;
      v4 = bullet->YPos + (random(-16, 16) << 9);
      v5 = random(-16, 16);
      createDustCloudsUp(bullet->XPos + (v5 << 9), v4, v3, 2);
    }
  }
  else if ( level == 2 )
  {
    if ( !(bullet->act_wait % 3) )
    {
      v6 = bullet->sizeWidth;
      v7 = bullet->YPos + (random(-32, 32) << 9);
      v8 = random(-32, 32);
      createDustCloudsUp(bullet->XPos + (v8 << 9), v7, v6, 2);
    }
  }
  else if ( level == 3 && !(bullet->act_wait % 3) )
  {
    v9 = bullet->sizeWidth;
    v10 = bullet->YPos + (random(-40, 40) << 9);
    v11 = random(-40, 40);
    createDustCloudsUp(bullet->XPos + (v11 << 9), v10, v9, 2);
  }
  --bullet->act_wait;
  result = bullet;
  if ( bullet->act_wait < 0 )
    bullet->isAlive = 0;
  return result;
}

//----- (00405F30) --------------------------------------------------------
void __cdecl bullet13_BubblerLevel1(Bullet *bullet)
{
  RECT bulletRects[4]; // [esp+Ch] [ebp-40h]

  if ( bullet->isUsed & 0x2FF )
  {
    bullet->isAlive = 0;
    createEffect(bullet->XPos, bullet->YPos, effectRisingDisc, 0);
  }
  else
  {
    if ( !bullet->currentState )
    {
      bullet->currentState = 1;
      switch ( bullet->direction )
      {
        case 0u:
          bullet->XVel = -1536;
          break;
        case 1u:
          bullet->YVel = -1536;
          break;
        case 2u:
          bullet->XVel = 1536;
          break;
        case 3u:
          bullet->YVel = 1536;
          break;
        default:
          break;
      }
    }
    switch ( bullet->direction )
    {
      case 0u:
        bullet->XVel += 42;
        break;
      case 1u:
        bullet->YVel += 42;
        break;
      case 2u:
        bullet->XVel -= 42;
        break;
      case 3u:
        bullet->YVel -= 42;
        break;
      default:
        break;
    }
    bullet->XPos += bullet->XVel;
    bullet->YPos += bullet->YVel;
    if ( ++bullet->act_wait > 40 )
    {
      bullet->isAlive = 0;
      createEffect(bullet->XPos, bullet->YPos, effectNothing, 0);
    }
    bulletRects[0].left = 192;
    bulletRects[0].top = 0;
    bulletRects[0].right = 200;
    bulletRects[0].bottom = 8;
    bulletRects[1].left = 200;
    bulletRects[1].top = 0;
    bulletRects[1].right = 208;
    bulletRects[1].bottom = 8;
    bulletRects[2].left = 208;
    bulletRects[2].top = 0;
    bulletRects[2].right = 216;
    bulletRects[2].bottom = 8;
    bulletRects[3].left = 216;
    bulletRects[3].top = 0;
    bulletRects[3].right = 224;
    bulletRects[3].bottom = 8;
    if ( ++bullet->frameTimer > 3 )
    {
      bullet->frameTimer = 0;
      ++bullet->animationNum;
    }
    if ( bullet->animationNum > 3 )
      bullet->animationNum = 3;
    bullet->displayRect = bulletRects[bullet->animationNum];
  }
}

//----- (00406190) --------------------------------------------------------
void __cdecl bullet14_BubllerLevel2(Bullet *bullet)
{
  signed int v1; // [esp+Ch] [ebp-44h]
  RECT bulletRects[4]; // [esp+10h] [ebp-40h]

  v1 = 0;
  if ( !bullet->direction && bullet->isUsed & 1 )
    v1 = 1;
  if ( bullet->direction == 2 && bullet->isUsed & 4 )
    v1 = 1;
  if ( bullet->direction == 1 && bullet->isUsed & 2 )
    v1 = 1;
  if ( bullet->direction == 3 && bullet->isUsed & 8 )
    v1 = 1;
  if ( v1 )
  {
    bullet->isAlive = 0;
    createEffect(bullet->XPos, bullet->YPos, effectRisingDisc, 0);
  }
  else
  {
    if ( !bullet->currentState )
    {
      bullet->currentState = 1;
      switch ( bullet->direction )
      {
        case 0u:
          bullet->XVel = -1536;
          bullet->YVel = random(-256, 256);
          break;
        case 1u:
          bullet->YVel = -1536;
          bullet->XVel = random(-256, 256);
          break;
        case 2u:
          bullet->XVel = 1536;
          bullet->YVel = random(-256, 256);
          break;
        case 3u:
          bullet->YVel = 1536;
          bullet->XVel = random(-256, 256);
          break;
        default:
          break;
      }
    }
    switch ( bullet->direction )
    {
      case 0u:
        bullet->XVel += 16;
        break;
      case 1u:
        bullet->YVel += 16;
        break;
      case 2u:
        bullet->XVel -= 16;
        break;
      case 3u:
        bullet->YVel -= 16;
        break;
      default:
        break;
    }
    bullet->XPos += bullet->XVel;
    bullet->YPos += bullet->YVel;
    if ( ++bullet->act_wait > 60 )
    {
      bullet->isAlive = 0;
      createEffect(bullet->XPos, bullet->YPos, effectNothing, 0);
    }
    bulletRects[0].left = 192;
    bulletRects[0].top = 8;
    bulletRects[0].right = 200;
    bulletRects[0].bottom = 16;
    bulletRects[1].left = 200;
    bulletRects[1].top = 8;
    bulletRects[1].right = 208;
    bulletRects[1].bottom = 16;
    bulletRects[2].left = 208;
    bulletRects[2].top = 8;
    bulletRects[2].right = 216;
    bulletRects[2].bottom = 16;
    bulletRects[3].left = 216;
    bulletRects[3].top = 8;
    bulletRects[3].right = 224;
    bulletRects[3].bottom = 16;
    if ( ++bullet->frameTimer > 3 )
    {
      bullet->frameTimer = 0;
      ++bullet->animationNum;
    }
    if ( bullet->animationNum > 3 )
      bullet->animationNum = 3;
    bullet->displayRect = bulletRects[bullet->animationNum];
  }
}

//----- (004064D0) --------------------------------------------------------
void __cdecl bullet15_BubblerLevel3(Bullet *bullet)
{
  RECT bulletRects[4]; // [esp+8h] [ebp-40h]

  if ( ++bullet->act_wait <= 100 && keyShoot & keyHeld )
  {
    if ( !bullet->currentState )
    {
      bullet->currentState = 1;
      switch ( bullet->direction )
      {
        case 0u:
          bullet->XVel = random(-1024, -512);
          bullet->YVel = (random(-4, 4) << 9) / 2;
          break;
        case 1u:
          bullet->YVel = random(-1024, -512);
          bullet->XVel = (random(-4, 4) << 9) / 2;
          break;
        case 2u:
          bullet->XVel = random(512, 1024);
          bullet->YVel = (random(-4, 4) << 9) / 2;
          break;
        case 3u:
          bullet->YVel = random(128, 256);
          bullet->XVel = (random(-4, 4) << 9) / 2;
          break;
        default:
          break;
      }
    }
    if ( bullet->XPos < quote.XPos )
      bullet->XVel += 32;
    if ( bullet->XPos > quote.XPos )
      bullet->XVel -= 32;
    if ( bullet->YPos < quote.YPos )
      bullet->YVel += 32;
    if ( bullet->YPos > quote.YPos )
      bullet->YVel -= 32;
    if ( bullet->XVel < 0 && bullet->isUsed & 1 )
      bullet->XVel = 1024;
    if ( bullet->XVel > 0 && bullet->isUsed & 4 )
      bullet->XVel = -1024;
    if ( bullet->YVel < 0 && bullet->isUsed & 2 )
      bullet->YVel = 1024;
    if ( bullet->YVel > 0 && bullet->isUsed & 8 )
      bullet->YVel = -1024;
    bullet->XPos += bullet->XVel;
    bullet->YPos += bullet->YVel;
    bulletRects[0].left = 240;
    bulletRects[0].top = 16;
    bulletRects[0].right = 248;
    bulletRects[0].bottom = 24;
    bulletRects[1].left = 248;
    bulletRects[1].top = 16;
    bulletRects[1].right = 256;
    bulletRects[1].bottom = 24;
    bulletRects[2].left = 240;
    bulletRects[2].top = 24;
    bulletRects[2].right = 248;
    bulletRects[2].bottom = 32;
    bulletRects[3].left = 248;
    bulletRects[3].top = 24;
    bulletRects[3].right = 256;
    bulletRects[3].bottom = 32;
    if ( ++bullet->frameTimer > 3 )
    {
      bullet->frameTimer = 0;
      ++bullet->animationNum;
    }
    if ( bullet->animationNum > 3 )
      bullet->animationNum = 3;
    bullet->displayRect = bulletRects[bullet->animationNum];
  }
  else
  {
    bullet->isAlive = 0;
    createEffect(bullet->XPos, bullet->YPos, effectRisingDisc, 0);
    playSoundEffect(SFXBubblerShootLevel3, 1);
    if ( quote.isFacingUp )
    {
      createBullet(bulletBubblerSpurs, bullet->XPos, bullet->YPos, up);
    }
    else if ( quote.isFacingDown )
    {
      createBullet(bulletBubblerSpurs, bullet->XPos, bullet->YPos, down);
    }
    else
    {
      createBullet(bulletBubblerSpurs, bullet->XPos, bullet->YPos, quote.direction);
    }
  }
}
// 493614: using guessed type int keyShoot;
// 49E210: using guessed type int keyHeld;

//----- (004068B0) --------------------------------------------------------
void __cdecl bullet16_BubblerSpurs(Bullet *bullet)
{
  RECT rcUpDown[2]; // [esp+8h] [ebp-60h]
  RECT rcRight[2]; // [esp+28h] [ebp-40h]
  RECT rcLeft[2]; // [esp+48h] [ebp-20h]

  if ( ++bullet->count1 > bullet->maxDistance || bullet->isUsed & 8 )
  {
    bullet->isAlive = 0;
    createEffect(bullet->XPos, bullet->YPos, effectStar, 0);
  }
  else
  {
    if ( bullet->currentState )
    {
      bullet->XPos += bullet->XVel;
      bullet->YPos += bullet->YVel;
    }
    else
    {
      bullet->currentState = 1;
      switch ( bullet->direction )
      {
        case 0u:
          bullet->XVel = -512 * random(10, 16) / 2;
          break;
        case 1u:
          bullet->YVel = -512 * random(10, 16) / 2;
          break;
        case 2u:
          bullet->XVel = (random(10, 16) << 9) / 2;
          break;
        case 3u:
          bullet->YVel = (random(10, 16) << 9) / 2;
          break;
        default:
          break;
      }
    }
    if ( ++bullet->frameTimer > 1 )
    {
      bullet->frameTimer = 0;
      ++bullet->animationNum;
    }
    if ( bullet->animationNum > 1 )
      bullet->animationNum = 0;
    rcLeft[0].left = 224;
    rcLeft[0].top = 0;
    rcLeft[0].right = 232;
    rcLeft[0].bottom = 8;
    rcLeft[1].left = 232;
    rcLeft[1].top = 0;
    rcLeft[1].right = 240;
    rcLeft[1].bottom = 8;
    rcRight[0].left = 224;
    rcRight[0].top = 0;
    rcRight[0].right = 232;
    rcRight[0].bottom = 8;
    rcRight[1].left = 232;
    rcRight[1].top = 0;
    rcRight[1].right = 240;
    rcRight[1].bottom = 8;
    rcUpDown[0].left = 224;
    rcUpDown[0].top = 8;
    rcUpDown[0].right = 232;
    rcUpDown[0].bottom = 16;
    rcUpDown[1].left = 232;
    rcUpDown[1].top = 8;
    rcUpDown[1].right = 240;
    rcUpDown[1].bottom = 16;
    switch ( bullet->direction )
    {
      case left:
        bullet->displayRect = rcLeft[bullet->animationNum];
        break;
      case up:
        bullet->displayRect = rcUpDown[bullet->animationNum];
        break;
      case right:
        bullet->displayRect = rcRight[bullet->animationNum];
        break;
      case down:
        bullet->displayRect = rcUpDown[bullet->animationNum];
        break;
      default:
        return;
    }
  }
}

//----- (00406BB0) --------------------------------------------------------
void __cdecl bullet19_BladeLevel1(Bullet *bullet)
{
  int *v1; // eax
  RECT *v2; // ecx
  int v3; // [esp+4h] [ebp-80h]
  int v4; // [esp+8h] [ebp-7Ch]
  int v5; // [esp+Ch] [ebp-78h]
  int v6; // [esp+10h] [ebp-74h]
  int v7; // [esp+14h] [ebp-70h]
  int v8; // [esp+18h] [ebp-6Ch]
  int v9; // [esp+1Ch] [ebp-68h]
  int v10; // [esp+20h] [ebp-64h]
  int v11; // [esp+24h] [ebp-60h]
  int v12; // [esp+28h] [ebp-5Ch]
  int v13; // [esp+2Ch] [ebp-58h]
  int v14; // [esp+30h] [ebp-54h]
  int v15; // [esp+34h] [ebp-50h]
  int v16; // [esp+38h] [ebp-4Ch]
  int v17; // [esp+3Ch] [ebp-48h]
  int v18; // [esp+40h] [ebp-44h]
  int v19; // [esp+44h] [ebp-40h]
  int v20; // [esp+48h] [ebp-3Ch]
  int v21; // [esp+4Ch] [ebp-38h]
  int v22; // [esp+50h] [ebp-34h]
  int v23; // [esp+54h] [ebp-30h]
  int v24; // [esp+58h] [ebp-2Ch]
  int v25; // [esp+5Ch] [ebp-28h]
  int v26; // [esp+60h] [ebp-24h]
  int v27; // [esp+64h] [ebp-20h]
  int v28; // [esp+68h] [ebp-1Ch]
  int v29; // [esp+6Ch] [ebp-18h]
  int v30; // [esp+70h] [ebp-14h]
  int v31; // [esp+74h] [ebp-10h]
  int v32; // [esp+78h] [ebp-Ch]
  int v33; // [esp+7Ch] [ebp-8h]
  int v34; // [esp+80h] [ebp-4h]

  if ( ++bullet->count1 <= bullet->maxDistance )
  {
    if ( bullet->count1 == 3 )
      bullet->flags &= 0xFFFFFFFB;
    if ( bullet->count1 % 5 == 1 )
      playSoundEffect(SFXFireballBounce, 1);
    if ( bullet->currentState )
    {
      bullet->XPos += bullet->XVel;
      bullet->YPos += bullet->YVel;
    }
    else
    {
      bullet->currentState = 1;
      switch ( bullet->direction )
      {
        case 0u:
          bullet->XVel = -2048;
          break;
        case 1u:
          bullet->YVel = -2048;
          break;
        case 2u:
          bullet->XVel = 2048;
          break;
        case 3u:
          bullet->YVel = 2048;
          break;
        default:
          break;
      }
    }
    v19 = 0;
    v20 = 48;
    v21 = 16;
    v22 = 64;
    v23 = 16;
    v24 = 48;
    v25 = 32;
    v26 = 64;
    v27 = 32;
    v28 = 48;
    v29 = 48;
    v30 = 64;
    v31 = 48;
    v32 = 48;
    v33 = 64;
    v34 = 64;
    v3 = 64;
    v4 = 48;
    v5 = 80;
    v6 = 64;
    v7 = 80;
    v8 = 48;
    v9 = 96;
    v10 = 64;
    v11 = 96;
    v12 = 48;
    v13 = 112;
    v14 = 64;
    v15 = 112;
    v16 = 48;
    v17 = 128;
    v18 = 64;
    if ( ++bullet->frameTimer > 1 )
    {
      bullet->frameTimer = 0;
      ++bullet->animationNum;
    }
    if ( bullet->animationNum > 3 )
      bullet->animationNum = 0;
    if ( bullet->direction )
      v1 = &v3 + 4 * bullet->animationNum;
    else
      v1 = &v19 + 4 * bullet->animationNum;
    v2 = &bullet->displayRect;
    v2->left = *v1;
    v2->top = v1[1];
    v2->right = v1[2];
    v2->bottom = v1[3];
  }
  else
  {
    bullet->isAlive = 0;
    createEffect(bullet->XPos, bullet->YPos, effectStar, 0);
  }
}

//----- (00406E60) --------------------------------------------------------
void __cdecl bullet1A_BladeLevel2(Bullet *bullet)
{
  int *v1; // eax
  RECT *v2; // ecx
  int v3; // [esp+4h] [ebp-80h]
  int v4; // [esp+8h] [ebp-7Ch]
  int v5; // [esp+Ch] [ebp-78h]
  int v6; // [esp+10h] [ebp-74h]
  int v7; // [esp+14h] [ebp-70h]
  int v8; // [esp+18h] [ebp-6Ch]
  int v9; // [esp+1Ch] [ebp-68h]
  int v10; // [esp+20h] [ebp-64h]
  int v11; // [esp+24h] [ebp-60h]
  int v12; // [esp+28h] [ebp-5Ch]
  int v13; // [esp+2Ch] [ebp-58h]
  int v14; // [esp+30h] [ebp-54h]
  int v15; // [esp+34h] [ebp-50h]
  int v16; // [esp+38h] [ebp-4Ch]
  int v17; // [esp+3Ch] [ebp-48h]
  int v18; // [esp+40h] [ebp-44h]
  int v19; // [esp+44h] [ebp-40h]
  int v20; // [esp+48h] [ebp-3Ch]
  int v21; // [esp+4Ch] [ebp-38h]
  int v22; // [esp+50h] [ebp-34h]
  int v23; // [esp+54h] [ebp-30h]
  int v24; // [esp+58h] [ebp-2Ch]
  int v25; // [esp+5Ch] [ebp-28h]
  int v26; // [esp+60h] [ebp-24h]
  int v27; // [esp+64h] [ebp-20h]
  int v28; // [esp+68h] [ebp-1Ch]
  int v29; // [esp+6Ch] [ebp-18h]
  int v30; // [esp+70h] [ebp-14h]
  int v31; // [esp+74h] [ebp-10h]
  int v32; // [esp+78h] [ebp-Ch]
  int v33; // [esp+7Ch] [ebp-8h]
  int v34; // [esp+80h] [ebp-4h]

  if ( ++bullet->count1 <= bullet->maxDistance )
  {
    if ( bullet->count1 == 3 )
      bullet->flags &= 0xFFFFFFFB;
    if ( bullet->count1 % 7 == 1 )
      playSoundEffect(SFXSpinningProjectile, 1);
    if ( bullet->currentState )
    {
      bullet->XPos += bullet->XVel;
      bullet->YPos += bullet->YVel;
    }
    else
    {
      bullet->currentState = 1;
      switch ( bullet->direction )
      {
        case 0u:
          bullet->XVel = -2048;
          break;
        case 1u:
          bullet->YVel = -2048;
          break;
        case 2u:
          bullet->XVel = 2048;
          break;
        case 3u:
          bullet->YVel = 2048;
          break;
        default:
          break;
      }
    }
    v19 = 160;
    v20 = 48;
    v21 = 184;
    v22 = 72;
    v23 = 184;
    v24 = 48;
    v25 = 208;
    v26 = 72;
    v27 = 208;
    v28 = 48;
    v29 = 232;
    v30 = 72;
    v31 = 232;
    v32 = 48;
    v33 = 256;
    v34 = 72;
    v3 = 160;
    v4 = 72;
    v5 = 184;
    v6 = 96;
    v7 = 184;
    v8 = 72;
    v9 = 208;
    v10 = 96;
    v11 = 208;
    v12 = 72;
    v13 = 232;
    v14 = 96;
    v15 = 232;
    v16 = 72;
    v17 = 256;
    v18 = 96;
    if ( ++bullet->frameTimer > 1 )
    {
      bullet->frameTimer = 0;
      ++bullet->animationNum;
    }
    if ( bullet->animationNum > 3 )
      bullet->animationNum = 0;
    if ( bullet->direction )
      v1 = &v3 + 4 * bullet->animationNum;
    else
      v1 = &v19 + 4 * bullet->animationNum;
    v2 = &bullet->displayRect;
    v2->left = *v1;
    v2->top = v1[1];
    v2->right = v1[2];
    v2->bottom = v1[3];
  }
  else
  {
    bullet->isAlive = 0;
    createEffect(bullet->XPos, bullet->YPos, effectStar, 0);
  }
}

//----- (00407110) --------------------------------------------------------
void __cdecl bullet1B_BladeLevel3(Bullet *bullet)
{
  int v1; // ST08_4
  int v2; // eax
  int v3; // ST08_4
  int v4; // eax
  int *v5; // eax
  RECT *v6; // ecx
  int *v7; // eax
  RECT *v8; // ecx
  int *v9; // eax
  RECT *v10; // ecx
  int *v11; // eax
  RECT *v12; // ecx
  int v13; // [esp+8h] [ebp-84h]
  int v14; // [esp+Ch] [ebp-80h]
  int v15; // [esp+10h] [ebp-7Ch]
  int v16; // [esp+14h] [ebp-78h]
  int v17; // [esp+18h] [ebp-74h]
  int v18; // [esp+1Ch] [ebp-70h]
  int v19; // [esp+20h] [ebp-6Ch]
  int v20; // [esp+24h] [ebp-68h]
  int v21; // [esp+28h] [ebp-64h]
  int v22; // [esp+2Ch] [ebp-60h]
  int v23; // [esp+30h] [ebp-5Ch]
  int v24; // [esp+34h] [ebp-58h]
  int v25; // [esp+38h] [ebp-54h]
  int v26; // [esp+3Ch] [ebp-50h]
  int v27; // [esp+40h] [ebp-4Ch]
  int v28; // [esp+44h] [ebp-48h]
  int v29; // [esp+48h] [ebp-44h]
  int v30; // [esp+4Ch] [ebp-40h]
  int v31; // [esp+50h] [ebp-3Ch]
  int v32; // [esp+54h] [ebp-38h]
  int v33; // [esp+58h] [ebp-34h]
  int v34; // [esp+5Ch] [ebp-30h]
  int v35; // [esp+60h] [ebp-2Ch]
  int v36; // [esp+64h] [ebp-28h]
  int v37; // [esp+68h] [ebp-24h]
  int v38; // [esp+6Ch] [ebp-20h]
  int v39; // [esp+70h] [ebp-1Ch]
  int v40; // [esp+74h] [ebp-18h]
  int v41; // [esp+78h] [ebp-14h]
  int v42; // [esp+7Ch] [ebp-10h]
  int v43; // [esp+80h] [ebp-Ch]
  int v44; // [esp+84h] [ebp-8h]
  int v45; // [esp+88h] [ebp-4h]

  v30 = 272;
  v31 = 0;
  v32 = 296;
  v33 = 24;
  v34 = 296;
  v35 = 0;
  v36 = 320;
  v37 = 24;
  v38 = 272;
  v39 = 48;
  v40 = 296;
  v41 = 72;
  v42 = 296;
  v43 = 0;
  v44 = 320;
  v45 = 24;
  v22 = 272;
  v23 = 24;
  v24 = 296;
  v25 = 48;
  v26 = 296;
  v27 = 24;
  v28 = 320;
  v29 = 48;
  v14 = 296;
  v15 = 48;
  v16 = 320;
  v17 = 72;
  v18 = 296;
  v19 = 24;
  v20 = 320;
  v21 = 48;
  v13 = bullet->currentState;
  if ( v13 )
  {
    if ( v13 != 1 )
    {
      if ( v13 == 2 )
      {
        bullet->XVel = 0;
        bullet->YVel = 0;
        ++bullet->act_wait;
        if ( !random(-1, 1) )
        {
          playSoundEffect(SFXSpinningProjectile, 1);
          if ( random(0, 1) % 2 )
          {
            v1 = bullet->YPos + (random(-64, 64) << 9);
            v2 = random(-64, 64);
            createBullet(bulletBladeSlash, bullet->XPos + (v2 << 9), v1, 0);
          }
          else
          {
            v3 = bullet->YPos + (random(-64, 64) << 9);
            v4 = random(-64, 64);
            createBullet(bulletBladeSlash, bullet->XPos + (v4 << 9), v3, right);
          }
        }
        if ( bullet->act_wait > 50 )
          bullet->isAlive = 0;
      }
      goto LABEL_28;
    }
  }
  else
  {
    bullet->currentState = 1;
    bullet->XVel = 0;
    bullet->YVel = 0;
  }
  switch ( bullet->direction )
  {
    case 0u:
      bullet->XVel = -2048;
      break;
    case 1u:
      bullet->YVel = -2048;
      break;
    case 2u:
      bullet->XVel = 2048;
      break;
    case 3u:
      bullet->YVel = 2048;
      break;
    default:
      break;
  }
  if ( bullet->numberImpacts != 100 )
  {
    bullet->currentState = 2;
    bullet->animationNum = 1;
    bullet->damage = -1;
    bullet->act_wait = 0;
  }
  if ( ++bullet->act_wait % 4 == 1 )
  {
    playSoundEffect(SFXSpinningProjectile, 1);
    if ( ++bullet->count1 % 2 )
      createBullet(bulletBladeSlash, bullet->XPos, bullet->YPos, 0);
    else
      createBullet(bulletBladeSlash, bullet->XPos, bullet->YPos, right);
  }
  if ( ++bullet->count1 == 5 )
    bullet->flags &= 0xFFFFFFFB;
  if ( bullet->count1 > bullet->maxDistance )
  {
    bullet->isAlive = 0;
    createEffect(bullet->XPos, bullet->YPos, effectStar, 0);
    return;
  }
LABEL_28:
  bullet->XPos += bullet->XVel;
  bullet->YPos += bullet->YVel;
  switch ( bullet->direction )
  {
    case 0u:
      v5 = &v30 + 4 * bullet->animationNum;
      v6 = &bullet->displayRect;
      v6->left = *v5;
      v6->top = v5[1];
      v6->right = v5[2];
      v6->bottom = v5[3];
      break;
    case 1u:
      v7 = &v38 + 4 * bullet->animationNum;
      v8 = &bullet->displayRect;
      v8->left = *v7;
      v8->top = v7[1];
      v8->right = v7[2];
      v8->bottom = v7[3];
      break;
    case 2u:
      v9 = &v22 + 4 * bullet->animationNum;
      v10 = &bullet->displayRect;
      v10->left = *v9;
      v10->top = v9[1];
      v10->right = v9[2];
      v10->bottom = v9[3];
      break;
    case 3u:
      v11 = &v14 + 4 * bullet->animationNum;
      v12 = &bullet->displayRect;
      v12->left = *v11;
      v12->top = v11[1];
      v12->right = v11[2];
      v12->bottom = v11[3];
      break;
    default:
      break;
  }
  if ( bullet->act_wait % 2 )
    bullet->displayRect.right = 0;
}

//----- (004075E0) --------------------------------------------------------
void __cdecl bullet17_BladeSlash(Bullet *bullet)
{
  int v1; // eax
  int v2; // ecx
  RECT *v3; // eax
  int v4; // [esp+0h] [ebp-A4h]
  RECT rcRight[5]; // [esp+4h] [ebp-A0h]
  RECT rcLeft[5]; // [esp+54h] [ebp-50h]

  v4 = bullet->currentState;
  if ( v4 )
  {
    if ( v4 != 1 )
      goto LABEL_18;
  }
  else
  {
    bullet->currentState = 1;
    bullet->YPos -= 6144;
    if ( bullet->direction )
      v1 = bullet->XPos - 0x2000;
    else
      v1 = bullet->XPos + 0x2000;
    bullet->XPos = v1;
  }
  if ( ++bullet->frameTimer > 2 )
  {
    bullet->frameTimer = 0;
    ++bullet->animationNum;
  }
  if ( bullet->direction )
    v2 = bullet->XPos + 1024;
  else
    v2 = bullet->XPos - 1024;
  bullet->XPos = v2;
  bullet->YPos += 1024;
  if ( bullet->animationNum == 1 )
    bullet->damage = 2;
  else
    bullet->damage = 1;
  if ( bullet->animationNum > 4 )
    bullet->isAlive = 0;
LABEL_18:
  rcLeft[0].left = 0;
  rcLeft[0].top = 64;
  rcLeft[0].right = 24;
  rcLeft[0].bottom = 88;
  rcLeft[1].left = 24;
  rcLeft[1].top = 64;
  rcLeft[1].right = 48;
  rcLeft[1].bottom = 88;
  rcLeft[2].left = 48;
  rcLeft[2].top = 64;
  rcLeft[2].right = 72;
  rcLeft[2].bottom = 88;
  rcLeft[3].left = 72;
  rcLeft[3].top = 64;
  rcLeft[3].right = 96;
  rcLeft[3].bottom = 88;
  rcLeft[4].left = 96;
  rcLeft[4].top = 64;
  rcLeft[4].right = 120;
  rcLeft[4].bottom = 88;
  rcRight[0].left = 0;
  rcRight[0].top = 88;
  rcRight[0].right = 24;
  rcRight[0].bottom = 112;
  rcRight[1].left = 24;
  rcRight[1].top = 88;
  rcRight[1].right = 48;
  rcRight[1].bottom = 112;
  rcRight[2].left = 48;
  rcRight[2].top = 88;
  rcRight[2].right = 72;
  rcRight[2].bottom = 112;
  rcRight[3].left = 72;
  rcRight[3].top = 88;
  rcRight[3].right = 96;
  rcRight[3].bottom = 112;
  rcRight[4].left = 96;
  rcRight[4].top = 88;
  rcRight[4].right = 120;
  rcRight[4].bottom = 112;
  if ( bullet->direction )
    v3 = &rcRight[bullet->animationNum];
  else
    v3 = &rcLeft[bullet->animationNum];
  bullet->displayRect = *v3;
}

//----- (004078A0) --------------------------------------------------------
// Unused
void __cdecl bullet18_Unused(Bullet *npc)
{
  RECT *v1; // edx

  if ( ++npc->act_wait > 2 )
    npc->isAlive = 0;
  v1 = &npc->displayRect;
  v1->left = 0;
  v1->top = 0;
  v1->right = 0;
  v1->bottom = 0;
}

//----- (00407910) --------------------------------------------------------
void __cdecl bullet1C_1D_1E_SuperMissileLauncher(Bullet *bullet, int level)
{
  int v2; // edx
  int v3; // edx
  int *v4; // edx
  RECT *v5; // eax
  int *v6; // edx
  RECT *v7; // eax
  int *v8; // edx
  RECT *v9; // eax
  unsigned int v10; // [esp+10h] [ebp-98h]
  int v11; // [esp+1Ch] [ebp-8Ch]
  int v12; // [esp+20h] [ebp-88h]
  int v13; // [esp+24h] [ebp-84h]
  int v14; // [esp+28h] [ebp-80h]
  int v15; // [esp+2Ch] [ebp-7Ch]
  int v16; // [esp+30h] [ebp-78h]
  int v17; // [esp+34h] [ebp-74h]
  int v18; // [esp+38h] [ebp-70h]
  int v19; // [esp+3Ch] [ebp-6Ch]
  int v20; // [esp+40h] [ebp-68h]
  int v21; // [esp+44h] [ebp-64h]
  int v22; // [esp+48h] [ebp-60h]
  int v23; // [esp+4Ch] [ebp-5Ch]
  int v24; // [esp+50h] [ebp-58h]
  int v25; // [esp+54h] [ebp-54h]
  int v26; // [esp+58h] [ebp-50h]
  int v27; // [esp+5Ch] [ebp-4Ch]
  int v28; // [esp+60h] [ebp-48h]
  int v29; // [esp+64h] [ebp-44h]
  int v30; // [esp+68h] [ebp-40h]
  int v31; // [esp+6Ch] [ebp-3Ch]
  int v32; // [esp+70h] [ebp-38h]
  int v33; // [esp+74h] [ebp-34h]
  int v34; // [esp+78h] [ebp-30h]
  int v35; // [esp+7Ch] [ebp-2Ch]
  int v36; // [esp+80h] [ebp-28h]
  int v37; // [esp+84h] [ebp-24h]
  int v38; // [esp+88h] [ebp-20h]
  int v39; // [esp+8Ch] [ebp-1Ch]
  int v40; // [esp+90h] [ebp-18h]
  int v41; // [esp+94h] [ebp-14h]
  int v42; // [esp+98h] [ebp-10h]
  int v43; // [esp+9Ch] [ebp-Ch]
  int v44; // [esp+A4h] [ebp-4h]

  if ( ++bullet->count1 > bullet->maxDistance )
  {
    bullet->isAlive = 0;
    createEffect(bullet->XPos, bullet->YPos, effectStar, 0);
    return;
  }
  v44 = 0;
  if ( bullet->numberImpacts != 10 )
    v44 = 1;
  if ( !bullet->direction && bullet->isUsed & 1 )
    v44 = 1;
  if ( bullet->direction == 2 && bullet->isUsed & 4 )
    v44 = 1;
  if ( bullet->direction == 1 && bullet->isUsed & 2 )
    v44 = 1;
  if ( bullet->direction == 3 && bullet->isUsed & 8 )
    v44 = 1;
  if ( !bullet->direction && bullet->isUsed & 0x80 )
    v44 = 1;
  if ( !bullet->direction && bullet->isUsed & 0x20 )
    v44 = 1;
  if ( bullet->direction == 2 && bullet->isUsed & 0x40 )
    v44 = 1;
  if ( bullet->direction == 2 && bullet->isUsed & 0x10 )
    v44 = 1;
  if ( v44 )
  {
    createBullet((bullets)(level + bulletSuperMissileLauncherLevel3), bullet->XPos, bullet->YPos, 0);
    bullet->isAlive = 0;
  }
  v11 = bullet->currentState;
  if ( !v11 )
  {
    bullet->currentState = 1;
    switch ( bullet->direction )
    {
      case 0u:
      case 2u:
        bullet->targetY = bullet->YPos;
        bullet->sizeWidth = 4096;
        bullet->collisionX = 4096;
        break;
      case 1u:
      case 3u:
        bullet->targetX = bullet->XPos;
        bullet->sizeHeight = 4096;
        bullet->collisionY = 4096;
        break;
      default:
        break;
    }
    if ( level == 3 )
    {
      switch ( bullet->direction )
      {
        case 0u:
        case 2u:
          if ( bullet->YPos <= quote.YPos )
            bullet->YVel = -256;
          else
            bullet->YVel = 256;
          bullet->XVel = random(-512, 512);
          break;
        case 1u:
        case 3u:
          if ( bullet->XPos <= quote.XPos )
            bullet->XVel = -256;
          else
            bullet->XVel = 256;
          bullet->YVel = random(-512, 512);
          break;
        default:
          break;
      }
      v10 = ++dword_49BCA0 % 3u;
      if ( dword_49BCA0 % 3u )
      {
        if ( v10 == 1 )
        {
          bullet->animationNum = 256;
        }
        else if ( v10 == 2 )
        {
          bullet->animationNum = 170;
        }
      }
      else
      {
        bullet->animationNum = 512;
      }
    }
    else
    {
      bullet->animationNum = 512;
    }
    goto LABEL_56;
  }
  if ( v11 == 1 )
  {
LABEL_56:
    switch ( bullet->direction )
    {
      case 0u:
        bullet->XVel -= bullet->animationNum;
        break;
      case 1u:
        bullet->YVel -= bullet->animationNum;
        break;
      case 2u:
        bullet->XVel += bullet->animationNum;
        break;
      case 3u:
        bullet->YVel += bullet->animationNum;
        break;
      default:
        break;
    }
    if ( level == 3 )
    {
      switch ( bullet->direction )
      {
        case 0u:
        case 2u:
          if ( bullet->YPos >= bullet->targetY )
            v2 = bullet->YVel - 64;
          else
            v2 = bullet->YVel + 64;
          bullet->YVel = v2;
          break;
        case 1u:
        case 3u:
          if ( bullet->XPos >= bullet->targetX )
            v3 = bullet->XVel - 64;
          else
            v3 = bullet->XVel + 64;
          bullet->XVel = v3;
          break;
        default:
          break;
      }
    }
    if ( bullet->XVel < -5120 )
      bullet->XVel = -5120;
    if ( bullet->XVel > 5120 )
      bullet->XVel = 5120;
    if ( bullet->YVel < -5120 )
      bullet->YVel = -5120;
    if ( bullet->YVel > 5120 )
      bullet->YVel = 5120;
    bullet->XPos += bullet->XVel;
    bullet->YPos += bullet->YVel;
  }
  if ( ++bullet->count2 > 2 )
  {
    bullet->count2 = 0;
    switch ( bullet->direction )
    {
      case 0u:
        createEffect(bullet->XPos + 4096, bullet->YPos, effectDrownedQuote, right);
        break;
      case 1u:
        createEffect(bullet->XPos, bullet->YPos + 4096, effectDrownedQuote, down);
        break;
      case 2u:
        createEffect(bullet->XPos - 4096, bullet->YPos, effectDrownedQuote, 0);
        break;
      case 3u:
        createEffect(bullet->XPos, bullet->YPos - 4096, effectDrownedQuote, up);
        break;
      default:
        break;
    }
  }
  v28 = 120;
  v29 = 96;
  v30 = 136;
  v31 = 112;
  v32 = 136;
  v33 = 96;
  v34 = 152;
  v35 = 112;
  v36 = 152;
  v37 = 96;
  v38 = 168;
  v39 = 112;
  v40 = 168;
  v41 = 96;
  v42 = 184;
  v43 = 112;
  v12 = 184;
  v13 = 96;
  v14 = 200;
  v15 = 112;
  v16 = 200;
  v17 = 96;
  v18 = 216;
  v19 = 112;
  v20 = 216;
  v21 = 96;
  v22 = 232;
  v23 = 112;
  v24 = 232;
  v25 = 96;
  v26 = 248;
  v27 = 112;
  switch ( level )
  {
    case 1:
      v4 = &v28 + 4 * bullet->direction;
      v5 = &bullet->displayRect;
      v5->left = *v4;
      v5->top = v4[1];
      v5->right = v4[2];
      v5->bottom = v4[3];
      break;
    case 2:
      v6 = &v12 + 4 * bullet->direction;
      v7 = &bullet->displayRect;
      v7->left = *v6;
      v7->top = v6[1];
      v7->right = v6[2];
      v7->bottom = v6[3];
      break;
    case 3:
      v8 = &v28 + 4 * bullet->direction;
      v9 = &bullet->displayRect;
      v9->left = *v8;
      v9->top = v8[1];
      v9->right = v8[2];
      v9->bottom = v8[3];
      break;
  }
}
// 49BCA0: using guessed type int dword_49BCA0;

//----- (00408080) --------------------------------------------------------
Bullet *__cdecl bullet1F_20_21(Bullet *bullet, int level)
{
  Bullet *result; // eax
  int v3; // ST0C_4
  int v4; // ST08_4
  int v5; // eax
  int v6; // ST0C_4
  int v7; // ST08_4
  int v8; // eax
  int v9; // ST0C_4
  int v10; // ST08_4
  int v11; // eax
  int v12; // [esp+8h] [ebp-4h]

  result = bullet;
  v12 = bullet->currentState;
  if ( v12 )
  {
    if ( v12 != 1 )
      return result;
  }
  else
  {
    bullet->currentState = 1;
    switch ( level )
    {
      case 1:
        bullet->act_wait = 10;
        break;
      case 2:
        bullet->act_wait = 14;
        break;
      case 3:
        bullet->act_wait = 6;
        break;
    }
    playSoundEffect(SFXMissileImpact, 1);
  }
  if ( level == 1 )
  {
    if ( !(bullet->act_wait % 3) )
    {
      v3 = bullet->sizeWidth;
      v4 = bullet->YPos + (random(-16, 16) << 9);
      v5 = random(-16, 16);
      createDustCloudsUp(bullet->XPos + (v5 << 9), v4, v3, 2);
    }
  }
  else if ( level == 2 )
  {
    if ( !(bullet->act_wait % 3) )
    {
      v6 = bullet->sizeWidth;
      v7 = bullet->YPos + (random(-32, 32) << 9);
      v8 = random(-32, 32);
      createDustCloudsUp(bullet->XPos + (v8 << 9), v7, v6, 2);
    }
  }
  else if ( level == 3 && !(bullet->act_wait % 3) )
  {
    v9 = bullet->sizeWidth;
    v10 = bullet->YPos + (random(-40, 40) << 9);
    v11 = random(-40, 40);
    createDustCloudsUp(bullet->XPos + (v11 << 9), v10, v9, 2);
  }
  --bullet->act_wait;
  result = bullet;
  if ( bullet->act_wait < 0 )
    bullet->isAlive = 0;
  return result;
}

//----- (00408230) --------------------------------------------------------
void __cdecl bullet22_23_24_2B_Nemesis(Bullet *bullet, int level)
{
  int Child_Y_Vel; // eax MAPDST
  int Child_X_Vel; // eax MAPDST
  RECT *v6; // eax
  RECT *v7; // ecx
  RECT *v8; // eax
  RECT *v9; // ecx
  RECT *v10; // eax
  RECT *v11; // ecx
  RECT *v12; // eax
  RECT *v13; // ecx
  RECT Rects_Down[2]; // [esp+10h] [ebp-80h]
  RECT Rects_Left[2]; // [esp+30h] [ebp-60h]
  RECT Rects_Up[2]; // [esp+50h] [ebp-40h]
  RECT Rects_Right[2]; // [esp+70h] [ebp-20h]

  if ( ++bullet->count1 <= bullet->maxDistance )// compare bullet distance to max distance.
  {
    if ( bullet->currentState )                 // bullet was set up? 
    {
      if ( level == 1 && bullet->count1 % 4 == 1 )
      {
        switch ( bullet->direction )
        {
          case left:
            Child_Y_Vel = random(-512, 512);
            createNPC(NPCSmoke, bullet->XPos, bullet->YPos, -512, Child_Y_Vel, right, 0, 256);
            break;
          case up:
            Child_X_Vel = random(-512, 512);
            createNPC(NPCSmoke, bullet->XPos, bullet->YPos, Child_X_Vel, -512, right, 0, 256);
            break;
          case right:
            Child_Y_Vel = random(-512, 512);
            createNPC(NPCSmoke, bullet->XPos, bullet->YPos, 512, Child_Y_Vel, right, 0, 256);
            break;
          case down:
            Child_X_Vel = random(-512, 512);
            createNPC(NPCSmoke, bullet->XPos, bullet->YPos, Child_X_Vel, 512, right, 0, 256);
            break;
          default:
            break;
        }
      }
      bullet->XPos += bullet->XVel;
      bullet->YPos += bullet->YVel;
    }
    else
    {
      // -----------------------------
      // -----===Create bullet===-----
      // -----------------------------
      bullet->currentState = 1;                 // Bullet set up = true (doesn't actually create bullet)
      bullet->count1 = 0;                       // Bullet distance = 0
      // ------=Set Velocities=------
      switch ( bullet->direction )
      {
        case 0u:
          bullet->XVel = -4096;
          break;
        case 1u:
          bullet->YVel = -4096;
          break;
        case 2u:
          bullet->XVel = 4096;
          break;
        case 3u:
          bullet->YVel = 4096;
          break;
        default:
          break;
      }
      if ( level == 3 )
      {
        bullet->XVel /= 3;
        bullet->YVel /= 3;
      }
    }
    if ( ++bullet->animationNum > 1 )
      bullet->animationNum = 0;
    Rects_Left[0].left = 0;                     // left yellow bullet
    Rects_Left[0].top = 0x70;
    Rects_Left[0].right = 0x20;
    Rects_Left[0].bottom = 0x80;
    Rects_Left[1].left = 0;                     // left blue bullet
    Rects_Left[1].top = 0x80;
    Rects_Left[1].right = 0x20;
    Rects_Left[1].bottom = 0x90;
    Rects_Up[0].left = 0x20;                    // up yellow bullet
    Rects_Up[0].top = 0x70;
    Rects_Up[0].right = 0x30;
    Rects_Up[0].bottom = 0x90;
    Rects_Up[1].left = 0x30;                    // up blue bullet
    Rects_Up[1].top = 0x70;
    Rects_Up[1].right = 0x40;
    Rects_Up[1].bottom = 0x90;
    Rects_Right[0].left = 0x40;                 // right yellow bullet
    Rects_Right[0].top = 0x70;
    Rects_Right[0].right = 0x60;
    Rects_Right[0].bottom = 0x80;
    Rects_Right[1].left = 0x40;                 // right Blue bullet
    Rects_Right[1].top = 0x80;
    Rects_Right[1].right = 0x60;
    Rects_Right[1].bottom = 0x90;
    Rects_Down[0].left = 0x60;                  // down yellow bullet
    Rects_Down[0].top = 0x70;
    Rects_Down[0].right = 0x70;
    Rects_Down[0].bottom = 0x90;
    Rects_Down[1].left = 0x70;                  // Down blue bullet
    Rects_Down[1].top = 0x70;
    Rects_Down[1].right = 0x80;
    Rects_Down[1].bottom = 0x90;
    switch ( bullet->direction )
    {
      case left:
        v6 = &Rects_Left[bullet->animationNum];
        v7 = &bullet->displayRect;
        v7->left = v6->left;
        v7->top = v6->top;
        v7->right = v6->right;
        v7->bottom = v6->bottom;
        break;
      case up:
        v8 = &Rects_Up[bullet->animationNum];
        v9 = &bullet->displayRect;
        v9->left = v8->left;
        v9->top = v8->top;
        v9->right = v8->right;
        v9->bottom = v8->bottom;
        break;
      case right:
        v10 = &Rects_Right[bullet->animationNum];
        v11 = &bullet->displayRect;
        v11->left = v10->left;
        v11->top = v10->top;
        v11->right = v10->right;
        v11->bottom = v10->bottom;
        break;
      case down:
        v12 = &Rects_Down[bullet->animationNum];
        v13 = &bullet->displayRect;
        v13->left = v12->left;
        v13->top = v12->top;
        v13->right = v12->right;
        v13->bottom = v12->bottom;
        break;
      default:
        break;
    }
    // Relatives rects according to weapon level
    bullet->displayRect.top += 32 * ((level - 1) / 2);
    bullet->displayRect.bottom += 32 * ((level - 1) / 2);
    bullet->displayRect.left += (level - 1) % 2 << 7;
    bullet->displayRect.right += (level - 1) % 2 << 7;
  }
  else
  {
    bullet->isAlive = 0;                        // bullet in use = 0 = kills
    createEffect(bullet->XPos, bullet->YPos, effectStar, 0);
  }
}

//----- (00408710) --------------------------------------------------------
void __cdecl bullet25_26_27_ChargelessSpur(Bullet *bullet, int level)
{
  RECT *v2; // eax
  RECT *v3; // eax
  RECT *v4; // ecx
  RECT *v5; // ecx
  RECT *v6; // edx
  RECT *v7; // edx

  if ( ++bullet->count1 <= bullet->maxDistance )
  {
    if ( bullet->damage && bullet->numberImpacts != 100 )
      bullet->damage = 0;
    if ( bullet->currentState )
    {
      bullet->XPos += bullet->XVel;
      bullet->YPos += bullet->YVel;
    }
    else
    {
      bullet->currentState = 1;
      switch ( bullet->direction )
      {
        case 0u:
          bullet->XVel = -4096;
          break;
        case 1u:
          bullet->YVel = -4096;
          break;
        case 2u:
          bullet->XVel = 4096;
          break;
        case 3u:
          bullet->YVel = 4096;
          break;
        default:
          break;
      }
      if ( level == 1 )
      {
        switch ( bullet->direction )
        {
          case 0u:
            bullet->sizeHeight = 1024;
            break;
          case 1u:
            bullet->sizeWidth = 1024;
            break;
          case 2u:
            bullet->sizeHeight = 1024;
            break;
          case 3u:
            bullet->sizeWidth = 1024;
            break;
          default:
            break;
        }
      }
      else if ( level == 2 )
      {
        switch ( bullet->direction )
        {
          case 0u:
            bullet->sizeHeight = 2048;
            break;
          case 1u:
            bullet->sizeWidth = 2048;
            break;
          case 2u:
            bullet->sizeHeight = 2048;
            break;
          case 3u:
            bullet->sizeWidth = 2048;
            break;
          default:
            break;
        }
      }
    }
    bullet->damage = bullet->numberImpacts;
    switch ( level )
    {
      case 1:
        if ( bullet->direction != 1 && bullet->direction != 3 )
        {
          v3 = &bullet->displayRect;
          v3->left = 128;
          v3->top = 32;
          v3->right = 144;
          v3->bottom = 48;
        }
        else
        {
          v2 = &bullet->displayRect;
          v2->left = 144;
          v2->top = 32;
          v2->right = 160;
          v2->bottom = 48;
        }
        break;
      case 2:
        if ( bullet->direction != 1 && bullet->direction != 3 )
        {
          v5 = &bullet->displayRect;
          v5->left = 160;
          v5->top = 32;
          v5->right = 176;
          v5->bottom = 48;
        }
        else
        {
          v4 = &bullet->displayRect;
          v4->left = 176;
          v4->top = 32;
          v4->right = 192;
          v4->bottom = 48;
        }
        break;
      case 3:
        if ( bullet->direction != 1 && bullet->direction != 3 )
        {
          v7 = &bullet->displayRect;
          v7->left = 128;
          v7->top = 48;
          v7->right = 144;
          v7->bottom = 64;
        }
        else
        {
          v6 = &bullet->displayRect;
          v6->left = 144;
          v6->top = 48;
          v6->right = 160;
          v6->bottom = 64;
        }
        break;
    }
    createBullet(
      (bullets)(level + bulletChargelessSpurLevel3),
      bullet->XPos,
      bullet->YPos,
      (Directions)bullet->direction);
  }
  else
  {
    bullet->isAlive = 0;
    createEffect(bullet->XPos, bullet->YPos, effectStar, 0);
  }
}

//----- (00408AE0) --------------------------------------------------------
void __cdecl bullet28_29_2A_NonMovingSpur(Bullet *bullet, int level)
{
  int *v2; // ecx
  RECT *v3; // edx
  int *v4; // ecx
  RECT *v5; // edx
  int *v6; // edx
  RECT *v7; // eax
  int *v8; // edx
  RECT *v9; // eax
  int *v10; // eax
  RECT *v11; // ecx
  int *v12; // eax
  RECT *v13; // ecx
  int v14; // [esp+4h] [ebp-120h]
  int v15; // [esp+8h] [ebp-11Ch]
  int v16; // [esp+Ch] [ebp-118h]
  int v17; // [esp+10h] [ebp-114h]
  int v18; // [esp+14h] [ebp-110h]
  int v19; // [esp+18h] [ebp-10Ch]
  int v20; // [esp+1Ch] [ebp-108h]
  int v21; // [esp+20h] [ebp-104h]
  int v22; // [esp+24h] [ebp-100h]
  int v23; // [esp+28h] [ebp-FCh]
  int v24; // [esp+2Ch] [ebp-F8h]
  int v25; // [esp+30h] [ebp-F4h]
  int v26; // [esp+34h] [ebp-F0h]
  int v27; // [esp+38h] [ebp-ECh]
  int v28; // [esp+3Ch] [ebp-E8h]
  int v29; // [esp+40h] [ebp-E4h]
  int v30; // [esp+44h] [ebp-E0h]
  int v31; // [esp+48h] [ebp-DCh]
  int v32; // [esp+4Ch] [ebp-D8h]
  int v33; // [esp+50h] [ebp-D4h]
  int v34; // [esp+54h] [ebp-D0h]
  int v35; // [esp+58h] [ebp-CCh]
  int v36; // [esp+5Ch] [ebp-C8h]
  int v37; // [esp+60h] [ebp-C4h]
  int v38; // [esp+64h] [ebp-C0h]
  int v39; // [esp+68h] [ebp-BCh]
  int v40; // [esp+6Ch] [ebp-B8h]
  int v41; // [esp+70h] [ebp-B4h]
  int v42; // [esp+74h] [ebp-B0h]
  int v43; // [esp+78h] [ebp-ACh]
  int v44; // [esp+7Ch] [ebp-A8h]
  int v45; // [esp+80h] [ebp-A4h]
  int v46; // [esp+84h] [ebp-A0h]
  int v47; // [esp+88h] [ebp-9Ch]
  int v48; // [esp+8Ch] [ebp-98h]
  int v49; // [esp+90h] [ebp-94h]
  int v50; // [esp+94h] [ebp-90h]
  int v51; // [esp+98h] [ebp-8Ch]
  int v52; // [esp+9Ch] [ebp-88h]
  int v53; // [esp+A0h] [ebp-84h]
  int v54; // [esp+A4h] [ebp-80h]
  int v55; // [esp+A8h] [ebp-7Ch]
  int v56; // [esp+ACh] [ebp-78h]
  int v57; // [esp+B0h] [ebp-74h]
  int v58; // [esp+B4h] [ebp-70h]
  int v59; // [esp+B8h] [ebp-6Ch]
  int v60; // [esp+BCh] [ebp-68h]
  int v61; // [esp+C0h] [ebp-64h]
  int v62; // [esp+C4h] [ebp-60h]
  int v63; // [esp+C8h] [ebp-5Ch]
  int v64; // [esp+CCh] [ebp-58h]
  int v65; // [esp+D0h] [ebp-54h]
  int v66; // [esp+D4h] [ebp-50h]
  int v67; // [esp+D8h] [ebp-4Ch]
  int v68; // [esp+DCh] [ebp-48h]
  int v69; // [esp+E0h] [ebp-44h]
  int v70; // [esp+E4h] [ebp-40h]
  int v71; // [esp+E8h] [ebp-3Ch]
  int v72; // [esp+ECh] [ebp-38h]
  int v73; // [esp+F0h] [ebp-34h]
  int v74; // [esp+F4h] [ebp-30h]
  int v75; // [esp+F8h] [ebp-2Ch]
  int v76; // [esp+FCh] [ebp-28h]
  int v77; // [esp+100h] [ebp-24h]
  int v78; // [esp+104h] [ebp-20h]
  int v79; // [esp+108h] [ebp-1Ch]
  int v80; // [esp+10Ch] [ebp-18h]
  int v81; // [esp+110h] [ebp-14h]
  int v82; // [esp+114h] [ebp-10h]
  int v83; // [esp+118h] [ebp-Ch]
  int v84; // [esp+11Ch] [ebp-8h]
  int v85; // [esp+120h] [ebp-4h]

  if ( ++bullet->count1 > 20 )
    bullet->animationNum = bullet->count1 - 20;
  if ( bullet->animationNum > 2 )
    bullet->isAlive = 0;
  if ( bullet->damage && bullet->numberImpacts != 100 )
    bullet->damage = 0;
  v62 = 192;
  v63 = 32;
  v64 = 200;
  v65 = 40;
  v66 = 200;
  v67 = 32;
  v68 = 208;
  v69 = 40;
  v70 = 208;
  v71 = 32;
  v72 = 216;
  v73 = 40;
  v74 = 192;
  v75 = 40;
  v76 = 200;
  v77 = 48;
  v78 = 200;
  v79 = 40;
  v80 = 208;
  v81 = 48;
  v82 = 208;
  v83 = 40;
  v84 = 216;
  v85 = 48;
  v38 = 216;
  v39 = 32;
  v40 = 224;
  v41 = 40;
  v42 = 224;
  v43 = 32;
  v44 = 232;
  v45 = 40;
  v46 = 232;
  v47 = 32;
  v48 = 240;
  v49 = 40;
  v50 = 216;
  v51 = 40;
  v52 = 224;
  v53 = 48;
  v54 = 224;
  v55 = 40;
  v56 = 232;
  v57 = 48;
  v58 = 232;
  v59 = 40;
  v60 = 240;
  v61 = 48;
  v14 = 240;
  v15 = 32;
  v16 = 248;
  v17 = 40;
  v18 = 248;
  v19 = 32;
  v20 = 256;
  v21 = 40;
  v22 = 256;
  v23 = 32;
  v24 = 264;
  v25 = 40;
  v26 = 240;
  v27 = 32;
  v28 = 248;
  v29 = 40;
  v30 = 248;
  v31 = 32;
  v32 = 256;
  v33 = 40;
  v34 = 256;
  v35 = 32;
  v36 = 264;
  v37 = 40;
  switch ( level )
  {
    case 1:
      if ( bullet->direction && bullet->direction != 2 )
      {
        v4 = &v74 + 4 * bullet->animationNum;
        v5 = &bullet->displayRect;
        v5->left = *v4;
        v5->top = v4[1];
        v5->right = v4[2];
        v5->bottom = v4[3];
      }
      else
      {
        v2 = &v62 + 4 * bullet->animationNum;
        v3 = &bullet->displayRect;
        v3->left = *v2;
        v3->top = v2[1];
        v3->right = v2[2];
        v3->bottom = v2[3];
      }
      break;
    case 2:
      if ( bullet->direction && bullet->direction != 2 )
      {
        v8 = &v50 + 4 * bullet->animationNum;
        v9 = &bullet->displayRect;
        v9->left = *v8;
        v9->top = v8[1];
        v9->right = v8[2];
        v9->bottom = v8[3];
      }
      else
      {
        v6 = &v38 + 4 * bullet->animationNum;
        v7 = &bullet->displayRect;
        v7->left = *v6;
        v7->top = v6[1];
        v7->right = v6[2];
        v7->bottom = v6[3];
      }
      break;
    case 3:
      if ( bullet->direction && bullet->direction != 2 )
      {
        v12 = &v26 + 4 * bullet->animationNum;
        v13 = &bullet->displayRect;
        v13->left = *v12;
        v13->top = v12[1];
        v13->right = v12[2];
        v13->bottom = v12[3];
      }
      else
      {
        v10 = &v14 + 4 * bullet->animationNum;
        v11 = &bullet->displayRect;
        v11->left = *v10;
        v11->top = v10[1];
        v11->right = v10[2];
        v11->bottom = v10[3];
      }
      break;
  }
}

//----- (00408F40) --------------------------------------------------------
void __cdecl bullet2C_SpurLevel2(Bullet *bullet)
{
  if ( ++bullet->count1 <= bullet->maxDistance )
  {
    bullet->damage = 10000;
    bullet->sizeWidth = 819200;
    bullet->sizeHeight = 819200;
  }
  else
  {
    bullet->isAlive = 0;
  }
}

//----- (00408F90) --------------------------------------------------------
void __cdecl bullet2D_SpurLevel3(Bullet *bullet)
{
  if ( ++bullet->count1 > bullet->maxDistance )
    bullet->isAlive = 0;
}

//----- (00408FC0) --------------------------------------------------------
void __cdecl runBulletCode()
{
  signed int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i < 64; ++i )
  {
    if ( bulletObjects[i].isAlive & 0x80 )
    {
      if ( bulletObjects[i].numberImpacts >= 1 )
      {
        switch ( bulletObjects[i].bulletID )
        {
          case 1:
            bullet1_Level1Snake(&bulletObjects[i]);
            break;
          case 2:
            bullet2_3_SnakeLevel2_3(&bulletObjects[i], 2);
            break;
          case 3:
            bullet2_3_SnakeLevel2_3(&bulletObjects[i], 3);
            break;
          case 4:
            bullet4_5_6_PolarStar(&bulletObjects[i], 1);
            break;
          case 5:
            bullet4_5_6_PolarStar(&bulletObjects[i], 2);
            break;
          case 6:
            bullet4_5_6_PolarStar(&bulletObjects[i], 3);
            break;
          case 7:
            bullet7_8_9_Fireball(&bulletObjects[i], 1);
            break;
          case 8:
            bullet7_8_9_Fireball(&bulletObjects[i], 2);
            break;
          case 9:
            bullet7_8_9_Fireball(&bulletObjects[i], 3);
            break;
          case 0xA:
            bulletA_B_C_MachineGun(&bulletObjects[i], 1);
            break;
          case 0xB:
            bulletA_B_C_MachineGun(&bulletObjects[i], 2);
            break;
          case 0xC:
            bulletA_B_C_MachineGun(&bulletObjects[i], 3);
            break;
          case 0xD:
            bulletD_E_F_MissileLauncher(&bulletObjects[i], 1);
            break;
          case 0xE:
            bulletD_E_F_MissileLauncher(&bulletObjects[i], 2);
            break;
          case 0xF:
            bulletD_E_F_MissileLauncher(&bulletObjects[i], 3);
            break;
          case 0x10:
            bullet10_11_12_MissileExplosion(&bulletObjects[i], 1);
            break;
          case 0x11:
            bullet10_11_12_MissileExplosion(&bulletObjects[i], 2);
            break;
          case 0x12:
            bullet10_11_12_MissileExplosion(&bulletObjects[i], 3);
            break;
          case 0x13:
            bullet13_BubblerLevel1(&bulletObjects[i]);
            break;
          case 0x14:
            bullet14_BubllerLevel2(&bulletObjects[i]);
            break;
          case 0x15:
            bullet15_BubblerLevel3(&bulletObjects[i]);
            break;
          case 0x16:
            bullet16_BubblerSpurs(&bulletObjects[i]);
            break;
          case 0x17:
            bullet17_BladeSlash(&bulletObjects[i]);
            break;
          case 0x18:
            bullet18_Unused(&bulletObjects[i]);
            break;
          case 0x19:
            bullet19_BladeLevel1(&bulletObjects[i]);
            break;
          case 0x1A:
            bullet1A_BladeLevel2(&bulletObjects[i]);
            break;
          case 0x1B:
            bullet1B_BladeLevel3(&bulletObjects[i]);
            break;
          case 0x1C:
            bullet1C_1D_1E_SuperMissileLauncher(&bulletObjects[i], 1);
            break;
          case 0x1D:
            bullet1C_1D_1E_SuperMissileLauncher(&bulletObjects[i], 2);
            break;
          case 0x1E:
            bullet1C_1D_1E_SuperMissileLauncher(&bulletObjects[i], 3);
            break;
          case 0x1F:
            bullet1F_20_21(&bulletObjects[i], 1);
            break;
          case 0x20:
            bullet1F_20_21(&bulletObjects[i], 2);
            break;
          case 0x21:
            bullet1F_20_21(&bulletObjects[i], 3);
            break;
          case 0x22:
            bullet22_23_24_2B_Nemesis(&bulletObjects[i], 1);
            break;
          case 0x23:
            bullet22_23_24_2B_Nemesis(&bulletObjects[i], 2);
            break;
          case 0x24:
            bullet22_23_24_2B_Nemesis(&bulletObjects[i], 3);
            break;
          case 0x25:
            bullet25_26_27_ChargelessSpur(&bulletObjects[i], 1);
            break;
          case 0x26:
            bullet25_26_27_ChargelessSpur(&bulletObjects[i], 2);
            break;
          case 0x27:
            bullet25_26_27_ChargelessSpur(&bulletObjects[i], 3);
            break;
          case 0x28:
            bullet28_29_2A_NonMovingSpur(&bulletObjects[i], 1);
            break;
          case 0x29:
            bullet28_29_2A_NonMovingSpur(&bulletObjects[i], 2);
            break;
          case 0x2A:
            bullet28_29_2A_NonMovingSpur(&bulletObjects[i], 3);
            break;
          case 0x2B:
            bullet22_23_24_2B_Nemesis(&bulletObjects[i], 1);
            break;
          case 0x2C:
            bullet2C_SpurLevel2(&bulletObjects[i]);
            break;
          case 0x2D:
            bullet2D_SpurLevel3(&bulletObjects[i]);
            break;
          default:
            continue;
        }
      }
      else
      {
        bulletObjects[i].isAlive = 0;
      }
    }
  }
}

//----- (004095C0) --------------------------------------------------------
signed int isSomeBulletActive()
{
  signed int result; // eax
  signed int i; // [esp+4h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    if ( i >= 64 )
      return 0;
    if ( bulletObjects[i].isAlive & 0x80 )
      break;
For_Loop_Restart:
    ;
  }
  switch ( bulletObjects[i].bulletID )
  {
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x17:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
    case 0x21:
      result = 1;
      break;
    default:
      goto For_Loop_Restart;
  }
  return result;
}

//----- (00409650) --------------------------------------------------------
void __cdecl initEffects()
{
  memset(effectObjects, 0, 0x1100u);
}

//----- (00409680) --------------------------------------------------------
// mode 0: blue discs, mode 1: red discs
void __cdecl effect1_RandomFountainPulsingDiscParticles(Effect *effect)
{
  RECT *v1; // edx MAPDST
  RECT Red_Disk_Rects[4]; // [esp+0h] [ebp-80h]
  RECT Blue_Disk_Rects[4]; // [esp+40h] [ebp-40h]

  Blue_Disk_Rects[0].left = 0;
  Blue_Disk_Rects[0].top = 64;
  Blue_Disk_Rects[0].right = 8;
  Blue_Disk_Rects[0].bottom = 72;
  Blue_Disk_Rects[1].left = 8;
  Blue_Disk_Rects[1].top = 64;
  Blue_Disk_Rects[1].right = 16;
  Blue_Disk_Rects[1].bottom = 72;
  Blue_Disk_Rects[2].left = 16;
  Blue_Disk_Rects[2].top = 64;
  Blue_Disk_Rects[2].right = 24;
  Blue_Disk_Rects[2].bottom = 72;
  Blue_Disk_Rects[3].left = 24;
  Blue_Disk_Rects[3].top = 64;
  Blue_Disk_Rects[3].right = 32;
  Blue_Disk_Rects[3].bottom = 72;
  Red_Disk_Rects[0].left = 64;
  Red_Disk_Rects[0].top = 24;
  Red_Disk_Rects[0].right = 72;
  Red_Disk_Rects[0].bottom = 32;
  Red_Disk_Rects[1].left = 72;
  Red_Disk_Rects[1].top = 24;
  Red_Disk_Rects[1].right = 80;
  Red_Disk_Rects[1].bottom = 32;
  Red_Disk_Rects[2].left = 80;
  Red_Disk_Rects[2].top = 24;
  Red_Disk_Rects[2].right = 88;
  Red_Disk_Rects[2].bottom = 32;
  Red_Disk_Rects[3].left = 88;
  Red_Disk_Rects[3].top = 24;
  Red_Disk_Rects[3].right = 96;
  Red_Disk_Rects[3].bottom = 32;
  if ( !effect->actionNumber )                  // If disk not init
  {
    effect->actionNumber = 1;                   // Mark disk as initiated
    effect->XVel = random(-1024, 1024);
    effect->YVel = random(-1024, 0);
  }
  effect->YVel += 64;
  effect->XPos += effect->XVel;
  effect->YPos += effect->YVel;
  if ( ++effect->animationTimer > 5 )
  {
    effect->animationTimer = 0;
    if ( ++effect->animationNumber > 3 )
      effect->isUsed = 0;
  }
  if ( effect->direction )
    v1 = &Red_Disk_Rects[effect->animationNumber];
  else
    v1 = &Blue_Disk_Rects[effect->animationNumber];
  v1 = &effect->rect;
  v1->left = v1->left;
  v1->top = v1->top;
  v1->right = v1->right;
  v1->bottom = v1->bottom;
}

//----- (00409880) --------------------------------------------------------
// mode 0: green disc, mode 1: diamond explosion
void __cdecl effect2_RisingDiscAndExplodingDiamond(Effect *Effect_Vars)
{
  int *v1; // eax
  RECT *v2; // ecx
  int *v3; // ecx
  RECT *v4; // edx
  int *v5; // edx
  RECT *v6; // eax
  Directions v7; // [esp+0h] [ebp-B4h]
  int v8; // [esp+4h] [ebp-B0h]
  int v9; // [esp+8h] [ebp-ACh]
  int v10; // [esp+Ch] [ebp-A8h]
  int v11; // [esp+10h] [ebp-A4h]
  int v12; // [esp+14h] [ebp-A0h]
  int v13; // [esp+18h] [ebp-9Ch]
  int v14; // [esp+1Ch] [ebp-98h]
  int v15; // [esp+20h] [ebp-94h]
  int v16; // [esp+24h] [ebp-90h]
  int v17; // [esp+28h] [ebp-8Ch]
  int v18; // [esp+2Ch] [ebp-88h]
  int v19; // [esp+30h] [ebp-84h]
  int v20; // [esp+34h] [ebp-80h]
  int v21; // [esp+38h] [ebp-7Ch]
  int v22; // [esp+3Ch] [ebp-78h]
  int v23; // [esp+40h] [ebp-74h]
  int v24; // [esp+44h] [ebp-70h]
  int v25; // [esp+48h] [ebp-6Ch]
  int v26; // [esp+4Ch] [ebp-68h]
  int v27; // [esp+50h] [ebp-64h]
  int v28; // [esp+54h] [ebp-60h]
  int v29; // [esp+58h] [ebp-5Ch]
  int v30; // [esp+5Ch] [ebp-58h]
  int v31; // [esp+60h] [ebp-54h]
  int v32; // [esp+64h] [ebp-50h]
  int v33; // [esp+68h] [ebp-4Ch]
  int v34; // [esp+6Ch] [ebp-48h]
  int v35; // [esp+70h] [ebp-44h]
  int v36; // [esp+74h] [ebp-40h]
  int v37; // [esp+78h] [ebp-3Ch]
  int v38; // [esp+7Ch] [ebp-38h]
  int v39; // [esp+80h] [ebp-34h]
  int v40; // [esp+84h] [ebp-30h]
  int v41; // [esp+88h] [ebp-2Ch]
  int v42; // [esp+8Ch] [ebp-28h]
  int v43; // [esp+90h] [ebp-24h]
  int v44; // [esp+94h] [ebp-20h]
  int v45; // [esp+98h] [ebp-1Ch]
  int v46; // [esp+9Ch] [ebp-18h]
  int v47; // [esp+A0h] [ebp-14h]
  int v48; // [esp+A4h] [ebp-10h]
  int v49; // [esp+A8h] [ebp-Ch]
  int v50; // [esp+ACh] [ebp-8h]
  int v51; // [esp+B0h] [ebp-4h]

  v36 = 0;
  v37 = 32;
  v38 = 16;
  v39 = 48;
  v40 = 16;
  v41 = 32;
  v42 = 32;
  v43 = 48;
  v44 = 32;
  v45 = 32;
  v46 = 48;
  v47 = 48;
  v48 = 48;
  v49 = 32;
  v50 = 64;
  v51 = 48;
  v20 = 176;
  v21 = 0;
  v22 = 192;
  v23 = 16;
  v24 = 192;
  v25 = 0;
  v26 = 208;
  v27 = 16;
  v28 = 208;
  v29 = 0;
  v30 = 224;
  v31 = 16;
  v32 = 224;
  v33 = 0;
  v34 = 240;
  v35 = 16;
  v8 = 0;
  v9 = 32;
  v10 = 16;
  v11 = 48;
  v12 = 32;
  v13 = 32;
  v14 = 48;
  v15 = 48;
  v16 = 16;
  v17 = 32;
  v18 = 32;
  v19 = 48;
  v7 = Effect_Vars->direction;
  if ( v7 )
  {
    if ( v7 == 1 )
    {
      v5 = &v8 + 4 * (++Effect_Vars->animationTimer / 2 % 3);
      v6 = &Effect_Vars->rect;
      v6->left = *v5;
      v6->top = v5[1];
      v6->right = v5[2];
      v6->bottom = v5[3];
      if ( Effect_Vars->animationTimer > 24 )
        Effect_Vars->isUsed = 0;
    }
    else if ( v7 == 2 )
    {
      if ( ++Effect_Vars->animationTimer > 2 )
      {
        Effect_Vars->animationTimer = 0;
        ++Effect_Vars->animationNumber;
      }
      if ( Effect_Vars->animationNumber > 3 )
        Effect_Vars->isUsed = 0;
      v3 = &v20 + 4 * Effect_Vars->animationNumber;
      v4 = &Effect_Vars->rect;
      v4->left = *v3;
      v4->top = v3[1];
      v4->right = v3[2];
      v4->bottom = v3[3];
    }
  }
  else
  {
    Effect_Vars->YVel -= 16;
    Effect_Vars->YPos += Effect_Vars->YVel;
    if ( ++Effect_Vars->animationTimer > 5 )
    {
      Effect_Vars->animationTimer = 0;
      ++Effect_Vars->animationNumber;
    }
    if ( Effect_Vars->animationNumber > 3 )
      Effect_Vars->isUsed = 0;
    v1 = &v36 + 4 * Effect_Vars->animationNumber;
    v2 = &Effect_Vars->rect;
    v2->left = *v1;
    v2->top = v1[1];
    v2->right = v1[2];
    v2->bottom = v1[3];
  }
}

//----- (00409B80) --------------------------------------------------------
// Mode 0 only
void __cdecl effect3_Star(Effect *effect)
{
  int *v1; // eax
  RECT *v2; // ecx
  int v3; // [esp+0h] [ebp-40h]
  int v4; // [esp+4h] [ebp-3Ch]
  int v5; // [esp+8h] [ebp-38h]
  int v6; // [esp+Ch] [ebp-34h]
  int v7; // [esp+10h] [ebp-30h]
  int v8; // [esp+14h] [ebp-2Ch]
  int v9; // [esp+18h] [ebp-28h]
  int v10; // [esp+1Ch] [ebp-24h]
  int v11; // [esp+20h] [ebp-20h]
  int v12; // [esp+24h] [ebp-1Ch]
  int v13; // [esp+28h] [ebp-18h]
  int v14; // [esp+2Ch] [ebp-14h]
  int v15; // [esp+30h] [ebp-10h]
  int v16; // [esp+34h] [ebp-Ch]
  int v17; // [esp+38h] [ebp-8h]
  int v18; // [esp+3Ch] [ebp-4h]

  v3 = 0;
  v4 = 48;
  v5 = 16;
  v6 = 64;
  v7 = 16;
  v8 = 48;
  v9 = 32;
  v10 = 64;
  v11 = 32;
  v12 = 48;
  v13 = 48;
  v14 = 64;
  v15 = 48;
  v16 = 48;
  v17 = 64;
  v18 = 64;
  if ( ++effect->animationTimer > 2 )
  {
    effect->animationTimer = 0;
    if ( ++effect->animationNumber > 3 )
      effect->isUsed = 0;
  }
  v1 = &v3 + 4 * effect->animationNumber;
  v2 = &effect->rect;
  v2->left = *v1;
  v2->top = v1[1];
  v2->right = v1[2];
  v2->bottom = v1[3];
}

//----- (00409C70) --------------------------------------------------------
// mode 0 only
void __cdecl effect4_FireballImpact(Effect *effect)
{
  int *v1; // ecx
  RECT *v2; // edx
  int v3; // [esp+0h] [ebp-90h]
  int v4; // [esp+4h] [ebp-8Ch]
  int v5; // [esp+8h] [ebp-88h]
  int v6; // [esp+Ch] [ebp-84h]
  int v7; // [esp+10h] [ebp-80h]
  int v8; // [esp+14h] [ebp-7Ch]
  int v9; // [esp+18h] [ebp-78h]
  int v10; // [esp+1Ch] [ebp-74h]
  int v11; // [esp+20h] [ebp-70h]
  int v12; // [esp+24h] [ebp-6Ch]
  int v13; // [esp+28h] [ebp-68h]
  int v14; // [esp+2Ch] [ebp-64h]
  int v15; // [esp+30h] [ebp-60h]
  int v16; // [esp+34h] [ebp-5Ch]
  int v17; // [esp+38h] [ebp-58h]
  int v18; // [esp+3Ch] [ebp-54h]
  int v19; // [esp+40h] [ebp-50h]
  int v20; // [esp+44h] [ebp-4Ch]
  int v21; // [esp+48h] [ebp-48h]
  int v22; // [esp+4Ch] [ebp-44h]
  int v23; // [esp+50h] [ebp-40h]
  int v24; // [esp+54h] [ebp-3Ch]
  int v25; // [esp+58h] [ebp-38h]
  int v26; // [esp+5Ch] [ebp-34h]
  int v27; // [esp+60h] [ebp-30h]
  int v28; // [esp+64h] [ebp-2Ch]
  int v29; // [esp+68h] [ebp-28h]
  int v30; // [esp+6Ch] [ebp-24h]
  int v31; // [esp+70h] [ebp-20h]
  int v32; // [esp+74h] [ebp-1Ch]
  int v33; // [esp+78h] [ebp-18h]
  int v34; // [esp+7Ch] [ebp-14h]
  int v35; // [esp+80h] [ebp-10h]
  int v36; // [esp+84h] [ebp-Ch]
  int v37; // [esp+88h] [ebp-8h]
  int v38; // [esp+8Ch] [ebp-4h]

  v3 = 64;
  v4 = 32;
  v5 = 80;
  v6 = 48;
  v7 = 80;
  v8 = 32;
  v9 = 96;
  v10 = 48;
  v11 = 96;
  v12 = 32;
  v13 = 112;
  v14 = 48;
  v15 = 64;
  v16 = 48;
  v17 = 80;
  v18 = 64;
  v19 = 80;
  v20 = 48;
  v21 = 96;
  v22 = 64;
  v23 = 96;
  v24 = 48;
  v25 = 112;
  v26 = 64;
  v27 = 64;
  v28 = 64;
  v29 = 80;
  v30 = 80;
  v31 = 80;
  v32 = 64;
  v33 = 96;
  v34 = 80;
  v35 = 96;
  v36 = 64;
  v37 = 112;
  v38 = 80;
  if ( ++effect->animationTimer > 1 )
  {
    effect->animationTimer = 0;
    if ( ++effect->animationNumber > 2 )
      effect->isUsed = 0;
  }
  v1 = &v3 + 4 * (effect->animationNumber + 3 * effect->direction);
  v2 = &effect->rect;
  v2->left = *v1;
  v2->top = v1[1];
  v2->right = v1[2];
  v2->bottom = v1[3];
}

//----- (00409E00) --------------------------------------------------------
// mode 0 only
void __cdecl effect5_ZzZ(Effect *effect)
{
  int *v1; // eax
  RECT *v2; // ecx
  int v3; // [esp+0h] [ebp-70h]
  int v4; // [esp+4h] [ebp-6Ch]
  int v5; // [esp+8h] [ebp-68h]
  int v6; // [esp+Ch] [ebp-64h]
  int v7; // [esp+10h] [ebp-60h]
  int v8; // [esp+14h] [ebp-5Ch]
  int v9; // [esp+18h] [ebp-58h]
  int v10; // [esp+1Ch] [ebp-54h]
  int v11; // [esp+20h] [ebp-50h]
  int v12; // [esp+24h] [ebp-4Ch]
  int v13; // [esp+28h] [ebp-48h]
  int v14; // [esp+2Ch] [ebp-44h]
  int v15; // [esp+30h] [ebp-40h]
  int v16; // [esp+34h] [ebp-3Ch]
  int v17; // [esp+38h] [ebp-38h]
  int v18; // [esp+3Ch] [ebp-34h]
  int v19; // [esp+40h] [ebp-30h]
  int v20; // [esp+44h] [ebp-2Ch]
  int v21; // [esp+48h] [ebp-28h]
  int v22; // [esp+4Ch] [ebp-24h]
  int v23; // [esp+50h] [ebp-20h]
  int v24; // [esp+54h] [ebp-1Ch]
  int v25; // [esp+58h] [ebp-18h]
  int v26; // [esp+5Ch] [ebp-14h]
  int v27; // [esp+60h] [ebp-10h]
  int v28; // [esp+64h] [ebp-Ch]
  int v29; // [esp+68h] [ebp-8h]
  int v30; // [esp+6Ch] [ebp-4h]

  v3 = 32;
  v4 = 64;
  v5 = 40;
  v6 = 72;
  v7 = 32;
  v8 = 72;
  v9 = 40;
  v10 = 80;
  v11 = 40;
  v12 = 64;
  v13 = 48;
  v14 = 72;
  v15 = 40;
  v16 = 72;
  v17 = 48;
  v18 = 80;
  v19 = 40;
  v20 = 64;
  v21 = 48;
  v22 = 72;
  v23 = 40;
  v24 = 72;
  v25 = 48;
  v26 = 80;
  v27 = 40;
  v28 = 64;
  v29 = 48;
  v30 = 72;
  if ( ++effect->animationTimer > 4 )
  {
    effect->animationTimer = 0;
    ++effect->animationNumber;
  }
  if ( effect->animationNumber > 6 )
    effect->isUsed = 0;
  effect->XPos += 128;
  effect->YPos -= 128;
  v1 = &v3 + 4 * effect->animationNumber;
  v2 = &effect->rect;
  v2->left = *v1;
  v2->top = v1[1];
  v2->right = v1[2];
  v2->bottom = v1[3];
}

//----- (00409F60) --------------------------------------------------------
// mode 0 only
void __cdecl effect6_BoosterSmoke(Effect *effect)
{
  int *v1; // eax
  RECT *v2; // ecx
  int v3; // [esp+4h] [ebp-70h]
  int v4; // [esp+8h] [ebp-6Ch]
  int v5; // [esp+Ch] [ebp-68h]
  int v6; // [esp+10h] [ebp-64h]
  int v7; // [esp+14h] [ebp-60h]
  int v8; // [esp+18h] [ebp-5Ch]
  int v9; // [esp+1Ch] [ebp-58h]
  int v10; // [esp+20h] [ebp-54h]
  int v11; // [esp+24h] [ebp-50h]
  int v12; // [esp+28h] [ebp-4Ch]
  int v13; // [esp+2Ch] [ebp-48h]
  int v14; // [esp+30h] [ebp-44h]
  int v15; // [esp+34h] [ebp-40h]
  int v16; // [esp+38h] [ebp-3Ch]
  int v17; // [esp+3Ch] [ebp-38h]
  int v18; // [esp+40h] [ebp-34h]
  int v19; // [esp+44h] [ebp-30h]
  int v20; // [esp+48h] [ebp-2Ch]
  int v21; // [esp+4Ch] [ebp-28h]
  int v22; // [esp+50h] [ebp-24h]
  int v23; // [esp+54h] [ebp-20h]
  int v24; // [esp+58h] [ebp-1Ch]
  int v25; // [esp+5Ch] [ebp-18h]
  int v26; // [esp+60h] [ebp-14h]
  int v27; // [esp+64h] [ebp-10h]
  int v28; // [esp+68h] [ebp-Ch]
  int v29; // [esp+6Ch] [ebp-8h]
  int v30; // [esp+70h] [ebp-4h]

  v3 = 56;
  v4 = 0;
  v5 = 64;
  v6 = 8;
  v7 = 64;
  v8 = 0;
  v9 = 72;
  v10 = 8;
  v11 = 72;
  v12 = 0;
  v13 = 80;
  v14 = 8;
  v15 = 80;
  v16 = 0;
  v17 = 88;
  v18 = 8;
  v19 = 88;
  v20 = 0;
  v21 = 96;
  v22 = 8;
  v23 = 96;
  v24 = 0;
  v25 = 104;
  v26 = 8;
  v27 = 104;
  v28 = 0;
  v29 = 112;
  v30 = 8;
  if ( ++effect->animationTimer > 1 )
  {
    effect->animationTimer = 0;
    if ( ++effect->animationNumber > 6 )
      effect->isUsed = 0;
  }
  v1 = &v3 + 4 * effect->animationNumber;
  v2 = &effect->rect;
  v2->left = *v1;
  v2->top = v1[1];
  v2->right = v1[2];
  v2->bottom = v1[3];
  switch ( effect->direction )
  {
    case 0:
      effect->XPos -= 1024;
      break;
    case 1:
      effect->YPos -= 1024;
      break;
    case 2:
      effect->XPos += 1024;
      break;
    case 3:
      effect->YPos += 1024;
      break;
    default:
      return;
  }
}

//----- (0040A120) --------------------------------------------------------
// mode 0: face left, mode 1: face right
void __cdecl effect7_DrownedQuote(Effect *effect)
{
  RECT *v1; // ecx

  if ( effect->direction )
  {
    v1 = &effect->rect;
    v1->left = 32;
    v1->top = 80;
    v1->right = 48;
  }
  else
  {
    v1 = &effect->rect;
    v1->left = 16;
    v1->top = 80;
    v1->right = 32;
  }
  v1->bottom = 96;
}

//----- (0040A1B0) --------------------------------------------------------
// mode 0: question mark, mode 1: exclamation mark
void __cdecl effect8_ExclamationMark(Effect *effect)
{
  RECT *v1; // ecx
  RECT *v2; // ecx

  if ( ++effect->animationTimer < 5 )
    effect->YPos -= 2048;
  if ( effect->animationTimer == 32 )
    effect->isUsed = 0;
  if ( effect->direction )
  {
    v2 = &effect->rect;
    v2->left = 48;
    v2->top = 64;
    v2->right = 64;
    v2->bottom = 80;
  }
  else
  {
    v1 = &effect->rect;
    v1->left = 0;
    v1->top = 80;
    v1->right = 16;
    v1->bottom = 96;
  }
}

//----- (0040A280) --------------------------------------------------------
// mode 0: level up, mode 1: level down
void __cdecl effect9_LevelUpOrDown(Effect *effect)
{
  int *v1; // eax
  RECT *v2; // ecx
  int *v3; // edx
  RECT *v4; // eax
  int v5; // [esp+0h] [ebp-40h]
  int v6; // [esp+4h] [ebp-3Ch]
  int v7; // [esp+8h] [ebp-38h]
  int v8; // [esp+Ch] [ebp-34h]
  int v9; // [esp+10h] [ebp-30h]
  int v10; // [esp+14h] [ebp-2Ch]
  int v11; // [esp+18h] [ebp-28h]
  int v12; // [esp+1Ch] [ebp-24h]
  int v13; // [esp+20h] [ebp-20h]
  int v14; // [esp+24h] [ebp-1Ch]
  int v15; // [esp+28h] [ebp-18h]
  int v16; // [esp+2Ch] [ebp-14h]
  int v17; // [esp+30h] [ebp-10h]
  int v18; // [esp+34h] [ebp-Ch]
  int v19; // [esp+38h] [ebp-8h]
  int v20; // [esp+3Ch] [ebp-4h]

  v13 = 0;
  v14 = 0;
  v15 = 56;
  v16 = 16;
  v17 = 0;
  v18 = 16;
  v19 = 56;
  v20 = 32;
  v5 = 0;
  v6 = 96;
  v7 = 56;
  v8 = 112;
  v9 = 0;
  v10 = 112;
  v11 = 56;
  v12 = 128;
  ++effect->animationTimer;
  if ( effect->direction )
  {
    if ( effect->animationTimer < 20 )
      effect->YPos -= 512;
    if ( effect->animationTimer == 80 )
      effect->isUsed = 0;
  }
  else
  {
    if ( effect->animationTimer < 20 )
      effect->YPos -= 1024;
    if ( effect->animationTimer == 80 )
      effect->isUsed = 0;
  }
  if ( effect->direction )
  {
    v3 = &v5 + 4 * (effect->animationTimer / 2 % 2);
    v4 = &effect->rect;
    v4->left = *v3;
    v4->top = v3[1];
    v4->right = v3[2];
    v4->bottom = v3[3];
  }
  else
  {
    v1 = &v13 + 4 * (effect->animationTimer / 2 % 2);
    v2 = &effect->rect;
    v2->left = *v1;
    v2->top = v1[1];
    v2->right = v1[2];
    v2->bottom = v1[3];
  }
}

//----- (0040A3F0) --------------------------------------------------------
// mode 0 only
void __cdecl effect10_RedDamageRings(Effect *effect)
{
  int *v1; // ecx
  RECT *v2; // edx
  int v3; // [esp+0h] [ebp-78h]
  int v4; // [esp+4h] [ebp-74h]
  int v5; // [esp+8h] [ebp-70h]
  int v6; // [esp+Ch] [ebp-6Ch]
  int v7; // [esp+10h] [ebp-68h]
  int v8; // [esp+14h] [ebp-64h]
  int v9; // [esp+18h] [ebp-60h]
  int v10; // [esp+1Ch] [ebp-5Ch]
  int v11; // [esp+20h] [ebp-58h]
  int v12; // [esp+24h] [ebp-54h]
  int v13; // [esp+28h] [ebp-50h]
  int v14; // [esp+2Ch] [ebp-4Ch]
  int v15; // [esp+30h] [ebp-48h]
  int v16; // [esp+34h] [ebp-44h]
  int v17; // [esp+38h] [ebp-40h]
  int v18; // [esp+3Ch] [ebp-3Ch]
  int v19; // [esp+40h] [ebp-38h]
  int v20; // [esp+44h] [ebp-34h]
  int v21; // [esp+48h] [ebp-30h]
  int v22; // [esp+4Ch] [ebp-2Ch]
  int v23; // [esp+50h] [ebp-28h]
  int v24; // [esp+54h] [ebp-24h]
  int v25; // [esp+58h] [ebp-20h]
  int v26; // [esp+5Ch] [ebp-1Ch]
  int v27; // [esp+60h] [ebp-18h]
  int v28; // [esp+64h] [ebp-14h]
  int v29; // [esp+68h] [ebp-10h]
  int v30; // [esp+6Ch] [ebp-Ch]
  unsigned __int8 v31; // [esp+77h] [ebp-1h]

  if ( !effect->actionNumber )
  {
    effect->actionNumber = 1;
    v31 = random(0, 255);
    effect->XVel = 2 * getCos(v31);
    effect->YVel = 2 * getSin(v31);
  }
  effect->XPos += effect->XVel;
  effect->YPos += effect->YVel;
  v3 = 56;
  v4 = 8;
  v5 = 64;
  v6 = 16;
  v7 = 64;
  v8 = 8;
  v9 = 72;
  v10 = 16;
  v11 = 72;
  v12 = 8;
  v13 = 80;
  v14 = 16;
  v15 = 80;
  v16 = 8;
  v17 = 88;
  v18 = 16;
  v19 = 88;
  v20 = 8;
  v21 = 96;
  v22 = 16;
  v23 = 96;
  v24 = 8;
  v25 = 104;
  v26 = 16;
  v27 = 104;
  v28 = 8;
  v29 = 112;
  v30 = 16;
  if ( ++effect->animationTimer > 2 )
  {
    effect->animationTimer = 0;
    if ( ++effect->animationNumber > 6 )
      effect->isUsed = 0;
  }
  v1 = &v3 + 4 * effect->animationNumber;
  v2 = &effect->rect;
  v2->left = *v1;
  v2->top = v1[1];
  v2->right = v1[2];
  v2->bottom = v1[3];
}

//----- (0040A5A0) --------------------------------------------------------
// mode 0 only
void __cdecl effect11_BigExplosion(Effect *effect)
{
  int *v1; // eax
  RECT *v2; // ecx
  int v3; // [esp+0h] [ebp-20h]
  int v4; // [esp+4h] [ebp-1Ch]
  int v5; // [esp+8h] [ebp-18h]
  int v6; // [esp+Ch] [ebp-14h]
  int v7; // [esp+10h] [ebp-10h]
  int v8; // [esp+14h] [ebp-Ch]
  int v9; // [esp+18h] [ebp-8h]
  int v10; // [esp+1Ch] [ebp-4h]

  v3 = 112;
  v4 = 0;
  v5 = 144;
  v6 = 32;
  v7 = 144;
  v8 = 0;
  v9 = 176;
  v10 = 32;
  if ( ++effect->animationTimer > 2 )
  {
    effect->animationTimer = 0;
    if ( ++effect->animationNumber > 1 )
      effect->isUsed = 0;
  }
  v1 = &v3 + 4 * effect->animationNumber;
  v2 = &effect->rect;
  v2->left = *v1;
  v2->top = v1[1];
  v2->right = v1[2];
  v2->bottom = v1[3];
}

//----- (0040A650) --------------------------------------------------------
// mode 0 only
void __cdecl effect12_HeadbumpSparks(Effect *effect)
{
  int *v1; // edx
  RECT *v2; // eax
  Directions v3; // [esp+4h] [ebp-24h]
  int v4; // [esp+8h] [ebp-20h]
  int v5; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]
  int v10; // [esp+20h] [ebp-8h]
  int v11; // [esp+24h] [ebp-4h]

  v4 = 56;
  v5 = 24;
  v6 = 64;
  v7 = 32;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  if ( !effect->actionNumber )
  {
    effect->actionNumber = 1;
    v3 = effect->direction;
    if ( v3 )
    {
      if ( v3 == 1 )
        effect->YVel = -512 * random(1, 3);
    }
    else
    {
      effect->XVel = random(-1536, 1536);
      effect->YVel = random(-512, 512);
    }
  }
  if ( effect->direction == left )
  {
    effect->XVel = 4 * effect->XVel / 5;
    effect->YVel = 4 * effect->YVel / 5;
  }
  effect->XPos += effect->XVel;
  effect->YPos += effect->YVel;
  if ( ++effect->animationTimer > 20 )
    effect->isUsed = 0;
  v1 = &v4 + 4 * (effect->animationTimer / 2 % 2);
  v2 = &effect->rect;
  v2->left = *v1;
  v2->top = v1[1];
  v2->right = v1[2];
  v2->bottom = v1[3];
  if ( effect->direction == 5 )
    effect->XPos -= 2048;
}

//----- (0040A7E0) --------------------------------------------------------
// Unused
void __cdecl effect13_UnknownUnused(Effect *effect)
{
  int *v1; // eax
  RECT *v2; // ecx
  int v3; // [esp+0h] [ebp-50h]
  int v4; // [esp+4h] [ebp-4Ch]
  int v5; // [esp+8h] [ebp-48h]
  int v6; // [esp+Ch] [ebp-44h]
  int v7; // [esp+10h] [ebp-40h]
  int v8; // [esp+14h] [ebp-3Ch]
  int v9; // [esp+18h] [ebp-38h]
  int v10; // [esp+1Ch] [ebp-34h]
  int v11; // [esp+20h] [ebp-30h]
  int v12; // [esp+24h] [ebp-2Ch]
  int v13; // [esp+28h] [ebp-28h]
  int v14; // [esp+2Ch] [ebp-24h]
  int v15; // [esp+30h] [ebp-20h]
  int v16; // [esp+34h] [ebp-1Ch]
  int v17; // [esp+38h] [ebp-18h]
  int v18; // [esp+3Ch] [ebp-14h]
  int v19; // [esp+40h] [ebp-10h]
  int v20; // [esp+44h] [ebp-Ch]
  int v21; // [esp+48h] [ebp-8h]
  int v22; // [esp+4Ch] [ebp-4h]

  v3 = 0;
  v4 = 96;
  v5 = 40;
  v6 = 136;
  v7 = 40;
  v8 = 96;
  v9 = 80;
  v10 = 136;
  v11 = 80;
  v12 = 96;
  v13 = 120;
  v14 = 136;
  v15 = 120;
  v16 = 96;
  v17 = 160;
  v18 = 136;
  v19 = 160;
  v20 = 96;
  v21 = 200;
  v22 = 136;
  if ( ++effect->animationTimer > 1 )
  {
    effect->animationTimer = 0;
    if ( ++effect->animationNumber > 4 )
      effect->isUsed = 0;
  }
  v1 = &v3 + 4 * effect->animationNumber;
  v2 = &effect->rect;
  v2->left = *v1;
  v2->top = v1[1];
  v2->right = v1[2];
  v2->bottom = v1[3];
}

//----- (0040A8F0) --------------------------------------------------------
// mode 0 only
void __cdecl effect14_SmallWhiteExplosionDisc(Effect *effect)
{
  int *v1; // eax
  RECT *v2; // ecx
  int v3; // [esp+0h] [ebp-40h]
  int v4; // [esp+4h] [ebp-3Ch]
  int v5; // [esp+8h] [ebp-38h]
  int v6; // [esp+Ch] [ebp-34h]
  int v7; // [esp+10h] [ebp-30h]
  int v8; // [esp+14h] [ebp-2Ch]
  int v9; // [esp+18h] [ebp-28h]
  int v10; // [esp+1Ch] [ebp-24h]
  int v11; // [esp+20h] [ebp-20h]
  int v12; // [esp+24h] [ebp-1Ch]
  int v13; // [esp+28h] [ebp-18h]
  int v14; // [esp+2Ch] [ebp-14h]
  int v15; // [esp+30h] [ebp-10h]
  int v16; // [esp+34h] [ebp-Ch]
  int v17; // [esp+38h] [ebp-8h]
  int v18; // [esp+3Ch] [ebp-4h]

  v3 = 0;
  v4 = 72;
  v5 = 8;
  v6 = 80;
  v7 = 8;
  v8 = 72;
  v9 = 16;
  v10 = 80;
  v11 = 16;
  v12 = 72;
  v13 = 24;
  v14 = 80;
  v15 = 24;
  v16 = 72;
  v17 = 32;
  v18 = 80;
  if ( ++effect->animationTimer > 2 )
  {
    effect->animationTimer = 0;
    if ( ++effect->animationNumber > 3 )
      effect->isUsed = 0;
  }
  v1 = &v3 + 4 * effect->animationNumber;
  v2 = &effect->rect;
  v2->left = *v1;
  v2->top = v1[1];
  v2->right = v1[2];
  v2->bottom = v1[3];
}

//----- (0040A9E0) --------------------------------------------------------
// mode 0 only
void __cdecl effect15_Nothing(Effect *effect)
{
  int *v1; // ecx
  RECT *v2; // edx
  int v3; // [esp+0h] [ebp-20h]
  int v4; // [esp+4h] [ebp-1Ch]
  int v5; // [esp+8h] [ebp-18h]
  int v6; // [esp+Ch] [ebp-14h]
  int v7; // [esp+10h] [ebp-10h]
  int v8; // [esp+14h] [ebp-Ch]
  int v9; // [esp+18h] [ebp-8h]
  int v10; // [esp+1Ch] [ebp-4h]

  v3 = 104;
  v4 = 96;
  v5 = 144;
  v6 = 104;
  v7 = 104;
  v8 = 104;
  v9 = 144;
  v10 = 112;
  if ( ++effect->animationTimer < 10 )
    effect->YPos -= 1024;
  if ( effect->animationTimer == 40 )
    effect->isUsed = 0;
  v1 = &v3 + 4 * (effect->animationTimer / 2 % 2);
  v2 = &effect->rect;
  v2->left = *v1;
  v2->top = v1[1];
  v2->right = v1[2];
  v2->bottom = v1[3];
}

//----- (0040AAA0) --------------------------------------------------------
// mode 0 only
void __cdecl effect16_PushJumpKey(Effect *effect)
{
  RECT *v1; // eax
  RECT *v2; // eax

  if ( ++effect->animationTimer >= 40 )
    effect->animationTimer = 0;
  if ( effect->animationTimer >= 30 )
  {
    v2 = &effect->rect;
    v2->left = 0;
    v2->top = 0;
    v2->right = 0;
    v2->bottom = 0;
  }
  else
  {
    v1 = &effect->rect;
    v1->left = 0;
    v1->top = 144;
    v1->right = 144;
    v1->bottom = 152;
  }
}

//----- (0040AB50) --------------------------------------------------------
void __cdecl updateEffects()
{
  signed int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i < 64; ++i )
  {
    if ( effectObjects[i].isUsed & 0x80 )
      effectFunctionTable[effectObjects[i].effectNum](&effectObjects[i]);
  }
}

//----- (0040ABC0) --------------------------------------------------------
void __cdecl drawEffects(signed int cameraXPos, signed int cameraYPos)
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 64; ++i )
  {
    if ( effectObjects[i].isUsed & 0x80 )
      drawBitmapWithTransparency(
        &gameRect,
        (effectObjects[i].XPos - effectObjects[i].viewLeft) / 512 - cameraXPos / 512,
        (effectObjects[i].YPos - effectObjects[i].viewTop) / 512 - cameraYPos / 512,
        &effectObjects[i].rect,
        19);
  }
}

//----- (0040AC90) --------------------------------------------------------
void __cdecl createEffect(int XPos, int YPos, EffectNames effectID, Directions effectDirection)
{
  signed int c; // [esp+0h] [ebp-4h]

  for ( c = 0; c < 64 && effectObjects[c].isUsed; ++c )// Search for free effect space
    ;
  if ( c != 64 )
  {
    memset(&effectObjects[c], 0, 0x44u);
    effectObjects[c].isUsed = 128;
    effectObjects[c].effectNum = effectID;
    effectObjects[c].XPos = XPos;
    effectObjects[c].YPos = YPos;
    effectObjects[c].viewLeft = effectDataViewLeft[effectID].viewLeft;
    effectObjects[c].viewTop = effectDataViewLeft[effectID].viewTop;
    effectObjects[c].direction = effectDirection;
  }
}

//----- (0040AD60) --------------------------------------------------------
// Load Config.dat, check string DOUKUTSU20041206 (return 0 if not equal)
int __cdecl loadConfigData(configDataFile *config)
{
  char path[260]; // [esp+0h] [ebp-118h]
  size_t v3; // [esp+110h] [ebp-8h]
  FILE *stream; // [esp+114h] [ebp-4h]

  memset(config, 0, 0x94u);
  sprintf(path, "%s\\%s", exePath, configDat);
  stream = fopen(path, "rb");
  if ( !stream )
    return 0;
  v3 = fread(config, 0x94u, 1u, stream);
  fclose(stream);
  if ( v3 == 1 && !strcmp(config->proof, DOUKUTSU20041206) )
    return 1;
  memset(config, 0, 0x94u);
  return 0;
}

//----- (0040AE30) --------------------------------------------------------
// Sets Config.dat to default values (Called if check above fails)
void __cdecl setDefaultConfigData(configDataFile *config)
{
  memset(config, 0, 0x94u);
  config->joystickMode = 1;
  config->joystickButton[0] = 2;
  config->joystickButton[1] = 1;
  config->joystickButton[2] = 5;
  config->joystickButton[3] = 6;
  config->joystickButton[4] = 3;
  config->joystickButton[5] = 4;
  config->joystickButton[6] = 6;
  config->joystickButton[7] = 3;
}

//----- (0040AEC0) --------------------------------------------------------
// Runs when you hit "Version" menu button
signed int __stdcall aboutDialog(HWND windowHandle, UINT message, WPARAM wParam, LPARAM lParam)
{
  signed int result; // eax
  const char string[108]; // [esp+8h] [ebp-88h]
  int v6; // [esp+74h] [ebp-1Ch]
  int v7; // [esp+78h] [ebp-18h]
  int v8; // [esp+7Ch] [ebp-14h]
  int v9; // [esp+80h] [ebp-10h]
  int v10; // [esp+84h] [ebp-Ch]
  int v11; // [esp+88h] [ebp-8h]
  int v12; // [esp+8Ch] [ebp-4h]

  if ( message == WM_INITDIALOG )
  {
    getBuildData(&v11, &v6, &v7);
    getVersionNumber(&v10, &v8, &v12, &v9);
    sprintf((char *)string, versionString, v10, v8, v12, v9, v11, v6, v7);
    SetDlgItemTextA(windowHandle, 1011, string);
    centerWindow(windowHandle);
    result = 1;
  }
  else
  {
    if ( message == WM_COMMAND && (unsigned __int16)wParam == 1 )
      EndDialog(windowHandle, 1);
    result = 0;
  }
  return result;
}

//----- (0040AFC0) --------------------------------------------------------
// Runs when you hit "Mute" menu button
signed int __stdcall muteButton(HWND windowHandle, UINT message, WPARAM wParam, LPARAM lParam)
{
  signed int result; // eax

  if ( message == WM_INITDIALOG )
  {
    centerWindow(windowHandle);
    CheckDlgButton(windowHandle, buttonMute0, mute[0] != 0);
    CheckDlgButton(windowHandle, buttonMute1, mute[1] != 0);
    CheckDlgButton(windowHandle, buttonMute2, mute[2] != 0);
    CheckDlgButton(windowHandle, buttonMute3, mute[3] != 0);
    CheckDlgButton(windowHandle, buttonMute4, mute[4] != 0);
    CheckDlgButton(windowHandle, buttonMute5, mute[5] != 0);
    CheckDlgButton(windowHandle, buttonMute6, mute[6] != 0);
    CheckDlgButton(windowHandle, buttonMute7, mute[7] != 0);
    result = 1;
  }
  else
  {
    if ( message == WM_COMMAND )
    {
      if ( (unsigned __int16)wParam == 1 )
      {
        mute[0] = IsDlgButtonChecked(windowHandle, buttonMute0);
        mute[1] = IsDlgButtonChecked(windowHandle, buttonMute1);
        mute[2] = IsDlgButtonChecked(windowHandle, buttonMute2);
        mute[3] = IsDlgButtonChecked(windowHandle, buttonMute3);
        mute[4] = IsDlgButtonChecked(windowHandle, buttonMute4);
        mute[5] = IsDlgButtonChecked(windowHandle, buttonMute5);
        mute[6] = IsDlgButtonChecked(windowHandle, buttonMute6);
        mute[7] = IsDlgButtonChecked(windowHandle, buttonMute7);
        EndDialog(windowHandle, 1);
      }
      else if ( (unsigned __int16)wParam == 2 )
      {
        EndDialog(windowHandle, 0);
      }
    }
    result = 0;
  }
  return result;
}

//----- (0040B1D0) --------------------------------------------------------
// Runs when you hit "Debug Save" menu button
signed int __stdcall debugSaveButton(HWND windowHandle, UINT message, WPARAM wParam, LPARAM lParam)
{
  signed int result; // eax
  char string[100]; // [esp+8h] [ebp-70h]

  if ( message == WM_INITDIALOG )
  {
    SetDlgItemTextA(windowHandle, 1008, "000.dat");
    centerWindow(windowHandle);
    result = 1;
  }
  else
  {
    if ( message == WM_COMMAND )
    {
      if ( (unsigned __int16)wParam == 1 )
      {
        GetDlgItemTextA(windowHandle, 1008, string, 100);
        saveProfile(string);
        EndDialog(windowHandle, 1);
      }
      else if ( (unsigned __int16)wParam == 2 )
      {
        EndDialog(windowHandle, 0);
      }
    }
    result = 0;
  }
  return result;
}

//----- (0040B290) --------------------------------------------------------
// Runs when you hit "Quit" menu button
signed int __stdcall yesNoDialog(HWND windowHandle, int message, WPARAM wParam, const CHAR *lpString)
{
  signed int result; // eax

  if ( message == WM_INITDIALOG )
  {
    SetDlgItemTextA(windowHandle, fieldQuitMessage, lpString);
    centerWindow(windowHandle);
    result = 1;
  }
  else
  {
    if ( message == WM_COMMAND )
    {
      if ( (unsigned __int16)wParam == 1 )
      {
        EndDialog(windowHandle, 1);
      }
      else if ( (unsigned __int16)wParam == 2 )
      {
        EndDialog(windowHandle, 2);
      }
    }
    result = 0;
  }
  return result;
}

//----- (0040B320) --------------------------------------------------------
void __cdecl changeScreenOffsets(int newScreenOffsetY, int newScreenOffsetX)
{
  screenOffsetY = newScreenOffsetY;
  screenOffsetX = newScreenOffsetX;
}
// 49CDA8: using guessed type int screenOffsetX;

//----- (0040B340) --------------------------------------------------------
// Draws the window. Also contains FPS delimiter
int __cdecl drawWindow(HWND windowHandle)
{
  while ( 1 )
  {
    if ( !messageQueue() )
      return 0;
    currentTickCount = GetTickCount();
    if ( currentTickCount >= previousTickCount + 20 )
      break;
    Sleep(1u);
  }
  if ( currentTickCount < previousTickCount + 100 )
    previousTickCount += 20;
  else
    previousTickCount = currentTickCount;
  GetWindowRect(windowHandle, &finalScreenDistRects);
  finalScreenDistRects.left += screenOffsetY;
  finalScreenDistRects.top += screenOffsetX;
  finalScreenDistRects.right = fullscreenSurfaceHeight + finalScreenDistRects.left;
  finalScreenDistRects.bottom = windowSurfaceWidth + finalScreenDistRects.top;
  directDrawFinalScreenSurface->lpVtbl->Blt(
    directDrawFinalScreenSurface,
    &finalScreenDistRects,
    directDrawScreenSurface,
    &windowIdk,
    DDBLT_WAIT,
    0);
  if ( regenerateSurfaces() )
  {
    drawsSomeText();
    redrawRoomTextToSurface();
    drawTextToTextBoxSurfaces();
  }
  return 1;
}
// 49CDA8: using guessed type int screenOffsetX;
// 49D374: using guessed type int fullscreenSurfaceHeight;
// 49D378: using guessed type int windowSurfaceWidth;
// 49D43C: using guessed type int currentTickCount;

//----- (0040B450) --------------------------------------------------------
void __cdecl initDirectDraw(HWND windowHandle, int mode, int bitsPerPixel)
{
  DDSURFACEDESC surfaceParams; // [esp+4h] [ebp-70h]

  if ( !DirectDrawCreate(0, &directDrawObject, 0) )
  {
    memset(namesThingy, 0, 0x5A0u);
    if ( mode )
    {
      if ( mode == mode640480Windowed )
      {
        graphicScale = 2;
        directDrawIsFullscreen = 0;
        directDrawObject->lpVtbl->SetCooperativeLevel(directDrawObject, windowHandle, DDSCL_NORMAL);
      }
      else if ( mode == modeFullscreen )
      {
        graphicScale = 2;
        directDrawIsFullscreen = 1;
        directDrawObject->lpVtbl->SetCooperativeLevel(directDrawObject, windowHandle, DDSCL_EXCLUSIVE|DDSCL_FULLSCREEN);
        directDrawObject->lpVtbl->SetDisplayMode(directDrawObject, 320 * graphicScale, 240 * graphicScale, bitsPerPixel);
      }
    }
    else
    {
      graphicScale = 1;
      directDrawIsFullscreen = 0;
      directDrawObject->lpVtbl->SetCooperativeLevel(directDrawObject, windowHandle, DDSCL_NORMAL);
    }
    windowIdk.left = 0;
    windowIdk.top = 0;
    windowIdk.right = 320 * graphicScale;
    windowIdk.bottom = 240 * graphicScale;
    fullscreenSurfaceHeight = 320 * graphicScale;
    windowSurfaceWidth = 240 * graphicScale;
    memset(&surfaceParams, 0, 108u);
    surfaceParams.dwSize = 108;
    surfaceParams.dwFlags = DDSD_CAPS;
    surfaceParams.ddsCaps.dwCaps = 512;
    surfaceParams.dwBackBufferCount = 0;
    if ( !directDrawObject->lpVtbl->CreateSurface(directDrawObject, &surfaceParams, &directDrawFinalScreenSurface, 0) )
    {
      memset(&surfaceParams, 0, 108u);
      surfaceParams.dwSize = 108;
      surfaceParams.dwFlags = 7;
      surfaceParams.ddsCaps.dwCaps = 64;
      surfaceParams.dwWidth = 320 * graphicScale;
      surfaceParams.dwHeight = 240 * graphicScale;
      if ( !directDrawObject->lpVtbl->CreateSurface(directDrawObject, &surfaceParams, &directDrawScreenSurface, 0) )
      {
        directDrawObject->lpVtbl->CreateClipper(directDrawObject, 0, &clipListMaybe, 0);
        clipListMaybe->lpVtbl->SetHWnd(clipListMaybe, 0, windowHandle);
        directDrawFinalScreenSurface->lpVtbl->SetClipper(directDrawFinalScreenSurface, clipListMaybe);
      }
    }
  }
}
// 48F914: using guessed type int graphicScale;
// 49CDC0: using guessed type int directDrawIsFullscreen;
// 49D374: using guessed type int fullscreenSurfaceHeight;
// 49D378: using guessed type int windowSurfaceWidth;

//----- (0040B6C0) --------------------------------------------------------
// Kills Direct Draw (Called on program exit)
void __cdecl deleteDirectDraw(HWND windowHandle)
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 40; ++i )
  {
    if ( imageResSurface[i] )
    {
      imageResSurface[i]->lpVtbl->Release(imageResSurface[i]);
      imageResSurface[i] = 0;
    }
  }
  if ( directDrawFinalScreenSurface )
  {
    directDrawFinalScreenSurface->lpVtbl->Release(directDrawFinalScreenSurface);
    directDrawFinalScreenSurface = 0;
    directDrawScreenSurface = 0;
  }
  if ( directDrawIsFullscreen )
    directDrawObject->lpVtbl->SetCooperativeLevel(directDrawObject, windowHandle, DDSCL_NORMAL);
  if ( directDrawObject )
  {
    directDrawObject->lpVtbl->Release(directDrawObject);
    directDrawObject = 0;
  }
  memset(namesThingy, 0, 0x5A0u);
}
// 49CDC0: using guessed type int directDrawIsFullscreen;

//----- (0040B7A0) --------------------------------------------------------
// Destroy bitmap objects? (Called on program exit)
void __cdecl destroyBitmapObjectsMaybe(int a1)
{
  if ( imageResSurface[a1] )
  {
    ((void (__stdcall *)(LPDIRECTDRAWSURFACE))imageResSurface[a1]->lpVtbl->Release)(imageResSurface[a1]);
    imageResSurface[a1] = 0;
  }
  memset(&namesThingy[36 * a1], 0, 0x24u);
}

//----- (0040B800) --------------------------------------------------------
int __cdecl makeSurfaceFromResource(char *ptrGraphic, int graphicID)
{
  HINSTANCE v3; // eax
  int v4; // ST4C_4
  int v5; // ST50_4
  HDC v6; // ST54_4
  int v7; // [esp+14h] [ebp-B0h]
  int v8; // [esp+18h] [ebp-ACh]
  int v9; // [esp+1Ch] [ebp-A8h]
  DDSURFACEDESC ptr; // [esp+2Ch] [ebp-98h]
  HGDIOBJ v11; // [esp+A0h] [ebp-24h]
  HDC v12; // [esp+A4h] [ebp-20h]
  DDCOLORKEY v13; // [esp+A8h] [ebp-1Ch]
  HGDIOBJ v14; // [esp+B0h] [ebp-14h]
  int v15; // [esp+B4h] [ebp-10h]
  int v16; // [esp+B8h] [ebp-Ch]
  int v17; // [esp+BCh] [ebp-8h]
  int v18; // [esp+C0h] [ebp-4h]

  if ( graphicID >= 40 )
    return 0;
  if ( imageResSurface[graphicID] )
    return 0;
  v3 = GetModuleHandleA(0);
  v14 = LoadImageA(v3, ptrGraphic, 0, 0, 0, 0x2000u);
  if ( !v14 )
    return 0;
  GetObjectA(v14, 24, &v7);
  memset(&ptr, 0, 108u);
  ptr.dwSize = 108;
  ptr.dwFlags = 7;
  ptr.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
  ptr.dwWidth = graphicScale * v8;
  ptr.dwHeight = graphicScale * v9;
  if ( directDrawObject->lpVtbl->CreateSurface(directDrawObject, &ptr, &imageResSurface[graphicID], 0) )
    return 0;
  v15 = 0;
  v16 = 0;
  v17 = v8;
  v18 = v9;
  v4 = graphicScale * v8;
  v5 = graphicScale * v9;
  v6 = CreateCompatibleDC(0);
  v11 = SelectObject(v6, v14);
  imageResSurface[graphicID]->lpVtbl->GetDC(imageResSurface[graphicID], &v12);
  StretchBlt(v12, 0, 0, v4, v5, v6, v15, v16, v17, v18, 0xCC0020u);
  imageResSurface[graphicID]->lpVtbl->ReleaseDC(imageResSurface[graphicID], v12);
  SelectObject(v6, v11);
  DeleteDC(v6);
  v13.dwColorSpaceLowValue = 0;
  v13.dwColorSpaceHighValue = 0;
  imageResSurface[graphicID]->lpVtbl->SetColorKey(imageResSurface[graphicID], 8, &v13);
  imageResSurface[graphicID]->lpVtbl->SetClipper(imageResSurface[graphicID], clipListMaybe);
  dword_49CDE4[9 * graphicID] = 2;
  dword_49CDDC[9 * graphicID] = v8;
  dword_49CDE0[9 * graphicID] = v9;
  dword_49CDE8[9 * graphicID] = 0;
  strcpy(&namesThingy[36 * graphicID], ptrGraphic);
  return 1;
}
// 48F914: using guessed type int graphicScale;

//----- (0040BAC0) --------------------------------------------------------
// Loads BMP from a file and creates a surface (Permanent)
int __cdecl makeSurfaceFromFile(char *surfaceName, int destination)
{
  int result; // eax
  HINSTANCE v3; // eax
  char path; // [esp+0h] [ebp-1D0h]
  int v5; // [esp+10Ch] [ebp-C4h]
  int v6; // [esp+110h] [ebp-C0h]
  int v7; // [esp+114h] [ebp-BCh]
  int v8; // [esp+118h] [ebp-B8h]
  HDC v9; // [esp+11Ch] [ebp-B4h]
  int v10; // [esp+120h] [ebp-B0h]
  int v11; // [esp+124h] [ebp-ACh]
  int v12; // [esp+128h] [ebp-A8h]
  DDSURFACEDESC surfaceParams; // [esp+138h] [ebp-98h]
  HGDIOBJ v14; // [esp+1ACh] [ebp-24h]
  HDC v15; // [esp+1B0h] [ebp-20h]
  DDCOLORKEY v16; // [esp+1B4h] [ebp-1Ch]
  HGDIOBJ v17; // [esp+1BCh] [ebp-14h]
  int v18; // [esp+1C0h] [ebp-10h]
  int v19; // [esp+1C4h] [ebp-Ch]
  int v20; // [esp+1C8h] [ebp-8h]
  int v21; // [esp+1CCh] [ebp-4h]

  sprintf(&path, "%s\\%s.pbm", dataPath, surfaceName);
  if ( isEnableBitmap(&path) )
  {
    if ( destination <= 40 )
    {
      if ( imageResSurface[destination] )
      {
        logError("existing", destination);
        result = 0;
      }
      else
      {
        v3 = GetModuleHandleA(0);
        v17 = LoadImageA(v3, &path, 0, 0, 0, 0x2010u);
        if ( v17 )
        {
          GetObjectA(v17, 24, &v10);
          memset(&surfaceParams, 0, 108u);
          surfaceParams.dwSize = 108;
          surfaceParams.dwFlags = 7;
          surfaceParams.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
          surfaceParams.dwWidth = graphicScale * v11;
          surfaceParams.dwHeight = graphicScale * v12;
          directDrawObject->lpVtbl->CreateSurface(directDrawObject, &surfaceParams, &imageResSurface[destination], 0);
          v18 = 0;
          v19 = 0;
          v20 = v11;
          v21 = v12;
          v5 = 0;
          v6 = 0;
          v7 = graphicScale * v11;
          v8 = graphicScale * v12;
          v9 = CreateCompatibleDC(0);
          v14 = SelectObject(v9, v17);
          imageResSurface[destination]->lpVtbl->GetDC(imageResSurface[destination], &v15);
          StretchBlt(v15, v5, v6, v7, v8, v9, v18, v19, v20, v21, SRCCOPY);
          imageResSurface[destination]->lpVtbl->ReleaseDC(imageResSurface[destination], v15);
          SelectObject(v9, v14);
          DeleteDC(v9);
          v16.dwColorSpaceLowValue = 0;
          v16.dwColorSpaceHighValue = 0;
          imageResSurface[destination]->lpVtbl->SetColorKey(imageResSurface[destination], 8, &v16);
          imageResSurface[destination]->lpVtbl->SetClipper(imageResSurface[destination], clipListMaybe);
          DeleteObject(v17);
          dword_49CDE4[9 * destination] = 3;
          dword_49CDDC[9 * destination] = v11;
          dword_49CDE0[9 * destination] = v12;
          dword_49CDE8[9 * destination] = 0;
          strcpy(&namesThingy[36 * destination], surfaceName);
          result = 1;
        }
        else
        {
          logError(&path, 1);
          result = 0;
        }
      }
    }
    else
    {
      logError("surface no", destination);
      result = 0;
    }
  }
  else
  {
    logError(&path, 0);
    result = 0;
  }
  return result;
}
// 48F914: using guessed type int graphicScale;

//----- (0040BE10) --------------------------------------------------------
int __cdecl loadBMPFromResourceOntoExistingSurface(char *source, int a2)
{
  HINSTANCE v3; // eax
  int v4; // ST3C_4
  int v5; // ST40_4
  HDC v6; // ST44_4
  int v7; // [esp+14h] [ebp-3Ch]
  int v8; // [esp+18h] [ebp-38h]
  int v9; // [esp+1Ch] [ebp-34h]
  HGDIOBJ v10; // [esp+2Ch] [ebp-24h]
  HDC v11; // [esp+30h] [ebp-20h]
  DDCOLORKEY v12; // [esp+34h] [ebp-1Ch]
  HGDIOBJ v13; // [esp+3Ch] [ebp-14h]
  int v14; // [esp+40h] [ebp-10h]
  int v15; // [esp+44h] [ebp-Ch]
  int v16; // [esp+48h] [ebp-8h]
  int v17; // [esp+4Ch] [ebp-4h]

  if ( a2 >= 40 )
    return 0;
  v3 = GetModuleHandleA(0);
  v13 = LoadImageA(v3, source, 0, 0, 0, 0x2000u);
  if ( !v13 )
    return 0;
  GetObjectA(v13, 24, &v7);
  v14 = 0;
  v15 = 0;
  v16 = v8;
  v17 = v9;
  v4 = graphicScale * v8;
  v5 = graphicScale * v9;
  v6 = CreateCompatibleDC(0);
  v10 = SelectObject(v6, v13);
  imageResSurface[a2]->lpVtbl->GetDC(imageResSurface[a2], &v11);
  StretchBlt(v11, 0, 0, v4, v5, v6, v14, v15, v16, v17, 0xCC0020u);
  imageResSurface[a2]->lpVtbl->ReleaseDC(imageResSurface[a2], v11);
  SelectObject(v6, v10);
  DeleteDC(v6);
  v12.dwColorSpaceLowValue = 0;
  v12.dwColorSpaceHighValue = 0;
  imageResSurface[a2]->lpVtbl->SetColorKey(imageResSurface[a2], 8, &v12);
  imageResSurface[a2]->lpVtbl->SetClipper(imageResSurface[a2], clipListMaybe);
  dword_49CDE4[9 * a2] = 2;
  strcpy(&namesThingy[36 * a2], source);
  return 1;
}
// 48F914: using guessed type int graphicScale;

//----- (0040BFD0) --------------------------------------------------------
int __cdecl reloadBitmapFromFile(char *surfaceName, int destination)
{
  int result; // eax
  HINSTANCE v3; // eax
  char str; // [esp+0h] [ebp-158h]
  int v5; // [esp+110h] [ebp-48h]
  int v6; // [esp+114h] [ebp-44h]
  int v7; // [esp+118h] [ebp-40h]
  int v8; // [esp+11Ch] [ebp-3Ch]
  HDC v9; // [esp+120h] [ebp-38h]
  int v10; // [esp+124h] [ebp-34h]
  int v11; // [esp+128h] [ebp-30h]
  int v12; // [esp+12Ch] [ebp-2Ch]
  HGDIOBJ v13; // [esp+13Ch] [ebp-1Ch]
  HDC v14; // [esp+140h] [ebp-18h]
  HGDIOBJ v15; // [esp+144h] [ebp-14h]
  int v16; // [esp+148h] [ebp-10h]
  int v17; // [esp+14Ch] [ebp-Ch]
  int v18; // [esp+150h] [ebp-8h]
  int v19; // [esp+154h] [ebp-4h]

  sprintf(&str, "%s\\%s.pbm", dataPath, surfaceName);
  if ( isEnableBitmap(&str) )
  {
    if ( destination <= 40 )
    {
      v3 = GetModuleHandleA(0);
      v15 = LoadImageA(v3, &str, 0, 0, 0, 0x2010u);
      if ( v15 )
      {
        GetObjectA(v15, 24, &v10);
        v16 = 0;
        v17 = 0;
        v18 = v11;
        v19 = v12;
        v5 = 0;
        v6 = 0;
        v7 = graphicScale * v11;
        v8 = graphicScale * v12;
        v9 = CreateCompatibleDC(0);
        v13 = SelectObject(v9, v15);
        imageResSurface[destination]->lpVtbl->GetDC(imageResSurface[destination], &v14);
        StretchBlt(v14, v5, v6, v7, v8, v9, v16, v17, v18, v19, 0xCC0020u);
        imageResSurface[destination]->lpVtbl->ReleaseDC(imageResSurface[destination], v14);
        SelectObject(v9, v13);
        DeleteDC(v9);
        DeleteObject(v15);
        dword_49CDE4[9 * destination] = 3;
        strcpy(&namesThingy[36 * destination], surfaceName);
        result = 1;
      }
      else
      {
        logError(&str, 1);
        result = 0;
      }
    }
    else
    {
      logError("surface no", destination);
      result = 0;
    }
  }
  else
  {
    logError(&str, 0);
    result = 0;
  }
  return result;
}
// 48F914: using guessed type int graphicScale;

//----- (0040C1D0) --------------------------------------------------------
signed int __cdecl makeBlankSurface(int a1, int a2, signed int a3, int a4)
{
  DDCOLORKEY v5; // [esp+0h] [ebp-78h]
  DDSURFACEDESC ptr; // [esp+8h] [ebp-70h]

  if ( a3 > 40 )
    return 0;
  if ( imageResSurface[a3] )
    return 0;
  memset(&ptr, 0, 0x6Cu);
  ptr.dwSize = 108;
  ptr.dwFlags = 7;
  if ( a4 )
    ptr.ddsCaps.dwCaps = DDSCAPS_SYSTEMMEMORY|DDSCAPS_OFFSCREENPLAIN;
  else
    ptr.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
  ptr.dwWidth = graphicScale * a1;
  ptr.dwHeight = graphicScale * a2;
  directDrawObject->lpVtbl->CreateSurface(directDrawObject, &ptr, &imageResSurface[a3], 0);
  v5.dwColorSpaceLowValue = 0;
  v5.dwColorSpaceHighValue = 0;
  imageResSurface[a3]->lpVtbl->SetColorKey(imageResSurface[a3], 8, &v5);
  dword_49CDE4[9 * a3] = 1;
  dword_49CDDC[9 * a3] = ptr.dwWidth / graphicScale;
  dword_49CDE0[9 * a3] = ptr.dwHeight / graphicScale;
  if ( a4 )
    dword_49CDE8[9 * a3] = 1;
  else
    dword_49CDE8[9 * a3] = 0;
  strcpy(&namesThingy[36 * a3], "generic");
  return 1;
}
// 48F914: using guessed type int graphicScale;

//----- (0040C320) --------------------------------------------------------
int __cdecl backupSurface(int DstRect, RECT *rect)
{
  memset(&DDBLTFX_ScreenCopy, 0, 0x64u);
  DDBLTFX_ScreenCopy.dwSize = 100;
  RECT_ScreenCopy.left = graphicScale * rect->left;
  RECT_ScreenCopy.top = graphicScale * rect->top;
  RECT_ScreenCopy.right = graphicScale * rect->right;
  RECT_ScreenCopy.bottom = graphicScale * rect->bottom;
  return imageResSurface[DstRect]->lpVtbl->Blt(
           imageResSurface[DstRect],
           &RECT_ScreenCopy,
           directDrawScreenSurface,
           &RECT_ScreenCopy,
           0x1000000,
           &DDBLTFX_ScreenCopy);
}
// 48F914: using guessed type int graphicScale;

//----- (0040C3C0) --------------------------------------------------------
void __cdecl drawBitmapWithTransparency(RECT *rectView, int XPos, int YPos, RECT *rect, int GraphicsID)
{
  rectWork.left = rect->left;
  rectWork.top = rect->top;
  rectWork.right = rect->right;
  rectWork.bottom = rect->bottom;
  if ( rect->right + XPos - rect->left > rectView->right )
    rectWork.right -= rect->right + XPos - rect->left - rectView->right;
  if ( XPos < rectView->left )
  {
    rectWork.left += rectView->left - XPos;
    XPos = rectView->left;
  }
  if ( rect->bottom + YPos - rect->top > rectView->bottom )
    rectWork.bottom -= rect->bottom + YPos - rect->top - rectView->bottom;
  if ( YPos < rectView->top )
  {
    rectWork.top += rectView->top - YPos;
    YPos = rectView->top;
  }
  finalDestinationRect1.left = graphicScale * XPos;
  finalDestinationRect1.top = graphicScale * YPos;
  finalDestinationRect1.right = graphicScale * (rectWork.right + XPos - rectWork.left);
  finalDestinationRect1.bottom = graphicScale * (rectWork.bottom + YPos - rectWork.top);
  rectWork.left *= graphicScale;
  rectWork.top *= graphicScale;
  rectWork.right *= graphicScale;
  rectWork.bottom *= graphicScale;
  directDrawScreenSurface->lpVtbl->Blt(
    directDrawScreenSurface,
    &finalDestinationRect1,
    imageResSurface[GraphicsID],
    &rectWork,
    DDBLT_WAIT|DDBLT_KEYSRC,
    0);
}
// 48F914: using guessed type int graphicScale;

//----- (0040C5B0) --------------------------------------------------------
// Render_Graphics for backgrounds
int __cdecl drawSpriteNoTransparency(RECT *Dst_Rects, int X_Position, int Y_Position, RECT *Src_Rects, int a5)
{
  Final_Src_Rect_2.left = Src_Rects->left;
  Final_Src_Rect_2.top = Src_Rects->top;
  Final_Src_Rect_2.right = Src_Rects->right;
  Final_Src_Rect_2.bottom = Src_Rects->bottom;
  if ( Src_Rects->right + X_Position - Src_Rects->left > Dst_Rects->right )
    Final_Src_Rect_2.right -= Src_Rects->right + X_Position - Src_Rects->left - Dst_Rects->right;
  if ( X_Position < Dst_Rects->left )
  {
    Final_Src_Rect_2.left += Dst_Rects->left - X_Position;
    X_Position = Dst_Rects->left;
  }
  if ( Src_Rects->bottom + Y_Position - Src_Rects->top > Dst_Rects->bottom )
    Final_Src_Rect_2.bottom -= Src_Rects->bottom + Y_Position - Src_Rects->top - Dst_Rects->bottom;
  if ( Y_Position < Dst_Rects->top )
  {
    Final_Src_Rect_2.top += Dst_Rects->top - Y_Position;
    Y_Position = Dst_Rects->top;
  }
  Final_Dst_Rect_2.left = graphicScale * X_Position;
  Final_Dst_Rect_2.top = graphicScale * Y_Position;
  Final_Dst_Rect_2.right = graphicScale * (Final_Src_Rect_2.right + X_Position - Final_Src_Rect_2.left);
  Final_Dst_Rect_2.bottom = graphicScale * (Final_Src_Rect_2.bottom + Y_Position - Final_Src_Rect_2.top);
  Final_Src_Rect_2.left *= graphicScale;
  Final_Src_Rect_2.top *= graphicScale;
  Final_Src_Rect_2.right *= graphicScale;
  Final_Src_Rect_2.bottom *= graphicScale;
  return directDrawScreenSurface->lpVtbl->Blt(
           directDrawScreenSurface,
           &Final_Dst_Rect_2,
           imageResSurface[a5],
           &Final_Src_Rect_2,
           0x1000000,
           0);
}
// 48F914: using guessed type int graphicScale;

//----- (0040C7A0) --------------------------------------------------------
int __cdecl drawSpriteOntoSurface(LONG a1, LONG a2, RECT *a3, int a4, int a5)
{
  Final_Src_Rect_3.left = graphicScale * a3->left;
  Final_Src_Rect_3.top = graphicScale * a3->top;
  Final_Src_Rect_3.right = graphicScale * a3->right;
  Final_Src_Rect_3.bottom = graphicScale * a3->bottom;
  Final_Dst_Rect_3.left = a1;
  Final_Dst_Rect_3.top = a2;
  Final_Dst_Rect_3.right = a3->right + a1 - a3->left;
  Final_Dst_Rect_3.bottom = a3->bottom + a2 - a3->top;
  Final_Dst_Rect_3.left = graphicScale * a1;
  Final_Dst_Rect_3.top = graphicScale * a2;
  Final_Dst_Rect_3.right *= graphicScale;
  Final_Dst_Rect_3.bottom *= graphicScale;
  return imageResSurface[a4]->lpVtbl->Blt(
           imageResSurface[a4],
           &Final_Dst_Rect_3,
           imageResSurface[a5],
           &Final_Src_Rect_3,
           0x1008000,
           0);
}
// 48F914: using guessed type int graphicScale;

//----- (0040C8B0) --------------------------------------------------------
int __cdecl makeRGB(COLORREF color)
{
  COLORREF v2; // [esp+0h] [ebp-7Ch]
  DDSURFACEDESC ptr; // [esp+4h] [ebp-78h]
  HDC Screen_Context; // [esp+74h] [ebp-8h]
  int v5; // [esp+78h] [ebp-4h]

  if ( directDrawScreenSurface->lpVtbl->GetDC(directDrawScreenSurface, &Screen_Context) )
    return -1;
  v2 = GetPixel(Screen_Context, 0, 0);
  SetPixel(Screen_Context, 0, 0, color);
  directDrawScreenSurface->lpVtbl->ReleaseDC(directDrawScreenSurface, Screen_Context);
  memset(&ptr, 0, 0x6Cu);
  ptr.dwSize = 108;
  if ( directDrawScreenSurface->lpVtbl->Lock(directDrawScreenSurface, 0, &ptr, 1, 0) )
    return -1;
  v5 = *(_DWORD *)ptr.lpSurface;
  if ( ptr.ddpfPixelFormat.dwRGBBitCount < 0x20 )
    v5 &= (1 << SLOBYTE(ptr.ddpfPixelFormat.dwRGBBitCount)) - 1;
  ((void (__cdecl *)(LPDIRECTDRAWSURFACE, _DWORD))directDrawScreenSurface->lpVtbl->Unlock)(directDrawScreenSurface, 0);
  if ( directDrawScreenSurface->lpVtbl->GetDC(directDrawScreenSurface, &Screen_Context) )
    return -1;
  SetPixel(Screen_Context, 0, 0, v2);
  directDrawScreenSurface->lpVtbl->ReleaseDC(directDrawScreenSurface, Screen_Context);
  return v5;
}

//----- (0040C9E0) --------------------------------------------------------
void __cdecl drawColorFill(RECT *rect, int Mask_Color)
{
  memset(Draw_Colour_Fill_DDBLTFX, 0, 0x64u);
  *(_DWORD *)Draw_Colour_Fill_DDBLTFX = 100;
  *(_DWORD *)Draw_Colour_Fill_DDBLTFX_dxFillColor = Mask_Color;
  Dest_Rect.left = graphicScale * rect->left;
  Dest_Rect.top = graphicScale * rect->top;
  Dest_Rect.right = graphicScale * rect->right;
  Dest_Rect.bottom = graphicScale * rect->bottom;
  directDrawScreenSurface->lpVtbl->Blt(
    directDrawScreenSurface,
    &Dest_Rect,
    0,
    0,
    16778240,
    (LPDDBLTFX)Draw_Colour_Fill_DDBLTFX);
}
// 48F914: using guessed type int graphicScale;

//----- (0040CA80) --------------------------------------------------------
void __cdecl drawColorFillOntoSurface(RECT *rect, int column, int surface)
{
  memset(Draw_Colour_Fill_Onto_Surface_DDBLTFX, 0, 0x64u);
  *(_DWORD *)Draw_Colour_Fill_Onto_Surface_DDBLTFX = 100;
  *(_DWORD *)Draw_Colour_Fill_Onto_Surface_DDBLTFX_dxFillColor = column;
  Final_Dst_Rect_5.left = graphicScale * rect->left;
  Final_Dst_Rect_5.top = graphicScale * rect->top;
  Final_Dst_Rect_5.right = graphicScale * rect->right;
  Final_Dst_Rect_5.bottom = graphicScale * rect->bottom;
  dword_49CDE4[9 * surface] = 1;
  imageResSurface[surface]->lpVtbl->Blt(
    imageResSurface[surface],
    &Final_Dst_Rect_5,
    0,
    0,
    16778240,
    (LPDDBLTFX)Draw_Colour_Fill_Onto_Surface_DDBLTFX);
}
// 48F914: using guessed type int graphicScale;

//----- (0040CB30) --------------------------------------------------------
signed int return1()
{
  return 1;
}

//----- (0040CB60) --------------------------------------------------------
int regenerateSurfaces()
{
  int v1; // [esp+0h] [ebp-1Ch]
  RECT a1; // [esp+4h] [ebp-18h]
  int a3; // [esp+14h] [ebp-8h]
  int Was_Surface_Lost; // [esp+18h] [ebp-4h]

  Was_Surface_Lost = 0;
  if ( !directDrawFinalScreenSurface )
    return Was_Surface_Lost;
  if ( !directDrawScreenSurface )
    return Was_Surface_Lost;
  if ( directDrawFinalScreenSurface->lpVtbl->IsLost(directDrawFinalScreenSurface) == DDERR_SURFACELOST )
  {
    ++Was_Surface_Lost;
    directDrawFinalScreenSurface->lpVtbl->Restore(directDrawFinalScreenSurface);
    return1();
  }
  if ( directDrawScreenSurface->lpVtbl->IsLost(directDrawScreenSurface) == DDERR_SURFACELOST )
  {
    ++Was_Surface_Lost;
    directDrawScreenSurface->lpVtbl->Restore(directDrawScreenSurface);
    return1();
  }
  for ( a3 = 0; a3 < 40; ++a3 )
  {
    if ( imageResSurface[a3] )
    {
      if ( imageResSurface[a3]->lpVtbl->IsLost(imageResSurface[a3]) == DDERR_SURFACELOST )
      {
        ++Was_Surface_Lost;
        imageResSurface[a3]->lpVtbl->Restore(imageResSurface[a3]);
        return1();
        if ( !dword_49CDE8[9 * a3] )
        {
          v1 = dword_49CDE4[9 * a3];
          switch ( v1 )
          {
            case 1:
              a1.left = 0;
              a1.top = 0;
              a1.right = dword_49CDDC[9 * a3];
              a1.bottom = dword_49CDE0[9 * a3];
              drawColorFillOntoSurface(&a1, 0, a3);
              break;
            case 2:
              loadBMPFromResourceOntoExistingSurface(&namesThingy[36 * a3], a3);
              break;
            case 3:
              reloadBitmapFromFile(&namesThingy[36 * a3], a3);
              break;
          }
        }
      }
    }
  }
  return Was_Surface_Lost;
}

//----- (0040CD50) --------------------------------------------------------
void __cdecl initFontObject(LPCSTR a1)
{
  signed int v1; // [esp+4h] [ebp-8h]
  signed int v2; // [esp+8h] [ebp-4h]

  if ( graphicScale == 1 )
  {
    v1 = 12;
    v2 = 6;
  }
  else if ( graphicScale == 2 )
  {
    v1 = 20;
    v2 = 10;
  }
  fontHandle[0] = CreateFontA(v1, v2, 0, 0, 400, 0, 0, 0, 1u, 4u, 0, 0, 1u, a1);
  if ( !fontHandle[0] )
    fontHandle[0] = CreateFontA(v1, v2, 0, 0, 400, 0, 0, 0, 1u, 4u, 0, 0, 1u, 0);
}
// 48F914: using guessed type int graphicScale;

//----- (0040CE00) --------------------------------------------------------
// Unused
int __cdecl Draw_String(int a1, int a2, const char *String, COLORREF String_Color)
{
  int v4; // eax
  HDC v6; // [esp+0h] [ebp-8h]
  HGDIOBJ v7; // [esp+4h] [ebp-4h]

  directDrawScreenSurface->lpVtbl->GetDC(directDrawScreenSurface, &v6);
  v7 = SelectObject(v6, fontHandle[0]);
  SetBkMode(v6, 1);
  SetTextColor(v6, String_Color);
  v4 = strlen(String);
  TextOutA(v6, graphicScale * a1, graphicScale * a2, String, v4);
  SelectObject(v6, v7);
  return directDrawScreenSurface->lpVtbl->ReleaseDC(directDrawScreenSurface, v6);
}
// 48F914: using guessed type int graphicScale;

//----- (0040CEB0) --------------------------------------------------------
// Draws text to screen (Message box writing?)
int __cdecl drawStringOntoSurface(int XPos, int YPos, char *string, COLORREF color, int DDrawThingy)
{
  int v5; // eax
  HDC v7; // [esp+0h] [ebp-8h]
  HGDIOBJ v8; // [esp+4h] [ebp-4h]

  imageResSurface[DDrawThingy]->lpVtbl->GetDC(imageResSurface[DDrawThingy], &v7);
  v8 = SelectObject(v7, fontHandle[0]);
  SetBkMode(v7, 1);
  SetTextColor(v7, color);
  v5 = strlen(string);
  TextOutA(v7, graphicScale * XPos, graphicScale * YPos, string, v5);
  SelectObject(v7, v8);
  return imageResSurface[DDrawThingy]->lpVtbl->ReleaseDC(imageResSurface[DDrawThingy], v7);
}
// 48F914: using guessed type int graphicScale;

//----- (0040CF90) --------------------------------------------------------
int scrollCreditsText()
{
  int result; // eax
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 16; ++i )
  {
    if ( textObjectArray[i].flag & 0x80 && creditScript.mode )
      textObjectArray[i].y -= 256;
    if ( textObjectArray[i].y <= -8192 )
      textObjectArray[i].flag = 0;
    result = i + 1;
  }
  return result;
}

//----- (0040D010) --------------------------------------------------------
// Draws something from Bitmap Slot 0x25, which might be the credits text
int drawFromSlot0x25CreditsTextMaybe()
{
  int result; // eax
  signed int i; // [esp+0h] [ebp-14h]
  RECT rect; // [esp+4h] [ebp-10h]

  for ( i = 0; i < 16; ++i )
  {
    if ( textObjectArray[i].flag & 0x80 )
    {
      rect.left = 0;
      rect.right = 320;
      rect.top = 16 * i;
      rect.bottom = 16 * i + 16;
      drawBitmapWithTransparency(&::rect, textObjectArray[i].x / 512, textObjectArray[i].y / 512, &rect, 35);
      rect.left = 24 * (textObjectArray[i].cast % 13);
      rect.right = rect.left + 24;
      rect.top = 24 * (textObjectArray[i].cast / 13);
      rect.bottom = rect.top + 24;
      drawBitmapWithTransparency(&::rect, textObjectArray[i].x / 512 - 24, textObjectArray[i].y / 512 - 8, &rect, 37);
    }
    result = i + 1;
  }
  return result;
}

//----- (0040D150) --------------------------------------------------------
// Draws some text
int __cdecl Print_Text_Maybe(int arg0, int a2, char *source, int a4)
{
  int result; // eax
  signed int i; // [esp+0h] [ebp-14h]
  RECT a1; // [esp+4h] [ebp-10h]

  for ( i = 0; i < 16 && textObjectArray[i].flag & 0x80; ++i )
    result = i + 1;
  if ( i != 16 )
  {
    textObjectArray[i].flag = 128;
    textObjectArray[i].x = arg0;
    textObjectArray[i].y = a2;
    textObjectArray[i].cast = a4;
    strcpy(textObjectArray[i].string, source);
    a1.left = 0;
    a1.right = 320;
    a1.top = 16 * i;
    a1.bottom = 16 * i + 16;
    drawColorFillOntoSurface(&a1, 0, 35);
    result = drawStringOntoSurface(0, a1.top, source, 0xFEFFFFu, 35);
  }
  return result;
}

//----- (0040D240) --------------------------------------------------------
// Draws some text
int drawsSomeText()
{
  int result; // eax
  signed int i; // [esp+0h] [ebp-14h]
  RECT a1; // [esp+4h] [ebp-10h]

  for ( i = 0; i < 16; ++i )
  {
    if ( textObjectArray[i].flag & 0x80 )
    {
      a1.left = 0;
      a1.right = 320;
      a1.top = 16 * i;
      a1.bottom = 16 * i + 16;
      drawColorFillOntoSurface(&a1, 0, 35);
      drawStringOntoSurface(0, a1.top, textObjectArray[i].string, 0xFEFFFFu, 35);
    }
    result = i + 1;
  }
  return result;
}

//----- (0040D2D0) --------------------------------------------------------
// Does some odd stuff with a few variables based on what's the value of 49D608
int slideCreditsPicture()
{
  int result; // eax

  result = creditPicture.actionNumber;
  if ( creditPicture.actionNumber )
  {
    if ( creditPicture.actionNumber == 1 )
    {
      creditPicture.XPos += 20480;
      if ( creditPicture.XPos > 0 )
        creditPicture.XPos = 0;
    }
    else if ( creditPicture.actionNumber == 2 )
    {
      creditPicture.XPos -= 20480;
      if ( creditPicture.XPos < -81920 )
        creditPicture.XPos = -81920;
    }
  }
  else
  {
    creditPicture.XPos = -81920;
  }
  return result;
}

//----- (0040D350) --------------------------------------------------------
// Draws credits image (from Bitmap Slot 0x24)
void drawCreditsImage()
{
  RECT rect; // [esp+0h] [ebp-10h]

  rect.left = 0;
  rect.top = 0;
  rect.right = 160;
  rect.bottom = 240;
  drawBitmapWithTransparency(&::rect, creditPicture.XPos / 512, 0, &rect, 36);
}

//----- (0040D3A0) --------------------------------------------------------
// Slot 36 : Used for Credit images
void __cdecl loadCreditsIllustration(int illustrationNumber)
{
  char name[16]; // [esp+0h] [ebp-14h]

  sprintf(name, "CREDIT%02d", illustrationNumber);
  loadBMPFromResourceOntoExistingSurface(name, 36);
}

//----- (0040D3E0) --------------------------------------------------------
void __cdecl initCreditScript()
{
  memset(&creditScript, 0, 0x18u);
  memset(textObjectArray, 0, 0x500u);
}

//----- (0040D410) --------------------------------------------------------
void deleteCreditScript()
{
  if ( creditScript.buffer )
  {
    free(creditScript.buffer);
    creditScript.buffer = 0;
  }
}

//----- (0040D440) --------------------------------------------------------
// Initializes Credits. Loads a file, puts casts.pbm into slot 0x25
signed int startCreditsScript()
{
  signed int result; // eax
  char path[260]; // [esp+0h] [ebp-110h]
  FILE *stream; // [esp+10Ch] [ebp-4h]

  if ( creditScript.buffer )
  {
    free(creditScript.buffer);
    creditScript.buffer = 0;
  }
  sprintf(path, "%s\\%s", dataPath, off_48F918);
  creditScript.length = getFileSize(path);
  if ( creditScript.length == -1 )
    return 0;
  creditScript.buffer = (char *)malloc(creditScript.length);
  if ( !creditScript.buffer )
    return 0;
  stream = fopen(path, "rb");
  if ( stream )
  {
    fread(creditScript.buffer, 1u, creditScript.length, stream);
    decryptTSCScript((unsigned __int8 *)creditScript.buffer, creditScript.length);
    creditScript.offset = 0;
    creditScript.wait = 0;
    creditScript.mode = 1;
    creditPicture.XPos = -81920;
    creditPicture.actionNumber = 0;
    gameRect.left = 160;
    if ( reloadBitmapFromFile("casts", 37) )
    {
      memset(textObjectArray, 0, 0x500u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    free(creditScript.buffer);
    result = 0;
  }
  return result;
}
// 48F918: using guessed type char *off_48F918;

//----- (0040D5C0) --------------------------------------------------------
void creditsRelatedMaybe()
{
  if ( creditScript.offset < creditScript.length )
  {
    if ( creditScript.mode == 1 )
    {
      Credits_Related_2_Maybe();
    }
    else if ( creditScript.mode == 2 && --creditScript.wait <= 0 )
    {
      creditScript.mode = 1;
    }
  }
}

//----- (0040D620) --------------------------------------------------------
void Credits_Related_2_Maybe()
{
  size_t count; // ST18_4
  size_t v1; // ST18_4
  int music; // ST1C_4
  int v3; // ST1C_4
  int v4; // ST1C_4
  int v5; // ST1C_4
  int v6; // [esp+4h] [ebp-38h]
  int v7; // [esp+4h] [ebp-38h]
  signed int Music_To_Play; // [esp+Ch] [ebp-30h]
  char destination[40]; // [esp+10h] [ebp-2Ch]

  while ( 2 )
  {
    if ( creditScript.offset < creditScript.length )
    {
      switch ( creditScript.buffer[creditScript.offset] )
      {
        case 33:
          music = Credits_Related_3_Maybe((int)&creditScript.buffer[++creditScript.offset]);
          creditScript.offset += 4;
          changeMusic((musics)music);
          return;
        case 43:
          creditScript.start_x = Credits_Related_3_Maybe((int)&creditScript.buffer[++creditScript.offset]) << 9;
          creditScript.offset += 4;
          return;
        case 45:
          creditScript.wait = Credits_Related_3_Maybe((int)&creditScript.buffer[++creditScript.offset]);
          creditScript.offset += 4;
          creditScript.mode = 2;
          return;
        case 47:
          creditScript.mode = 0;
          return;
        case 91:
          Music_To_Play = ++creditScript.offset;
          while ( creditScript.buffer[Music_To_Play] != 93 )
          {
            if ( isShiftJIS(creditScript.buffer[Music_To_Play]) )
              Music_To_Play += 2;
            else
              ++Music_To_Play;
          }
          count = Music_To_Play - creditScript.offset;
          memcpy(destination, &creditScript.buffer[creditScript.offset], Music_To_Play - creditScript.offset);
          destination[count] = 0;
          creditScript.offset = Music_To_Play + 1;
          v1 = Credits_Related_3_Maybe((int)&creditScript.buffer[Music_To_Play + 1]);
          Print_Text_Maybe(creditScript.start_x, 126976, destination, v1);
          creditScript.offset += 4;
          return;
        case 102:
          v4 = Credits_Related_3_Maybe((int)&creditScript.buffer[++creditScript.offset]);
          creditScript.offset += 5;
          v7 = Credits_Related_3_Maybe((int)&creditScript.buffer[creditScript.offset]);
          creditScript.offset += 4;
          if ( !getNPCFlag(v4) )
            return;
          do
          {
LABEL_26:
            if ( creditScript.offset >= creditScript.length )
              break;
            if ( creditScript.buffer[creditScript.offset] != 108 )
            {
              if ( isShiftJIS(creditScript.buffer[creditScript.offset]) )
                creditScript.offset += 2;
              else
                ++creditScript.offset;
              goto LABEL_26;
            }
            v5 = Credits_Related_3_Maybe((int)&creditScript.buffer[++creditScript.offset]);
            creditScript.offset += 4;
          }
          while ( v7 != v5 );
          return;
        case 106:
          v6 = Credits_Related_3_Maybe((int)&creditScript.buffer[++creditScript.offset]);
          creditScript.offset += 4;
          break;
        case 126:
          ++creditScript.offset;
          fadeMusic();
          return;
        default:
          ++creditScript.offset;
          continue;
      }
      while ( creditScript.offset < creditScript.length )
      {
        if ( creditScript.buffer[creditScript.offset] == 108 )
        {
          v3 = Credits_Related_3_Maybe((int)&creditScript.buffer[++creditScript.offset]);
          creditScript.offset += 4;
          if ( v6 == v3 )
            return;
        }
        else if ( isShiftJIS(creditScript.buffer[creditScript.offset]) )
        {
          creditScript.offset += 2;
        }
        else
        {
          ++creditScript.offset;
        }
      }
    }
    break;
  }
}
// 40D620: using guessed type char destination[40];

//----- (0040DB00) --------------------------------------------------------
int __cdecl Credits_Related_3_Maybe(int a1)
{
  return 10 * (*(char *)(a1 + 2) - 48)
       + 100 * (*(char *)(a1 + 1) - 48)
       + 1000 * (*(char *)a1 - 48)
       + *(char *)(a1 + 3)
       - 48;
}

//----- (0040DB40) --------------------------------------------------------
void __cdecl setCreditIllustration(int num)
{
  loadCreditsIllustration(num);
  creditPicture.actionNumber = 1;
}

//----- (0040DB60) --------------------------------------------------------
void cutCreditIllustration()
{
  creditPicture.actionNumber = 2;
}

//----- (0040DB70) --------------------------------------------------------
// XX1 : Shows distant view of island
int __cdecl sceneIslandCrash(HWND hWnd, int mode)
{
  int Call_Escape_Ret; // [esp+4h] [ebp-50h]
  signed int wait; // [esp+8h] [ebp-4Ch]
  RECT Rect_Ground; // [esp+Ch] [ebp-48h]
  Position Sprite; // [esp+1Ch] [ebp-38h]
  RECT Rect_Frame; // [esp+24h] [ebp-30h]
  RECT Rect_Sky; // [esp+34h] [ebp-20h]
  RECT Rect_Sprite; // [esp+44h] [ebp-10h]

  Rect_Frame.left = 80;
  Rect_Frame.top = 80;
  Rect_Frame.right = 240;
  Rect_Frame.bottom = 160;
  Rect_Sky.left = 0;
  Rect_Sky.top = 0;
  Rect_Sky.right = 160;
  Rect_Sky.bottom = 80;
  Rect_Ground.left = 160;
  Rect_Ground.top = 48;
  Rect_Ground.right = 320;
  Rect_Ground.bottom = 80;
  Rect_Sprite.left = 160;
  Rect_Sprite.top = 0;
  Rect_Sprite.right = 200;
  Rect_Sprite.bottom = 24;
  Sprite.X = 0x15000;
  Sprite.Y = 0x8000;
  for ( wait = 0; wait < 900; ++wait )
  {
    getKeys();
    if ( keyHeld & 0x8000 )
    {
      Call_Escape_Ret = callOnEscape(hWnd);
      if ( !Call_Escape_Ret )
        return 0;
      if ( Call_Escape_Ret == 2 )
        return 2;
    }
    if ( mode )
    {
      if ( mode == 1 )
      {
        if ( wait >= 350 )
        {
          if ( wait >= 500 )
          {
            if ( wait >= 600 )
            {
              if ( wait == 750 )
                wait = 900;
            }
            else
            {
              Sprite.Y += 12;
            }
          }
          else
          {
            Sprite.Y += 25;
          }
        }
        else
        {
          Sprite.Y += 51;
        }
      }
    }
    else
    {
      Sprite.Y += 51;
    }
    drawColorFill(&rect, 0);
    drawBitmapWithTransparency(&Rect_Frame, 80, 80, &Rect_Sky, 21);
    drawBitmapWithTransparency(&Rect_Frame, Sprite.X / 512 - 20, Sprite.Y / 512 - 12, &Rect_Sprite, 21);
    drawBitmapWithTransparency(&Rect_Frame, 80, 128, &Rect_Ground, 21);
    drawNikamaruTimer(16, 8);
    displayFPSCounter();
    if ( !drawWindow(hWnd) )
      return 0;
  }
  return 1;
}
// 49E210: using guessed type int keyHeld;

//----- (0040DD70) --------------------------------------------------------
// Called On Esc
int __cdecl callOnEscape(HWND hWnd)
{
  RECT Src_Rects; // [esp+0h] [ebp-10h]

  Src_Rects.left = 0;
  Src_Rects.top = 128;
  Src_Rects.right = 208;
  Src_Rects.bottom = 144;
  do
  {
    getKeys();
    if ( keyPressed & 0x8000 )
    {
      keyPressed = 0;
      return 0;
    }
    if ( keyPressed & 0x400 )
    {
      keyPressed = 0;
      return 1;
    }
    if ( keyPressed & 0x800 )
    {
      keyPressed = 0;
      return 2;
    }
    drawColorFill(&rect, 0);
    drawBitmapWithTransparency(&rect, 56, 112, &Src_Rects, 26);
    displayFPSCounter();
  }
  while ( drawWindow(hWnd) );
  keyPressed = 0;
  return 0;
}
// 49E214: using guessed type int keyPressed;

//----- (0040DE60) --------------------------------------------------------
void __cdecl initFade()
{
  memset(&fadeObject, 0, 0x268u);
  Mask_Color = makeRGB(0x200000u);
}

//----- (0040DEA0) --------------------------------------------------------
void resetFadeVars()
{
  fadeObject.byteMask = 0;
  fadeObject.mode = 0;
}

//----- (0040DEC0) --------------------------------------------------------
void __cdecl startFadeOut(char Direction)
{
  signed int j; // [esp+0h] [ebp-8h]
  signed int i; // [esp+4h] [ebp-4h]

  fadeObject.mode = 2;
  fadeObject.count = 0;
  fadeObject.direction = Direction;
  fadeObject.byteMask = 0;
  for ( i = 0; i < 15; ++i )
  {
    for ( j = 0; j < 20; ++j )
    {
      fadeObject.animationNumber[i][j] = 0;
      fadeObject.flag[i][j] = 0;
    }
  }
}

//----- (0040DF50) --------------------------------------------------------
void __cdecl startFadeIn(char Direction)
{
  signed int j; // [esp+0h] [ebp-8h]
  signed int i; // [esp+4h] [ebp-4h]

  fadeObject.mode = 1;
  fadeObject.count = 0;
  fadeObject.direction = Direction;
  fadeObject.byteMask = 1;
  for ( i = 0; i < 15; ++i )
  {
    for ( j = 0; j < 20; ++j )
    {
      fadeObject.animationNumber[i][j] = 15;
      fadeObject.flag[i][j] = 0;
    }
  }
}

//----- (0040DFE0) --------------------------------------------------------
void __cdecl processFade()
{
  signed int x; // [esp+Ch] [ebp-8h]
  signed int xa; // [esp+Ch] [ebp-8h]
  signed int xb; // [esp+Ch] [ebp-8h]
  signed int xc; // [esp+Ch] [ebp-8h]
  signed int xd; // [esp+Ch] [ebp-8h]
  signed int xe; // [esp+Ch] [ebp-8h]
  signed int xf; // [esp+Ch] [ebp-8h]
  signed int xg; // [esp+Ch] [ebp-8h]
  signed int xr; // [esp+Ch] [ebp-8h]
  signed int xi; // [esp+Ch] [ebp-8h]
  signed int xj; // [esp+Ch] [ebp-8h]
  signed int xk; // [esp+Ch] [ebp-8h]
  signed int xl; // [esp+Ch] [ebp-8h]
  signed int xm; // [esp+Ch] [ebp-8h]
  signed int xn; // [esp+Ch] [ebp-8h]
  signed int xo; // [esp+Ch] [ebp-8h]
  signed int xp; // [esp+Ch] [ebp-8h]
  signed int xq; // [esp+Ch] [ebp-8h]
  signed int y; // [esp+10h] [ebp-4h]
  signed int ya; // [esp+10h] [ebp-4h]
  signed int yb; // [esp+10h] [ebp-4h]
  signed int yc; // [esp+10h] [ebp-4h]
  signed int yd; // [esp+10h] [ebp-4h]
  signed int ye; // [esp+10h] [ebp-4h]
  signed int yf; // [esp+10h] [ebp-4h]
  signed int yg; // [esp+10h] [ebp-4h]
  signed int yr; // [esp+10h] [ebp-4h]
  signed int yi; // [esp+10h] [ebp-4h]
  signed int yj; // [esp+10h] [ebp-4h]
  signed int yk; // [esp+10h] [ebp-4h]
  signed int yl; // [esp+10h] [ebp-4h]
  signed int ym; // [esp+10h] [ebp-4h]
  signed int yn; // [esp+10h] [ebp-4h]
  signed int yo; // [esp+10h] [ebp-4h]
  signed int yp; // [esp+10h] [ebp-4h]
  signed int yq; // [esp+10h] [ebp-4h]

  if ( fadeObject.mode == 1 )
  {
    fadeObject.byteMask = 0;
    switch ( fadeObject.direction )
    {
      case 0:
        for ( yi = 0; yi < 15; ++yi )
        {
          for ( xi = 0; xi < 20; ++xi )
          {
            if ( 19 - fadeObject.count == xi )
              fadeObject.flag[yi][xi] = 1;
          }
        }
        break;
      case 1:
        for ( yk = 0; yk < 15; ++yk )
        {
          for ( xk = 0; xk < 20; ++xk )
          {
            if ( 14 - fadeObject.count == yk )
              fadeObject.flag[yk][xk] = 1;
          }
        }
        break;
      case 2:
        for ( yj = 0; yj < 15; ++yj )
        {
          for ( xj = 0; xj < 20; ++xj )
          {
            if ( fadeObject.count == xj )
              fadeObject.flag[yj][xj] = 1;
          }
        }
        break;
      case 3:
        for ( yl = 0; yl < 15; ++yl )
        {
          for ( xl = 0; xl < 20; ++xl )
          {
            if ( fadeObject.count == yl )
              fadeObject.flag[yl][xl] = 1;
          }
        }
        break;
      case 4:
        for ( ym = 0; ym < 7; ++ym )
        {
          for ( xm = 0; xm < 10; ++xm )
          {
            if ( 19 - fadeObject.count == ym + xm )
              fadeObject.flag[ym][xm] = 1;
          }
        }
        for ( yn = 0; yn < 7; ++yn )
        {
          for ( xn = 10; xn < 20; ++xn )
          {
            if ( 19 - fadeObject.count == yn + 19 - xn )
              fadeObject.flag[yn][xn] = 1;
          }
        }
        for ( yo = 7; yo < 15; ++yo )
        {
          for ( xo = 0; xo < 10; ++xo )
          {
            if ( 19 - fadeObject.count == xo + 14 - yo )
              fadeObject.flag[yo][xo] = 1;
          }
        }
        for ( yp = 7; yp < 15; ++yp )
        {
          for ( xp = 10; xp < 20; ++xp )
          {
            if ( 19 - fadeObject.count == 14 - yp + 19 - xp )
              fadeObject.flag[yp][xp] = 1;
          }
        }
        break;
      default:
        break;
    }
    for ( yq = 0; yq < 15; ++yq )
    {
      for ( xq = 0; xq < 20; ++xq )
      {
        if ( fadeObject.animationNumber[yq][xq] > 0 && fadeObject.flag[yq][xq] )
          --fadeObject.animationNumber[yq][xq];
      }
    }
    if ( ++fadeObject.count > 36 )
      fadeObject.mode = 0;
  }
  else if ( fadeObject.mode == 2 )
  {
    switch ( fadeObject.direction )
    {
      case 0:
        for ( y = 0; y < 15; ++y )
        {
          for ( x = 0; x < 20; ++x )
          {
            if ( 19 - fadeObject.count == x )
              fadeObject.flag[y][x] = 1;
          }
        }
        break;
      case 1:
        for ( yb = 0; yb < 15; ++yb )
        {
          for ( xb = 0; xb < 20; ++xb )
          {
            if ( 14 - fadeObject.count == yb )
              fadeObject.flag[yb][xb] = 1;
          }
        }
        break;
      case 2:
        for ( ya = 0; ya < 15; ++ya )
        {
          for ( xa = 0; xa < 20; ++xa )
          {
            if ( fadeObject.count == xa )
              fadeObject.flag[ya][xa] = 1;
          }
        }
        break;
      case 3:
        for ( yc = 0; yc < 15; ++yc )
        {
          for ( xc = 0; xc < 20; ++xc )
          {
            if ( fadeObject.count == yc )
              fadeObject.flag[yc][xc] = 1;
          }
        }
        break;
      case 4:
        for ( yd = 0; yd < 7; ++yd )
        {
          for ( xd = 0; xd < 10; ++xd )
          {
            if ( fadeObject.count == yd + xd )
              fadeObject.flag[yd][xd] = 1;
          }
        }
        for ( ye = 0; ye < 7; ++ye )
        {
          for ( xe = 10; xe < 20; ++xe )
          {
            if ( fadeObject.count == ye + 19 - xe )
              fadeObject.flag[ye][xe] = 1;
          }
        }
        for ( yf = 7; yf < 15; ++yf )
        {
          for ( xf = 0; xf < 10; ++xf )
          {
            if ( fadeObject.count == xf + 14 - yf )
              fadeObject.flag[yf][xf] = 1;
          }
        }
        for ( yg = 7; yg < 15; ++yg )
        {
          for ( xg = 10; xg < 20; ++xg )
          {
            if ( fadeObject.count == 14 - yg + 19 - xg )
              fadeObject.flag[yg][xg] = 1;
          }
        }
        break;
      default:
        break;
    }
    for ( yr = 0; yr < 15; ++yr )
    {
      for ( xr = 0; xr < 20; ++xr )
      {
        if ( fadeObject.animationNumber[yr][xr] < 15 && fadeObject.flag[yr][xr] )
          ++fadeObject.animationNumber[yr][xr];
      }
    }
    if ( ++fadeObject.count > 36 )
    {
      fadeObject.byteMask = 1;
      fadeObject.mode = 0;
    }
  }
}

//----- (0040E770) --------------------------------------------------------
// Render Fade out / Fade in
void drawFadeOutIn()
{
  signed int x; // [esp+0h] [ebp-18h]
  signed int y; // [esp+4h] [ebp-14h]
  RECT rect; // [esp+8h] [ebp-10h]

  rect.top = 0;
  rect.bottom = 16;
  if ( fadeObject.byteMask )
  {
    drawColorFill(&gameRect, Mask_Color);
  }
  else if ( fadeObject.mode )
  {
    for ( y = 0; y < 15; ++y )
    {
      for ( x = 0; x < 20; ++x )
      {
        rect.left = 16 * fadeObject.animationNumber[y][x];
        rect.right = rect.left + 16;
        drawBitmapWithTransparency(&gameRect, 16 * x, 16 * y, &rect, 6);
      }
    }
  }
}

//----- (0040E830) --------------------------------------------------------
// If fade is happening, returns 1
bool getFadeMode()
{
  return fadeObject.mode != 0;
}

//----- (0040E850) --------------------------------------------------------
void *clearEventFlags()
{
  return memset(eventFlags, 0, 1000u);
}

//----- (0040E870) --------------------------------------------------------
void *__cdecl initSkipFlags()
{
  return memset(skipFlags, 0, 8u);
}

//----- (0040E890) --------------------------------------------------------
void __cdecl Set_NPC_Flag(signed int Flag_Num)
{
  eventFlags[Flag_Num / 8] |= 1 << Flag_Num % 8;
}

//----- (0040E8E0) --------------------------------------------------------
void __cdecl unsetNPCFlag(signed int Flag_To_Unset)
{
  eventFlags[Flag_To_Unset / 8] &= ~(1 << Flag_To_Unset % 8);
}

//----- (0040E930) --------------------------------------------------------
bool __cdecl getNPCFlag(signed int Flag_hashtag)
{
  return ((1 << Flag_hashtag % 8) & (unsigned __int8)eventFlags[Flag_hashtag / 8]) != 0;
}

//----- (0040E970) --------------------------------------------------------
void __cdecl setSkipFlag(signed int Flag_To_Set)
{
  skipFlags[Flag_To_Set / 8] |= 1 << Flag_To_Set % 8;
}

//----- (0040E9C0) --------------------------------------------------------
int __cdecl unsetSkipFlag(signed int Flag_To_Unset)
{
  int result; // eax

  result = Flag_To_Unset / 8;
  skipFlags[Flag_To_Unset / 8] &= ~(1 << Flag_To_Unset % 8);
  return result;
}

//----- (0040EA10) --------------------------------------------------------
bool __cdecl getSkipFlag(signed int a1)
{
  return ((1 << a1 % 8) & (unsigned __int8)skipFlags[a1 / 8]) != 0;
}

//----- (0040EA70) --------------------------------------------------------
void __cdecl startFlash(int X_Pos, int Y_Pos, int mode)
{
  Flash.act_no = 0;
  Flash.flashFlag = 1;
  Flash.XPos = X_Pos;
  Flash.YPos = Y_Pos;
  Flash.mode = mode;
  Flash.count = 0;
  Flash.width = 0;
}

//----- (0040EAC0) --------------------------------------------------------
int __cdecl updateBossExplosion(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+4h] [ebp-10h]
  int v4; // [esp+4h] [ebp-10h]
  int v5; // [esp+8h] [ebp-Ch]
  int v6; // [esp+Ch] [ebp-8h]
  int v7; // [esp+10h] [ebp-4h]
  int v8; // [esp+10h] [ebp-4h]

  result = Flash.act_no;
  if ( Flash.act_no )
  {
    if ( Flash.act_no == 1 )
    {
      Flash.width -= Flash.width / 8;
      if ( !(Flash.width / 256) )
        Flash.flashFlag = 0;
      v4 = (Flash.YPos - a2 - Flash.width) / 512;
      if ( v4 < 0 )
        v4 = 0;
      v8 = (Flash.width + Flash.YPos - a2) / 512;
      if ( v8 > 240 )
        v8 = 240;
      Flash.rect1.left = 0;
      Flash.rect1.right = 0;
      Flash.rect1.top = 0;
      Flash.rect1.bottom = 0;
      Flash.rect2.top = v4;
      result = v8;
      Flash.rect2.bottom = v8;
      Flash.rect2.left = 0;
      Flash.rect2.right = 320;
    }
  }
  else
  {
    Flash.count += 512;
    Flash.width += Flash.count;
    v6 = (Flash.XPos - a1 - Flash.width) / 512;
    v3 = (Flash.YPos - a2 - Flash.width) / 512;
    v5 = (Flash.width + Flash.XPos - a1) / 512;
    v7 = (Flash.width + Flash.YPos - a2) / 512;
    if ( v6 < 0 )
      v6 = 0;
    if ( v3 < 0 )
      v3 = 0;
    if ( v5 > 320 )
      v5 = 320;
    if ( v7 > 240 )
      v7 = 240;
    Flash.rect1.left = v6;
    Flash.rect1.right = v5;
    Flash.rect1.top = 0;
    Flash.rect1.bottom = 240;
    Flash.rect2.left = 0;
    Flash.rect2.right = 320;
    Flash.rect2.top = v3;
    result = v7;
    Flash.rect2.bottom = v7;
    if ( Flash.width > 655360 )
    {
      Flash.act_no = 1;
      Flash.count = 0;
      Flash.width = 122880;
    }
  }
  return result;
}

//----- (0040ED20) --------------------------------------------------------
int TSC_FLA_Handler()
{
  int result; // eax

  ++Flash.count;
  Flash.rect1.left = 0;
  Flash.rect1.right = 0;
  Flash.rect1.top = 0;
  Flash.rect1.bottom = 0;
  result = Flash.count / 2 % 2;
  if ( result )
  {
    Flash.rect2.top = 0;
    Flash.rect2.bottom = 240;
    Flash.rect2.left = 0;
    Flash.rect2.right = 320;
  }
  else
  {
    Flash.rect2.left = 0;
    Flash.rect2.right = 0;
    Flash.rect2.top = 0;
    Flash.rect2.bottom = 0;
  }
  if ( Flash.count > 20 )
    Flash.flashFlag = 0;
  return result;
}

//----- (0040EDE0) --------------------------------------------------------
int __cdecl mainWhiteScreenHandler(int a1, int a2)
{
  int result; // eax

  if ( Flash.flashFlag )
  {
    result = Flash.mode;
    if ( Flash.mode == 1 )
    {
      result = updateBossExplosion(a1, a2);
    }
    else if ( Flash.mode == 2 )
    {
      result = TSC_FLA_Handler();
    }
  }
  return result;
}

//----- (0040EE20) --------------------------------------------------------
void drawBossExplosion()
{
  if ( Flash.flashFlag )
  {
    drawColorFill(&Flash.rect1, FlashColor);
    drawColorFill(&Flash.rect2, FlashColor);
  }
}

//----- (0040EE70) --------------------------------------------------------
// The camera code. Handles quakes.
void __cdecl updateCamera()
{
  __int16 a2; // [esp+0h] [ebp-8h]
  __int16 a3; // [esp+4h] [ebp-4h]

  getMapData(0, &a2, &a3);
  gCamera.XPos += (*gCamera.targetXPos - 81920 - gCamera.XPos) / gCamera.moveTicks;
  gCamera.YPos += (*gCamera.targetYPos - 61440 - gCamera.YPos) / gCamera.moveTicks;
  if ( gCamera.XPos / 512 < 0 )
    gCamera.XPos = 0;
  if ( gCamera.YPos / 512 < 0 )
    gCamera.YPos = 0;
  if ( gCamera.XPos > (16 * (a2 - 1) - 320) << 9 )
    gCamera.XPos = (16 * (a2 - 1) - 320) << 9;
  if ( gCamera.YPos > (16 * (a3 - 1) - 240) << 9 )
    gCamera.YPos = (16 * (a3 - 1) - 240) << 9;
  if ( gCamera.hardQuakeDuration )              // If there is still time remaining to the hard quake
  {
    gCamera.XPos += random(-5, 5) << 9;
    gCamera.YPos += random(-3, 3) << 9;
    --gCamera.hardQuakeDuration;
  }
  else if ( gCamera.softQuakeDuration )         // If there is still time to the soft quake
  {
    gCamera.XPos += random(-1, 1) << 9;
    gCamera.YPos += random(-1, 1) << 9;
    --gCamera.softQuakeDuration;
  }
}

//----- (0040F020) --------------------------------------------------------
void __cdecl getCameraPosition(int *XPosDest, int *YPosDest)
{
  *XPosDest = gCamera.XPos;
  *YPosDest = gCamera.YPos;
}

//----- (0040F040) --------------------------------------------------------
// Unused
int __cdecl cameraUpdate(signed int a1, int arg4)
{
  int result; // eax
  _WORD a2[2]; // [esp+0h] [ebp-8h]
  _WORD a3[2]; // [esp+4h] [ebp-4h]

  gCamera.softQuakeDuration = 0;
  gCamera.hardQuakeDuration = 0;
  getMapData(0, a2, a3);
  gCamera.XPos = a1;
  gCamera.YPos = arg4;
  if ( a1 / 512 < 0 )
    gCamera.XPos = 0;
  if ( gCamera.YPos / 512 < 0 )
    gCamera.YPos = 0;
  if ( gCamera.XPos > (16 * (a2[0] - 1) - 320) << 9 )
    gCamera.XPos = (16 * (a2[0] - 1) - 320) << 9;
  result = (16 * (a3[0] - 1) - 240) << 9;
  if ( gCamera.YPos > result )
    gCamera.YPos = (16 * (a3[0] - 1) - 240) << 9;
  return result;
}

//----- (0040F130) --------------------------------------------------------
void __cdecl setCameraQuote()
{
  int quoteYPos; // [esp+0h] [ebp-10h]
  int quoteXPos; // [esp+4h] [ebp-Ch]
  signed __int16 currentMapWidth; // [esp+8h] [ebp-8h]
  signed __int16 currentMapLength; // [esp+Ch] [ebp-4h]

  getQuotePos(&quoteXPos, &quoteYPos);
  getMapData(0, &currentMapWidth, &currentMapLength);
  gCamera.XPos = quoteXPos - 81920;
  gCamera.YPos = quoteYPos - 61440;
  if ( (quoteXPos - 81920) / 512 < 0 )
    gCamera.XPos = 0;
  if ( gCamera.YPos / 512 < 0 )
    gCamera.YPos = 0;
  if ( gCamera.XPos > (16 * (currentMapWidth - 1) - 320) << 9 )
    gCamera.XPos = (16 * (currentMapWidth - 1) - 320) << 9;
  if ( gCamera.YPos > (16 * (currentMapLength - 1) - 240) << 9 )
    gCamera.YPos = (16 * (currentMapLength - 1) - 240) << 9;
}

//----- (0040F220) --------------------------------------------------------
// Sets camera move ticks
void __cdecl setCameraTargetQuote(int Ticks)
{
  gCamera.targetXPos = &quote.cameraXPos;
  gCamera.targetYPos = &quote.cameraYPos;
  gCamera.moveTicks = Ticks;
}

//----- (0040F250) --------------------------------------------------------
void __cdecl setCameraMoveTicks(int event, int Move_Ticks)
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 512 && NPCObjects[i].entityEventNum != event; ++i )
    ;
  if ( i != 512 )
  {
    gCamera.targetXPos = &NPCObjects[i].XPos;
    gCamera.targetYPos = &NPCObjects[i].YPos;
    gCamera.moveTicks = Move_Ticks;
  }
}

//----- (0040F2D0) --------------------------------------------------------
// FON : Focus camera on boss
void __cdecl TSC_FOB(int BossNum, int moveTicks)
{
  gCamera.targetXPos = &bossObjects[BossNum].XPos;
  gCamera.targetYPos = &bossObjects[BossNum].YPos;
  gCamera.moveTicks = moveTicks;
}

//----- (0040F310) --------------------------------------------------------
// QUA : Set Soft QUAke Duration
void __cdecl setQuake(int Duration)
{
  gCamera.softQuakeDuration = Duration;
}

//----- (0040F320) --------------------------------------------------------
void __cdecl setHardQuakeDuration(int Duration)
{
  gCamera.hardQuakeDuration = Duration;
}

//----- (0040F330) --------------------------------------------------------
void resetQuake()
{
  gCamera.softQuakeDuration = 0;
  gCamera.hardQuakeDuration = 0;
}

//----- (0040F350) --------------------------------------------------------
// Creates random number in given range
int __cdecl random(signed int Minimum, signed int Maximum)
{
  return Minimum + rand() % (Maximum - Minimum + 1);
}

//----- (0040F380) --------------------------------------------------------
void __cdecl drawNumbers(int XPos, int YPos, int numberToDisplay, int numberOfDigits)
{
  RECT rcView; // [esp+0h] [ebp-D0h]
  int v5; // [esp+10h] [ebp-C0h]
  int i; // [esp+14h] [ebp-BCh]
  int Rects; // [esp+18h] [ebp-B8h]
  int v8; // [esp+1Ch] [ebp-B4h]
  int v9; // [esp+20h] [ebp-B0h]
  int v10; // [esp+24h] [ebp-ACh]
  int v11; // [esp+28h] [ebp-A8h]
  int v12; // [esp+2Ch] [ebp-A4h]
  int v13; // [esp+30h] [ebp-A0h]
  int v14; // [esp+34h] [ebp-9Ch]
  int v15; // [esp+38h] [ebp-98h]
  int v16; // [esp+3Ch] [ebp-94h]
  int v17; // [esp+40h] [ebp-90h]
  int v18; // [esp+44h] [ebp-8Ch]
  int v19; // [esp+48h] [ebp-88h]
  int v20; // [esp+4Ch] [ebp-84h]
  int v21; // [esp+50h] [ebp-80h]
  int v22; // [esp+54h] [ebp-7Ch]
  int v23; // [esp+58h] [ebp-78h]
  int v24; // [esp+5Ch] [ebp-74h]
  int v25; // [esp+60h] [ebp-70h]
  int v26; // [esp+64h] [ebp-6Ch]
  int v27; // [esp+68h] [ebp-68h]
  int v28; // [esp+6Ch] [ebp-64h]
  int v29; // [esp+70h] [ebp-60h]
  int v30; // [esp+74h] [ebp-5Ch]
  int v31; // [esp+78h] [ebp-58h]
  int v32; // [esp+7Ch] [ebp-54h]
  int v33; // [esp+80h] [ebp-50h]
  int v34; // [esp+84h] [ebp-4Ch]
  int v35; // [esp+88h] [ebp-48h]
  int v36; // [esp+8Ch] [ebp-44h]
  int v37; // [esp+90h] [ebp-40h]
  int v38; // [esp+94h] [ebp-3Ch]
  int v39; // [esp+98h] [ebp-38h]
  int v40; // [esp+9Ch] [ebp-34h]
  int v41; // [esp+A0h] [ebp-30h]
  int v42; // [esp+A4h] [ebp-2Ch]
  int v43; // [esp+A8h] [ebp-28h]
  int v44; // [esp+ACh] [ebp-24h]
  int v45; // [esp+B0h] [ebp-20h]
  int v46; // [esp+B4h] [ebp-1Ch]
  int v47; // [esp+BCh] [ebp-14h]
  int v48; // [esp+C0h] [ebp-10h]
  int v49; // [esp+C4h] [ebp-Ch]
  int v50; // [esp+C8h] [ebp-8h]
  int v51; // [esp+CCh] [ebp-4h]

  rcView.left = 0;
  rcView.top = 0;
  rcView.right = 320;
  rcView.bottom = 240;
  Rects = 0;
  v8 = 56;
  v9 = 8;
  v10 = 64;
  v11 = 8;
  v12 = 56;
  v13 = 16;
  v14 = 64;
  v15 = 16;
  v16 = 56;
  v17 = 24;
  v18 = 64;
  v19 = 24;
  v20 = 56;
  v21 = 32;
  v22 = 64;
  v23 = 32;
  v24 = 56;
  v25 = 40;
  v26 = 64;
  v27 = 40;
  v28 = 56;
  v29 = 48;
  v30 = 64;
  v31 = 48;
  v32 = 56;
  v33 = 56;
  v34 = 64;
  v35 = 56;
  v36 = 56;
  v37 = 64;
  v38 = 64;
  v39 = 64;
  v40 = 56;
  v41 = 72;
  v42 = 64;
  v43 = 72;
  v44 = 56;
  v45 = 80;
  v46 = 64;
  v48 = 1000;
  v49 = 100;
  v50 = 10;
  v51 = 1;
  if ( numberToDisplay > 9999 )
    numberToDisplay = 9999;
  i = 0;
  v5 = 0;
  while ( i < 4 )
  {
    v47 = 0;
    while ( numberToDisplay >= *(&v48 + i) )
    {
      numberToDisplay -= *(&v48 + i);
      ++v47;
      ++v5;
    }
    if ( numberOfDigits && i == 2 || v5 || i == 3 )
      drawBitmapWithTransparency(&rcView, XPos + 8 * i, YPos, (RECT *)&Rects + v47, 26);
    ++i;
  }
}

//----- (0040F5F0) --------------------------------------------------------
// Updating game window, maintaining game loop, etc
int __cdecl gameModeSelector(HWND hWnd)
{
  int result; // eax
  char FileName[268]; // [esp+0h] [ebp-110h]
  int mode; // [esp+10Ch] [ebp-4h]

  if ( loadInitialResources() )
  {
    playSoundEffect(SFXSilence73, -1);
    sprintf(FileName, "%s\\npc.tbl", dataPath);
    if ( loadNPCTable(FileName) )
    {
      initTSC();
      initSkipFlags();
      initMapData();
      initCreditScript();
      mode = 1;
      while ( mode )
      {
        if ( mode == 1 )
          mode = gameModeOpeningCutscene();
        if ( mode == 2 )
          mode = gameModeTitleScreen();
        if ( mode == 3 )
          mode = gameModeMainGame(hWnd);
      }
      playSoundEffect(SFXSilence73, 0);
      deleteMapData();
      deleteTSC();
      deleteNPCTable();
      deleteCreditScript();
      if ( !isFullscreen )
        saveWindowRectFile(hWnd, "window.rect");
      result = 1;
    }
    else
    {
      MessageBoxA(hWnd, "NPCe\x81[u", "G\x81[", 0);// Loading unsuccesful
      result = 0;
    }
  }
  else
  {
    MessageBoxA(hWnd, "pt@C", "G\x81[", 0);
    result = 0;
  }
  return result;
}
// 49E460: using guessed type int isFullscreen;

//----- (0040F730) --------------------------------------------------------
signed int gameModeOpeningCutscene()
{
  int TSCParserRet; // [esp+0h] [ebp-14h]
  int v2; // [esp+4h] [ebp-10h]
  int cameraYPos; // [esp+8h] [ebp-Ch]
  unsigned int tickCount; // [esp+Ch] [ebp-8h]
  int cameraXPos; // [esp+10h] [ebp-4h]

  initNPCs();
  initEffects();
  initWhimsicalStar();
  initFade();
  initFlash();
  initBossLife();
  changeMusic(0);
  changeStage(72, 100, 3, 3);
  setCameraTargetQuote(16);
  setFadeMask();
  gameRect.left = 0;
  gameFlags = 3;
  cutNoise();
  tickCount = 0;
  while ( tickCount < 0x1F4 )
  {
    ++tickCount;
    getKeys();
    if ( keyHeld & 0x8000 )
    {
      v2 = callOnEscape(appWinHandle);
      if ( !v2 )
        return 0;
      if ( v2 == 2 )
        return 1;
    }
    if ( keyOk & keyHeld )
      break;
    updateNPCs();
    updateBoss();
    updateBackground();
    resetQuoteCollisionFlags();
    doCollisionCheckPlayerMap();
    doCollisionCheckPlayerNPCs();
    doCollisionCheckPlayerBosses();
    doCollisionCheckNPCsMap();
    doCollisionCheckBossesMap();
    doCollisionCheckBossesBullets();
    updateEffects();
    updateCamera();
    processFade();
    drawColorFill(&rect, 0);
    getCameraPosition(&cameraXPos, &cameraYPos);
    drawBackground(cameraXPos, cameraYPos);
    drawStageBackground(cameraXPos, cameraYPos);
    drawBoss(cameraXPos, cameraYPos);
    drawNPCs(cameraXPos, cameraYPos);
    drawMapDataVector(cameraXPos, cameraYPos);
    drawStageForeground(cameraXPos, cameraYPos);
    drawForeground(cameraXPos, cameraYPos);
    drawEffects(cameraXPos, cameraYPos);
    drawFadeOutIn();
    TSCParserRet = TSCParser();
    if ( !TSCParserRet )
      return 0;
    if ( TSCParserRet == 2 )
      return 1;
    drawMapName(0);
    drawTextBox();
    displayFPSCounter();
    if ( !drawWindow(appWinHandle) )
      return 0;
    ++gameTime;
  }
  tickCount = GetTickCount();
  while ( GetTickCount() < tickCount + 500 )
  {
    drawColorFill(&gameRect, 0);
    displayFPSCounter();
    if ( !drawWindow(appWinHandle) )
      return 0;
  }
  return 2;
}
// 493628: using guessed type int keyOk;
// 49E1E8: using guessed type int gameFlags;
// 49E1EC: using guessed type int gameTime;
// 49E210: using guessed type int keyHeld;

//----- (0040F9B0) --------------------------------------------------------
signed int gameModeTitleScreen()
{
  RECT *v1; // edx
  RECT *v2; // edx
  RECT *v3; // edx
  RECT *v4; // edx
  RECT *v5; // edx
  int v6; // [esp+4h] [ebp-1ECh]
  RECT rcQuote[4]; // [esp+8h] [ebp-1E8h]
  RECT rcSue[4]; // [esp+48h] [ebp-1A8h]
  int hellTime; // [esp+8Ch] [ebp-164h]
  RECT rcToroko[4]; // [esp+90h] [ebp-160h]
  int titleScreenMusic; // [esp+D4h] [ebp-11Ch]
  unsigned int tickCount; // [esp+D8h] [ebp-118h]
  RECT rcStudioPixelText; // [esp+DCh] [ebp-114h]
  RECT rect; // [esp+ECh] [ebp-104h]
  int YPos; // [esp+FCh] [ebp-F4h]
  RECT rcUnknown; // [esp+100h] [ebp-F0h]
  RECT rcCurly[4]; // [esp+110h] [ebp-E0h]
  int v18; // [esp+154h] [ebp-9Ch]
  RECT rcVersionDots; // [esp+158h] [ebp-98h]
  RECT rcKing[4]; // [esp+168h] [ebp-88h]
  int numberToDisplay; // [esp+1A8h] [ebp-48h]
  int v22; // [esp+1ACh] [ebp-44h]
  int maskColor; // [esp+1B0h] [ebp-40h]
  int graphicsID; // [esp+1B4h] [ebp-3Ch]
  RECT rcVersionText; // [esp+1B8h] [ebp-38h]
  int numbersToDisplay; // [esp+1C8h] [ebp-28h]
  int v27; // [esp+1CCh] [ebp-24h]
  RECT rcTitleScreen; // [esp+1D0h] [ebp-20h]
  RECT rcContinueButton; // [esp+1E0h] [ebp-10h]

  rcTitleScreen.left = 0;
  rcTitleScreen.top = 0;
  rcTitleScreen.right = 144;
  rcTitleScreen.bottom = 40;
  rcStudioPixelText.left = 0;
  rcStudioPixelText.top = 0;
  rcStudioPixelText.right = 160;
  rcStudioPixelText.bottom = 16;
  rcUnknown.left = 144;
  rcUnknown.top = 0;
  rcUnknown.right = 192;
  rcUnknown.bottom = 16;
  rcContinueButton.left = 144;
  rcContinueButton.top = 16;
  rcContinueButton.right = 192;
  rcContinueButton.bottom = 32;
  rcVersionText.left = 152;
  rcVersionText.top = 80;
  rcVersionText.right = 208;
  rcVersionText.bottom = 88;
  rcVersionDots.left = 152;
  rcVersionDots.top = 88;
  rcVersionDots.right = 208;
  rcVersionDots.bottom = 96;
  rcQuote[0].left = 0;
  rcQuote[0].top = 16;
  rcQuote[0].right = 16;
  rcQuote[0].bottom = 32;
  rcQuote[1].left = 16;
  rcQuote[1].top = 16;
  rcQuote[1].right = 32;
  rcQuote[1].bottom = 32;
  rcQuote[2].left = 0;
  rcQuote[2].top = 16;
  rcQuote[2].right = 16;
  rcQuote[2].bottom = 32;
  rcQuote[3].left = 32;
  rcQuote[3].top = 16;
  rcQuote[3].right = 48;
  rcQuote[3].bottom = 32;
  rcCurly[0].left = 0;
  rcCurly[0].top = 112;
  rcCurly[0].right = 16;
  rcCurly[0].bottom = 128;
  rcCurly[1].left = 16;
  rcCurly[1].top = 112;
  rcCurly[1].right = 32;
  rcCurly[1].bottom = 128;
  rcCurly[2].left = 0;
  rcCurly[2].top = 112;
  rcCurly[2].right = 16;
  rcCurly[2].bottom = 128;
  rcCurly[3].left = 32;
  rcCurly[3].top = 112;
  rcCurly[3].right = 48;
  rcCurly[3].bottom = 128;
  rcToroko[0].left = 64;
  rcToroko[0].top = 80;
  rcToroko[0].right = 80;
  rcToroko[0].bottom = 96;
  rcToroko[1].left = 80;
  rcToroko[1].top = 80;
  rcToroko[1].right = 96;
  rcToroko[1].bottom = 96;
  rcToroko[2].left = 64;
  rcToroko[2].top = 80;
  rcToroko[2].right = 80;
  rcToroko[2].bottom = 96;
  rcToroko[3].left = 96;
  rcToroko[3].top = 80;
  rcToroko[3].right = 112;
  rcToroko[3].bottom = 96;
  rcKing[0].left = 224;
  rcKing[0].top = 48;
  rcKing[0].right = 240;
  rcKing[0].bottom = 64;
  rcKing[1].left = 288;
  rcKing[1].top = 48;
  rcKing[1].right = 304;
  rcKing[1].bottom = 64;
  rcKing[2].left = 224;
  rcKing[2].top = 48;
  rcKing[2].right = 240;
  rcKing[2].bottom = 64;
  rcKing[3].left = 304;
  rcKing[3].top = 48;
  rcKing[3].right = 320;
  rcKing[3].bottom = 64;
  rcSue[0].left = 0;
  rcSue[0].top = 16;
  rcSue[0].right = 16;
  rcSue[0].bottom = 32;
  rcSue[1].left = 32;
  rcSue[1].top = 16;
  rcSue[1].right = 48;
  rcSue[1].bottom = 32;
  rcSue[2].left = 0;
  rcSue[2].top = 16;
  rcSue[2].right = 16;
  rcSue[2].bottom = 32;
  rcSue[3].left = 48;
  rcSue[3].top = 16;
  rcSue[3].right = 64;
  rcSue[3].bottom = 32;
  initEffects();
  initWhimsicalStar();
  cutNoise();
  v18 = 0;
  titleScreenMusic = 0;
  maskColor = makeRGB(0x202020u);
  getVersionNumber(&numbersToDisplay, &numberToDisplay, &v27, &v22);
  cursorPosition = checkForProfileDat() != 0;
  hellTime = getHellTime();
  if ( hellTime && hellTime < 18000 )
    titleScreenMusic = 1;
  if ( hellTime && hellTime < 15000 )
    titleScreenMusic = 2;
  if ( hellTime && hellTime < 12000 )
    titleScreenMusic = 3;
  if ( hellTime && hellTime < 9000 )
    titleScreenMusic = 4;
  switch ( titleScreenMusic )
  {
    case 1:
      changeMusic(musicRunningHell);
      break;
    case 2:
      changeMusic(musicTorokosTheme);
      break;
    case 3:
      changeMusic(musicWhite);
      break;
    case 4:
      changeMusic(musicSafety);
      break;
    default:
      changeMusic(musicCaveStory);
      break;
  }
  gameRect.left = 0;
  gameFlags = 0;
  quote.equippedItems |= 0x100u;
  tickCount = 0;
  while ( 1 )
  {
    if ( tickCount < 0xA )
      ++tickCount;
    getKeys();
    if ( tickCount >= 0xA )
    {
      if ( keyOk & keyPressed )
        break;
    }
    if ( keyHeld & 0x8000 )
    {
      v6 = callOnEscape(appWinHandle);
      if ( !v6 )
        return 0;
      if ( v6 == 2 )
        return 1;
    }
    if ( keyPressed & (keyDown | keyUp) )
    {
      playSoundEffect(SFXYNChangeChoice, 1);
      cursorPosition = cursorPosition == 0;
    }
    updateEffects();
    if ( ++v18 >= 40 )
      v18 = 0;
    drawColorFill(&gameRect, maskColor);
    drawBitmapWithTransparency(&gameRect, 100, 216, &rcVersionText, 26);
    drawBitmapWithTransparency(&gameRect, 156, 216, &rcVersionDots, 26);
    drawNumbers(140, 216, numbersToDisplay, 0);
    drawNumbers(156, 216, numberToDisplay, 0);
    drawNumbers(172, 216, v27, 0);
    drawNumbers(188, 216, v22, 0);
    drawBitmapWithTransparency(&gameRect, 88, 40, &rcTitleScreen, 0);
    drawBitmapWithTransparency(&gameRect, 136, 128, &rcUnknown, 0);
    drawBitmapWithTransparency(&gameRect, 136, 148, &rcContinueButton, 0);
    drawBitmapWithTransparency(&gameRect, 80, 192, &rcStudioPixelText, 1);
    switch ( titleScreenMusic )
    {
      case 0:
        v1 = &rcQuote[v18 / 10 % 4];
        rect.left = v1->left;
        rect.top = v1->top;
        rect.right = v1->right;
        rect.bottom = v1->bottom;
        graphicsID = 16;
        break;
      case 1:
        v2 = &rcCurly[v18 / 10 % 4];
        rect.left = v2->left;
        rect.top = v2->top;
        rect.right = v2->right;
        rect.bottom = v2->bottom;
        graphicsID = 23;
        break;
      case 2:
        v3 = &rcToroko[v18 / 10 % 4];
        rect.left = v3->left;
        rect.top = v3->top;
        rect.right = v3->right;
        rect.bottom = v3->bottom;
        graphicsID = 23;
        break;
      case 3:
        v4 = &rcKing[v18 / 10 % 4];
        rect.left = v4->left;
        rect.top = v4->top;
        rect.right = v4->right;
        rect.bottom = v4->bottom;
        graphicsID = 23;
        break;
      case 4:
        v5 = &rcSue[v18 / 10 % 4];
        rect.left = v5->left;
        rect.top = v5->top;
        rect.right = v5->right;
        rect.bottom = v5->bottom;
        graphicsID = 23;
        break;
      default:
        break;
    }
    if ( cursorPosition )
      YPos = 147;
    else
      YPos = 127;
    drawBitmapWithTransparency(&gameRect, 116, YPos, &rect, graphicsID);
    drawEffects(0, 0);
    if ( hellTime )
      drawNikamaruTimer(16, 8);
    displayFPSCounter();
    if ( !drawWindow(appWinHandle) )
      return 0;
  }
  playSoundEffect(SFXYNConfirm, 1);
  changeMusic(0);
  tickCount = GetTickCount();
  while ( GetTickCount() < tickCount + 1000 )
  {
    drawColorFill(&gameRect, 0);
    displayFPSCounter();
    if ( !drawWindow(appWinHandle) )
      return 0;
  }
  return 3;
}
// 493628: using guessed type int keyOk;
// 493634: using guessed type int keyUp;
// 49363C: using guessed type int keyDown;
// 49E1E8: using guessed type int gameFlags;
// 49E210: using guessed type int keyHeld;
// 49E214: using guessed type int keyPressed;

//----- (00410400) --------------------------------------------------------
// Main Game Loop
signed int __cdecl gameModeMainGame(HWND hWnd)
{
  signed int result; // eax
  int v2; // [esp+0h] [ebp-20h]
  signed int v3; // [esp+4h] [ebp-1Ch]
  signed int v4; // [esp+8h] [ebp-18h]
  int v5; // [esp+Ch] [ebp-14h]
  int cameraYPos; // [esp+10h] [ebp-10h]
  unsigned int v7; // [esp+14h] [ebp-Ch]
  int maskColor; // [esp+18h] [ebp-8h]
  int cameraXPos; // [esp+1Ch] [ebp-4h]

  maskColor = makeRGB(0x200000u);
  v7 = 1;
  gameTime = 0;
  gameRect.left = 0;
  gameFlags = 3;
  setQuoteinitialValues();
  initNPCs();
  resetWeapons();
  initEffects();
  initWhimsicalStar();
  initFade();
  initFlash();
  clearWeaponData();
  clearItemData();
  clearUnlockedStages();
  clearMapFlagArray();
  clearEventFlags();
  initBossLife();
  if ( cursorPosition )
  {
    if ( loadProfileDat(0) || initialiseGame(hWnd) )
    {
      while ( 1 )
      {
LABEL_8:
        getKeys();
        if ( keyPressed & 0x8000 )
        {
          v5 = callOnEscape(appWinHandle);
          if ( !v5 )
            return 0;
          if ( v5 == 2 )
            return 1;
        }
        if ( v7 % 2 && gameFlags & 1 )
        {
          if ( gameFlags & 2 )
            Player_Related_Maybe(1);
          else
            Player_Related_Maybe(0);
          doWhimsicalStar();
          updateNPCs();
          updateBoss();
          actValueView();
          updateBackground();
          resetQuoteCollisionFlags();
          doCollisionCheckPlayerMap();
          doCollisionCheckPlayerNPCs();
          doCollisionCheckPlayerBosses();
          doCollisionCheckNPCsMap();
          doCollisionCheckBossesMap();
          bulletTileCollisionAlgorithm();
          entityBulletCollision();
          doCollisionCheckBossesBullets();
          if ( gameFlags & 2 )
            shootBullet();
          runBulletCode();
          updateEffects();
          updateCamera();
          mainWhiteScreenHandler(cameraXPos, cameraYPos);
          if ( gameFlags & 2 )
            doPlayerAnimation(1);
          else
            doPlayerAnimation(0);
        }
        if ( gameFlags & 8 )
        {
          creditsRelatedMaybe();
          slideCreditsPicture();
          scrollCreditsText();
        }
        processFade();
        drawColorFill(&rect, maskColor);
        getCameraPosition(&cameraXPos, &cameraYPos);
        drawBackground(cameraXPos, cameraYPos);
        drawStageBackground(cameraXPos, cameraYPos);
        drawBoss(cameraXPos, cameraYPos);
        drawNPCs(cameraXPos, cameraYPos);
        renderBullets(cameraXPos, cameraYPos);
        drawQuoteAndGun(cameraXPos, cameraYPos);
        drawWhimsicalStar(cameraXPos, cameraYPos);
        drawMapDataVector(cameraXPos, cameraYPos);
        drawStageForeground(cameraXPos, cameraYPos);
        drawForeground(cameraXPos, cameraYPos);
        drawBossExplosion();
        drawEffects(cameraXPos, cameraYPos);
        putValueView(cameraXPos, cameraYPos);
        drawBossHealth();
        drawFadeOutIn();
        if ( !(gameFlags & 4) )
        {
          if ( keyMenu & keyPressed )
          {
            backupSurface(10, &gameRect);
            v4 = inventoryLoop();
            if ( !v4 )
              return 0;
            if ( v4 == 2 )
              return 1;
            quote.flags &= -2u;
          }
          else if ( quote.equippedItems & 2 && keyForMap & keyPressed )
          {
            backupSurface(10, &gameRect);
            v3 = gameLoopMap();
            if ( !v3 )
              return 0;
            if ( v3 == 2 )
              return 1;
          }
        }
        if ( gameFlags & 2 )
        {
          if ( keyNextWeapon & keyPressed )
          {
            switchWeaponForward();
          }
          else if ( keyPreviousWeapon & keyPressed )
          {
            switchWeaponBackwards();
          }
        }
        if ( v7 % 2 )
        {
          v2 = TSCParser();
          if ( !v2 )
            return 0;
          if ( v2 == 2 )
            return 1;
        }
        drawMapName(0);
        drawNikamaruTimer(16, 8);
        if ( gameFlags & 2 )
        {
          drawHealthBar(1);
          drawEXPBarAndMisc(1);
          drawUnderwaterTimer(120, 104);
          drawHUDWeaponIcons();
        }
        if ( gameFlags & 8 )
        {
          drawCreditsImage();
          drawFromSlot0x25CreditsTextMaybe();
        }
        drawTextBox();
        displayFPSCounter();
        if ( !drawWindow(appWinHandle) )
          break;
        ++gameTime;
      }
      result = 0;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    if ( initialiseGame(hWnd) )
      goto LABEL_8;
    result = 0;
  }
  return result;
}
// 493618: using guessed type int keyNextWeapon;
// 49361C: using guessed type int keyPreviousWeapon;
// 493620: using guessed type int keyMenu;
// 493624: using guessed type int keyForMap;
// 49E1E8: using guessed type int gameFlags;
// 49E1EC: using guessed type int gameTime;
// 49E214: using guessed type int keyPressed;

//----- (004108B0) --------------------------------------------------------
int __cdecl getBuildData(int *a1, _DWORD *a2, int *a3)
{
  int result; // eax
  int buf1; // [esp+0h] [ebp-4Ch]
  void *buf2; // [esp+14h] [ebp-38h]
  const char *v6; // [esp+18h] [ebp-34h]
  const char *v7; // [esp+1Ch] [ebp-30h]
  const char *v8; // [esp+20h] [ebp-2Ch]
  const char *v9; // [esp+24h] [ebp-28h]
  const char *v10; // [esp+28h] [ebp-24h]
  const char *v11; // [esp+2Ch] [ebp-20h]
  const char *v12; // [esp+30h] [ebp-1Ch]
  const char *v13; // [esp+34h] [ebp-18h]
  const char *v14; // [esp+38h] [ebp-14h]
  const char *v15; // [esp+3Ch] [ebp-10h]
  const char *v16; // [esp+40h] [ebp-Ch]
  const char *v17; // [esp+44h] [ebp-8h]
  int i; // [esp+48h] [ebp-4h]

  buf2 = "XXX";
  v6 = "Jan";
  v7 = "Feb";
  v8 = "Mar";
  v9 = "Apr";
  v10 = "May";
  v11 = "Jun";
  v12 = "Jul";
  v13 = "Aug";
  v14 = "Sep";
  v15 = "Oct";
  v16 = "Nov";
  v17 = "Dec";
  result = sscanf("Jun 12 2005", "%s %d %d", &buf1, a3, a1);
  for ( i = 0; i < 12; ++i )
  {
    result = memcmp(&buf1, *(&buf2 + i), 3u);
    if ( !result )
      break;
    result = i + 1;
  }
  *a2 = i;
  return result;
}

//----- (00410990) --------------------------------------------------------
int __cdecl getVersionNumber(int *a1, int *a2, int *a3, int *a4)
{
  CHAR tstrFilename; // [esp+0h] [ebp-128h]
  unsigned int puLen; // [esp+110h] [ebp-18h]
  LPVOID lpBuffer; // [esp+114h] [ebp-14h]
  int v8; // [esp+118h] [ebp-10h]
  DWORD dwHandle; // [esp+11Ch] [ebp-Ch]
  size_t size; // [esp+120h] [ebp-8h]
  void *ptr; // [esp+124h] [ebp-4h]

  ptr = 0;
  v8 = 0;
  GetModuleFileNameA(0, &tstrFilename, 0x104u);
  size = GetFileVersionInfoSizeA(&tstrFilename, &dwHandle);
  if ( size )
  {
    ptr = malloc(size);
    if ( ptr )
    {
      if ( GetFileVersionInfoA(&tstrFilename, 0, size, ptr) && VerQueryValueA(ptr, byte_48C42C, &lpBuffer, &puLen) )
      {
        *a1 = (unsigned __int16)(*((_DWORD *)lpBuffer + 2) >> 16);
        *a2 = (unsigned __int16)*((_DWORD *)lpBuffer + 2);
        *a3 = (unsigned __int16)(*((_DWORD *)lpBuffer + 3) >> 16);
        *a4 = (unsigned __int16)*((_DWORD *)lpBuffer + 3);
        v8 = 1;
      }
    }
  }
  if ( ptr )
    free(ptr);
  return v8;
}

//----- (00410AB0) --------------------------------------------------------
bool __cdecl openSndVol32(HWND windowHandle)
{
  int v2; // [esp-4h] [ebp-334h]
  int v3; // [esp-4h] [ebp-334h]
  char str[264]; // [esp+0h] [ebp-330h]
  const CHAR File; // [esp+108h] [ebp-228h]
  HINSTANCE v6; // [esp+214h] [ebp-11Ch]
  size_t i; // [esp+218h] [ebp-118h]
  HINSTANCE v8; // [esp+21Ch] [ebp-114h]
  CHAR string; // [esp+220h] [ebp-110h]

  GetSystemDirectoryA(str, 0x104u);
  sprintf((char *)&File, "%s\\Sndvol32.exe", v2);
  for ( i = strlen(str); str[i] != 92; --i )
    ;
  str[i] = 0;
  sprintf(&string, "%s\\Sndvol32.exe", v3);
  v6 = ShellExecuteA(windowHandle, "open", &File, 0, 0, 5);
  v8 = ShellExecuteA(windowHandle, "open", &string, 0, 0, 5);
  return (signed int)v6 > 32 || (signed int)v8 > 32;
}
// 410AB0: using guessed type CHAR str[264];

//----- (00410BC0) --------------------------------------------------------
// Unused
BOOL deleteDebugTxt()
{
  const CHAR FileName; // [esp+0h] [ebp-110h]

  sprintf((char *)&FileName, "%s\\debug.txt", exePath);
  return DeleteFileA(&FileName);
}

//----- (00410C10) --------------------------------------------------------
// Unused
signed int __cdecl debugPrint(int a1, int a2, int a3, int a4)
{
  char debug.txt; // [esp+0h] [ebp-110h]
  FILE *str; // [esp+10Ch] [ebp-4h]

  sprintf(&debug.txt, "%s\\debug.txt", exePath);
  str = fopen(&debug.txt, "a+t");
  if ( !str )
    return 0;
  fprintf(str, (FILE *)"%s,%d,%d,%d\n", a1, a2, a3, a4);
  fclose(str);
  return 1;
}

//----- (00410CA0) --------------------------------------------------------
// Check If Param Time 2 < Now < Param Time 1
// Unused
int __cdecl getDateLimit(PSCOPETABLE_ENTRY *System_Time_1, int System_Time_2)
{
  FILETIME FileTime1; // [esp+0h] [ebp-20h]
  FILETIME FileTime2; // [esp+8h] [ebp-18h]
  SYSTEMTIME SystemTime; // [esp+10h] [ebp-10h]

  GetSystemTime((LPSYSTEMTIME)&SystemTime);
  SystemTimeToFileTime((PSCOPETABLE_ENTRY *)&SystemTime, (LPFILETIME)&FileTime2);
  SystemTimeToFileTime(System_Time_1, (LPFILETIME)&FileTime1);
  if ( CompareFileTime((EH3_EXCEPTION_REGISTRATION *)&FileTime1, (EH3_EXCEPTION_REGISTRATION *)&FileTime2) >= 0 )
    return -1;
  SystemTimeToFileTime((PSCOPETABLE_ENTRY *)System_Time_2, (LPFILETIME)&FileTime1);
  return CompareFileTime((EH3_EXCEPTION_REGISTRATION *)&FileTime1, (EH3_EXCEPTION_REGISTRATION *)&FileTime2) <= 0;
}

//----- (00410D10) --------------------------------------------------------
signed int __cdecl doesFileExist(const char *fileName)
{
  char str; // [esp+0h] [ebp-110h]
  FILE *stream; // [esp+10Ch] [ebp-4h]

  sprintf(&str, "%s\\%s", exePath, fileName);
  stream = fopen(&str, "rb");
  if ( !stream )
    return 0;
  fclose(stream);
  return 1;
}

//----- (00410D80) --------------------------------------------------------
int __cdecl getFileSize(char *path)
{
  int File_Size; // ST1C_4
  HANDLE hObject; // [esp+4h] [ebp-4h]

  hObject = CreateFileA(path, 0, 1u, 0, 3u, 0x80u, 0);
  if ( hObject == (HANDLE)-1 )
    return -1;
  File_Size = GetFileSize(hObject, 0);
  CloseHandle(hObject);
  return File_Size;
}

//----- (00410DE0) --------------------------------------------------------
int __cdecl logError(int Error_String, int Error_Number)
{
  char FileName; // [esp+0h] [ebp-110h]
  FILE *stream; // [esp+10Ch] [ebp-4h]

  sprintf(&FileName, "%s\\%s", exePath, "error.log");
  if ( getFileSize(&FileName) > 102400 )
    DeleteFileA(&FileName);
  stream = fopen(&FileName, "a+t");
  if ( !stream )
    return 0;
  fprintf(stream, &::stream, Error_String, Error_Number);
  fclose(stream);
  return 1;
}

//----- (00410E90) --------------------------------------------------------
bool __cdecl isShiftJIS(unsigned __int8 a1)
{
  if ( (signed int)a1 >= '' && (signed int)a1 <= '' )
    return 1;
  if ( (signed int)a1 < '' || (signed int)a1 > '' )
    return 0;
  return 1;
}

//----- (00410EE0) --------------------------------------------------------
BOOL __cdecl centerWindow(HWND Window_Handle)
{
  RECT Rect; // [esp+0h] [ebp-3Ch]
  HWND hWnd; // [esp+10h] [ebp-2Ch]
  RECT v4; // [esp+14h] [ebp-28h]
  int X; // [esp+24h] [ebp-18h]
  int Y; // [esp+28h] [ebp-14h]
  int pvParam; // [esp+2Ch] [ebp-10h]
  int v8; // [esp+30h] [ebp-Ch]
  LONG v9; // [esp+34h] [ebp-8h]
  LONG v10; // [esp+38h] [ebp-4h]

  SystemParametersInfoA(0x30u, 0, &pvParam, 0);
  GetWindowRect(Window_Handle, &Rect);
  hWnd = GetParent(Window_Handle);
  if ( hWnd )
    GetWindowRect(hWnd, &v4);
  else
    SystemParametersInfoA(0x30u, 0, &v4, 0);
  X = v4.left + (v4.right - v4.left - (Rect.right - Rect.left)) / 2;
  Y = v4.top + (v4.bottom - v4.top - (Rect.bottom - Rect.top)) / 2;
  if ( X < pvParam )
    X = pvParam;
  if ( Y < v8 )
    Y = v8;
  if ( X + Rect.right - Rect.left > v9 )
    X = v9 - (Rect.right - Rect.left);
  if ( Y + Rect.bottom - Rect.top > v10 )
    Y = v10 - (Rect.bottom - Rect.top);
  return SetWindowPos(Window_Handle, 0, X, Y, 0, 0, 1u);
}

//----- (00410FE0) --------------------------------------------------------
int __cdecl Load_Window_Rects(HWND Window_Handle, int a2, int a3)
{
  char str; // [esp+0h] [ebp-148h]
  int v5; // [esp+110h] [ebp-38h]
  int v6; // [esp+114h] [ebp-34h]
  int v7; // [esp+118h] [ebp-30h]
  FILE *stream; // [esp+11Ch] [ebp-2Ch]
  int v9; // [esp+120h] [ebp-28h]
  int X; // [esp+124h] [ebp-24h]
  int Y; // [esp+128h] [ebp-20h]
  int v12; // [esp+12Ch] [ebp-1Ch]
  int v13; // [esp+130h] [ebp-18h]
  int buffer; // [esp+134h] [ebp-14h]
  int pvParam; // [esp+138h] [ebp-10h]
  int v16; // [esp+13Ch] [ebp-Ch]
  int v17; // [esp+140h] [ebp-8h]
  int v18; // [esp+144h] [ebp-4h]

  buffer = 1;
  sprintf(&str, (const char *)&::stream._base, exePath, a2);
  stream = fopen(&str, (const _TSCHAR *)&::stream._file);
  if ( stream )
  {
    fread(&X, 0x10u, 1u, stream);
    fread(&buffer, 4u, 1u, stream);
    fclose(stream);
    SystemParametersInfoA(0x30u, 0, &pvParam, 0);
    v7 = GetSystemMetrics(61);
    v5 = GetSystemMetrics(62);
    v6 = GetSystemMetrics(28);
    v9 = GetSystemMetrics(29);
    if ( v12 - X < v6 )
      v12 = v6 + X;
    if ( v13 - Y < v9 )
      v13 = v9 + Y;
    if ( v12 - X > v7 )
      v12 = v7 + X;
    if ( v13 - Y > v5 )
      v13 = v7 + Y;
    if ( X < pvParam )
    {
      v12 += pvParam - X;
      X = pvParam;
    }
    if ( Y < v16 )
    {
      v13 += v16 - Y;
      Y = v16;
    }
    if ( v12 > v17 )
    {
      X -= v12 - v17;
      v12 = v17;
    }
    if ( v13 > v18 )
    {
      Y -= v13 - v18;
      v13 = v18;
    }
    if ( a3 )
      MoveWindow(Window_Handle, X, Y, v12 - X, v13 - Y, 0);
    else
      SetWindowPos(Window_Handle, 0, X, Y, 0, 0, 1u);
  }
  if ( buffer == 3 )
  {
    if ( !ShowWindow(Window_Handle, 3) )
      return 0;
  }
  else
  {
    ShowWindow(Window_Handle, 1);
  }
  return 1;
}

//----- (004111F0) --------------------------------------------------------
int __cdecl saveWindowRectFile(HWND hWnd, const char *fileName)
{
  char str; // [esp+0h] [ebp-150h]
  WINDOWPLACEMENT wndpl; // [esp+110h] [ebp-40h]
  FILE *stream; // [esp+13Ch] [ebp-14h]
  RECT Rect; // [esp+140h] [ebp-10h]

  if ( !GetWindowPlacement(hWnd, (RECT *)&wndpl) )
    return 0;
  if ( wndpl.showCmd == 1 )
  {
    if ( !GetWindowRect(hWnd, &Rect) )
      return 0;
    wndpl.rcNormalPosition = Rect;
  }
  sprintf(&str, (const char *)&::stream._charbuf, exePath, fileName);
  stream = fopen(&str, (const _TSCHAR *)&::stream._tmpfname);
  if ( !stream )
    return 0;
  fwrite(&wndpl.rcNormalPosition, 0x10u, 1u, stream);
  fwrite(&wndpl.showCmd, 4u, 1u, stream);
  fclose(stream);
  return 1;
}

//----- (004112E0) --------------------------------------------------------
BOOL __cdecl isEnableBitmap(char *filename)
{
  int str; // [esp+0h] [ebp-1Ch]
  size_t len; // [esp+14h] [ebp-8h]
  FILE *stream; // [esp+18h] [ebp-4h]

  len = strlen(Image_Tag);
  stream = fopen(filename, "rb");
  if ( !stream )
    return 0;
  fseek((int)stream, (FILE *)-len, 2);
  fread(&str, 1u, len, stream);
  fclose(stream);
  return memcmp(&str, Image_Tag, len) == 0;
}

//----- (00411390) --------------------------------------------------------
// Loads initial resources (Called at Startup)
signed int loadInitialResources()
{
  char str; // [esp+0h] [ebp-50h]
  int bError; // [esp+48h] [ebp-8h]
  size_t pt_size; // [esp+4Ch] [ebp-4h]

  makeSurfaceFromResource("PIXEL", 1);
  bError = 0;
  if ( !makeSurfaceFromFile("MyChar", 16) )
    bError = 1;
  if ( !makeSurfaceFromFile("Title", 0) )
    bError = 1;
  if ( !makeSurfaceFromFile("ArmsImage", 12) )
    bError = 1;
  if ( !makeSurfaceFromFile("Arms", 11) )
    bError = 1;
  if ( !makeSurfaceFromFile("ItemImage", 8) )
    bError = 1;
  if ( !makeSurfaceFromFile("StageImage", 14) )
    bError = 1;
  if ( !makeSurfaceFromFile("Npc\\NpcSym", 20) )
    bError = 1;
  if ( !makeSurfaceFromFile("Npc\\NpcRegu", 23) )
    bError = 1;
  if ( !makeSurfaceFromFile("TextBox", 26) )
    bError = 1;
  if ( !makeSurfaceFromFile("Caret", 19) )
    bError = 1;
  if ( !makeSurfaceFromFile("Bullet", 17) )
    bError = 1;
  if ( !makeSurfaceFromFile("Face", 27) )
    bError = 1;
  if ( !makeSurfaceFromFile("Fade", 6) )
    bError = 1;
  makeSurfaceFromResource("CREDIT01", 36);
  if ( bError )
    return 0;
  makeBlankSurface(320, 240, 10, 1);
  makeBlankSurface(320, 240, 28, 0);
  makeBlankSurface(320, 240, 9, 1);
  makeBlankSurface(320, 240, 37, 0);
  makeBlankSurface(256, 256, 2, 0);
  makeBlankSurface(160, 16, 13, 0);
  makeBlankSurface(40, 240, 29, 0);
  makeBlankSurface(320, 240, 21, 0);
  makeBlankSurface(320, 240, 22, 0);
  makeBlankSurface(320, 240, 35, 0);
  pt_size = makePixtoneObject(&Snd_Data_Table, 2, 32);
  pt_size += makePixtoneObject(&Ptr_Sound, 2, 33);
  pt_size += makePixtoneObject(&dword_48FB00, 2, 34);
  pt_size += makePixtoneObject(&dword_48FBE0, 1, 15);
  pt_size += makePixtoneObject(&dword_48FC50, 1, 24);
  pt_size += makePixtoneObject(&dword_48FCC0, 1, 23);
  pt_size += makePixtoneObject(&dword_48FD30, 2, 50);
  pt_size += makePixtoneObject(&dword_48FE10, 2, 51);
  pt_size += makePixtoneObject(&dword_4907B0, 1, 1);
  pt_size += makePixtoneObject(&dword_4909E0, 1, 2);
  pt_size += makePixtoneObject(&dword_4911C0, 1, 29);
  pt_size += makePixtoneObject(&dword_4913F0, 1, 43);
  pt_size += makePixtoneObject(&dword_491460, 3, 44);
  pt_size += makePixtoneObject(&dword_4915B0, 1, 45);
  pt_size += makePixtoneObject(&dword_491620, 1, 46);
  pt_size += makePixtoneObject(&dword_491700, 1, 47);
  pt_size += makePixtoneObject(&dword_490EB0, 3, 35);
  pt_size += makePixtoneObject(&dword_491000, 3, 39);
  pt_size += makePixtoneObject(&dword_48FEF0, 2, 52);
  pt_size += makePixtoneObject(&dword_490580, 2, 53);
  pt_size += makePixtoneObject(&dword_48FFD0, 2, 70);
  pt_size += makePixtoneObject(&dword_4900B0, 2, 71);
  pt_size += makePixtoneObject(&dword_490190, 2, 72);
  pt_size += makePixtoneObject(&dword_490660, 1, 5);
  pt_size += makePixtoneObject(&dword_490740, 1, 11);
  pt_size += makePixtoneObject(&dword_490890, 1, 4);
  pt_size += makePixtoneObject(&dword_490D60, 2, 25);
  pt_size += makePixtoneObject(&dword_490E40, 1, 27);
  pt_size += makePixtoneObject(&dword_4910E0, 2, 28);
  pt_size += makePixtoneObject(&dword_490A50, 1, 14);
  pt_size += makePixtoneObject(&dword_490350, 2, 16);
  pt_size += makePixtoneObject(&dword_490430, 3, 17);
  pt_size += makePixtoneObject(&dword_490820, 1, 18);
  pt_size += makePixtoneObject(&dword_490900, 2, 20);
  pt_size += makePixtoneObject(&dword_4906D0, 1, 22);
  pt_size += makePixtoneObject(&dword_490B30, 2, 26);
  pt_size += makePixtoneObject(&dword_490C10, 1, 21);
  pt_size += makePixtoneObject(&dword_490C80, 2, 12);
  pt_size += makePixtoneObject(&dword_491230, 2, 38);
  pt_size += makePixtoneObject(&dword_491310, 1, 31);
  pt_size += makePixtoneObject(&dword_491380, 1, 42);
  pt_size += makePixtoneObject(&dword_491770, 1, 48);
  pt_size += makePixtoneObject(&unk_4917E0, 2, 49);
  pt_size += makePixtoneObject(&dword_4918C0, 1, 100);
  pt_size += makePixtoneObject(&dword_491930, 3, 101);
  pt_size += makePixtoneObject(&dword_491A80, 2, 54);
  pt_size += makePixtoneObject(&dword_491B60, 2, 102);
  pt_size += makePixtoneObject(&dword_491C40, 2, 103);
  pt_size += makePixtoneObject(&dword_491CB0, 1, 104);
  pt_size += makePixtoneObject(&dword_491D20, 1, 105);
  pt_size += makePixtoneObject(&dword_491D90, 2, 106);
  pt_size += makePixtoneObject(&dword_491E70, 1, 107);
  pt_size += makePixtoneObject(&dword_491EE0, 1, 30);
  pt_size += makePixtoneObject(&dword_491F50, 1, 108);
  pt_size += makePixtoneObject(&dword_491FC0, 1, 109);
  pt_size += makePixtoneObject(&dword_492030, 1, 110);
  pt_size += makePixtoneObject(&dword_4920A0, 1, 111);
  pt_size += makePixtoneObject(&dword_492110, 1, 112);
  pt_size += makePixtoneObject(&dword_492180, 1, 113);
  pt_size += makePixtoneObject(&dword_4921F0, 2, 114);
  pt_size += makePixtoneObject(&dword_4922D0, 2, 150);
  pt_size += makePixtoneObject(&dword_4923B0, 2, 151);
  pt_size += makePixtoneObject(&dword_492490, 1, 152);
  pt_size += makePixtoneObject(&dword_492500, 1, 153);
  pt_size += makePixtoneObject(&dword_492570, 2, 154);
  pt_size += makePixtoneObject(&dword_4929D0, 2, 155);
  pt_size += makePixtoneObject(&dword_492650, 2, 56);
  pt_size += makePixtoneObject(&dword_492730, 2, 40);
  pt_size += makePixtoneObject(&dword_492730, 2, 41);
  pt_size += makePixtoneObject(&dword_492810, 2, 37);
  pt_size += makePixtoneObject(&unk_4928F0, 2, 57);
  pt_size += makePixtoneObject(&dword_492AB0, 3, 115);
  pt_size += makePixtoneObject(&dword_492C00, 1, 104);
  pt_size += makePixtoneObject(&dword_492C70, 3, 116);
  pt_size += makePixtoneObject(&dword_492DC0, 2, 58);
  pt_size += makePixtoneObject(&dword_492EA0, 2, 55);
  pt_size += makePixtoneObject(&dword_492F80, 2, 117);
  pt_size += makePixtoneObject(&dword_493060, 1, 59);
  pt_size += makePixtoneObject(&dword_4930D0, 1, 60);
  pt_size += makePixtoneObject(&dword_493140, 1, 61);
  pt_size += makePixtoneObject(&dword_4931B0, 2, 62);
  pt_size += makePixtoneObject(&dword_493290, 2, 63);
  pt_size += makePixtoneObject(&dword_493370, 2, 64);
  pt_size += makePixtoneObject(&dword_493450, 1, 65);
  pt_size += makePixtoneObject(&dword_4934C0, 1, 3);
  pt_size += makePixtoneObject(&dword_493530, 1, 6);
  pt_size += makePixtoneObject(&dword_4935A0, 1, 7);
  sprintf(&str, "PixTone = %d byte", pt_size);
  return 1;
}

//----- (00411E10) --------------------------------------------------------
// Unused
int activateDirectInput()
{
  int result; // eax

  if ( dword_49E1F4 )
  {
    result = (*(int (__stdcall **)(int))(*(_DWORD *)dword_49E1F4 + 8))(dword_49E1F4);
    dword_49E1F4 = 0;
  }
  if ( DirectInputObj )
  {
    result = DirectInputObj->lpVtbl->Release(DirectInputObj);
    DirectInputObj = 0;
  }
  return result;
}
// 49E1F4: using guessed type int dword_49E1F4;

//----- (00411E60) --------------------------------------------------------
signed int __cdecl releaseDirectInput(int a1)
{
  if ( a1 == 1 )
  {
    if ( dword_49E1F4 )
      (*(void (__stdcall **)(int))(*(_DWORD *)dword_49E1F4 + 28))(dword_49E1F4);
  }
  else if ( dword_49E1F4 )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)dword_49E1F4 + 32))(dword_49E1F4);
  }
  return 1;
}
// 49E1F4: using guessed type int dword_49E1F4;

//----- (00411EB0) --------------------------------------------------------
bool __cdecl initDirectInput(HINSTANCE currentInstance, HWND windowHandle)
{
  bool result; // eax

  if ( DirectInputCreateA(currentInstance, 0x500u, &DirectInputObj, 0) )
    result = 0;
  else
    result = directInputSomething(windowHandle) != 0;
  return result;
}

//----- (00411EF0) --------------------------------------------------------
signed int __cdecl directInputSomething(HWND windowHandle)
{
  LPDIRECTINPUTA v2; // [esp+0h] [ebp-8h]
  int v3; // [esp+4h] [ebp-4h]

  v3 = 0;
  v2 = DirectInputObj;
  DirectInputObj->lpVtbl->AddRef(DirectInputObj);
  DirectInputObj->lpVtbl->EnumDevices(DirectInputObj, 4, (LPDIENUMDEVICESCALLBACKA)enumDevicesCallback, &v2, 1);
  if ( v2 )
  {
    ((void (__cdecl *)(LPDIRECTINPUTA))v2->lpVtbl->Release)(v2);
    v2 = 0;
  }
  if ( !v3 )
    return 0;
  dword_49E1F4 = v3;
  if ( (*(int (__cdecl **)(int, char *))(*(_DWORD *)v3 + 44))(v3, &byte_480D10) )
    return 0;
  if ( (*(int (__cdecl **)(int, HWND, signed int))(*(_DWORD *)dword_49E1F4 + 52))(dword_49E1F4, windowHandle, 9) )
    return 0;
  (*(void (__cdecl **)(int))(*(_DWORD *)dword_49E1F4 + 28))(dword_49E1F4);
  return 1;
}
// 480D10: using guessed type char byte_480D10;
// 49E1F4: using guessed type int dword_49E1F4;

//----- (00411FC0) --------------------------------------------------------
signed int __stdcall enumDevicesCallback(int a1, int a2)
{
  signed int result; // eax
  const CHAR OutputString; // [esp+0h] [ebp-108h]
  int v4; // [esp+104h] [ebp-4h]

  if ( !(dword_49E20C & 1) )
  {
    dword_49E20C |= 1u;
    dword_49E208 = a2;
  }
  if ( (*(int (__cdecl **)(_DWORD, int, int *, _DWORD))(**(_DWORD **)dword_49E208 + 12))(
         *(_DWORD *)dword_49E208,
         a1 + 4,
         &dword_49E204,
         0) )
  {
    *(_DWORD *)(dword_49E208 + 4) = 0;
    result = 1;
  }
  else
  {
    v4 = (**(int (__cdecl ***)(int, const char *, int *))dword_49E204)(dword_49E204, aVcdy_Dest, &dword_49E200);
    if ( v4 >= 0 )
    {
      if ( dword_49E204 )
      {
        (*(void (__cdecl **)(int))(*(_DWORD *)dword_49E204 + 8))(dword_49E204);
        dword_49E204 = 0;
      }
      *(_DWORD *)(dword_49E208 + 4) = dword_49E200;
      sprintf(
        (char *)&OutputString,
        "DeviceGUID = %x\n",
        *(_DWORD *)(a1 + 4),
        *(_DWORD *)(a1 + 8),
        *(_DWORD *)(a1 + 12),
        *(_DWORD *)(a1 + 16));
      OutputDebugStringA(&OutputString);
      result = 0;
    }
    else
    {
      dword_49E1F4 = 0;
      result = 1;
    }
  }
  return result;
}
// 49E1F4: using guessed type int dword_49E1F4;
// 49E200: using guessed type int dword_49E200;
// 49E204: using guessed type int dword_49E204;
// 49E208: using guessed type int dword_49E208;
// 49E20C: using guessed type int dword_49E20C;

//----- (004120F0) --------------------------------------------------------
signed int __cdecl getJoystickStatus(int a1)
{
  signed int i; // [esp+0h] [ebp-5Ch]
  int v3; // [esp+4h] [ebp-58h]
  int v4; // [esp+8h] [ebp-54h]
  char v5[32]; // [esp+34h] [ebp-28h]
  int v6; // [esp+58h] [ebp-4h]

  if ( !dword_49E1F4 )
    return 0;
  if ( (*(int (__cdecl **)(int))(*(_DWORD *)dword_49E1F4 + 100))(dword_49E1F4) )
    return 0;
  v6 = (*(int (__cdecl **)(int, signed int, int *))(*(_DWORD *)dword_49E1F4 + 36))(dword_49E1F4, 80, &v3);
  if ( v6 )
  {
    if ( v6 != DIERR_INPUTLOST )
      return 0;
    releaseDirectInput(0);
  }
  for ( i = 0; i < 32; ++i )
  {
    if ( v5[i] & 0x80 )
      *(_DWORD *)(a1 + 4 * i + 16) = 1;
    else
      *(_DWORD *)(a1 + 4 * i + 16) = 0;
  }
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)a1 = 0;
  if ( v3 >= dword_49E1F8 - 10000 )
  {
    if ( v3 > dword_49E1F8 + 10000 )
      *(_DWORD *)(a1 + 4) = 1;
  }
  else
  {
    *(_DWORD *)a1 = 1;
  }
  if ( v4 >= dword_49E1FC - 10000 )
  {
    if ( v4 > dword_49E1FC + 10000 )
      *(_DWORD *)(a1 + 12) = 1;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = 1;
  }
  return 1;
}
// 49E1F4: using guessed type int dword_49E1F4;
// 49E1F8: using guessed type int dword_49E1F8;
// 49E1FC: using guessed type int dword_49E1FC;
// 4120F0: using guessed type char var_28[32];

//----- (00412250) --------------------------------------------------------
signed int ResetJoystickStatus()
{
  int v1; // [esp+0h] [ebp-58h]
  int v2; // [esp+4h] [ebp-54h]
  int v3; // [esp+54h] [ebp-4h]

  if ( !dword_49E1F4 )
    return 0;
  if ( (*(int (__cdecl **)(int))(*(_DWORD *)dword_49E1F4 + 100))(dword_49E1F4) )
    return 0;
  v3 = (*(int (__cdecl **)(int, signed int, int *))(*(_DWORD *)dword_49E1F4 + 36))(dword_49E1F4, 80, &v1);
  if ( v3 )
  {
    if ( v3 != -2147024866 )
      return 0;
    releaseDirectInput(0);
  }
  dword_49E1F8 = v1;
  dword_49E1FC = v2;
  return 1;
}
// 49E1F4: using guessed type int dword_49E1F4;
// 49E1F8: using guessed type int dword_49E1F8;
// 49E1FC: using guessed type int dword_49E1FC;

//----- (004122E0) --------------------------------------------------------
void __cdecl getKeys()
{
  keyPressed = (lastKeyHeld ^ keyHeld) & keyHeld;
  lastKeyHeld = keyHeld;
}
// 49E210: using guessed type int keyHeld;
// 49E214: using guessed type int keyPressed;
// 49E218: using guessed type int lastKeyHeld;

//----- (00412320) --------------------------------------------------------
// Useless since it's already set
BOOL __cdecl setWindowTitle(HWND hWnd)
{
  const CHAR String; // [esp+0h] [ebp-108h]

  sprintf((char *)&String, "%s", windowName);
  return SetWindowTextA(hWnd, &String);
}

//----- (00412370) --------------------------------------------------------
void displayFPSCounter()
{
  int numberToDisplay; // ST10_4

  if ( FPSCounterEnabled )
  {
    numberToDisplay = countFPS();
    drawNumbers(280, 8, numberToDisplay, 0);
  }
}
// 49E464: using guessed type int FPSCounterEnabled;

//----- (004123A0) --------------------------------------------------------
int countFPS()
{
  unsigned int v0; // eax

  if ( dword_493644 )
  {
    Timer1000Ticks = GetTickCount();
    dword_493644 = 0;
  }
  v0 = GetTickCount();
  ++Timer1000Elapsed;
  if ( Timer1000Ticks + 1000 <= v0 )
  {
    Timer1000Ticks += 1000;
    Timer1000Time = Timer1000Elapsed;
    Timer1000Elapsed = 0;
  }
  return Timer1000Time;
}
// 493644: using guessed type int dword_493644;
// 49E46C: using guessed type int Timer1000Time;
// 49E470: using guessed type int Timer1000Elapsed;
// 49E474: using guessed type int Timer1000Ticks;

//----- (00412420) --------------------------------------------------------
// Creating game window, starting game
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  int result; // eax
  int v5; // esi
  int v6; // esi
  int v7; // esi
  int v8; // esi
  int v9; // ST2C_4
  int v10; // eax
  int v11; // ST1C_4
  int v12; // eax
  RECT rect; // [esp+1Ch] [ebp-124h]
  RECT v14; // [esp+2Ch] [ebp-114h]
  int v15; // [esp+3Ch] [ebp-104h]
  int bitsPerPixel; // [esp+40h] [ebp-100h]
  HMENU v17; // [esp+44h] [ebp-FCh]
  configDataFile config; // [esp+48h] [ebp-F8h]
  WNDCLASSEXA windowVars; // [esp+E8h] [ebp-58h]
  int X; // [esp+118h] [ebp-28h]
  int nHeight; // [esp+11Ch] [ebp-24h]
  int nWidth; // [esp+120h] [ebp-20h]
  int i; // [esp+124h] [ebp-1Ch]
  HWND windowHandle; // [esp+128h] [ebp-18h]
  int Y; // [esp+12Ch] [ebp-14h]
  int v26; // [esp+130h] [ebp-10h]
  int v27; // [esp+134h] [ebp-Ch]
  int v28; // [esp+138h] [ebp-8h]
  int v29; // [esp+13Ch] [ebp-4h]

  hObject = OpenMutexA(0x1F0001u, 0, pDoukutsu);
  if ( hObject )
  {
    CloseHandle(hObject);
    result = 0;
  }
  else
  {
    hMutex = CreateMutexA(0, 0, pDoukutsu);
    appInstance = hInstance;
    GetModuleFileNameA(0, exePath, 0x104u);
    PathRemoveFileSpecA(exePath);
    strcpy(dataPath, exePath);
    strcat(dataPath, "\\data");
    if ( !loadConfigData(&config) )
      setDefaultConfigData(&config);
    if ( config.attackButtonMode )
    {
      if ( config.attackButtonMode == 1 )
      {
        keyJump = 32;
        keyShoot = 64;
      }
    }
    else
    {
      keyJump = 64;
      keyShoot = 32;
    }
    if ( config.okButtonMode )
    {
      if ( config.okButtonMode == 1 )
      {
        keyOk = keyShoot;
        keyCancel = keyJump;
      }
    }
    else
    {
      keyOk = keyJump;
      keyCancel = keyShoot;
    }
    if ( doesFileExist("s_reverse") )
    {
      keyNextWeapon = 256;
      keyPreviousWeapon = 128;
    }
    if ( config.moveButtonMode )
    {
      if ( config.moveButtonMode == 1 )
      {
        keyLeft = 0x10000;
        keyUp = 0x180000;
        keyRight = 0x40000;
        keyDown = 0x20000;
      }
    }
    else
    {
      keyLeft = 1;
      keyUp = 4;
      keyRight = 2;
      keyDown = 8;
    }
    for ( i = 0; i < 8; ++i )
    {
      switch ( config.joystickButton[i] )
      {
        case 1:
          joystickButtonTable[i] = keyJump;
          break;
        case 2:
          joystickButtonTable[i] = keyShoot;
          break;
        case 3:
          joystickButtonTable[i] = keyNextWeapon;
          break;
        case 4:
          joystickButtonTable[i] = keyMenu;
          break;
        case 5:
          joystickButtonTable[i] = keyForMap;
          break;
        case 6:
          joystickButtonTable[i] = keyPreviousWeapon;
          break;
        default:
          continue;
      }
    }
    v26 = 0;
    v27 = 0;
    v28 = 320;
    v29 = 240;
    memset(&windowVars, 0, 0x30u);
    windowVars.cbSize = 48;
    windowVars.lpfnWndProc = windowProcedure;
    windowVars.hInstance = hInstance;
    windowVars.hbrBackground = (HBRUSH)GetStockObject(3);
    windowVars.lpszClassName = windowName;
    windowVars.hCursor = LoadCursorA(hInstance, "CURSOR_NORMAL");
    windowVars.hIcon = LoadIconA(hInstance, iconName);
    windowVars.hIconSm = LoadIconA(hInstance, "ICON_MINI");
    switch ( config.displayMode )
    {
      case 0:
      case 3:
      case 4:
        if ( RegisterClassExA(&windowVars) )
        {
          windowWidth = 640;
          windowHeight = 480;
          changeScreenOffsets(0, 0);
          v11 = GetSystemMetrics(1);
          v12 = GetSystemMetrics(0);
          windowHandle = CreateWindowExA(0, windowName, windowName, 0x90080000, 0, 0, v12, v11, 0, 0, hInstance, 0);
          appWinHandle = windowHandle;
          if ( windowHandle )
          {
            if ( config.displayMode )
            {
              if ( config.displayMode == 3 )
              {
                // 24-bit mode
                bitsPerPixel = 24;
              }
              else if ( config.displayMode == 4 )
              {
                // 32-bit mode
                bitsPerPixel = 32;
              }
            }
            else
            {
              // 16-bit mode
              bitsPerPixel = 16;
            }
            initDirectDraw(windowHandle, modeFullscreen, bitsPerPixel);
            isFullscreen = 1;
            ShowCursor(0);
            goto LABEL_57;
          }
          ReleaseMutex(hMutex);
          result = 0;
        }
        else
        {
          ReleaseMutex(hMutex);
          result = 0;
        }
        break;
      case 1:
      case 2:
        windowVars.lpszMenuName = "MENU_MAIN";
        if ( RegisterClassExA(&windowVars) )
        {
          if ( config.displayMode == 1 )
          {
            windowWidth = 320;
            windowHeight = 240;
          }
          else
          {
            windowWidth = 640;
            windowHeight = 480;
          }
          nWidth = windowWidth + 2 * GetSystemMetrics(7) + 2;
          v5 = GetSystemMetrics(8);
          v6 = GetSystemMetrics(4) + 2 * v5;
          nHeight = GetSystemMetrics(15) + windowHeight + v6 + 2;
          X = (GetSystemMetrics(0) - nWidth) / 2;
          Y = (GetSystemMetrics(1) - nHeight) / 2;
          v7 = GetSystemMetrics(8);
          v8 = GetSystemMetrics(4) + v7;
          v9 = v8 + GetSystemMetrics(15) + 1;
          v10 = GetSystemMetrics(7);
          changeScreenOffsets(v10 + 1, v9);
          // Generate main window
          windowHandle = CreateWindowExA(
                           0u,
                           windowName,
                           windowName,
                           0x10CA0000u,
                           X,
                           Y,
                           nWidth,
                           nHeight,
                           0,
                           0,
                           hInstance,
                           0);
          appWinHandle = windowHandle;
          if ( windowHandle )
          {
            v17 = GetMenu(windowHandle);
            if ( config.displayMode == 1 )
              initDirectDraw(windowHandle, mode320_40Windowed, 0);
            else
              initDirectDraw(windowHandle, mode640480Windowed, 0);
            goto LABEL_57;
          }
          ReleaseMutex(hMutex);
          result = 0;
        }
        else
        {
          ReleaseMutex(hMutex);
          result = 0;
        }
        break;
      default:
LABEL_57:
        v14.left = 0;
        v14.top = 0;
        v14.right = 64;
        v14.bottom = 8;
        rect.left = 0;
        rect.top = 0;
        rect.right = 320;
        rect.bottom = 240;
        v15 = makeSurfaceFromFile("Loading", 15);
        drawColorFill(&rect, 0);
        drawBitmapWithTransparency(&rect, 128, 116, &v14, 15);
        if ( drawWindow(appWinHandle) )
        {
          initDirectSound(windowHandle);
          if ( config.joystickMode && initDirectInput(hInstance, windowHandle) )
          {
            ResetJoystickStatus();
            useJoystick = 1;
          }
          initFontObject(config.fontName);
          initTriangleTable();
          gameModeSelector(windowHandle);
          deleteFontObject();
          deleteDirectSound();
          deleteDirectDraw(windowHandle);
          ReleaseMutex(hMutex);
          result = 1;
        }
        else
        {
          ReleaseMutex(hMutex);
          result = 1;
        }
        break;
    }
  }
  return result;
}
// 493610: using guessed type int keyJump;
// 493614: using guessed type int keyShoot;
// 493618: using guessed type int keyNextWeapon;
// 49361C: using guessed type int keyPreviousWeapon;
// 493620: using guessed type int keyMenu;
// 493624: using guessed type int keyForMap;
// 493628: using guessed type int keyOk;
// 49362C: using guessed type int keyCancel;
// 493630: using guessed type int keyLeft;
// 493634: using guessed type int keyUp;
// 493638: using guessed type int keyRight;
// 49363C: using guessed type int keyDown;
// 49E42C: using guessed type int joystickButtonTable[];
// 49E450: using guessed type int windowWidth;
// 49E454: using guessed type int windowHeight;
// 49E45C: using guessed type int useJoystick;
// 49E460: using guessed type int isFullscreen;

//----- (00412BC0) --------------------------------------------------------
void windowFocusLost()
{
  if ( canAcceptInput )
  {
    canAcceptInput = 0;
    stopOrganyaMusic();
    playStreamNoiseAndHelicopterBlades();
  }
  playSoundEffect(SFXSilence73, 0);
}
// 49E468: using guessed type int canAcceptInput;

//----- (00412BF0) --------------------------------------------------------
void windowFocusGained()
{
  if ( !canAcceptInput )
  {
    canAcceptInput = 1;
    stopOrganyaMusic();
    startOrganyaPlayback();
    playEnvironmentalSounds();
  }
  playSoundEffect(SFXSilence73, -1);
}
// 49E468: using guessed type int canAcceptInput;

//----- (00412C30) --------------------------------------------------------
signed int __cdecl loadDroppedProfile(int a1, HDROP a2)
{
  CHAR v3; // [esp+0h] [ebp-110h]
  HDROP v4; // [esp+10Ch] [ebp-4h]

  v4 = a2;
  if ( DragQueryFileA(a2, 0xFFFFFFFF, 0, 0) )
  {
    DragQueryFileA(v4, 0, &v3, 0x104u);
    loadProfileDat(&v3);
  }
  DragFinish(v4);
  return 1;
}

//----- (00412CA0) --------------------------------------------------------
LRESULT __stdcall windowProcedure(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam)
{
  HMENU hMenu; // ST38_4
  HIMC v5; // ST30_4
  bool actApp; // [esp+18h] [ebp-10h]
  HMENU v8; // [esp+20h] [ebp-8h]

  if ( Message > WM_KEYUP )
  {
    if ( Message > WM_DROPFILES )
    {
      if ( Message != WM_IME_NOTIFY )
        return DefWindowProcA(hWnd, Message, wParam, lParam);
      if ( wParam == 8 )
      {
        v5 = ImmGetContext(hWnd);
        ImmSetOpenStatus(v5, 0);
        ImmReleaseContext(hWnd, v5);
      }
    }
    else
    {
      switch ( Message )
      {
        case WM_DROPFILES:
          loadDroppedProfile((int)hWnd, (HDROP)wParam);
          break;
        case WM_COMMAND:
          switch ( (unsigned __int16)wParam )
          {
            case 0x9C41u:
              if ( DialogBoxParamA(appInstance, "DLG_YESNO", hWnd, (DLGPROC)yesNoDialog, (LPARAM)"Quit?") == 1 )
                PostMessageA(hWnd, 0x10u, 0, 0);
              break;
            case 0x9C42u:
              DialogBoxParamA(appInstance, "DLG_ABOUT", hWnd, aboutDialog, 0);
              break;
            case 0x9C44u:
              if ( !openSndVol32(hWnd) )
                MessageBoxA(hWnd, aGGkgebGarTsv, windowName, 0);
              break;
            case 0x9C45u:
              DialogBoxParamA(appInstance, "DLG_SAVE", hWnd, debugSaveButton, 0);
              break;
            case 0x9C47u:
              DialogBoxParamA(appInstance, "DLG_MUTE", hWnd, muteButton, 0);
              break;
            default:
              return 1;
          }
          break;
        case WM_SYSCOMMAND:
          if ( wParam != 61696 && wParam != 61760 && wParam != 61808 )
            DefWindowProcA(hWnd, Message, wParam, lParam);
          break;
        default:
          return DefWindowProcA(hWnd, Message, wParam, lParam);
      }
    }
  }
  else if ( Message == WM_KEYUP )
  {
    switch ( wParam )
    {
      case VK_SHIFT:
        keyHeld &= ~0x200u;
        break;
      case VK_ESCAPE:
        keyHeld &= ~0x8000u;
        break;
      case VK_LEFT:
        keyHeld &= ~1u;
        break;
      case VK_UP:
        keyHeld &= ~4u;
        break;
      case VK_RIGHT:
        keyHeld &= ~2u;
        break;
      case VK_DOWN:
        keyHeld &= ~8u;
        break;
      case 0x41u:
        keyHeld &= ~0x100u;
        break;
      case VK_CLEAR|0x40:
        keyHeld &= ~0x80000u;
        break;
      case VK_CONTROL|0x40:
        keyHeld &= ~0x1000u;
        break;
      case VK_PAUSE|0x40:
        keyHeld &= ~0x80u;
        break;
      case VK_JUNJA|0x40:
        keyHeld &= ~0x10u;
        break;
      case VK_FINAL|0x40:
        keyHeld &= ~0x20u;
        break;
      case VK_FINAL|VK_RBUTTON|0x40:
        keyHeld &= ~0x40u;
        break;
      case VK_F1:
        keyHeld &= ~0x400u;
        break;
      case VK_F2:
        keyHeld &= ~0x800u;
        break;
      case VK_RCONTROL|VK_FINAL:
        keyHeld &= ~0x100000u;
        break;
      case VK_LMENU|VK_FINAL:
        keyHeld &= ~0x10000u;
        break;
      case VK_LMENU|VK_FINAL|VK_RBUTTON:
        keyHeld &= ~0x20000u;
        break;
      case VK_RMENU|VK_FINAL|VK_RBUTTON:
        keyHeld &= ~0x40000u;
        break;
      default:
        return 1;
    }
  }
  else if ( Message > WM_CLOSE )
  {
    if ( Message != WM_KEYDOWN )
      return DefWindowProcA(hWnd, Message, wParam, lParam);
    switch ( wParam )
    {
      case VK_SHIFT:
        keyHeld |= 0x200u;
        break;
      case VK_ESCAPE:
        keyHeld |= 0x8000u;
        break;
      case VK_LEFT:
        keyHeld |= 1u;
        break;
      case VK_UP:
        keyHeld |= 4u;
        break;
      case VK_RIGHT:
        keyHeld |= 2u;
        break;
      case VK_DOWN:
        keyHeld |= 8u;
        break;
      case 0x41u:
        keyHeld |= 0x100u;
        break;
      case VK_CLEAR|0x40:
        keyHeld |= 0x80000u;
        break;
      case VK_CONTROL|0x40:
        keyHeld |= 0x1000u;
        break;
      case VK_PAUSE|0x40:
        keyHeld |= 0x80u;
        break;
      case VK_JUNJA|0x40:
        keyHeld |= 0x10u;
        break;
      case VK_FINAL|0x40:
        keyHeld |= 0x20u;
        break;
      case VK_FINAL|VK_RBUTTON|0x40:
        keyHeld |= 0x40u;
        break;
      case VK_F1:
        keyHeld |= 0x400u;
        break;
      case VK_F2:
        keyHeld |= 0x800u;
        break;
      case VK_F5:
        useJoystick = 0;
        break;
      case VK_RCONTROL|VK_FINAL:
        keyHeld |= 0x100000u;
        break;
      case VK_LMENU|VK_FINAL:
        keyHeld |= 0x10000u;
        break;
      case VK_LMENU|VK_FINAL|VK_RBUTTON:
        keyHeld |= 0x20000u;
        break;
      case VK_RMENU|VK_FINAL|VK_RBUTTON:
        keyHeld |= 0x40000u;
        break;
      default:
        return 1;
    }
  }
  else
  {
    switch ( Message )
    {
      case WM_CLOSE:
        stopOrganyaMusic();
        PostQuitMessage(0);
        break;
      case WM_CREATE:
        // Executed when created
        hMenu = GetMenu(hWnd);
        // Delete Debug Save menu
        DeleteMenu(hMenu, 40005u, 0);
        DrawMenuBar(hWnd);
        v8 = GetMenu(hWnd);
        if ( !doesFileExist("mute") )
          DeleteMenu(v8, 40007u, 0);
        DrawMenuBar(hWnd);
        if ( doesFileExist("fps") )
          FPSCounterEnabled = 1;
        if ( !isFullscreen )
          Load_Window_Rects(hWnd, (int)"window.rect", 0);
        setWindowTitle(hWnd);                   // Useless since it's already set
        break;
      case WM_ACTIVATE:
        if ( (_WORD)wParam )
        {
          if ( (signed int)(unsigned __int16)wParam > 0 && (signed int)(unsigned __int16)wParam <= 2 )
            actApp = HIWORD(wParam) == 0;
        }
        else
        {
          actApp = 0;
        }
        if ( actApp )
          windowFocusGained();
        else
          windowFocusLost();
        break;
      default:
        return DefWindowProcA(hWnd, Message, wParam, lParam);
    }
  }
  return 1;
}
// 49E20C: using guessed type int dword_49E20C;
// 49E210: using guessed type int keyHeld;
// 49E45C: using guessed type int useJoystick;
// 49E460: using guessed type int isFullscreen;
// 49E464: using guessed type int FPSCounterEnabled;

//----- (00413570) --------------------------------------------------------
signed int messageQueue(void)
{
  MSG Msg; // [esp+0h] [ebp-1Ch]

  while ( PeekMessageA((LPMSG)&Msg, 0, 0, 0, 0) || !canAcceptInput )
  {
    if ( !GetMessageA((LPMSG)&Msg, 0, 0, 0) )
      return 0;
    TranslateMessage((_STARTUPINFOA *)&Msg);
    DispatchMessageA((_STARTUPINFOA *)&Msg);
  }
  if ( useJoystick )
    joyStickProcedure();
  return 1;
}
// 49E45C: using guessed type int useJoystick;
// 49E468: using guessed type int canAcceptInput;

//----- (004135E0) --------------------------------------------------------
signed int joyStickProcedure()
{
  signed int result; // eax
  int v1; // [esp+0h] [ebp-98h]
  int v2; // [esp+4h] [ebp-94h]
  int v3; // [esp+8h] [ebp-90h]
  int v4; // [esp+Ch] [ebp-8Ch]
  int v5[33]; // [esp+10h] [ebp-88h]
  int i; // [esp+94h] [ebp-4h]

  result = getJoystickStatus((int)&v1);
  if ( result )
  {
    keyHeld &= 0x8C00u;
    if ( v1 )
    {
      keyHeld |= keyLeft;
    }
    else
    {
      result = keyHeld & ~keyLeft;
      keyHeld &= ~keyLeft;
    }
    if ( v2 )
      keyHeld |= keyRight;
    else
      keyHeld &= ~keyRight;
    if ( v3 )
    {
      result = keyUp | keyHeld;
      keyHeld |= keyUp;
    }
    else
    {
      keyHeld &= ~keyUp;
    }
    if ( v4 )
    {
      keyHeld |= keyDown;
    }
    else
    {
      result = keyHeld & ~keyDown;
      keyHeld &= ~keyDown;
    }
    for ( i = 0; i < 8; ++i )
    {
      result = keyHeld & ~joystickButtonTable[i];
      keyHeld &= ~joystickButtonTable[i];
    }
    for ( i = 0; i < 8; ++i )
    {
      if ( v5[i] )
      {
        result = i;
        keyHeld |= joystickButtonTable[i];
      }
    }
  }
  return result;
}
// 49362C: using guessed type int keyCancel;
// 493630: using guessed type int keyLeft;
// 493634: using guessed type int keyUp;
// 493638: using guessed type int keyRight;
// 49363C: using guessed type int keyDown;
// 49E20C: using guessed type int dword_49E20C;
// 49E210: using guessed type int keyHeld;
// 49E42C: using guessed type int joystickButtonTable[];
// 4135E0: using guessed type int var_88[33];

//----- (00413750) --------------------------------------------------------
// Reserves memory for PXM Data
signed int initMapData()
{
  currentMap.data = (unsigned __int8 *)malloc(307200u);
  return 1;
}

//----- (00413770) --------------------------------------------------------
// Load PXM file
signed int __cdecl loadMapData(char *path_map)
{
  signed int result; // eax
  char path[260]; // [esp+0h] [ebp-118h]
  unsigned __int8 dum; // [esp+10Fh] [ebp-9h]
  FILE *stream; // [esp+110h] [ebp-8h]
  char check[3]; // [esp+114h] [ebp-4h]

  sprintf(path, "%s\\%s", dataPath, path_map);
  stream = fopen(path, "rb");
  if ( !stream )
    return 0;
  fread(check, 1u, 3u, stream);
  // Inverting this if() statement will break the de-compiler. Do not do that.
  if ( !memcmp(check, PXM, 3u) )
  {
    fread(&dum, 1u, 1u, stream);
    fread(&currentMap.width, 2u, 1u, stream);
    fread(&currentMap.length, 2u, 1u, stream);
    if ( currentMap.data )
    {
      fread(currentMap.data, 1u, currentMap.length * currentMap.width, stream);
      fclose(stream);
      result = 1;
    }
    else
    {
      fclose(stream);
      result = 0;
    }
  }
  else
  {
    fclose(stream);
    result = 0;
  }
  return result;
}

//----- (004138A0) --------------------------------------------------------
// Loads PXA file
signed int __cdecl loadAttributeData(char *stageName)
{
  char path[260]; // [esp+0h] [ebp-110h]
  FILE *stream; // [esp+10Ch] [ebp-4h]

  sprintf(path, "%s\\%s", dataPath, stageName);
  stream = fopen(path, "rb");
  if ( !stream )
    return 0;
  fread(currentMap.mapLayoutBuffer, 1u, 256u, stream);
  fclose(stream);
  return 1;
}

//----- (00413930) --------------------------------------------------------
void deleteMapData()
{
  free(currentMap.data);
}

//----- (00413960) --------------------------------------------------------
void __cdecl getMapData(unsigned __int8 **data, __int16 *Map_Width, __int16 *Map_Height)
{
  if ( data )
    *data = currentMap.data;
  if ( Map_Width )
    *Map_Width = currentMap.width;
  if ( Map_Height )
    *Map_Height = currentMap.length;
}

//----- (004139A0) --------------------------------------------------------
unsigned __int8 __cdecl getTileAttributes(signed int X_Pos, signed int Y_Pos)
{
  unsigned __int8 result; // al

  if ( X_Pos >= 0 && Y_Pos >= 0 && X_Pos < currentMap.width && Y_Pos < currentMap.length )// Make sure coordinates are valid
    // Get coordinates from PXM file
    result = currentMap.mapLayoutBuffer[currentMap.data[X_Pos + Y_Pos * currentMap.width]];
  else
    // Coordinates are invalid
    result = 0;
  return result;
}

//----- (00413A00) --------------------------------------------------------
void __cdecl deleteTile(int XPos, int YPos)
{
  currentMap.data[XPos + YPos * currentMap.width] = 0;
}

//----- (00413A20) --------------------------------------------------------
// TSC SMP : Shift Map Parts
void __cdecl shiftMapParts(int X_Pos, int Y_pos)
{
  --currentMap.data[X_Pos + Y_pos * currentMap.width];
}

//----- (00413A60) --------------------------------------------------------
// TSC CMP : Change Map Parts
signed int __cdecl changeMapParts(int X_Pos, int Y_Pos, unsigned __int8 New_NPC)
{
  signed int i; // [esp+0h] [ebp-4h]

  if ( currentMap.data[X_Pos + Y_Pos * currentMap.width] == New_NPC )
    return 0;
  currentMap.data[X_Pos + Y_Pos * currentMap.width] = New_NPC;
  for ( i = 0; i < 3; ++i )
    createNPC(NPCSmoke, X_Pos << 13, Y_Pos << 13, 0, 0, 0, 0, 0);
  return 1;
}

//----- (00413AF0) --------------------------------------------------------
void __cdecl drawStageBackground(signed int Camera_X, signed int Camera_Y)
{
  int i; // [esp+0h] [ebp-30h]
  int offset; // [esp+Ch] [ebp-24h]
  int j; // [esp+18h] [ebp-18h]
  RECT rect; // [esp+1Ch] [ebp-14h]
  int Num_X; // [esp+2Ch] [ebp-4h]

  Num_X = 21;
  for ( i = (Camera_Y / 512 + 8) / 16; i < (Camera_Y / 512 + 8) / 16 + 16; ++i )
  {
    for ( j = (Camera_X / 512 + 8) / 16; j < Num_X + (Camera_X / 512 + 8) / 16; ++j )
    {
      offset = j + i * currentMap.width;
      if ( (signed int)getTileAttributes(j, i) < 32 )
      {
        rect.left = 16 * (currentMap.data[offset] % 16);
        rect.top = 16 * ((signed int)currentMap.data[offset] >> 4);
        rect.right = rect.left + 16;
        rect.bottom = rect.top + 16;
        drawBitmapWithTransparency(&gameRect, 16 * j - 8 - Camera_X / 512, 16 * i - 8 - Camera_Y / 512, &rect, 2);
      }
    }
  }
}

//----- (00413C60) --------------------------------------------------------
void __cdecl drawStageForeground(signed int Camera_X, signed int Camera_Y)
{
  int i; // [esp+0h] [ebp-40h]
  signed int Attributes; // [esp+8h] [ebp-38h]
  RECT rcSnack; // [esp+Ch] [ebp-34h]
  int offset; // [esp+1Ch] [ebp-24h]
  int put_X; // [esp+20h] [ebp-20h]
  int put_Y; // [esp+24h] [ebp-1Ch]
  int j; // [esp+28h] [ebp-18h]
  RECT rect; // [esp+2Ch] [ebp-14h]
  int num_X; // [esp+3Ch] [ebp-4h]

  rcSnack.left = 256;
  rcSnack.top = 48;
  rcSnack.right = 272;
  rcSnack.bottom = 64;
  num_X = 21;
  put_X = (Camera_X / 512 + 8) / 16;
  put_Y = (Camera_Y / 512 + 8) / 16;
  for ( i = (Camera_Y / 512 + 8) / 16; i < put_Y + 16; ++i )
  {
    for ( j = put_X; j < num_X + put_X; ++j )
    {
      offset = j + i * currentMap.width;
      Attributes = getTileAttributes(j, i);
      if ( Attributes >= 64 && Attributes < 128 )
      {
        rect.left = 16 * (currentMap.data[offset] % 16);
        rect.top = 16 * ((signed int)currentMap.data[offset] >> 4);
        rect.right = rect.left + 16;
        rect.bottom = rect.top + 16;
        drawBitmapWithTransparency(&gameRect, 16 * j - 8 - Camera_X / 512, 16 * i - 8 - Camera_Y / 512, &rect, 2);
        if ( Attributes == 67 )
          drawBitmapWithTransparency(&gameRect, 16 * j - 8 - Camera_X / 512, 16 * i - 8 - Camera_Y / 512, &rcSnack, 20);
      }
    }
  }
}

//----- (00413E40) --------------------------------------------------------
void __cdecl drawMapDataVector(signed int Camera_X, signed int Camera_Y)
{
  int temp1; // ecx MAPDST
  int i; // [esp+4h] [ebp-30h]
  int Attributes; // [esp+Ch] [ebp-28h]
  int j; // [esp+1Ch] [ebp-18h]
  RECT rect; // [esp+20h] [ebp-14h]
  int num_X; // [esp+30h] [ebp-4h]

  Draw_Map_Data_Vector::count += 2;
  num_X = 21;
  for ( i = (Camera_Y / 512 + 8) / 16; i < (Camera_Y / 512 + 8) / 16 + 16; ++i )
  {
    for ( j = (Camera_X / 512 + 8) / 16; j < num_X + (Camera_X / 512 + 8) / 16; ++j )
    {
      Attributes = getTileAttributes(j, i);
      if ( Attributes == 0x80
        || Attributes == 0x81
        || Attributes == 0x82
        || Attributes == 0x83
        || Attributes == 0xA0
        || Attributes == 0xA1
        || Attributes == 0xA2
        || Attributes == 0xA3 )
      {
        switch ( Attributes )
        {
          case 0x80:
          case 0xA0:
            temp1 = (unsigned __int8)Draw_Map_Data_Vector::count % 16;
            rect.left = temp1 + 224;
            rect.right = temp1 + 240;
            rect.top = 48;
            rect.bottom = 64;
            break;
          case 0x81:
          case 0xA1:
            rect.left = 224;
            rect.right = 240;
            temp1 = (unsigned __int8)Draw_Map_Data_Vector::count % 16;
            rect.top = temp1 + 48;
            rect.bottom = temp1 + 64;
            break;
          case 0x82:
          case 0xA2:
            rect.left = 240 - (unsigned __int8)Draw_Map_Data_Vector::count % 16;
            rect.right = rect.left + 16;
            rect.top = 48;
            rect.bottom = 64;
            break;
          case 0x83:
          case 0xA3:
            rect.left = 224;
            rect.right = 240;
            rect.top = 64 - (unsigned __int8)Draw_Map_Data_Vector::count % 16;
            rect.bottom = rect.top + 16;
            break;
          default:
            break;
        }
        drawBitmapWithTransparency(&gameRect, 16 * j - 8 - Camera_X / 512, 16 * i - 8 - Camera_Y / 512, &rect, 19);
      }
    }
  }
}
// 49E58C: using guessed type char Draw_Map_Data_Vector::count;

//----- (004140F0) --------------------------------------------------------
void __cdecl readyMapName(char *_name)
{
  char name[24]; // [esp+0h] [ebp-20h]
  int i; // [esp+1Ch] [ebp-4h]

  name[0] = 31;
  name[1] = 31;
  name[2] = 82;
  name[3] = -141;
  name[4] = -140;
  name[5] = 99;
  name[6] = 104;
  name[7] = 110;
  name[8] = 31;
  name[9] = 79;
  name[10] = 104;
  name[11] = 119;
  name[12] = 100;
  name[13] = 107;
  name[14] = 31;
  name[15] = 111;
  name[16] = 113;
  name[17] = 100;
  name[18] = 114;
  name[19] = 100;
  name[20] = 109;
  name[21] = 115;
  name[22] = 114;
  name[23] = 255;
  Map_Name.flag = 0;
  Map_Name.wait = 0;
  if ( !strcmp(_name, "u") )
  {
    for ( i = 0; i < 24; ++i )
      ++name[i];
    _name = name;
  }
  strcpy(Map_Name.name, _name);
  i = strlen(Map_Name.name);
  drawColorFillOntoSurface(&stru_493650, 0, 13);
  drawStringOntoSurface((160 - 6 * i) / 2 + 6, 1, Map_Name.name, 0x220011u, 13);
  drawStringOntoSurface((160 - 6 * i) / 2 + 6, 0, Map_Name.name, 0xFEFFFFu, 13);
}

//----- (00414250) --------------------------------------------------------
// MNA : Render Map Name
void __cdecl drawMapName(int bMini)
{
  RECT rcBack; // [esp+0h] [ebp-20h]
  RECT v1; // [esp+10h] [ebp-10h]

  v1.left = 0;
  v1.top = 0;
  v1.right = 160;
  v1.bottom = 16;
  if ( bMini )
  {
    rcBack.left = 0;
    rcBack.right = 320;
    rcBack.top = 7;
    rcBack.bottom = 24;
    drawColorFill(&rcBack, 0);
    drawBitmapWithTransparency(&gameRect, 74, 10, &stru_493650, 13);
  }
  else if ( Map_Name.flag )
  {
    drawBitmapWithTransparency(&gameRect, 74, 80, &stru_493650, 13);
    if ( ++Map_Name.wait > 160 )
      Map_Name.flag = 0;
  }
}

//----- (00414310) --------------------------------------------------------
void startMapName()
{
  Map_Name.flag = 1;
  Map_Name.wait = 0;
}

//----- (00414330) --------------------------------------------------------
int redrawRoomTextToSurface()
{
  size_t v0; // ST14_4

  v0 = strlen(Map_Name.name);
  drawColorFillOntoSurface(&stru_493650, 0, 13);
  drawStringOntoSurface((signed int)(160 - 6 * v0) / 2 + 6, 1, Map_Name.name, 0x220011u, 13);
  return drawStringOntoSurface((signed int)(160 - 6 * v0) / 2 + 6, 0, Map_Name.name, 0xFEFFFFu, 13);
}

//----- (004143C0) --------------------------------------------------------
void __cdecl Render_Map_System_Green_Stuff(LONG a1)
{
  int v1; // [esp+0h] [ebp-48h]
  int v2; // [esp+4h] [ebp-44h]
  int v3; // [esp+8h] [ebp-40h]
  int v4; // [esp+Ch] [ebp-3Ch]
  int v5; // [esp+10h] [ebp-38h]
  int v6; // [esp+14h] [ebp-34h]
  int v7; // [esp+18h] [ebp-30h]
  int v8; // [esp+1Ch] [ebp-2Ch]
  int v9; // [esp+20h] [ebp-28h]
  int v10; // [esp+24h] [ebp-24h]
  int v11; // [esp+28h] [ebp-20h]
  int v12; // [esp+2Ch] [ebp-1Ch]
  int v13; // [esp+30h] [ebp-18h]
  int v14; // [esp+34h] [ebp-14h]
  int v15; // [esp+38h] [ebp-10h]
  int v16; // [esp+3Ch] [ebp-Ch]
  int i; // [esp+40h] [ebp-8h]
  unsigned __int8 v18; // [esp+47h] [ebp-1h]

  v1 = 240;
  v2 = 24;
  v3 = 241;
  v4 = 25;
  v5 = 241;
  v6 = 24;
  v7 = 242;
  v8 = 25;
  v9 = 242;
  v10 = 24;
  v11 = 243;
  v12 = 25;
  v13 = 243;
  v14 = 24;
  v15 = 244;
  v16 = 25;
  for ( i = 0; i < currentMap.width; ++i )
  {
    v18 = getTileAttributes(i, a1);
    if ( v18 )
    {
      if ( v18 != 68
        && v18 != 1
        && v18 != 64
        && v18 != 128
        && v18 != 129
        && v18 != 130
        && v18 != 131
        && v18 != 81
        && v18 != 82
        && v18 != 85
        && v18 != 86
        && v18 != 2
        && v18 != 96
        && v18 != 113
        && v18 != 114
        && v18 != 117
        && v18 != 118
        && v18 != 160
        && v18 != 161
        && v18 != 162
        && v18 != 163 )
      {
        if ( v18 != 67
          && v18 != 99
          && v18 != 80
          && v18 != 83
          && v18 != 84
          && v18 != 87
          && v18 != 96
          && v18 != 112
          && v18 != 115
          && v18 != 116
          && v18 != 119 )
        {
          drawSpriteOntoSurface(i, a1, (RECT *)&v13, 9, 26);
        }
        else
        {
          drawSpriteOntoSurface(i, a1, (RECT *)&v9, 9, 26);
        }
      }
      else
      {
        drawSpriteOntoSurface(i, a1, (RECT *)&v5, 9, 26);
      }
    }
    else
    {
      drawSpriteOntoSurface(i, a1, (RECT *)&v1, 9, 26);
    }
  }
}

//----- (00414640) --------------------------------------------------------
signed int gameLoopMap()
{
  int v1; // [esp+0h] [ebp-50h]
  int v2; // [esp+4h] [ebp-4Ch]
  int v3; // [esp+8h] [ebp-48h]
  RECT Ptr_Img_Rects; // [esp+Ch] [ebp-44h]
  int My_Y; // [esp+1Ch] [ebp-34h]
  RECT rect; // [esp+20h] [ebp-30h]
  int My_X; // [esp+30h] [ebp-20h]
  char v8; // [esp+37h] [ebp-19h]
  int i; // [esp+38h] [ebp-18h]
  LONG v10; // [esp+3Ch] [ebp-14h]
  RECT My_Rect; // [esp+40h] [ebp-10h]

  My_Rect.left = 0;
  My_Rect.top = 57;
  My_Rect.right = 1;
  My_Rect.bottom = 58;
  My_X = (quote.XPos / 512 + 8) / 16;
  My_Y = (quote.YPos / 512 + 8) / 16;
  for ( i = 0; i <= 8; ++i )
  {
    getKeys();
    if ( keyHeld & 0x8000 )
    {
      v3 = callOnEscape(appWinHandle);
      if ( !v3 )
        return 0;
      if ( v3 == 2 )
        return 2;
    }
    drawSpriteNoTransparency(&gameRect, 0, 0, &gameRect, 10);
    Ptr_Img_Rects.left = 160 - i * currentMap.width / 8 / 2;
    Ptr_Img_Rects.right = i * currentMap.width / 8 / 2 + 160;
    Ptr_Img_Rects.top = 120 - i * currentMap.length / 8 / 2;
    Ptr_Img_Rects.bottom = i * currentMap.length / 8 / 2 + 120;
    drawMapName(1);
    drawColorFill(&Ptr_Img_Rects, 0);
    displayFPSCounter();
    if ( !drawWindow(appWinHandle) )
      return 0;
  }
  rect.left = 0;
  rect.right = currentMap.width;
  rect.top = 0;
  rect.bottom = currentMap.length;
  Ptr_Img_Rects.right = --Ptr_Img_Rects.left + currentMap.width + 2;
  Ptr_Img_Rects.bottom = --Ptr_Img_Rects.top + currentMap.length + 2;
  drawColorFillOntoSurface(&rect, 0, 9);
  v10 = 0;
  v8 = 0;
  while ( 1 )
  {
    getKeys();
    if ( keyPressed & (keyCancel | keyOk) )
      break;
    if ( keyHeld & 0x8000 )
    {
      v2 = callOnEscape(appWinHandle);
      if ( !v2 )
        return 0;
      if ( v2 == 2 )
        return 2;
    }
    drawSpriteNoTransparency(&gameRect, 0, 0, &gameRect, 10);
    drawColorFill(&Ptr_Img_Rects, 0);
    if ( v10 < currentMap.length )
      Render_Map_System_Green_Stuff(v10++);
    if ( v10 < currentMap.length )
      Render_Map_System_Green_Stuff(v10++);
    drawBitmapWithTransparency(&gameRect, Ptr_Img_Rects.left + 1, Ptr_Img_Rects.top + 1, &rect, 9);
    drawMapName(1);
    if ( ((signed int)(unsigned __int8)++v8 >> 3) % 2 )
      drawBitmapWithTransparency(&gameRect, My_X + Ptr_Img_Rects.left + 1, My_Y + Ptr_Img_Rects.top + 1, &My_Rect, 26);
    displayFPSCounter();
    if ( !drawWindow(appWinHandle) )
      return 0;
  }
  for ( i = 8; i >= -1; --i )
  {
    getKeys();
    if ( keyHeld & 0x8000 )
    {
      v1 = callOnEscape(appWinHandle);
      if ( !v1 )
        return 0;
      if ( v1 == 2 )
        return 2;
    }
    drawSpriteNoTransparency(&gameRect, 0, 0, &gameRect, 10);
    Ptr_Img_Rects.left = 160 - i * currentMap.width / 8 / 2;
    Ptr_Img_Rects.right = i * currentMap.width / 8 / 2 + 160;
    Ptr_Img_Rects.top = 120 - i * currentMap.length / 8 / 2;
    Ptr_Img_Rects.bottom = i * currentMap.length / 8 / 2 + 120;
    drawMapName(1);
    drawColorFill(&Ptr_Img_Rects, 0);
    displayFPSCounter();
    if ( !drawWindow(appWinHandle) )
      return 0;
  }
  return 1;
}
// 493628: using guessed type int keyOk;
// 49362C: using guessed type int keyCancel;
// 49E210: using guessed type int keyHeld;
// 49E214: using guessed type int keyPressed;

//----- (00414B00) --------------------------------------------------------
// Returns 1 if current map flag set, 0 if not set
bool checkMapFlag()
{
  return mapFlagArray[currentStageNumber] != 0;
}
// 4A57F0: using guessed type int currentStageNumber;

//----- (00414B20) --------------------------------------------------------
void *clearMapFlagArray()
{
  return memset(mapFlagArray, 0, 128u);
}

//----- (00414B40) --------------------------------------------------------
// Set MPJ array slot == true for map ID given
void __cdecl setMapFlag(int mapID)
{
  mapFlagArray[mapID] = 1;
}

//----- (00414B50) --------------------------------------------------------
void *setQuoteinitialValues()
{
  void *result; // eax

  result = memset(&quote, 0, 0xB4u);
  quote.flags = -128;
  quote.direction = 2;
  quote.Sizebox.back = 4096;
  quote.Sizebox.top = 4096;
  quote.Sizebox.front = 4096;
  quote.Sizebox.bottom = 4096;
  quote.Hitbox.back = 2560;
  quote.Hitbox.top = 4096;
  quote.Hitbox.front = 2560;
  quote.Hitbox.bottom = 4096;
  quote.Health = 3;
  quote.Max_Health = 3;
  quote.isInFishBattle = 0;
  return result;
}

//----- (00414BF0) --------------------------------------------------------
void __cdecl doPlayerAnimation(int bKey)
{
  RECT *Chosen_Rect; // eax MAPDST
  RECT Rects_Right[12]; // [esp+0h] [ebp-180h]
  RECT Rects_Left[12]; // [esp+C0h] [ebp-C0h]

  Rects_Left[0].left = 0;
  Rects_Left[0].top = 0;
  Rects_Left[0].right = 16;
  Rects_Left[0].bottom = 16;
  Rects_Left[1].left = 16;
  Rects_Left[1].top = 0;
  Rects_Left[1].right = 32;
  Rects_Left[1].bottom = 16;
  Rects_Left[2].left = 0;
  Rects_Left[2].top = 0;
  Rects_Left[2].right = 16;
  Rects_Left[2].bottom = 16;
  Rects_Left[3].left = 32;
  Rects_Left[3].top = 0;
  Rects_Left[3].right = 48;
  Rects_Left[3].bottom = 16;
  Rects_Left[4].left = 0;
  Rects_Left[4].top = 0;
  Rects_Left[4].right = 16;
  Rects_Left[4].bottom = 16;
  Rects_Left[5].left = 48;
  Rects_Left[5].top = 0;
  Rects_Left[5].right = 64;
  Rects_Left[5].bottom = 16;
  Rects_Left[6].left = 64;
  Rects_Left[6].top = 0;
  Rects_Left[6].right = 80;
  Rects_Left[6].bottom = 16;
  Rects_Left[7].left = 48;
  Rects_Left[7].top = 0;
  Rects_Left[7].right = 64;
  Rects_Left[7].bottom = 16;
  Rects_Left[8].left = 80;
  Rects_Left[8].top = 0;
  Rects_Left[8].right = 96;
  Rects_Left[8].bottom = 16;
  Rects_Left[9].left = 48;
  Rects_Left[9].top = 0;
  Rects_Left[9].right = 64;
  Rects_Left[9].bottom = 16;
  Rects_Left[10].left = 96;
  Rects_Left[10].top = 0;
  Rects_Left[10].right = 112;
  Rects_Left[10].bottom = 16;
  Rects_Left[11].left = 112;
  Rects_Left[11].top = 0;
  Rects_Left[11].right = 128;
  Rects_Left[11].bottom = 16;
  Rects_Right[0].left = 0;
  Rects_Right[0].top = 16;
  Rects_Right[0].right = 16;
  Rects_Right[0].bottom = 32;
  Rects_Right[1].left = 16;
  Rects_Right[1].top = 16;
  Rects_Right[1].right = 32;
  Rects_Right[1].bottom = 32;
  Rects_Right[2].left = 0;
  Rects_Right[2].top = 16;
  Rects_Right[2].right = 16;
  Rects_Right[2].bottom = 32;
  Rects_Right[3].left = 32;
  Rects_Right[3].top = 16;
  Rects_Right[3].right = 48;
  Rects_Right[3].bottom = 32;
  Rects_Right[4].left = 0;
  Rects_Right[4].top = 16;
  Rects_Right[4].right = 16;
  Rects_Right[4].bottom = 32;
  Rects_Right[5].left = 48;
  Rects_Right[5].top = 16;
  Rects_Right[5].right = 64;
  Rects_Right[5].bottom = 32;
  Rects_Right[6].left = 64;
  Rects_Right[6].top = 16;
  Rects_Right[6].right = 80;
  Rects_Right[6].bottom = 32;
  Rects_Right[7].left = 48;
  Rects_Right[7].top = 16;
  Rects_Right[7].right = 64;
  Rects_Right[7].bottom = 32;
  Rects_Right[8].left = 80;
  Rects_Right[8].top = 16;
  Rects_Right[8].right = 96;
  Rects_Right[8].bottom = 32;
  Rects_Right[9].left = 48;
  Rects_Right[9].top = 16;
  Rects_Right[9].right = 64;
  Rects_Right[9].bottom = 32;
  Rects_Right[10].left = 96;
  Rects_Right[10].top = 16;
  Rects_Right[10].right = 112;
  Rects_Right[10].bottom = 32;
  Rects_Right[11].left = 112;
  Rects_Right[11].top = 16;
  Rects_Right[11].right = 128;
  Rects_Right[11].bottom = 32;
  if ( !(quote.flags & 2) )
  {
    if ( quote.collisionFlags & 8 )
    {
      if ( quote.flags & 1 )
      {
        quote.animationNumber = 11;
      }
      else if ( keyUp & keyHeld && keyHeld & (keyRight | keyLeft) && bKey )
      {
        quote.flags |= 4u;
        if ( ++quote.animationTimer > 4 )
        {
          quote.animationTimer = 0;
          if ( ++quote.animationNumber == 7 || quote.animationNumber == 9 )
            playSoundEffect(SFXQuoteWalk, 1);
        }
        if ( quote.animationNumber > 9 || quote.animationNumber < 6 )
          quote.animationNumber = 6;
      }
      else if ( keyHeld & (keyRight | keyLeft) && bKey )
      {
        quote.flags |= 4u;
        if ( ++quote.animationTimer > 4 )
        {
          quote.animationTimer = 0;
          if ( ++quote.animationNumber == 2 || quote.animationNumber == 4 )
            playSoundEffect(SFXQuoteWalk, 1);
        }
        if ( quote.animationNumber > 4 || quote.animationNumber < 1 )
          quote.animationNumber = 1;
      }
      else if ( keyUp & keyHeld && bKey )
      {
        if ( quote.flags & 4 )
          playSoundEffect(SFXQuoteWalk, 1);
        quote.flags &= ~4u;
        quote.animationNumber = 5;
      }
      else
      {
        if ( quote.flags & 4 )
          playSoundEffect(SFXQuoteWalk, 1);
        quote.flags &= 0xFBu;
        quote.animationNumber = 0;
      }
    }
    else if ( quote.isFacingUp )
    {
      quote.animationNumber = 6;
    }
    else if ( quote.isFacingDown )
    {
      quote.animationNumber = 10;
    }
    else if ( quote.YVel <= 0 )
    {
      quote.animationNumber = 3;
    }
    else
    {
      quote.animationNumber = 1;
    }
    if ( quote.direction )
    {
      Chosen_Rect = &Rects_Right[quote.animationNumber];
      quote.Rect.left = Chosen_Rect->left;
      quote.Rect.top = Chosen_Rect->top;
      quote.Rect.right = Chosen_Rect->right;
      quote.Rect.bottom = Chosen_Rect->bottom;
    }
    else
    {
      Chosen_Rect = &Rects_Left[quote.animationNumber];
      quote.Rect.left = Chosen_Rect->left;
      quote.Rect.top = Chosen_Rect->top;
      quote.Rect.right = Chosen_Rect->right;
      quote.Rect.bottom = Chosen_Rect->bottom;
    }
  }
}
// 493630: using guessed type int keyLeft;
// 493634: using guessed type int keyUp;
// 493638: using guessed type int keyRight;
// 49E210: using guessed type int keyHeld;

//----- (00415220) --------------------------------------------------------
// TSC HMC/SMC : Hide My Character / Show My Character
void __cdecl showHidePlayer(int show)
{
  if ( show )
    quote.flags &= 0xFDu;
  else
    quote.flags |= 2u;
}

//----- (00415250) --------------------------------------------------------
void __cdecl drawQuoteAndGun(signed int a1, signed int a2)
{
  RECT rect; // [esp+0h] [ebp-34h]
  int v3; // [esp+10h] [ebp-24h]
  int v4; // [esp+14h] [ebp-20h]
  int v5; // [esp+18h] [ebp-1Ch]
  int v6; // [esp+1Ch] [ebp-18h]
  int v7; // [esp+20h] [ebp-14h]
  int Rects; // [esp+24h] [ebp-10h]
  LONG v9; // [esp+28h] [ebp-Ch]
  LONG v10; // [esp+2Ch] [ebp-8h]
  LONG v11; // [esp+30h] [ebp-4h]

  if ( quote.flags & 0x80 && !(quote.flags & 2) )
  {
    quote.Rect_Weapon.left = 24 * (gWeapons[selectedWeapon].weaponID % 13);
    quote.Rect_Weapon.right = quote.Rect_Weapon.left + 24;
    quote.Rect_Weapon.top = 96 * (gWeapons[selectedWeapon].weaponID / 13);
    quote.Rect_Weapon.bottom = quote.Rect_Weapon.top + 16;
    if ( quote.direction == 2 )
    {
      quote.Rect_Weapon.top += 16;
      quote.Rect_Weapon.bottom += 16;
    }
    if ( quote.isFacingUp )
    {
      v7 = -4;
      quote.Rect_Weapon.top += 32;
      quote.Rect_Weapon.bottom += 32;
    }
    else if ( quote.isFacingDown )
    {
      v7 = 4;
      quote.Rect_Weapon.top += 64;
      quote.Rect_Weapon.bottom += 64;
    }
    else
    {
      v7 = 0;
    }
    if ( quote.animationNumber == 1
      || quote.animationNumber == 3
      || quote.animationNumber == 6
      || quote.animationNumber == 8 )
    {
      ++quote.Rect_Weapon.top;
    }
    if ( quote.direction )
      drawBitmapWithTransparency(
        &gameRect,
        (quote.XPos - quote.Sizebox.front) / 512 - a1 / 512,
        v7 + (quote.YPos - quote.Sizebox.top) / 512 - a2 / 512,
        &quote.Rect_Weapon,
        11);
    else
      drawBitmapWithTransparency(
        &gameRect,
        (quote.XPos - quote.Sizebox.front) / 512 - a1 / 512 - 8,
        v7 + (quote.YPos - quote.Sizebox.top) / 512 - a2 / 512,
        &quote.Rect_Weapon,
        11);
    if ( !(quote.Invincibility_Timer / 2 % 2) )
    {
      Rects = quote.Rect.left;
      v9 = quote.Rect.top;
      v10 = quote.Rect.right;
      v11 = quote.Rect.bottom;
      if ( quote.equippedItems & 0x40 )
      {
        v9 += 32;
        v11 += 32;
      }
      drawBitmapWithTransparency(
        &gameRect,
        (quote.XPos - quote.Sizebox.front) / 512 - a1 / 512,
        (quote.YPos - quote.Sizebox.top) / 512 - a2 / 512,
        (RECT *)&Rects,
        16);
      rect.left = 56;
      rect.top = 96;
      rect.right = 80;
      rect.bottom = 120;
      v3 = 80;
      v4 = 96;
      v5 = 104;
      v6 = 120;
      ++quote.bubble;
      if ( quote.equippedItems & 0x10 && quote.collisionFlags & 0x100 )
      {
        drawBitmapWithTransparency(
          &gameRect,
          quote.XPos / 512 - 12 - a1 / 512,
          quote.YPos / 512 - 12 - a2 / 512,
          &rect + quote.bubble / 2 % 2,
          19);
      }
      else if ( quote.isInFishBattle == 1 )
      {
        drawBitmapWithTransparency(
          &gameRect,
          quote.XPos / 512 - 12 - a1 / 512,
          quote.YPos / 512 - 12 - a2 / 512,
          &rect + quote.bubble / 2 % 2,
          19);
      }
    }
  }
}
// 499C68: using guessed type int selectedWeapon;

//----- (004156C0) --------------------------------------------------------
int __cdecl playerPhysics(bool a1)
{
  int result; // eax
  int XPos; // ST48_4
  int v3; // ST10_4
  int v4; // eax
  int v5; // ST48_4
  int v6; // ST10_4
  int v7; // eax
  int direction; // [esp+0h] [ebp-2Ch]
  signed int jumpSpeed; // [esp+4h] [ebp-28h]
  signed int walkSpeed; // [esp+8h] [ebp-24h]
  int friction; // [esp+Ch] [ebp-20h]
  signed int gravity; // [esp+10h] [ebp-1Ch]
  signed int airControl; // [esp+14h] [ebp-18h]
  int quoteMaxSpeed; // [esp+18h] [ebp-14h]
  signed int gravityWhenPressingJump; // [esp+1Ch] [ebp-10h]
  signed int j; // [esp+24h] [ebp-8h]
  signed int i; // [esp+24h] [ebp-8h]

  result = quote.flags & 2;
  if ( !(quote.flags & 2) )
  {
    // Agility Code : How fast you move in water or land
    if ( quote.collisionFlags & 0x100 )
    {
      // Underwater physics
      quoteMaxSpeed = 406;
      gravity = 40;
      gravityWhenPressingJump = 16;
      jumpSpeed = 640;
      walkSpeed = 42;
      airControl = 16;
      friction = 25;
    }
    else
    {
      // Normal physics
      quoteMaxSpeed = 812;
      gravity = 80;
      gravityWhenPressingJump = 32;
      jumpSpeed = 1280;
      walkSpeed = 85;
      airControl = 32;
      friction = 51;
    }
    quote.ques = 0;
    if ( !a1 )
      quote.boost_sw = 0;
    if ( quote.collisionFlags & 8 || quote.collisionFlags & 0x10 || quote.collisionFlags & 0x20 )
    {
      quote.boost_sw = 0;
      if ( quote.equippedItems & 1 )
      {
        quote.boosterFuel = 50;                 // Booster 0.8 max fuel
      }
      else if ( quote.equippedItems & 0x20 )
      {
        quote.boosterFuel = 50;                 // Booster 2.0 max fuel
      }
      else
      {
        quote.boosterFuel = 0;
      }
      if ( a1 )
      {
        if ( keyPressed != keyDown || keyHeld != keyDown || quote.flags & 1 || gameFlags & 4 )
        {
          if ( keyHeld != keyDown )
          {
            if ( keyLeft & keyHeld && quote.XVel > -quoteMaxSpeed )
              quote.XVel -= walkSpeed;
            if ( keyRight & keyHeld && quote.XVel < quoteMaxSpeed )
              quote.XVel += walkSpeed;
            if ( keyLeft & keyHeld )
              quote.direction = 0;
            if ( keyRight & keyHeld )
              quote.direction = 2;
          }
        }
        else
        {
          quote.flags |= 1u;
          quote.ques = 1;
        }
      }
      if ( !(quote.flags & 0x20) )
      {
        if ( quote.XVel < 0 )
        {
          if ( quote.XVel <= -friction )
            quote.XVel += friction;
          else
            quote.XVel = 0;
        }
        if ( quote.XVel > 0 )
        {
          if ( quote.XVel >= friction )
            quote.XVel -= friction;
          else
            quote.XVel = 0;
        }
      }
    }
    else
    {
      if ( a1 )
      {
        if ( quote.equippedItems & 0x21 && keyJump & keyPressed && quote.boosterFuel )
        {
          if ( quote.equippedItems & 1 )
          {
            quote.boost_sw = 1;
            if ( quote.YVel > 256 )
              quote.YVel /= 2;
          }
          if ( quote.equippedItems & 0x20 )
          {
            if ( keyUp & keyHeld )
            {
              quote.boost_sw = 2;
              quote.XVel = 0;
              quote.YVel = -1535;
            }
            else if ( keyLeft & keyHeld )
            {
              quote.boost_sw = 1;
              quote.YVel = 0;
              quote.XVel = -1535;
            }
            else if ( keyRight & keyHeld )
            {
              quote.boost_sw = 1;
              quote.YVel = 0;
              quote.XVel = 1535;
            }
            else if ( keyDown & keyHeld )
            {
              quote.boost_sw = 3;
              quote.XVel = 0;
              quote.YVel = 1535;
            }
            else
            {
              quote.boost_sw = 2;
              quote.XVel = 0;
              quote.YVel = -1535;
            }
          }
        }
        if ( keyLeft & keyHeld && quote.XVel > -quoteMaxSpeed )
          quote.XVel -= airControl;
        if ( keyRight & keyHeld && quote.XVel < quoteMaxSpeed )
          quote.XVel += airControl;
        if ( keyLeft & keyHeld )
          quote.direction = 0;
        if ( keyRight & keyHeld )
          quote.direction = 2;
      }
      if ( quote.equippedItems & 0x20 && quote.boost_sw && (!(keyJump & keyHeld) || !quote.boosterFuel) )
      {
        if ( quote.boost_sw == 1 )
        {
          quote.XVel /= 2;
        }
        else if ( quote.boost_sw == 2 )
        {
          quote.YVel /= 2;
        }
      }
      if ( !quote.boosterFuel || !(keyJump & keyHeld) )
        quote.boost_sw = 0;
    }
    if ( a1 )
    {
      quote.isFacingUp = (keyUp & keyHeld) != 0;
      quote.isFacingDown = keyDown & keyHeld && !(quote.collisionFlags & 8);
      if ( keyJump & keyPressed
        && (quote.collisionFlags & 8 || quote.collisionFlags & 0x10 || quote.collisionFlags & 0x20)
        && !(quote.collisionFlags & 0x2000) )
      {
        // Jump function
        quote.YVel = -jumpSpeed;
        playSoundEffect(SFXQuoteJump, 1);
      }
    }
    if ( a1 && keyHeld & (keyShoot | keyJump | keyUp | keyRight | keyLeft) )
      quote.flags &= 0xFEu;
    if ( quote.boost_sw && quote.boosterFuel )
      --quote.boosterFuel;                      // Decrease booster fuel
    if ( quote.collisionFlags & 0x1000 )
      quote.XVel -= 136;
    if ( quote.collisionFlags & 0x2000 )
      quote.YVel -= 128;
    if ( quote.collisionFlags & 0x4000 )
      quote.XVel += 136;
    if ( quote.collisionFlags & 0x8000 )
      quote.YVel += 85;
    if ( quote.equippedItems & 0x20 && quote.boost_sw )
    {
      if ( quote.boost_sw == 1 )
      {
        if ( quote.collisionFlags & 5 )
          quote.YVel = -256;
        if ( quote.direction == left )
          quote.XVel -= 32;
        if ( quote.direction == 2 )
          quote.XVel += 32;
        if ( keyJump & keyPressed || quote.boosterFuel % 3 == 1 )
        {
          if ( quote.direction == left )
            createEffect(quote.XPos + 1024, quote.YPos + 1024, effectDrownedQuote, right);
          if ( quote.direction == 2 )
            createEffect(quote.XPos - 1024, quote.YPos + 1024, effectDrownedQuote, 0);
          playSoundEffect(SFXBooster, 1);       // Play booster sound
        }
      }
      else if ( quote.boost_sw == 2 )
      {
        quote.YVel -= 32;
        if ( keyJump & keyPressed || quote.boosterFuel % 3 == 1 )
        {
          // Make booster fuel trail and play booster sound
          createEffect(quote.XPos, quote.YPos + 3072, effectDrownedQuote, down);
          playSoundEffect(SFXBooster, 1);
        }
      }
      else if ( quote.boost_sw == 3 && (keyJump & keyPressed || quote.boosterFuel % 3 == 1) )
      {
        createEffect(quote.XPos, quote.YPos - 3072, effectDrownedQuote, up);
        playSoundEffect(SFXBooster, 1);
      }
    }
    else if ( quote.collisionFlags & 0x2000 )
    {
      quote.YVel += gravity;
    }
    else if ( quote.equippedItems & 1 && quote.boost_sw && quote.YVel > -1024 )
    {
      quote.YVel -= 32;
      if ( !(quote.boosterFuel % 3) )
      {
        createEffect(quote.XPos, quote.YPos + quote.Hitbox.bottom / 2, effectDrownedQuote, down);
        playSoundEffect(SFXBooster, 1);
      }
      if ( quote.collisionFlags & 2 )
        quote.YVel = 512;
    }
    else if ( quote.YVel < 0 && a1 && keyJump & keyHeld )
    {
      quote.YVel += gravityWhenPressingJump;
    }
    else
    {
      quote.YVel += gravity;
    }
    if ( !a1 || !(keyJump & keyPressed) )
    {
      if ( quote.collisionFlags & 0x10 && quote.XVel < 0 )
        quote.YVel = -quote.XVel;
      if ( quote.collisionFlags & 0x20 && quote.XVel > 0 )
        quote.YVel = quote.XVel;
      if ( quote.collisionFlags & 8 && quote.collisionFlags & 0x80000 && quote.XVel < 0 )
        quote.YVel = 1024;
      if ( quote.collisionFlags & 8 && quote.collisionFlags & 0x10000 && quote.XVel > 0 )
        quote.YVel = 1024;
      if ( quote.collisionFlags & 8 && quote.collisionFlags & 0x20000 && quote.collisionFlags & 0x40000 )
        quote.YVel = 1024;
    }
    if ( !(quote.collisionFlags & 0x100) || quote.collisionFlags & 0xF000 )
    {
      if ( quote.XVel < -1535 )
        quote.XVel = -1535;
      if ( quote.XVel > 1535 )
        quote.XVel = 1535;
      if ( quote.YVel < -1535 )
        quote.YVel = -1535;
      if ( quote.YVel > 1535 )
        quote.YVel = 1535;
    }
    else
    {
      if ( quote.XVel < -767 )
        quote.XVel = -767;
      if ( quote.XVel > 767 )
        quote.XVel = 767;
      if ( quote.YVel < -767 )
        quote.YVel = -767;
      if ( quote.YVel > 767 )
        quote.YVel = 767;
    }
    if ( !quote.sprash && quote.collisionFlags & 0x100 )
    {
      if ( quote.collisionFlags & 0x800 )
        direction = 2;
      else
        direction = 0;
      if ( quote.collisionFlags & 8 || quote.YVel <= 512 )
      {
        if ( quote.XVel > 512 || quote.XVel < -512 )
        {
          for ( i = 0; i < 8; ++i )
          {
            v5 = quote.XPos + (random(-8, 8) << 9);
            v6 = random(-512, 128);
            v7 = random(-512, 512);
            createNPC(NPCBalrogDropIn|0x40, v5, quote.YPos, quote.XVel + v7, v6, (Directions)direction, 0, 0);
          }
          playSoundEffect(SFXWaterSplash, 1);   // Play water splash
        }
      }
      else
      {
        for ( j = 0; j < 8; ++j )
        {
          XPos = quote.XPos + (random(-8, 8) << 9);
          v3 = random(-512, 128) - quote.YVel / 2;
          v4 = random(-512, 512);
          createNPC(NPCBalrogDropIn|0x40, XPos, quote.YPos, quote.XVel + v4, v3, (Directions)direction, 0, 0);
        }
        playSoundEffect(SFXWaterSplash, 1);     // Play water splash
      }
      quote.sprash = 1;
    }
    if ( !(quote.collisionFlags & 0x100) )
      quote.sprash = 0;
    if ( quote.collisionFlags & 0x400 )
      damagePlayer(10);
    if ( quote.direction )
    {
      quote.cameraXVel += 512;
      if ( quote.cameraXVel > 0x8000 )
        quote.cameraXVel = 0x8000;
    }
    else
    {
      quote.cameraXVel -= 512;
      if ( quote.cameraXVel < -32768 )
        quote.cameraXVel = -32768;
    }
    if ( keyUp & keyHeld && a1 )
    {
      quote.cameraYVel -= 512;
      if ( quote.cameraYVel < -32768 )
        quote.cameraYVel = -32768;
    }
    else if ( keyDown & keyHeld && a1 )
    {
      quote.cameraYVel += 512;
      if ( quote.cameraYVel > 0x8000 )
        quote.cameraYVel = 0x8000;
    }
    else
    {
      if ( quote.cameraYVel > 512 )
        quote.cameraYVel -= 512;
      if ( quote.cameraYVel < -512 )
        quote.cameraYVel += 512;
    }
    result = quote.cameraXVel + quote.XPos;
    quote.cameraXPos = quote.cameraXVel + quote.XPos;
    quote.cameraYPos = quote.cameraYVel + quote.YPos;
    if ( quote.XVel > friction || (result = -friction, quote.XVel < -friction) )
      quote.XPos += quote.XVel;
    quote.YPos += quote.YVel;
  }
  return result;
}
// 493610: using guessed type int keyJump;
// 493614: using guessed type int keyShoot;
// 493630: using guessed type int keyLeft;
// 493634: using guessed type int keyUp;
// 493638: using guessed type int keyRight;
// 49363C: using guessed type int keyDown;
// 49E1E8: using guessed type int gameFlags;
// 49E210: using guessed type int keyHeld;
// 49E214: using guessed type int keyPressed;

//----- (00416470) --------------------------------------------------------
// Also does the fish battle mode
int __cdecl Quote_Movement(bool a1)
{
  int result; // eax

  quote.isFacingUp = 0;
  quote.isFacingDown = 0;
  if ( a1 )
  {
    if ( keyHeld & (keyRight | keyLeft) )
    {
      if ( keyLeft & keyHeld )
        quote.XVel -= 256;
      if ( keyRight & keyHeld )
        quote.XVel += 256;
    }
    else if ( quote.XVel >= 128 || quote.XVel <= -128 )
    {
      if ( quote.XVel <= 0 )
        quote.XVel += quote.XVel < 0 ? 0x80 : 0;
      else
        quote.XVel -= 128;
    }
    else
    {
      quote.XVel = 0;
    }
    if ( keyHeld & (keyDown | keyUp) )
    {
      if ( keyUp & keyHeld )
        quote.YVel -= 256;
      if ( keyDown & keyHeld )
        quote.YVel += 256;
    }
    else if ( quote.YVel >= 128 || quote.YVel <= -128 )
    {
      if ( quote.YVel <= 0 )
        quote.YVel += quote.YVel < 0 ? 0x80 : 0;
      else
        quote.YVel -= 128;
    }
    else
    {
      quote.YVel = 0;
    }
  }
  else
  {
    if ( quote.XVel >= 128 || quote.XVel <= -64 )
    {
      if ( quote.XVel <= 0 )
        quote.XVel += quote.XVel < 0 ? 0x80 : 0;
      else
        quote.XVel -= 128;
    }
    else
    {
      quote.XVel = 0;
    }
    if ( quote.YVel >= 128 || quote.YVel <= -64 )
    {
      if ( quote.YVel <= 0 )
        quote.YVel += quote.YVel < 0 ? 0x80 : 0;
      else
        quote.YVel -= 128;
    }
    else
    {
      quote.YVel = 0;
    }
  }
  if ( quote.YVel < -512 && quote.collisionFlags & 2 )
    createEffect(quote.XPos, quote.YPos - quote.Hitbox.top, effectUnknownUnused, (Directions)5);
  if ( quote.YVel > 512 && quote.collisionFlags & 8 )
    createEffect(quote.XPos, quote.Hitbox.bottom + quote.YPos, effectUnknownUnused, (Directions)5);
  if ( quote.XVel > 1024 )
    quote.XVel = 1024;
  if ( quote.XVel < -1024 )
    quote.XVel = -1024;
  if ( quote.YVel > 1024 )
    quote.YVel = 1024;
  if ( quote.YVel < -1024 )
    quote.YVel = -1024;
  if ( (keyHeld & (keyUp | keyLeft)) == (keyUp | keyLeft) )
  {
    if ( quote.XVel < -780 )
      quote.XVel = -780;
    if ( quote.YVel < -780 )
      quote.YVel = -780;
  }
  if ( (keyHeld & (keyUp | keyRight)) == (keyUp | keyRight) )
  {
    if ( quote.XVel > 780 )
      quote.XVel = 780;
    if ( quote.YVel < -780 )
      quote.YVel = -780;
  }
  if ( (keyHeld & (keyDown | keyLeft)) == (keyDown | keyLeft) )
  {
    if ( quote.XVel < -780 )
      quote.XVel = -780;
    if ( quote.YVel > 780 )
      quote.YVel = 780;
  }
  if ( (keyHeld & (keyDown | keyRight)) == (keyDown | keyRight) )
  {
    if ( quote.XVel > 780 )
      quote.XVel = 780;
    if ( quote.YVel > 780 )
      quote.YVel = 780;
  }
  quote.XPos += quote.XVel;
  result = quote.YVel + quote.YPos;
  quote.YPos += quote.YVel;
  return result;
}
// 493630: using guessed type int keyLeft;
// 493634: using guessed type int keyUp;
// 493638: using guessed type int keyRight;
// 49363C: using guessed type int keyDown;
// 49E210: using guessed type int keyHeld;

//----- (004168C0) --------------------------------------------------------
int __cdecl Player_Related_Maybe(bool a1)
{
  int result; // eax

  result = quote.flags & 0x80;
  if ( quote.flags & 0x80 )
  {
    if ( quote.Level_Bar_Flashes )
      --quote.Level_Bar_Flashes;
    if ( quote.Invincibility_Timer )
    {
      --quote.Invincibility_Timer;
    }
    else if ( quote.Exp_To_Gain )
    {
      setValueView((__int32)&quote.XPos, (__int32)&quote.YPos, quote.Exp_To_Gain);
      quote.Exp_To_Gain = 0;
    }
    if ( quote.isInFishBattle )
    {
      if ( quote.isInFishBattle == 1 )
        Quote_Movement(a1);
    }
    else
    {
      if ( !(gameFlags & 4) && a1 )
        Quote_Air();
      playerPhysics(a1);
    }
    result = quote.flags & 0xDF;
    quote.flags &= 0xDFu;
  }
  return result;
}
// 49E1E8: using guessed type int gameFlags;

//----- (00416990) --------------------------------------------------------
void Quote_Air()
{
  if ( quote.equippedItems & 0x10 )
  {
    quote.Air = 1000;
    quote.air_get = 0;
  }
  else
  {
    if ( quote.collisionFlags & 0x100 )
    {
      if ( --quote.Air <= 0 )
      {
        if ( getNPCFlag(4000) )
        {
          startTSCEvent(1100);
        }
        else
        {
          startTSCEvent(41);
          if ( quote.direction )
            createEffect(quote.XPos, quote.YPos, effectExclamationMark, right);
          else
            createEffect(quote.XPos, quote.YPos, effectExclamationMark, 0);
          quote.flags &= 0x7Fu;
        }
      }
    }
    else
    {
      quote.Air = 1000;
    }
    if ( quote.collisionFlags & 0x100 )
    {
      quote.air_get = 60;
    }
    else if ( quote.air_get )
    {
      --quote.air_get;
    }
  }
}

//----- (00416AA0) --------------------------------------------------------
void __cdecl getQuotePos(int *XPos, int *YPos)
{
  *XPos = quote.XPos;
  *YPos = quote.YPos;
}

//----- (00416AC0) --------------------------------------------------------
// TSC : MOVe Quote
void __cdecl setQuotePosition(int X_Pos, int Y_Pos)
{
  quote.XPos = X_Pos;
  quote.YPos = Y_Pos;
  quote.cameraXPos = X_Pos;
  quote.cameraYPos = Y_Pos;
  quote.cameraXVel = 0;
  quote.cameraYVel = 0;
  quote.XVel = 0;
  quote.YVel = 0;
  quote.flags &= ~1u;
  initWhimsicalStar();
}

//----- (00416B30) --------------------------------------------------------
// Unused
void __cdecl setXAndYPos(int newXPos, int newYPos)
{
  quote.XPos = newXPos;
  quote.YPos = newYPos;
}

//----- (00416B60) --------------------------------------------------------
// TSC : UNiverse Jump ?
// Check if in Fish Battle
BOOL isInFishBattle()
{
  return quote.isInFishBattle;
}

//----- (00416B70) --------------------------------------------------------
// TSC : MY char Direction change ?
// Changes the player's direction
void __cdecl setPlayerDirection(unsigned __int8 New_Direction)
{
  signed int i; // [esp+0h] [ebp-4h]

  if ( New_Direction == 3 )
  {
    quote.flags |= 1u;
LABEL_13:
    quote.XVel = 0;
    doPlayerAnimation(0);
    return;
  }
  quote.flags &= 0xFEu;
  if ( (signed int)New_Direction < 10 )
  {
    quote.direction = New_Direction;
    goto LABEL_13;
  }
  for ( i = 0; i < 512 && NPCObjects[i].entityEventNum != New_Direction; ++i )
    ;
  if ( i != 512 )
  {
    if ( quote.XPos <= NPCObjects[i].XPos )
      quote.direction = 2;
    else
      quote.direction = 0;
    goto LABEL_13;
  }
}

//----- (00416C40) --------------------------------------------------------
void __cdecl changeUniverse(unsigned __int8 newUniverse)
{
  quote.isInFishBattle = newUniverse;
}

//----- (00416C50) --------------------------------------------------------
// Moves the player 4000 units down instantly.
// Unused
void __cdecl moveQuote4000UnitsDown()
{
  quote.YPos += 0x4000;
}

//----- (00416C70) --------------------------------------------------------
// EQ+ : EQuip +
// EQ- : EQuip -
// Equips or unequips items
void __cdecl equipItem(int Item_To_Equip, bool Unequip)
{
  if ( Unequip )
    quote.equippedItems |= Item_To_Equip;
  else
    quote.equippedItems &= ~Item_To_Equip;
}

//----- (00416CA0) --------------------------------------------------------
// Leaves "Inspecting" mode
// Unused
void __cdecl andQuoteFlagsMinus2()
{
  quote.flags &= -2u;
}

//----- (00416CC0) --------------------------------------------------------
void __cdecl setNoise(int Num, int Frequency)
{
  Noise_Frequency = Frequency;
  Noise_Num = Num;
  if ( Num == 1 )
  {
    changeSoundFrequency(40, Noise_Frequency);
    changeSoundFrequency(41, Noise_Frequency + 100);
    playSoundEffect(SFXStreamNoiseSSS2, -1);
    playSoundEffect(SFXStreamNoiseSSS1, -1);
  }
  else if ( Num == 2 )
  {
    playSoundEffect(SFXHelicopterBladesSPS, -1);
  }
}
// 49E6EC: using guessed type int Noise_Num;

//----- (00416D40) --------------------------------------------------------
// Enviroment sound = 0, play sound 28,29,3A
void __cdecl cutNoise()
{
  Noise_Num = 0;
  playSoundEffect(SFXStreamNoiseSSS2, 0);
  playSoundEffect(SFXStreamNoiseSSS1, 0);
  playSoundEffect(SFXHelicopterBladesSPS, 0);
}
// 49E6EC: using guessed type int Noise_Num;

//----- (00416D80) --------------------------------------------------------
void playEnvironmentalSounds()
{
  if ( Noise_Num == 1 )
  {
    changeSoundFrequency(40, Noise_Frequency);
    changeSoundFrequency(41, Noise_Frequency + 100);
    playSoundEffect(SFXStreamNoiseSSS2, -1);
    playSoundEffect(SFXStreamNoiseSSS1, -1);
  }
  else if ( Noise_Num == 2 )
  {
    playSoundEffect(SFXHelicopterBladesSPS, -1);
  }
}
// 49E6EC: using guessed type int Noise_Num;

//----- (00416DF0) --------------------------------------------------------
void playStreamNoiseAndHelicopterBlades()
{
  playSoundEffect(SFXStreamNoiseSSS2, 0);
  playSoundEffect(SFXStreamNoiseSSS1, 0);
  playSoundEffect(SFXHelicopterBladesSPS, 0);
}

//----- (00416E30) --------------------------------------------------------
signed int __cdecl Quote_Collision_Block(int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0;
  if ( quote.YPos - quote.Hitbox.top < (16 * Y_Pos + 4) << 9
    && quote.Hitbox.bottom + quote.YPos > (16 * Y_Pos - 4) << 9
    && quote.XPos - quote.Hitbox.back < (16 * X_Pos + 8) << 9
    && quote.XPos - quote.Hitbox.back > X_Pos << 13 )
  {
    quote.XPos = quote.Hitbox.back + ((16 * X_Pos + 8) << 9);
    if ( quote.XVel < -384 )
      quote.XVel = -384;
    if ( !(keyLeft & keyHeld) && quote.XVel < 0 )
      quote.XVel = 0;
    hit = 1;
  }
  if ( quote.YPos - quote.Hitbox.top < (16 * Y_Pos + 4) << 9
    && quote.Hitbox.bottom + quote.YPos > (16 * Y_Pos - 4) << 9
    && quote.Hitbox.back + quote.XPos > (16 * X_Pos - 8) << 9
    && quote.Hitbox.back + quote.XPos < X_Pos << 13 )
  {
    quote.XPos = ((16 * X_Pos - 8) << 9) - quote.Hitbox.back;
    if ( quote.XVel > 384 )
      quote.XVel = 384;
    if ( !(keyRight & keyHeld) && quote.XVel > 0 )
      quote.XVel = 0;
    hit |= 4u;
  }
  if ( quote.XPos - quote.Hitbox.back < (16 * X_Pos + 5) << 9
    && quote.Hitbox.back + quote.XPos > (16 * X_Pos - 5) << 9
    && quote.YPos - quote.Hitbox.top < (16 * Y_Pos + 8) << 9
    && quote.YPos - quote.Hitbox.top > Y_Pos << 13 )
  {
    quote.YPos = quote.Hitbox.top + ((16 * Y_Pos + 8) << 9);
    if ( !(quote.flags & 2) && quote.YVel < -512 )
      Put_Bump_Stars();
    if ( quote.YVel < 0 )
      quote.YVel = 0;
    hit |= 2u;
  }
  if ( quote.XPos - quote.Hitbox.back < (16 * X_Pos + 5) << 9
    && quote.Hitbox.back + quote.XPos > (16 * X_Pos - 5) << 9
    && quote.Hitbox.bottom + quote.YPos > (16 * Y_Pos - 8) << 9
    && quote.Hitbox.bottom + quote.YPos < Y_Pos << 13 )
  {
    quote.YPos = ((16 * Y_Pos - 8) << 9) - quote.Hitbox.bottom;
    if ( quote.YVel > 1024 )
      playSoundEffect(SFXQuoteHitGround, 1);
    if ( quote.YVel > 0 )
      quote.YVel = 0;
    hit |= 8u;
  }
  return hit;
}
// 493630: using guessed type int keyLeft;
// 493638: using guessed type int keyRight;
// 49E210: using guessed type int keyHeld;

//----- (00417160) --------------------------------------------------------
void Put_Bump_Stars()
{
  if ( !(quote.flags & 2) && quote.YVel < -512 )
  {
    playSoundEffect(SFXQuoteBumpHead, 1);
    createEffect(quote.XPos, quote.YPos - quote.Hitbox.top, effectUnknownUnused, 0);
    createEffect(quote.XPos, quote.YPos - quote.Hitbox.top, effectUnknownUnused, 0);
  }
}

//----- (004171D0) --------------------------------------------------------
signed int __cdecl Quote_Collision_Roof_Slope_1(int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0;
  if ( quote.XPos < (16 * X_Pos + 8) << 9
    && quote.XPos > (16 * X_Pos - 8) << 9
    && quote.YPos - quote.Hitbox.top < (Y_Pos << 13) - (quote.XPos - (X_Pos << 13)) / 2 + 2048
    && quote.Hitbox.bottom + quote.YPos > (16 * Y_Pos - 8) << 9 )
  {
    quote.YPos = (Y_Pos << 13) - (quote.XPos - (X_Pos << 13)) / 2 + quote.Hitbox.top + 2048;
    if ( !(quote.flags & 2) && quote.YVel < -512 )
      Put_Bump_Stars();
    if ( quote.YVel < 0 )
      quote.YVel = 0;
    hit = 2;
  }
  return hit;
}

//----- (004172E0) --------------------------------------------------------
signed int __cdecl Quote_Collision_Roof_Slope_2(int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0;
  if ( quote.XPos < (16 * X_Pos + 8) << 9
    && quote.XPos > (16 * X_Pos - 8) << 9
    && quote.YPos - quote.Hitbox.top < (Y_Pos << 13) - (quote.XPos - (X_Pos << 13)) / 2 - 2048
    && quote.Hitbox.bottom + quote.YPos > (16 * Y_Pos - 8) << 9 )
  {
    quote.YPos = (Y_Pos << 13) - (quote.XPos - (X_Pos << 13)) / 2 + quote.Hitbox.top - 2048;
    if ( !(quote.flags & 2) && quote.YVel < -512 )
      Put_Bump_Stars();
    if ( quote.YVel < 0 )
      quote.YVel = 0;
    hit = 2;
  }
  return hit;
}

//----- (004173F0) --------------------------------------------------------
signed int __cdecl Quote_Collision_Roof_Slope_3(int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0;
  if ( quote.XPos < (16 * X_Pos + 8) << 9
    && quote.XPos > (16 * X_Pos - 8) << 9
    && quote.YPos - quote.Hitbox.top < (Y_Pos << 13) + (quote.XPos - (X_Pos << 13)) / 2 - 2048
    && quote.Hitbox.bottom + quote.YPos > (16 * Y_Pos - 8) << 9 )
  {
    quote.YPos = (quote.XPos - (X_Pos << 13)) / 2 + quote.Hitbox.top + (Y_Pos << 13) - 2048;
    if ( !(quote.flags & 2) && quote.YVel < -512 )
      Put_Bump_Stars();
    if ( quote.YVel < 0 )
      quote.YVel = 0;
    hit = 2;
  }
  return hit;
}

//----- (00417500) --------------------------------------------------------
signed int __cdecl Quote_Collision_Roof_Slope_4(int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0;
  if ( quote.XPos < (16 * X_Pos + 8) << 9
    && quote.XPos > (16 * X_Pos - 8) << 9
    && quote.YPos - quote.Hitbox.top < (Y_Pos << 13) + (quote.XPos - (X_Pos << 13)) / 2 + 2048
    && quote.Hitbox.bottom + quote.YPos > (16 * Y_Pos - 8) << 9 )
  {
    quote.YPos = (quote.XPos - (X_Pos << 13)) / 2 + quote.Hitbox.top + (Y_Pos << 13) + 2048;
    if ( !(quote.flags & 2) && quote.YVel < -512 )
      Put_Bump_Stars();
    if ( quote.YVel < 0 )
      quote.YVel = 0;
    hit = 2;
  }
  return hit;
}

//----- (00417610) --------------------------------------------------------
signed int __cdecl Quote_Collision_Floor_Slope_1(int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0x10000;
  if ( quote.XPos < (16 * X_Pos + 8) << 9
    && quote.XPos > (16 * X_Pos - 8) << 9
    && quote.Hitbox.bottom + quote.YPos > (Y_Pos << 13) + (quote.XPos - (X_Pos << 13)) / 2 - 2048
    && quote.YPos - quote.Hitbox.top < (16 * Y_Pos + 8) << 9 )
  {
    quote.YPos = (Y_Pos << 13) + (quote.XPos - (X_Pos << 13)) / 2 - 2048 - quote.Hitbox.bottom;
    if ( quote.YVel > 1024 )
      playSoundEffect(SFXQuoteHitGround, 1);
    if ( quote.YVel > 0 )
      quote.YVel = 0;
    hit = 0x10028;
  }
  return hit;
}

//----- (00417720) --------------------------------------------------------
signed int __cdecl Quote_Collision_Floor_Slope_2(int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0x20000;
  if ( quote.XPos < (16 * X_Pos + 8) << 9
    && quote.XPos > (16 * X_Pos - 8) << 9
    && quote.Hitbox.bottom + quote.YPos > (Y_Pos << 13) + (quote.XPos - (X_Pos << 13)) / 2 + 2048
    && quote.YPos - quote.Hitbox.top < (16 * Y_Pos + 8) << 9 )
  {
    quote.YPos = (Y_Pos << 13) + (quote.XPos - (X_Pos << 13)) / 2 + 2048 - quote.Hitbox.bottom;
    if ( quote.YVel > 1024 )
      playSoundEffect(SFXQuoteHitGround, 1);
    if ( quote.YVel > 0 )
      quote.YVel = 0;
    hit = 0x20028;
  }
  return hit;
}

//----- (00417830) --------------------------------------------------------
signed int __cdecl Quote_Collision_Floor_Slope_3(int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0x40000;
  if ( quote.XPos < (16 * X_Pos + 8) << 9
    && quote.XPos > (16 * X_Pos - 8) << 9
    && quote.Hitbox.bottom + quote.YPos > (Y_Pos << 13) - (quote.XPos - (X_Pos << 13)) / 2 + 2048
    && quote.YPos - quote.Hitbox.top < (16 * Y_Pos + 8) << 9 )
  {
    quote.YPos = (Y_Pos << 13) - (quote.XPos - (X_Pos << 13)) / 2 + 2048 - quote.Hitbox.bottom;
    if ( quote.YVel > 1024 )
      playSoundEffect(SFXQuoteHitGround, 1);
    if ( quote.YVel > 0 )
      quote.YVel = 0;
    hit = 0x40018;
  }
  return hit;
}

//----- (00417940) --------------------------------------------------------
signed int __cdecl Quote_Collision_Floor_Slope_4(int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0x80000;
  if ( quote.XPos < (16 * X_Pos + 8) << 9
    && quote.XPos > (16 * X_Pos - 8) << 9
    && quote.Hitbox.bottom + quote.YPos > (Y_Pos << 13) - (quote.XPos - (X_Pos << 13)) / 2 - 2048
    && quote.YPos - quote.Hitbox.top < (16 * Y_Pos + 8) << 9 )
  {
    quote.YPos = (Y_Pos << 13) - (quote.XPos - (X_Pos << 13)) / 2 - 2048 - quote.Hitbox.bottom;
    if ( quote.YVel > 1024 )
      playSoundEffect(SFXQuoteHitGround, 1);
    if ( quote.YVel > 0 )
      quote.YVel = 0;
    hit = 524312;
  }
  return hit;
}

//----- (00417A50) --------------------------------------------------------
signed int __cdecl Quote_Collision_Water(int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0;
  if ( quote.XPos - quote.Hitbox.back < (16 * X_Pos + 5) << 9
    && quote.Hitbox.back + quote.XPos > (16 * X_Pos - 5) << 9
    && quote.YPos - quote.Hitbox.top < (16 * Y_Pos + 5) << 9
    && quote.Hitbox.bottom + quote.YPos > Y_Pos << 13 )
  {
    hit = 0x100;
  }
  return hit;
}

//----- (00417AE0) --------------------------------------------------------
signed int __cdecl Quote_Collision_Spike(int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0;
  if ( quote.XPos - 2048 < (16 * X_Pos + 4) << 9
    && quote.XPos + 2048 > (16 * X_Pos - 4) << 9
    && quote.YPos - 2048 < (16 * Y_Pos + 3) << 9
    && quote.YPos + 2048 > (16 * Y_Pos - 3) << 9 )
  {
    hit = 0x400;
  }
  return hit;
}

//----- (00417B70) --------------------------------------------------------
signed int __cdecl Quote_Collision_Spike_Water(int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0;
  if ( quote.XPos - 2048 < (16 * X_Pos + 4) << 9
    && quote.XPos + 2048 > (16 * X_Pos - 4) << 9
    && quote.YPos - 2048 < (16 * Y_Pos + 3) << 9
    && quote.YPos + 2048 > (16 * Y_Pos - 3) << 9 )
  {
    hit = 0xD00;
  }
  return hit;
}

//----- (00417C00) --------------------------------------------------------
signed int __cdecl Quote_Collision_Wind_Left(int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0;
  if ( quote.XPos - quote.Hitbox.back < (16 * X_Pos + 6) << 9
    && quote.Hitbox.back + quote.XPos > (16 * X_Pos - 6) << 9
    && quote.YPos - quote.Hitbox.top < (16 * Y_Pos + 6) << 9
    && quote.Hitbox.bottom + quote.YPos > (16 * Y_Pos - 6) << 9 )
  {
    hit = 0x1000;
  }
  return hit;
}

//----- (00417C90) --------------------------------------------------------
signed int __cdecl Quote_Collision_Wind_Up(int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0;
  if ( quote.XPos - quote.Hitbox.back < (16 * X_Pos + 6) << 9
    && quote.Hitbox.back + quote.XPos > (16 * X_Pos - 6) << 9
    && quote.YPos - quote.Hitbox.top < (16 * Y_Pos + 6) << 9
    && quote.Hitbox.bottom + quote.YPos > (16 * Y_Pos - 6) << 9 )
  {
    hit = 0x2000;
  }
  return hit;
}

//----- (00417D20) --------------------------------------------------------
signed int __cdecl Quote_Collision_Wind_Right(int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0;
  if ( quote.XPos - quote.Hitbox.back < (16 * X_Pos + 6) << 9
    && quote.Hitbox.back + quote.XPos > (16 * X_Pos - 6) << 9
    && quote.YPos - quote.Hitbox.top < (16 * Y_Pos + 6) << 9
    && quote.Hitbox.bottom + quote.YPos > (16 * Y_Pos - 6) << 9 )
  {
    hit = 0x4000;
  }
  return hit;
}

//----- (00417DB0) --------------------------------------------------------
signed int __cdecl Quote_Collision_Wind_Down(int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0;
  if ( quote.XPos - quote.Hitbox.back < (16 * X_Pos + 6) << 9
    && quote.Hitbox.back + quote.XPos > (16 * X_Pos - 6) << 9
    && quote.YPos - quote.Hitbox.top < (16 * Y_Pos + 6) << 9
    && quote.Hitbox.bottom + quote.YPos > (16 * Y_Pos - 6) << 9 )
  {
    hit = 0x8000;
  }
  return hit;
}

//----- (00417E40) --------------------------------------------------------
void __cdecl doCollisionCheckPlayerMap()
{
  unsigned __int8 v0; // al
  int Off_X[4]; // [esp+4h] [ebp-30h]
  char Attributes[4]; // [esp+14h] [ebp-20h]
  int i; // [esp+18h] [ebp-1Ch]
  int Off_Y[4]; // [esp+1Ch] [ebp-18h]
  int Quote_X_Pos_Blocks; // [esp+2Ch] [ebp-8h]
  int Quote_Y_Pos_Blocks; // [esp+30h] [ebp-4h]

  Quote_X_Pos_Blocks = quote.XPos / 16 / 512;
  Quote_Y_Pos_Blocks = quote.YPos / 16 / 512;
  Off_X[0] = 0;
  Off_X[1] = 1;
  Off_X[2] = 0;
  Off_X[3] = 1;
  Off_Y[0] = 0;
  Off_Y[1] = 0;
  Off_Y[2] = 1;
  Off_Y[3] = 1;
  for ( i = 0; i < 4; ++i )
  {
    v0 = getTileAttributes(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
    Attributes[i] = v0;
    switch ( Attributes[i] )
    {
      case 2:
        quote.collisionFlags |= Quote_Collision_Water(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 5:
      case 65:
      case 67:
      case 70:
        quote.collisionFlags |= Quote_Collision_Block(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 66:
        quote.collisionFlags |= Quote_Collision_Spike(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 80:
        quote.collisionFlags |= Quote_Collision_Roof_Slope_1(
                                  Off_X[i] + Quote_X_Pos_Blocks,
                                  Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 81:
        quote.collisionFlags |= Quote_Collision_Roof_Slope_2(
                                  Off_X[i] + Quote_X_Pos_Blocks,
                                  Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 82:
        quote.collisionFlags |= Quote_Collision_Roof_Slope_3(
                                  Off_X[i] + Quote_X_Pos_Blocks,
                                  Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 83:
        quote.collisionFlags |= Quote_Collision_Roof_Slope_4(
                                  Off_X[i] + Quote_X_Pos_Blocks,
                                  Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 84:
        quote.collisionFlags |= Quote_Collision_Floor_Slope_1(
                                  Off_X[i] + Quote_X_Pos_Blocks,
                                  Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 85:
        quote.collisionFlags |= Quote_Collision_Floor_Slope_2(
                                  Off_X[i] + Quote_X_Pos_Blocks,
                                  Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 86:
        quote.collisionFlags |= Quote_Collision_Floor_Slope_3(
                                  Off_X[i] + Quote_X_Pos_Blocks,
                                  Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 87:
        quote.collisionFlags |= Quote_Collision_Floor_Slope_4(
                                  Off_X[i] + Quote_X_Pos_Blocks,
                                  Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 96:
        quote.collisionFlags |= Quote_Collision_Water(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 97:
        quote.collisionFlags |= Quote_Collision_Block(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        quote.collisionFlags |= Quote_Collision_Water(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 98:
        quote.collisionFlags |= Quote_Collision_Spike_Water(
                                  Off_X[i] + Quote_X_Pos_Blocks,
                                  Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 112:
        quote.collisionFlags |= Quote_Collision_Roof_Slope_1(
                                  Off_X[i] + Quote_X_Pos_Blocks,
                                  Off_Y[i] + Quote_Y_Pos_Blocks);
        quote.collisionFlags |= Quote_Collision_Water(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 113:
        quote.collisionFlags |= Quote_Collision_Roof_Slope_2(
                                  Off_X[i] + Quote_X_Pos_Blocks,
                                  Off_Y[i] + Quote_Y_Pos_Blocks);
        quote.collisionFlags |= Quote_Collision_Water(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 114:
        quote.collisionFlags |= Quote_Collision_Roof_Slope_3(
                                  Off_X[i] + Quote_X_Pos_Blocks,
                                  Off_Y[i] + Quote_Y_Pos_Blocks);
        quote.collisionFlags |= Quote_Collision_Water(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 115:
        quote.collisionFlags |= Quote_Collision_Roof_Slope_4(
                                  Off_X[i] + Quote_X_Pos_Blocks,
                                  Off_Y[i] + Quote_Y_Pos_Blocks);
        quote.collisionFlags |= Quote_Collision_Water(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 116:
        quote.collisionFlags |= Quote_Collision_Floor_Slope_1(
                                  Off_X[i] + Quote_X_Pos_Blocks,
                                  Off_Y[i] + Quote_Y_Pos_Blocks);
        quote.collisionFlags |= Quote_Collision_Water(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 117:
        quote.collisionFlags |= Quote_Collision_Floor_Slope_2(
                                  Off_X[i] + Quote_X_Pos_Blocks,
                                  Off_Y[i] + Quote_Y_Pos_Blocks);
        quote.collisionFlags |= Quote_Collision_Water(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 118:
        quote.collisionFlags |= Quote_Collision_Floor_Slope_3(
                                  Off_X[i] + Quote_X_Pos_Blocks,
                                  Off_Y[i] + Quote_Y_Pos_Blocks);
        quote.collisionFlags |= Quote_Collision_Water(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 119:
        quote.collisionFlags |= Quote_Collision_Floor_Slope_4(
                                  Off_X[i] + Quote_X_Pos_Blocks,
                                  Off_Y[i] + Quote_Y_Pos_Blocks);
        quote.collisionFlags |= Quote_Collision_Water(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 128:
        quote.collisionFlags |= Quote_Collision_Wind_Left(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 129:
        quote.collisionFlags |= Quote_Collision_Wind_Up(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 130:
        quote.collisionFlags |= Quote_Collision_Wind_Right(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 131:
        quote.collisionFlags |= Quote_Collision_Wind_Down(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 160:
        quote.collisionFlags |= Quote_Collision_Wind_Left(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        quote.collisionFlags |= Quote_Collision_Water(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 161:
        quote.collisionFlags |= Quote_Collision_Wind_Up(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        quote.collisionFlags |= Quote_Collision_Water(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 162:
        quote.collisionFlags |= Quote_Collision_Wind_Right(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        quote.collisionFlags |= Quote_Collision_Water(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      case 163:
        quote.collisionFlags |= Quote_Collision_Wind_Down(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        quote.collisionFlags |= Quote_Collision_Water(Off_X[i] + Quote_X_Pos_Blocks, Off_Y[i] + Quote_Y_Pos_Blocks);
        break;
      default:
        continue;
    }
  }
  if ( quote.YPos > globalWaterDepth + 2048 )
    quote.collisionFlags |= 0x100u;
}
// 499C90: using guessed type int globalWaterDepth;
// 417E40: using guessed type char Attributes[4];

//----- (004187F0) --------------------------------------------------------
signed int __cdecl Entity_Collision_Solid(NPC *npc)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0;
  if ( quote.YPos - quote.Hitbox.top < npc->YPos + npc->hitbox.bottom - 1536
    && quote.Hitbox.bottom + quote.YPos > npc->YPos - npc->hitbox.top + 1536
    && quote.XPos - quote.Hitbox.back < npc->hitbox.back + npc->XPos
    && quote.XPos - quote.Hitbox.back > npc->XPos )
  {
    if ( quote.XVel < 512 )
      quote.XVel += 512;
    hit = 1;
  }
  if ( quote.YPos - quote.Hitbox.top < npc->YPos + npc->hitbox.bottom - 1536
    && quote.Hitbox.bottom + quote.YPos > npc->YPos - npc->hitbox.top + 1536
    && quote.XPos + quote.Hitbox.back - 512 > npc->XPos - npc->hitbox.back
    && quote.XPos + quote.Hitbox.back - 512 < npc->XPos )
  {
    if ( quote.XVel > -512 )
      quote.XVel -= 512;
    hit |= 4u;
  }
  if ( quote.XPos - quote.Hitbox.back < npc->XPos + npc->hitbox.back - 1536
    && quote.Hitbox.back + quote.XPos > npc->XPos - npc->hitbox.back + 1536
    && quote.YPos - quote.Hitbox.top < npc->hitbox.bottom + npc->YPos
    && quote.YPos - quote.Hitbox.top > npc->YPos )
  {
    if ( quote.YVel < 0 )
      quote.YVel = 0;
    hit |= 2u;
  }
  if ( quote.XPos - quote.Hitbox.back < npc->XPos + npc->hitbox.back - 1536
    && quote.Hitbox.back + quote.XPos > npc->XPos - npc->hitbox.back + 1536
    && quote.Hitbox.bottom + quote.YPos > npc->YPos - npc->hitbox.top
    && quote.Hitbox.bottom + quote.YPos < npc->YPos + 1536 )
  {
    if ( npc->entityFlags & 0x10 )
    {
      quote.YVel = npc->YVel - 512;
      hit |= 8u;
    }
    else if ( !(quote.collisionFlags & 8) && quote.YVel > npc->YVel )
    {
      quote.YPos = npc->YPos - npc->hitbox.top - quote.Hitbox.bottom + 512;
      quote.YVel = npc->YVel;
      quote.XPos += npc->XVel;
      hit |= 8u;
    }
  }
  return hit;
}

//----- (00418B10) --------------------------------------------------------
unsigned __int8 __cdecl Entity_Collision_NonSolid(NPC *npc)
{
  if ( npc->direction )
  {
    if ( quote.XPos + 1024 > npc->XPos - npc->hitbox.back
      && quote.XPos - 1024 < npc->hitbox.front + npc->XPos
      && quote.YPos + 1024 > npc->YPos - npc->hitbox.top
      && quote.YPos - 1024 < npc->hitbox.bottom + npc->YPos )
    {
      return 1;
    }
  }
  else if ( quote.XPos + 1024 > npc->XPos - npc->hitbox.front
         && quote.XPos - 1024 < npc->hitbox.back + npc->XPos
         && quote.YPos + 1024 > npc->YPos - npc->hitbox.top
         && quote.YPos - 1024 < npc->hitbox.bottom + npc->YPos )
  {
    return 1;
  }
  return 0;
}

//----- (00418C20) --------------------------------------------------------
signed int __cdecl Entity_Collision_SpecialSolid(NPC *npc)
{
  long double v1; // fst7
  long double v2; // fst7
  float fy1; // ST24_4
  float fy2; // ST1C_4
  float fx2; // [esp+10h] [ebp-14h]
  signed int hit; // [esp+18h] [ebp-Ch]
  float fx1; // [esp+20h] [ebp-4h]

  hit = 0;
  if ( npc->XPos <= quote.XPos )
    v1 = (long double)(quote.XPos - npc->XPos);
  else
    v1 = (long double)(npc->XPos - quote.XPos);
  fx1 = v1;
  if ( npc->YPos <= quote.YPos )
    v2 = (long double)(quote.YPos - npc->YPos);
  else
    v2 = (long double)(npc->YPos - quote.YPos);
  fx2 = (long double)npc->hitbox.back;
  if ( fx1 == 0.0 )
    fx1 = 1.0;
  if ( fx2 == 0.0 )
    fx2 = 1.0;
  fy2 = (long double)npc->hitbox.top;
  fy1 = v2;
  if ( fy2 / fx2 >= fy1 / fx1 )
  {
    if ( quote.YPos - quote.Hitbox.top < npc->hitbox.bottom + npc->YPos
      && quote.Hitbox.bottom + quote.YPos > npc->YPos - npc->hitbox.top )
    {
      if ( quote.XPos - quote.Hitbox.back < npc->hitbox.back + npc->XPos && quote.XPos - quote.Hitbox.back > npc->XPos )
      {
        if ( quote.XVel < npc->XVel )
          quote.XVel = npc->XVel;
        quote.XPos = quote.Hitbox.back + npc->hitbox.back + npc->XPos;
        hit = 1;
      }
      if ( quote.Hitbox.back + quote.XPos > npc->XPos - npc->hitbox.back && quote.Hitbox.back + quote.XPos < npc->XPos )
      {
        if ( quote.XVel > npc->XVel )
          quote.XVel = npc->XVel;
        quote.XPos = npc->XPos - npc->hitbox.back - quote.Hitbox.back;
        hit |= 4u;
      }
    }
  }
  else if ( quote.XPos - quote.Hitbox.back < npc->hitbox.back + npc->XPos
         && quote.Hitbox.back + quote.XPos > npc->XPos - npc->hitbox.back )
  {
    if ( quote.YPos - quote.Hitbox.top < npc->hitbox.bottom + npc->YPos && quote.YPos - quote.Hitbox.top > npc->YPos )
    {
      if ( quote.YVel >= npc->YVel )
      {
        if ( quote.YVel < 0 )
          quote.YVel = 0;
      }
      else
      {
        quote.YPos = npc->hitbox.bottom + npc->YPos + quote.Hitbox.top + 512;
        quote.YVel = npc->YVel;
      }
      hit = 2;
    }
    if ( quote.Hitbox.bottom + quote.YPos > npc->YPos - npc->hitbox.top
      && quote.Hitbox.bottom + quote.YPos < npc->YPos + 1536 )
    {
      if ( quote.YVel - npc->YVel > 1024 )
        playSoundEffect(SFXQuoteHitGround, 1);
      if ( quote.isInFishBattle == 1 )
      {
        quote.YPos = npc->YPos - npc->hitbox.top - quote.Hitbox.bottom + 512;
        hit |= 8u;
      }
      else if ( npc->entityFlags & 0x10 )
      {
        quote.YVel = npc->YVel - 512;
        hit |= 8u;
      }
      else if ( !(quote.collisionFlags & 8) && quote.YVel > npc->YVel )
      {
        quote.YPos = npc->YPos - npc->hitbox.top - quote.Hitbox.bottom + 512;
        quote.YVel = npc->YVel;
        quote.XPos += npc->XVel;
        hit |= 8u;
      }
    }
  }
  return hit;
}

//----- (00419030) --------------------------------------------------------
// Run collision checks for every entity vs. Quote
void doCollisionCheckPlayerNPCs()
{
  signed int hit; // [esp+0h] [ebp-8h]
  signed int i; // [esp+4h] [ebp-4h]

  if ( quote.flags & 0x80 && !(quote.flags & 2) )
  {
    for ( i = 0; i < 512; ++i )
    {
      if ( NPCObjects[i].isAlive & 0x80 )
      {
        if ( NPCObjects[i].entityFlags & 1 )
        {
          hit = Entity_Collision_Solid(&NPCObjects[i]);
          quote.collisionFlags |= hit;
        }
        else if ( NPCObjects[i].entityFlags & 0x40 )
        {
          hit = Entity_Collision_SpecialSolid(&NPCObjects[i]);
          quote.collisionFlags |= hit;
        }
        else
        {
          hit = Entity_Collision_NonSolid(&NPCObjects[i]);
        }
        if ( hit && NPCObjects[i].entityType == 1 )
        {
          playSoundEffect(SFXGetEXP, 1);
          Add_Weapon_EXP(NPCObjects[i].EXPAmount);
          NPCObjects[i].isAlive = 0;
        }
        if ( hit && NPCObjects[i].entityType == 86 )
        {
          playSoundEffect(SFXQuoteMissileGet, 1);
          Add_Rocket_Ammo(NPCObjects[i].entityEventNum, NPCObjects[i].EXPAmount);
          NPCObjects[i].isAlive = 0;
        }
        if ( hit && NPCObjects[i].entityType == 87 )
        {
          playSoundEffect(SFXQuoteHeal, 1);
          addLifePlayer(NPCObjects[i].EXPAmount);
          NPCObjects[i].isAlive = 0;
        }
        if ( !(gameFlags & 4) && hit && NPCObjects[i].entityFlags & 0x100 )
          startTSCEvent(NPCObjects[i].entityEventNum);
        if ( gameFlags & 2 && !(NPCObjects[i].entityFlags & 0x2000) )
        {
          if ( NPCObjects[i].entityFlags & 0x80 )
          {
            if ( hit & 4 && NPCObjects[i].XVel < 0 )
              damagePlayer(NPCObjects[i].damage);
            if ( hit & 1 && NPCObjects[i].XVel > 0 )
              damagePlayer(NPCObjects[i].damage);
            if ( hit & 8 && NPCObjects[i].YVel < 0 )
              damagePlayer(NPCObjects[i].damage);
            if ( hit & 2 && NPCObjects[i].YVel > 0 )
              damagePlayer(NPCObjects[i].damage);
          }
          else if ( hit && NPCObjects[i].damage && !(gameFlags & 4) )
          {
            damagePlayer(NPCObjects[i].damage);
          }
        }
        if ( !(gameFlags & 4) && hit && quote.flags & 1 )
        {
          if ( NPCObjects[i].entityFlags & 0x2000 )
          {
            startTSCEvent(NPCObjects[i].entityEventNum);
            quote.XVel = 0;
            quote.ques = 0;
          }
        }
      }
    }
    if ( quote.ques )
      createEffect(quote.XPos, quote.YPos, effectLevelUpOrDown, 0);
  }
}
// 49E1E8: using guessed type int gameFlags;

//----- (00419450) --------------------------------------------------------
// Run collision checks with boss entities vs. Quote
void doCollisionCheckPlayerBosses()
{
  signed int i; // [esp+0h] [ebp-8h]
  signed int hit; // [esp+4h] [ebp-4h]

  if ( quote.flags & 0x80 && !(quote.flags & 2) )
  {
    for ( i = 0; i < 20; ++i )
    {
      if ( bossObjects[i].isAlive & 0x80 )
      {
        if ( bossObjects[i].entityFlags & 1 )
        {
          hit = Entity_Collision_Solid(&bossObjects[i]);
          quote.collisionFlags |= hit;
        }
        else if ( bossObjects[i].entityFlags & 0x40 )
        {
          hit = Entity_Collision_SpecialSolid(&bossObjects[i]);
          quote.collisionFlags |= hit;
        }
        else
        {
          hit = Entity_Collision_NonSolid(&bossObjects[i]);
        }
        if ( !(gameFlags & 4) && hit && bossObjects[i].entityFlags & 0x100 )
        {
          startTSCEvent(bossObjects[i].entityEventNum);
          quote.ques = 0;
        }
        if ( bossObjects[i].entityFlags & 0x80 )
        {
          if ( hit & 4 && bossObjects[i].XVel < 0 )
            damagePlayer(bossObjects[i].damage);
          if ( hit & 1 && bossObjects[i].XVel > 0 )
            damagePlayer(bossObjects[i].damage);
        }
        else if ( hit && bossObjects[i].damage && !(gameFlags & 4) )
        {
          damagePlayer(bossObjects[i].damage);
        }
        if ( !(gameFlags & 4) && hit && quote.flags & 1 )
        {
          if ( bossObjects[i].entityFlags & 0x2000 )
          {
            startTSCEvent(bossObjects[i].entityEventNum);
            quote.XVel = 0;
            quote.ques = 0;
          }
        }
      }
    }
    if ( quote.ques )
      createEffect(quote.XPos, quote.YPos, effectLevelUpOrDown, 0);
  }
}
// 49E1E8: using guessed type int gameFlags;

//----- (004196F0) --------------------------------------------------------
void __cdecl Add_Weapon_EXP(int EXP_To_Add)
{
  int Level; // [esp+0h] [ebp-8h]
  weapons Weapon_ID; // [esp+4h] [ebp-4h]

  Level = gWeapons[selectedWeapon].level - 1;
  Weapon_ID = gWeapons[selectedWeapon].weaponID;
  gWeapons[selectedWeapon].EXP += EXP_To_Add;
  if ( Level == 2 )
  {
    if ( gWeapons[selectedWeapon].EXP >= Weapon_Level_Table[Weapon_ID].exp[2] )
    {
      gWeapons[selectedWeapon].EXP = Weapon_Level_Table[Weapon_ID].exp[2];
      if ( quote.equippedItems & 0x80 )
      {
        if ( quote.star < 3 )
          ++quote.star;
      }
    }
  }
  else
  {
    while ( Level < 2 )
    {
      if ( gWeapons[selectedWeapon].EXP >= Weapon_Level_Table[Weapon_ID].exp[Level] )
      {
        ++gWeapons[selectedWeapon].level;
        gWeapons[selectedWeapon].EXP = 0;
        if ( gWeapons[selectedWeapon].weaponID != 13 )
        {
          playSoundEffect(SFXLevelUp, 1);
          createEffect(quote.XPos, quote.YPos, effectRedDamageRings, 0);
        }
      }
      ++Level;
    }
  }
  if ( gWeapons[selectedWeapon].weaponID == 13 )
  {
    quote.Level_Bar_Flashes = 10;
  }
  else
  {
    quote.Exp_To_Gain += EXP_To_Add;
    quote.Level_Bar_Flashes = 30;
  }
}
// 499C68: using guessed type int selectedWeapon;

//----- (00419890) --------------------------------------------------------
void resetSelectedWeaponLevel(void)
{
  gWeapons[selectedWeapon].level = 1;
  gWeapons[selectedWeapon].EXP = 0;
}
// 499C68: using guessed type int selectedWeapon;

//----- (004198C0) --------------------------------------------------------
// Returns 1 if weapon at MAX, 0 otherwise
bool Check_Weapon_MAX(void)
{
  return gWeapons[selectedWeapon].level == 3
      && gWeapons[selectedWeapon].EXP >= Weapon_Level_Table[gWeapons[selectedWeapon].weaponID].exp[2];
}
// 499C68: using guessed type int selectedWeapon;

//----- (00419910) --------------------------------------------------------
void __cdecl damagePlayer(int damage)
{
  if ( gameFlags | 2 && !quote.Invincibility_Timer )
  {
    playSoundEffect(SFXQuoteHurt, 1);
    quote.flags &= 0xFEu;
    quote.Invincibility_Timer = -128;
    if ( quote.isInFishBattle != 1 )
      quote.YVel = -1024;                       // Knock back Quote
    quote.Health -= damage;
    if ( quote.equippedItems & 0x80 && quote.star > 0 )
      --quote.star;
    if ( quote.equippedItems & 4 )
      gWeapons[selectedWeapon].EXP -= damage;
    else
      gWeapons[selectedWeapon].EXP -= 2 * damage;
    while ( gWeapons[selectedWeapon].EXP < 0 )
    {
      if ( gWeapons[selectedWeapon].level <= 1 )
      {
        gWeapons[selectedWeapon].EXP = 0;
      }
      else
      {
        gWeapons[selectedWeapon].EXP += Weapon_Level_Table[gWeapons[selectedWeapon].weaponID].exp[--gWeapons[selectedWeapon].level
                                                                                                - 1];
        if ( quote.Health > 0 && gWeapons[selectedWeapon].weaponID != 13 )
          createEffect(quote.XPos, quote.YPos, effectRedDamageRings, right);
      }
    }
    setValueView((__int32)&quote.XPos, (__int32)&quote.YPos, -damage);
    if ( quote.Health <= 0 )
    {
      playSoundEffect(SFXQuoteDie, 1);
      quote.flags = 0;
      createDustClouds(quote.XPos, quote.YPos, 5120, 64);
      startTSCEvent(40);
    }
  }
}
// 499C68: using guessed type int selectedWeapon;
// 49E1E8: using guessed type int gameFlags;

//----- (00419B50) --------------------------------------------------------
// TSC ZAM : Zero ArMs EXP
// Resets weapon levels
int resetAllWeaponEXP()
{
  int result; // eax
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 8; ++i )
  {
    gWeapons[i].level = 1;
    gWeapons[i].EXP = 0;
    result = i + 1;
  }
  return result;
}

//----- (00419BA0) --------------------------------------------------------
void __cdecl Add_Rocket_Ammo(int Num, int Ammo_To_Refill)
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 8 && gWeapons[i].weaponID != 5; ++i )
    ;
  if ( i != 8 )
    goto Add_Ammo;
  for ( i = 0; i < 8 && gWeapons[i].weaponID != 10; ++i )
    ;
  if ( i != 8 )
  {
Add_Ammo:
    gWeapons[i].ammo += Ammo_To_Refill;
    if ( gWeapons[i].ammo > gWeapons[i].maxAmmo )
      gWeapons[i].ammo = gWeapons[i].maxAmmo;
  }
}

//----- (00419C60) --------------------------------------------------------
// LI+ : LIfe +
// Restore Health_To_Restore amount of health
void __cdecl addLifePlayer(int Health_To_Restore)
{
  quote.Health += Health_To_Restore;
  if ( quote.Health > quote.Max_Health )
    quote.Health = quote.Max_Health;
  quote.Life_Bar = quote.Health;
}

//----- (00419CB0) --------------------------------------------------------
// MP+ : Max Life +
// Max health increased by Life_To_Add
void __cdecl addMaxLifePlayer(int Life_To_Add)
{
  quote.Max_Health += Life_To_Add;
  if ( quote.Max_Health > 232 )
    quote.Max_Health = 232;
  quote.Health += Life_To_Add;
  quote.Life_Bar = quote.Health;
}

//----- (00419D10) --------------------------------------------------------
// Renders XP Bar, Weapon Level and Weapon Ammo Displays
void __cdecl drawEXPBarAndMisc(int a1)
{
  int v1; // eax
  RECT rcView; // [esp+0h] [ebp-90h]
  RECT rect; // [esp+10h] [ebp-80h]
  RECT v4; // [esp+20h] [ebp-70h]
  int v5; // [esp+30h] [ebp-60h]
  RECT v6; // [esp+34h] [ebp-5Ch]
  RECT v7; // [esp+44h] [ebp-4Ch]
  RECT v8; // [esp+54h] [ebp-3Ch]
  int v9; // [esp+64h] [ebp-2Ch]
  RECT v10; // [esp+68h] [ebp-28h]
  RECT v11; // [esp+78h] [ebp-18h]
  int v12; // [esp+88h] [ebp-8h]
  weapons v13; // [esp+8Ch] [ebp-4h]

  v10.left = 72;
  v10.top = 48;
  v10.right = 80;
  v10.bottom = 56;
  v11.left = 80;
  v11.top = 80;
  v11.right = 96;
  v11.bottom = 88;
  rcView.left = 0;
  rcView.top = 0;
  rcView.right = 320;
  rcView.bottom = 240;
  rect.left = 80;
  rect.top = 48;
  rect.right = 96;
  rect.bottom = 56;
  if ( weaponIconXOffset > 16 )
    weaponIconXOffset -= 2;
  if ( weaponIconXOffset < 16 )
    weaponIconXOffset += 2;
  if ( gWeapons[selectedWeapon].maxAmmo )
  {
    drawNumbers(weaponIconXOffset + 32, 16, gWeapons[selectedWeapon].ammo, 0);
    drawNumbers(weaponIconXOffset + 32, 24, gWeapons[selectedWeapon].maxAmmo, 0);
  }
  else
  {
    drawBitmapWithTransparency(&rcView, weaponIconXOffset + 48, 16, &rect, 26);
    drawBitmapWithTransparency(&rcView, weaponIconXOffset + 48, 24, &rect, 26);
  }
  if ( a1 != 1 || !(quote.Invincibility_Timer / 2 % 2) )
  {
    drawBitmapWithTransparency(&rcView, weaponIconXOffset + 32, 24, &v10, 26);
    drawBitmapWithTransparency(&rcView, weaponIconXOffset, 32, &v11, 26);
    drawNumbers(weaponIconXOffset - 8, 32, gWeapons[selectedWeapon].level, 0);
    v7.left = 0;
    v7.top = 72;
    v7.right = 40;
    v7.bottom = 80;
    v4.left = 0;
    v4.top = 80;
    v4.right = 0;
    v4.bottom = 88;
    v8.left = 40;
    v8.top = 72;
    v8.right = 80;
    v8.bottom = 80;
    v6.left = 40;
    v6.top = 80;
    v6.right = 80;
    v6.bottom = 88;
    v12 = gWeapons[selectedWeapon].level - 1;
    v13 = gWeapons[selectedWeapon].weaponID;
    v9 = gWeapons[selectedWeapon].EXP;
    v5 = Weapon_Level_Table[v13].exp[v12];
    drawBitmapWithTransparency(&rcView, weaponIconXOffset + 24, 32, &v7, 26);
    if ( v12 != 2 || gWeapons[selectedWeapon].EXP != Weapon_Level_Table[v13].exp[2] )
    {
      if ( v5 )
        v4.right += 40 * v9 / v5;
      else
        v4.right = 0;
      drawBitmapWithTransparency(&rcView, weaponIconXOffset + 24, 32, &v4, 26);
    }
    else
    {
      drawBitmapWithTransparency(&rcView, weaponIconXOffset + 24, 32, &v8, 26);
    }
    if ( quote.Level_Bar_Flashes )
    {
      v1 = (unsigned __int8)byte_49E6F8++ / 2 % 2;
      if ( v1 )
        drawBitmapWithTransparency(&rcView, weaponIconXOffset + 24, 32, &v6, 26);
    }
  }
}
// 499C68: using guessed type int selectedWeapon;
// 49E6F8: using guessed type char byte_49E6F8;

//----- (0041A0B0) --------------------------------------------------------
int drawHUDWeaponIcons()
{
  int result; // eax
  int i; // [esp+0h] [ebp-1Ch]
  int XPos; // [esp+4h] [ebp-18h]
  int j; // [esp+8h] [ebp-14h]
  RECT rect; // [esp+Ch] [ebp-10h]

  rect.left = 0;
  rect.top = 0;
  rect.right = 0;
  rect.bottom = 16;
  for ( i = 0; ; ++i )
  {
    result = 20 * i;
    if ( gWeapons[i].weaponID == 0 )
      break;
  }
  if ( i )
  {
    for ( j = 0; ; ++j )
    {
      result = j;
      if ( j >= i )
        break;
      XPos = weaponIconXOffset + 16 * (j - selectedWeapon);
      if ( XPos >= 8 )
      {
        if ( XPos >= 24 )
          XPos += 48;
      }
      else
      {
        XPos += 16 * i + 48;
      }
      if ( XPos >= 16 * (i - 1) + 72 )
        XPos -= 16 * i + 48;
      if ( XPos < 72 && XPos >= 24 )
        XPos -= 48;
      rect.left = 16 * gWeapons[j].weaponID;
      rect.right = rect.left + 16;
      drawBitmapWithTransparency(&gameRect, XPos, 16, &rect, 12);
    }
  }
  return result;
}
// 499C68: using guessed type int selectedWeapon;

//----- (0041A1D0) --------------------------------------------------------
// Renders HP bar and HP numbers
void __cdecl drawHealthBar(int Always_1)
{
  int Src_Rects; // [esp+0h] [ebp-30h]
  int v2; // [esp+4h] [ebp-2Ch]
  int v3; // [esp+8h] [ebp-28h]
  int v4; // [esp+Ch] [ebp-24h]
  RECT rect; // [esp+10h] [ebp-20h]
  RECT v6; // [esp+20h] [ebp-10h]

  Src_Rects = 0;
  v2 = 40;
  v3 = 232;
  v4 = 48;
  v6.left = 0;
  v6.top = 24;
  v6.right = 232;
  v6.bottom = 32;
  rect.left = 0;
  rect.top = 32;
  rect.right = 232;
  rect.bottom = 40;
  if ( Always_1 != 1 || !(quote.Invincibility_Timer / 2 % 2) )
  {
    if ( quote.Life_Bar < quote.Health )
      quote.Life_Bar = quote.Health;
    if ( quote.Life_Bar <= quote.Health )
    {
      quote.Health_Bar_Timer = 0;
    }
    else if ( ++quote.Health_Bar_Timer > 30 )
    {
      --quote.Life_Bar;
    }
    v3 = 64;
    v6.right = 40 * quote.Health / quote.Max_Health - 1;
    rect.right = 40 * quote.Life_Bar / quote.Max_Health - 1;
    drawBitmapWithTransparency(&gameRect, 16, 40, (RECT *)&Src_Rects, 26);
    drawBitmapWithTransparency(&gameRect, 40, 40, &rect, 26);
    drawBitmapWithTransparency(&gameRect, 40, 40, &v6, 26);
    drawNumbers(8, 40, quote.Life_Bar, 0);
  }
}

//----- (0041A350) --------------------------------------------------------
void __cdecl drawUnderwaterTimer(int XPos, int YPos)
{
  int Rects; // [esp+0h] [ebp-20h]
  int v3; // [esp+4h] [ebp-1Ch]
  int v4; // [esp+8h] [ebp-18h]
  int v5; // [esp+Ch] [ebp-14h]
  RECT rect; // [esp+10h] [ebp-10h]

  Rects = 112;
  v3 = 72;
  v4 = 144;
  v5 = 80;
  rect.left = 112;
  rect.top = 80;
  rect.right = 144;
  rect.bottom = 88;
  if ( !(quote.equippedItems & 0x10) && quote.air_get )
  {
    if ( quote.air_get % 6 < 4 )
      drawNumbers(XPos + 32, YPos, quote.Air / 10, 0);
    if ( quote.Air % 30 <= 10 )
      drawBitmapWithTransparency(&gameRect, XPos, YPos, &rect, 26);
    else
      drawBitmapWithTransparency(&gameRect, XPos, YPos, (RECT *)&Rects, 26);
  }
}

//----- (0041A430) --------------------------------------------------------
void __cdecl drawNikamaruTimer(int X_Pos, int Y_Pos)
{
  RECT Rect_Time[3]; // [esp+0h] [ebp-30h]

  Rect_Time[0].left = 112;
  Rect_Time[0].top = 104;
  Rect_Time[0].right = 120;
  Rect_Time[0].bottom = 112;
  Rect_Time[1].left = 120;
  Rect_Time[1].top = 104;
  Rect_Time[1].right = 128;
  Rect_Time[1].bottom = 112;
  Rect_Time[2].left = 128;
  Rect_Time[2].top = 104;
  Rect_Time[2].right = 160;
  Rect_Time[2].bottom = 112;
  if ( quote.equippedItems & 0x100 )
  {
    if ( gameFlags & 2 )
    {
      if ( Nikumaru_Counter < 300000 )
        ++Nikumaru_Counter;
      if ( Nikumaru_Counter % 30 <= 10 )
        drawBitmapWithTransparency(&gameRect, X_Pos, Y_Pos, &Rect_Time[1], 26);
      else
        drawBitmapWithTransparency(&gameRect, X_Pos, Y_Pos, Rect_Time, 26);
    }
    else
    {
      drawBitmapWithTransparency(&gameRect, X_Pos, Y_Pos, Rect_Time, 26);
    }
    drawNumbers(X_Pos, Y_Pos, Nikumaru_Counter / 3000, 0);
    drawNumbers(X_Pos + 20, Y_Pos, Nikumaru_Counter / 50 % 60, 1);
    drawNumbers(X_Pos + 32, Y_Pos, Nikumaru_Counter / 5 % 10, 0);
    drawBitmapWithTransparency(&gameRect, X_Pos + 30, Y_Pos, &Rect_Time[2], 26);
  }
  else
  {
    Nikumaru_Counter = 0;
  }
}
// 49E1E8: using guessed type int gameFlags;
// 49E6F4: using guessed type int Nikumaru_Counter;

//----- (0041A5D0) --------------------------------------------------------
signed int saveHellCounter()
{
  char v1; // al
  char str; // [esp+0h] [ebp-130h]
  HellTimeFile rec; // [esp+10Ch] [ebp-24h]
  FILE *stream; // [esp+124h] [ebp-Ch]
  int i; // [esp+128h] [ebp-8h]
  char *p; // [esp+12Ch] [ebp-4h]

  if ( !(quote.equippedItems & 0x100) )
    return 1;
  sprintf(&str, "%s\\290.rec", exePath);
  stream = fopen(&str, "rb");
  if ( stream )
  {
    fread(&rec, 0x14u, 1u, stream);
    fclose(stream);
    p = (char *)&rec;
    LOBYTE(rec.counter[0]) -= rec.random[0];
    BYTE1(rec.counter[0]) -= rec.random[0];
    BYTE2(rec.counter[0]) -= rec.random[0];
    HIBYTE(rec.counter[0]) -= rec.random[0] / 2;
    if ( rec.counter[0] < Nikumaru_Counter )
      return 1;
  }
  for ( i = 0; i < 4; ++i )
  {
    rec.counter[i] = Nikumaru_Counter;
    v1 = random(0, 250);
    rec.random[i] = i + v1;
    p = (char *)&rec.counter[i];
    LOBYTE(rec.counter[i]) += rec.random[i];
    p[1] += rec.random[i];
    p[2] += rec.random[i];
    p[3] += rec.random[i] / 2;
  }
  stream = fopen(&str, "wb");
  if ( !stream )
    return 0;
  fwrite(&rec, 0x14u, 1u, stream);
  fclose(stream);
  return 1;
}
// 49E6F4: using guessed type int Nikumaru_Counter;

//----- (0041A7C0) --------------------------------------------------------
// Returns hell time
int getHellTime()
{
  int result; // eax
  char str; // [esp+0h] [ebp-130h]
  int buffer; // [esp+10Ch] [ebp-24h]
  int v3; // [esp+110h] [ebp-20h]
  int v4; // [esp+114h] [ebp-1Ch]
  char v5[4]; // [esp+11Ch] [ebp-14h]
  FILE *stream; // [esp+124h] [ebp-Ch]
  int i; // [esp+128h] [ebp-8h]
  int *v8; // [esp+12Ch] [ebp-4h]

  sprintf(&str, "%s\\290.rec", exePath);
  stream = fopen(&str, "rb");
  if ( !stream )
    return 0;
  fread(&buffer, 0x14u, 1u, stream);
  fclose(stream);
  for ( i = 0; i < 4; ++i )
  {
    v8 = &buffer + i;
    *((_BYTE *)&buffer + 4 * i) -= v5[i];
    *((_BYTE *)v8 + 1) -= v5[i];
    *((_BYTE *)v8 + 2) -= v5[i];
    *((_BYTE *)v8 + 3) -= (unsigned __int8)v5[i] / 2;
  }
  if ( buffer == v3 && buffer == v4 )
  {
    Nikumaru_Counter = buffer;
    result = buffer;
  }
  else
  {
    Nikumaru_Counter = 0;
    result = 0;
  }
  return result;
}
// 49E6F4: using guessed type int Nikumaru_Counter;
// 41A7C0: using guessed type char var_14[4];

//----- (0041A8F0) --------------------------------------------------------
signed int __cdecl makeSoundObject(char *wavep, char track, char pipi)
{
  LPVOID lpbuf2; // [esp+0h] [ebp-60h]
  int hr; // [esp+4h] [ebp-5Ch]
  size_t dwbuf1; // [esp+8h] [ebp-58h]
  LPVOID lpbuf1; // [esp+Ch] [ebp-54h]
  size_t dwbuf2; // [esp+10h] [ebp-50h]
  unsigned int i; // [esp+14h] [ebp-4Ch]
  unsigned int j; // [esp+18h] [ebp-48h]
  DSBUFFERDESC dsbd; // [esp+1Ch] [ebp-44h]
  size_t data_size; // [esp+44h] [ebp-1Ch]
  void *wp; // [esp+48h] [ebp-18h]
  int work; // [esp+4Ch] [ebp-14h]
  _BYTE *wp_sub; // [esp+50h] [ebp-10h]
  size_t k; // [esp+54h] [ebp-Ch]
  size_t wave_size; // [esp+58h] [ebp-8h]
  unsigned int wav_tp; // [esp+5Ch] [ebp-4h] Wave pointer pointing to table

  if ( !lpDS )
    return 0;
  for ( i = 0; i < 8; ++i )
  {
    for ( j = 0; j < 2; ++j )
    {
      wave_size = oct_wave[i].wave_size;
      if ( pipi )
        data_size = wave_size * oct_wave[i].oct_size;
      else
        data_size = wave_size;
      memset(&dsbd, 0, 36u);
      dsbd.dwSize = 36;
      dsbd.dwBufferBytes = data_size;
      dsbd.lpwfxFormat = (LPWAVEFORMATEX)format_tbl2;
      dsbd.dwFlags = DSBCAPS_CTRLVOLUME|DSBCAPS_CTRLPAN|DSBCAPS_CTRLFREQUENCY|DSBCAPS_STATIC|0x8000;
      if ( lpDS->lpVtbl->CreateSoundBuffer(lpDS, &dsbd, &organBuffer[track][i][j], 0) )
        return 0;
      wp = malloc(data_size);                   // Make file workspace
      wp_sub = wp;
      wav_tp = 0;
      for ( k = 0; k < data_size; ++k )
      {
        work = wavep[wav_tp];
        work += 0x80;
        *wp_sub = work;
        wav_tp += 256 / wave_size;
        if ( wav_tp > 255 )
          wav_tp -= 256;
        ++wp_sub;
      }
      dwbuf2 = 0;
      // Data transfer
      hr = organBuffer[track][i][j]->lpVtbl->Lock(
             organBuffer[track][i][j],
             0,
             data_size,
             &lpbuf1,
             &dwbuf1,
             &lpbuf2,
             &dwbuf2,
             0);
      if ( hr )
        return 0;
      memcpy(lpbuf1, wp, dwbuf1);
      if ( dwbuf2 )
        memcpy(lpbuf2, (char *)wp + dwbuf1, dwbuf2);
      organBuffer[track][i][j]->lpVtbl->Unlock(organBuffer[track][i][j], lpbuf1, dwbuf1, lpbuf2, dwbuf2);
      organBuffer[track][i][j]->lpVtbl->SetCurrentPosition(organBuffer[track][i][j], 0);
      free(wp);
    }
  }
  return 1;
}
// D: found interdependent unknown calls

//----- (0041ABA0) --------------------------------------------------------
void __cdecl changeOrganFrequency(unsigned __int8 frequencyTableIndex, char organBufferIndex, int frequency)
{
  signed int j; // [esp+0h] [ebp-8h]
  signed int i; // [esp+4h] [ebp-4h]

  if ( lpDS )
  {
    for ( i = 0; i < 8; ++i )
    {
      for ( j = 0; j < 2; ++j )
        ((void (__cdecl *)(LPDIRECTSOUNDBUFFER, int))organBuffer[organBufferIndex][i][j]->lpVtbl->SetFrequency)(
          organBuffer[organBufferIndex][i][j],
          oct_wave[i].oct_par * frequencyTable[frequencyTableIndex] * oct_wave[i].wave_size / 8 + frequency - 1000);
    }
  }
}

//----- (0041AC70) --------------------------------------------------------
void __cdecl changeOrganPan(unsigned __int8 key, unsigned __int8 pan, char organBufferIndex)
{
  if ( lpDS )
  {
    if ( old_key[organBufferIndex] != 255 )
      organBuffer[organBufferIndex][old_key[organBufferIndex] / 12][key_twin[organBufferIndex]]->lpVtbl->SetPan(
        organBuffer[organBufferIndex][old_key[organBufferIndex] / 12][key_twin[organBufferIndex]],
        10 * (panTable[pan] - 256));
  }
}

//----- (0041AD20) --------------------------------------------------------
void __cdecl changeOrganVolume(int no, __int32 volume, char organBufferIndex)
{
  if ( lpDS )
  {
    if ( old_key[organBufferIndex] != 255 )
      organBuffer[organBufferIndex][old_key[organBufferIndex] / 12][key_twin[organBufferIndex]]->lpVtbl->SetVolume(
        organBuffer[organBufferIndex][old_key[organBufferIndex] / 12][key_twin[organBufferIndex]],
        8 * volume - 2040);
  }
}

//----- (0041ADC0) --------------------------------------------------------
void __cdecl playOrganyaObject(unsigned __int8 key, int mode, char organBufferIndex, DWORD freq)
{
  if ( lpDS && organBuffer[organBufferIndex][key / 12][key_twin[organBufferIndex]] )
  {
    if ( mode == -1 )
    {
      if ( old_key[organBufferIndex] == KEYDUMMY )
      {
        changeOrganFrequency(key % 12, organBufferIndex, freq);
        organBuffer[organBufferIndex][key / 12][key_twin[organBufferIndex]]->lpVtbl->Play(
          organBuffer[organBufferIndex][key / 12][key_twin[organBufferIndex]],
          0,
          0,
          DSBPLAY_LOOPING);
        old_key[organBufferIndex] = key;
        key_on[organBufferIndex] = 1;
      }
      else if ( key_on[organBufferIndex] != 1 || old_key[organBufferIndex] != key )
      {
        organBuffer[organBufferIndex][old_key[organBufferIndex] / 12][key_twin[organBufferIndex]]->lpVtbl->Play(
          organBuffer[organBufferIndex][old_key[organBufferIndex] / 12][key_twin[organBufferIndex]],
          0,
          0,
          0);
        if ( (signed int)++key_twin[organBufferIndex] > 1 )
          key_twin[organBufferIndex] = 0;
        changeOrganFrequency(key % 12, organBufferIndex, freq);
        organBuffer[organBufferIndex][key / 12][key_twin[organBufferIndex]]->lpVtbl->Play(
          organBuffer[organBufferIndex][key / 12][key_twin[organBufferIndex]],
          0,
          0,
          DSBPLAY_LOOPING);
        old_key[organBufferIndex] = key;
      }
      else
      {
        organBuffer[organBufferIndex][old_key[organBufferIndex] / 12][key_twin[organBufferIndex]]->lpVtbl->Play(
          organBuffer[organBufferIndex][old_key[organBufferIndex] / 12][key_twin[organBufferIndex]],
          0,
          0,
          0);
        if ( (signed int)++key_twin[organBufferIndex] > 1 )
          key_twin[organBufferIndex] = 0;
        organBuffer[organBufferIndex][key / 12][key_twin[organBufferIndex]]->lpVtbl->Play(
          organBuffer[organBufferIndex][key / 12][key_twin[organBufferIndex]],
          0,
          0,
          DSBPLAY_LOOPING);
      }
    }
    else if ( mode )
    {
      if ( mode == 2 && old_key[organBufferIndex] != 255 )
      {
        organBuffer[organBufferIndex][old_key[organBufferIndex] / 12][key_twin[organBufferIndex]]->lpVtbl->Play(
          organBuffer[organBufferIndex][old_key[organBufferIndex] / 12][key_twin[organBufferIndex]],
          0,
          0,
          0);
        old_key[organBufferIndex] = 255;
      }
    }
    else if ( old_key[organBufferIndex] != 255 )
    {
      organBuffer[organBufferIndex][old_key[organBufferIndex] / 12][key_twin[organBufferIndex]]->lpVtbl->Stop(organBuffer[organBufferIndex][old_key[organBufferIndex] / 12][key_twin[organBufferIndex]]);
      organBuffer[organBufferIndex][old_key[organBufferIndex] / 12][key_twin[organBufferIndex]]->lpVtbl->SetCurrentPosition(
        organBuffer[organBufferIndex][old_key[organBufferIndex] / 12][key_twin[organBufferIndex]],
        0);
    }
  }
}

//----- (0041B2A0) --------------------------------------------------------
void __cdecl releaseOrganyaObject(char organBufferIndex)
{
  signed int i; // [esp+0h] [ebp-4h]

  if ( lpDS )
  {
    for ( i = 0; i < 8; ++i )
    {
      if ( organBuffer[organBufferIndex][i][0] )
      {
        organBuffer[organBufferIndex][i][0]->lpVtbl->Release(organBuffer[organBufferIndex][i][0]);
        organBuffer[organBufferIndex][i][0] = 0;
      }
      if ( organBuffer[organBufferIndex][i][1] )
      {
        organBuffer[organBufferIndex][i][1]->lpVtbl->Release(organBuffer[organBufferIndex][i][1]);
        organBuffer[organBufferIndex][i][1] = 0;
      }
    }
  }
}

//----- (0041B380) --------------------------------------------------------
BOOL initWaveData100(void)
{
  HGLOBAL temp1; // eax
  LPVOID lpdword; // ST10_4
  HRSRC hrscr; // [esp+0h] [ebp-8h]

  if ( !lpDS )
    return 0;
  hrscr = FindResourceA(0, "WAVE100", "WAVE");
  if ( !hrscr )
    return 0;
  temp1 = LoadResource(0, hrscr);
  lpdword = LockResource(temp1);
  memcpy(wave_data, lpdword, 25600u);
  return 1;
}

//----- (0041B3F0) --------------------------------------------------------
BOOL __cdecl makeOrganyaWave(char track, char wave_num, char pipi)
{
  if ( !lpDS )
    return 0;
  if ( wave_num > 99 )
    return 0;
  releaseOrganyaObject(track);
  makeSoundObject(&wave_data[256 * wave_num], track, pipi);
  return 1;
}

//----- (0041B440) --------------------------------------------------------
void __cdecl changeDrumFrequency(unsigned __int8 frequency, char drumBufferIndex)
{
  if ( lpDS )
    drumBuffer[drumBufferIndex]->lpVtbl->SetFrequency(drumBuffer[drumBufferIndex], 800 * frequency + 100);
}

//----- (0041B480) --------------------------------------------------------
void __cdecl changeDrumPan(unsigned __int8 pan, char drumBufferIndex)
{
  if ( lpDS )
    drumBuffer[drumBufferIndex]->lpVtbl->SetPan(drumBuffer[drumBufferIndex], 10 * (panTable[pan] - 256));
}

//----- (0041B4D0) --------------------------------------------------------
void __cdecl changeDrumVolume(__int32 volume, char drumBufferIndex)
{
  if ( lpDS )
    drumBuffer[drumBufferIndex]->lpVtbl->SetVolume(drumBuffer[drumBufferIndex], 8 * volume - 2040);
}

//----- (0041B510) --------------------------------------------------------
void __cdecl playDrumObject(unsigned __int8 key, int mode, char drumBufferIndex)
{
  if ( lpDS && drumBuffer[drumBufferIndex] )
  {
    if ( mode )
    {
      if ( mode == 1 )
      {
        drumBuffer[drumBufferIndex]->lpVtbl->Stop(drumBuffer[drumBufferIndex]);
        drumBuffer[drumBufferIndex]->lpVtbl->SetCurrentPosition(drumBuffer[drumBufferIndex], 0);
        changeDrumFrequency(key, drumBufferIndex);
        drumBuffer[drumBufferIndex]->lpVtbl->Play(drumBuffer[drumBufferIndex], 0, 0, 0);
      }
    }
    else
    {
      drumBuffer[drumBufferIndex]->lpVtbl->Stop(drumBuffer[drumBufferIndex]);
      drumBuffer[drumBufferIndex]->lpVtbl->SetCurrentPosition(drumBuffer[drumBufferIndex], 0);
    }
  }
}

//----- (0041B600) --------------------------------------------------------
OrgData *__thiscall OrgData::OrgData(OrgData *this)
{
  signed int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i < 16; ++i )
  {
    this->info.tdata[i].noteList = 0;
    this->info.tdata[i].note_p = 0;
  }
  return this;
}

//----- (0041B650) --------------------------------------------------------
void __thiscall OrgData::InitOrgData(OrgData *this)
{
  signed int i; // [esp+4h] [ebp-4h]

  this->track = 0;
  this->info.alloc_note = ALLOCNOTE;
  this->info.dot = 4;
  this->info.line = 4;
  this->info.wait = 128;
  this->info.repeat_x = 0;
  this->info.end_x = 255 * this->info.line * this->info.dot;
  for ( i = 0; i < (signed int)MAXTRACK; ++i )
  {
    this->info.tdata[i].frequence = 1000;
    this->info.tdata[i].waveNumber = 0;
    this->info.tdata[i].pipi = 0;
  }
  OrgData::NoteAlloc(this, this->info.alloc_note);
  OrgData::SetMusicInfo(this, &this->info, -1u);
  BYTE1(this[1].info.end_x) = 6;
  BYTE2(this[1].info.end_x) = -56;
}

//----- (0041B730) --------------------------------------------------------
BOOL __thiscall OrgData::SetMusicInfo(OrgData *this, MUSICINFO *mi, unsigned __int32 flag)
{
  char str[32]; // [esp+4h] [ebp-28h]
  int i; // [esp+28h] [ebp-4h]

  if ( flag & SETGRID )                         // Enable grid
  {
    this->info.dot = mi->dot;
    this->info.line = mi->line;
  }
  if ( flag & SETWAIT )
  {
    this->info.wait = mi->wait;
    _itoa(mi->wait, str, 10);
  }
  if ( flag & MAXDRAM )
  {
    this->info.repeat_x = mi->repeat_x;
    this->info.end_x = mi->end_x;
  }
  if ( flag & SETFREQ )
  {
    for ( i = 0; i < (signed int)MAXMELODY; ++i )
    {
      this->info.tdata[i].frequence = mi->tdata[i].frequence;
      this->info.tdata[i].pipi = this->info.tdata[i].pipi;
    }
  }
  if ( flag & SETWAVE )
  {
    for ( i = 0; i < (signed int)MAXTRACK; ++i )
      this->info.tdata[i].waveNumber = mi->tdata[i].waveNumber;
  }
  if ( flag & SETPIPI )
  {
    for ( i = 0; i < (signed int)MAXTRACK; ++i )
      this->info.tdata[i].pipi = mi->tdata[i].pipi;
  }
  return 1;
}

//----- (0041B890) --------------------------------------------------------
BOOL __thiscall OrgData::NoteAlloc(OrgData *this, unsigned __int16 alloc)
{
  signed int i; // [esp+4h] [ebp-8h]
  signed int j; // [esp+4h] [ebp-8h]
  signed int l; // [esp+8h] [ebp-4h]
  signed int k; // [esp+8h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    if ( i >= (signed int)MAXTRACK )
    {
      for ( j = 0; j < (signed int)MAXMELODY; ++j )
        makeOrganyaWave(j, this->info.tdata[j].waveNumber, this->info.tdata[j].pipi);
      this->track = 0;
      return 1;
    }
    this->info.tdata[i].waveNumber = 0;
    this->info.tdata[i].noteList = 0;
    this->info.tdata[i].note_p = (NOTELIST *)malloc(16 * alloc);
    if ( !this->info.tdata[i].note_p )
      break;
    for ( k = 0; k < alloc; ++k )
    {
      this->info.tdata[i].note_p[k].from = 0;
      this->info.tdata[i].note_p[k].to = 0;
      this->info.tdata[i].note_p[k].length = 0;
      this->info.tdata[i].note_p[k].pan = PANDUMMY;
      this->info.tdata[i].note_p[k].volume = VOLDUMMY;
      this->info.tdata[i].note_p[k].y = KEYDUMMY;
    }
  }
  for ( l = 0; l < 16; ++l )
  {
    if ( this->info.tdata[l].note_p )
    {
      free(this->info.tdata[l].note_p);
      this->info.tdata[i].note_p = 0;
    }
  }
  return 0;
}

//----- (0041BA70) --------------------------------------------------------
void __thiscall OrgData::ReleaseNote(OrgData *this)
{
  signed int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i < (signed int)MAXTRACK; ++i )
  {
    if ( this->info.tdata[i].note_p )
    {
      free(this->info.tdata[i].note_p);
      this->info.tdata[i].note_p = 0;
    }
  }
}

//----- (0041BAD0) --------------------------------------------------------
signed int __thiscall OrgData::loadOrgFile(OrgData *this, char *musicName)
{
  HGLOBAL Load_res_ret; // eax
  NOTELIST *np; // ST18_4 MAPDST
  signed int j; // [esp+4h] [ebp-98h]
  signed int k; // [esp+4h] [ebp-98h]
  signed int l; // [esp+4h] [ebp-98h]
  MUSICINFO_file destination; // [esp+Ch] [ebp-90h]
  int pass_check; // [esp+80h] [ebp-1Ch]
  HRSRC hResInfo; // [esp+8Ch] [ebp-10h]
  char ver; // [esp+93h] [ebp-9h]
  int i; // [esp+94h] [ebp-8h]
  char *p; // [esp+98h] [ebp-4h]

  ver = 0;
  hResInfo = FindResourceA(0, musicName, "ORG");
  if ( !hResInfo )
    return 0;
  Load_res_ret = LoadResource(0, hResInfo);
  p = (char *)LockResource(Load_res_ret);
  memcpy(&pass_check, p, 6u);
  p += 6;
  if ( !memcmp(&pass_check, "Org-01", 6u) )
    ver = 1;
  if ( !memcmp(&pass_check, "Org-02", 6u) )
    ver = 2;
  if ( !ver )
    return 0;
  memcpy(&destination, p, 108u);
  p += 108;
  this->info.wait = destination.wait;
  this->info.line = destination.line;
  this->info.dot = destination.dot;
  this->info.repeat_x = destination.repeat_x;
  this->info.end_x = destination.end_x;
  for ( i = 0; i < (signed int)MAXTRACK; ++i )
  {
    this->info.tdata[i].frequence = destination.tdata[i].freq;
    if ( ver == 1 )
      this->info.tdata[i].pipi = 0;
    else
      this->info.tdata[i].pipi = destination.tdata[i].pipi;
    this->info.tdata[i].waveNumber = destination.tdata[i].wave_no;
  }
  for ( j = 0; j < (signed int)MAXTRACK; ++j )
  {
    if ( destination.tdata[j].note_num )
    {
      np = this->info.tdata[j].note_p;
      this->info.tdata[j].noteList = this->info.tdata[j].note_p;
      np->from = 0;
      np->to = np + 1;
      ++np;
      for ( i = 1; i < (unsigned __int16)destination.tdata[j].note_num; ++i )
      {
        np->from = np - 1;
        np->to = np + 1;
        ++np;
      }
      np[-1].to = 0;
      np = this->info.tdata[j].note_p;
      for ( i = 0; i < (unsigned __int16)destination.tdata[j].note_num; ++i )
      {
        memcpy(&np->position, p, 4u);
        p += 4;
        ++np;
      }
      np = this->info.tdata[j].note_p;
      for ( i = 0; i < (unsigned __int16)destination.tdata[j].note_num; ++i )
      {
        memcpy(&np->y, p++, 1u);
        ++np;
      }
      np = this->info.tdata[j].note_p;
      for ( i = 0; i < (unsigned __int16)destination.tdata[j].note_num; ++i )
      {
        memcpy(&np->length, p++, 1u);
        ++np;
      }
      np = this->info.tdata[j].note_p;
      for ( i = 0; i < (unsigned __int16)destination.tdata[j].note_num; ++i )
      {
        memcpy(&np->volume, p++, 1u);
        ++np;
      }
      np = this->info.tdata[j].note_p;
      for ( i = 0; i < (unsigned __int16)destination.tdata[j].note_num; ++i )
      {
        memcpy(&np->pan, p++, 1u);
        ++np;
      }
    }
    else
    {
      this->info.tdata[j].noteList = 0;
    }
  }
  for ( k = 0; k < (signed int)MAXMELODY; ++k )
    makeOrganyaWave(k, this->info.tdata[k].waveNumber, this->info.tdata[k].pipi);
  for ( l = 8; l < (signed int)MAXTRACK; ++l )
    i = this->info.tdata[l].waveNumber;
  OrgData::SetPlayPointer(this, 0);
  return 1;
}

//----- (0041C0B0) --------------------------------------------------------
// Unused
// Acquire song information
void __thiscall OrgData::GetMusicInfo(OrgData *this, MUSICINFO *mi)
{
  signed int i; // [esp+4h] [ebp-4h]

  mi->dot = this->info.dot;
  mi->line = this->info.line;
  mi->alloc_note = this->info.alloc_note;
  mi->wait = this->info.wait;
  mi->repeat_x = this->info.repeat_x;
  mi->end_x = this->info.end_x;
  for ( i = 0; i < (signed int)MAXTRACK; ++i )
  {
    mi->tdata[i].frequence = this->info.tdata[i].frequence;
    mi->tdata[i].waveNumber = this->info.tdata[i].waveNumber;
    mi->tdata[i].pipi = this->info.tdata[i].pipi;
  }
}

//----- (0041C180) --------------------------------------------------------
// Set the timer accuracy.
bool initMMTimer()
{
  struct timecaps_tag ptc; // [esp+0h] [ebp-Ch]
  MMRESULT ret; // [esp+8h] [ebp-4h]

  // Acquire timer accuracy information
  ret = timeGetDevCaps(&ptc, 8u);
  if ( ret )
    return 0;
  if ( ExactTime < ptc.wPeriodMin )
    ExactTime = ptc.wPeriodMin;
  return timeBeginPeriod(ExactTime) == TIMERR_NOERROR;
}
/* Orphan comments:
Initialize with this accuracy
*/

//----- (0041C1E0) --------------------------------------------------------
int __cdecl startTimer(DWORD dwTimer)
{
  ExactTime = dwTimer;
  TimerID = timeSetEvent(dwTimer, 10u, timerCallbackOrganya, NULL, TIME_PERIODIC);
  IsTimerActive = 1;
  return 1;
}
// 4A4DAC: using guessed type int IsTimerActive;

//----- (0041C230) --------------------------------------------------------
void __stdcall timerCallbackOrganya(UINT uTimerID, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2)
{
  timeGetTime();
  OrgData::PlayData(&orgDataObject);
}

//----- (0041C250) --------------------------------------------------------
signed int quitMMTimer()
{
  if ( !IsTimerActive )
    return 0;
  if ( TimerID && timeKillEvent(TimerID) )
    return 0;
  if ( timeEndPeriod(ExactTime) )
    return 0;
  IsTimerActive = 0;
  return 1;
}
// 4A4DAC: using guessed type int IsTimerActive;

//----- (0041C2B0) --------------------------------------------------------
// Main "engine" of the ORG player
void __thiscall OrgData::PlayData(OrgData *this)
{
  signed int i; // [esp+4h] [ebp-4h]
  signed int j; // [esp+4h] [ebp-4h]

  if ( musicFadeFlagMaybe && musicVolume )
    musicVolume -= 2;
  if ( musicVolume < 0 )
    musicVolume = 0;
  // Melody playback
  for ( i = 0; i < (signed int)MAXMELODY; ++i )
  {
    if ( np[i] && playPosition == np[i]->position )
    {
      if ( !mute[i] && np[i]->y != KEYDUMMY )
      {
        playOrganyaObject(np[i]->y, -1, i, this->info.tdata[i].frequence);
        Note_Lengths[i] = np[i]->length;
      }
      if ( np[i]->pan != PANDUMMY )
        changeOrganPan(np[i]->y, np[i]->pan, i);
      if ( np[i]->volume != VOLDUMMY )
        Track_Volume[i] = np[i]->volume;
      np[i] = np[i]->to;                        // Point to the next note
    }
    if ( !Note_Lengths[i] )
      playOrganyaObject(NULL, 2, i, this->info.tdata[i].frequence);
    if ( Note_Lengths[i] > 0 )
      --Note_Lengths[i];
    if ( np[i] )
      changeOrganVolume(np[i]->y, musicVolume * Track_Volume[i] / 127, i);
  }
  // Do drum playback
  for ( j = MAXMELODY; j < (signed int)MAXTRACK; ++j )
  {
    if ( np[j] && playPosition == np[j]->position )
    {
      if ( np[j]->y != KEYDUMMY && !mute[j] )
        playDrumObject(np[j]->y, 1, j - MAXMELODY);
      if ( np[j]->pan != PANDUMMY )
        changeDrumPan(np[j]->pan, j - MAXMELODY);
      if ( np[j]->volume != VOLDUMMY )
        Track_Volume[j] = np[j]->volume;
      np[j] = np[j]->to;                        // Point to the next note
    }
    if ( np[j] )
      changeDrumVolume(musicVolume * Track_Volume[j] / 127, j - 8);
  }
  if ( ++playPosition >= this->info.end_x )
  {
    playPosition = this->info.repeat_x;
    OrgData::SetPlayPointer(this, playPosition);
  }
}
// 4A4E10: using guessed type int musicFadeFlagMaybe;

//----- (0041C630) --------------------------------------------------------
void __thiscall OrgData::SetPlayPointer(OrgData *this, __int32 position)
{
  signed int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i < (signed int)MAXTRACK; ++i )
  {
    for ( np[i] = this->info.tdata[i].noteList; np[i] && np[i]->position < position; np[i] = np[i]->to )
      ;
  }
  playPosition = position;
}

//----- (0041C6C0) --------------------------------------------------------
signed int startOrganya()
{
  if ( !lpDS )
    return 0;
  if ( !initWaveData100() )
    return 0;
  OrgData::InitOrgData(&orgDataObject);
  return 1;
}

//----- (0041C6F0) --------------------------------------------------------
int __cdecl loadOrganya(char *musicName)
{
  if ( !lpDS )
    return 0;
  if ( OrgData::loadOrgFile(&orgDataObject, musicName) )
  {
    musicVolume = 100;
    musicFadeFlagMaybe = 0;
  }
  return 0;
}
// 4A4E10: using guessed type int musicFadeFlagMaybe;

//----- (0041C730) --------------------------------------------------------
void __cdecl setOrganyaPosition(int position)
{
  if ( lpDS )
  {
    OrgData::SetPlayPointer(&orgDataObject, position);
    musicVolume = 100;
    musicFadeFlagMaybe = 0;
  }
}
// 4A4E10: using guessed type int musicFadeFlagMaybe;

//----- (0041C770) --------------------------------------------------------
__int32 getOrganyaPosition()
{
  __int32 result; // eax

  if ( lpDS )
    result = playPosition;
  else
    result = 0;
  return result;
}

//----- (0041C790) --------------------------------------------------------
int startOrganyaPlayback()
{
  int result; // eax

  if ( lpDS )
  {
    quitMMTimer();
    initMMTimer();
    result = startTimer(orgDataObject.info.wait);
  }
  return result;
}

//----- (0041C7C0) --------------------------------------------------------
signed int __cdecl changeOrganyaVolume(signed int volume)
{
  if ( !lpDS )
    return 0;
  if ( volume < 0 || volume > 100 )
    return 0;
  musicVolume = volume;
  return 1;
}

//----- (0041C7F0) --------------------------------------------------------
void stopOrganyaMusic()
{
  signed int i; // [esp+0h] [ebp-4h]

  if ( lpDS )
  {
    quitMMTimer();
    for ( i = 0; i < 8; ++i )
      playOrganyaObject(0, 2, i, 0);
    memset(old_key, 255, 16u);
    memset(key_on, 0, 16u);
    memset(key_twin, 0, 16u);
    Sleep(100u);
  }
}

//----- (0041C890) --------------------------------------------------------
void deleteOrganya()
{
  signed int i; // [esp+0h] [ebp-4h]

  if ( lpDS )
  {
    quitMMTimer();
    OrgData::ReleaseNote(&orgDataObject);
    for ( i = 0; i < (signed int)MAXMELODY; ++i )
    {
      playOrganyaObject(0, 0, i, 0);
      releaseOrganyaObject(i);
    }
  }
}

//----- (0041C8F0) --------------------------------------------------------
void MakeWaveTables()
{
  sin((long double)0 * 6.283184 / 256.0);
}

//----- (0041CB10) --------------------------------------------------------
// Init procedure for SFX
signed int __cdecl MakePixelWaveData(int a1, int a2)
{
  int v2; // eax
  long double v3; // fst7
  double v5; // [esp+18h] [ebp-158h]
  double v6; // [esp+28h] [ebp-148h]
  double v7; // [esp+38h] [ebp-138h]
  double v8; // [esp+38h] [ebp-138h]
  double v9; // [esp+38h] [ebp-138h]
  double v10; // [esp+38h] [ebp-138h]
  double v11; // [esp+40h] [ebp-130h]
  double v12; // [esp+48h] [ebp-128h]
  double v13; // [esp+50h] [ebp-120h]
  _BYTE ptr[260]; // [esp+58h] [ebp-118h]
  int i; // [esp+160h] [ebp-10h]
  int v16; // [esp+164h] [ebp-Ch]
  double v17; // [esp+168h] [ebp-8h]

  MakeWaveTables();
  memset(ptr, 0, 0x100u);
  i = 0;
  v7 = (long double)*(signed int *)(a1 + 80);
  while ( i < *(_DWORD *)(a1 + 84) )
  {
    ptr[i] = (unsigned __int64)v7;
    v7 = ((long double)*(signed int *)(a1 + 88) - (long double)*(signed int *)(a1 + 80))
       / (long double)*(signed int *)(a1 + 84)
       + v7;
    ++i;
  }
  v8 = (long double)*(signed int *)(a1 + 88);
  while ( i < *(_DWORD *)(a1 + 92) )
  {
    ptr[i] = (unsigned __int64)v8;
    v8 = ((long double)*(signed int *)(a1 + 96) - (long double)*(signed int *)(a1 + 88))
       / (long double)(*(_DWORD *)(a1 + 92) - *(_DWORD *)(a1 + 84))
       + v8;
    ++i;
  }
  v9 = (long double)*(signed int *)(a1 + 96);
  while ( i < *(_DWORD *)(a1 + 100) )
  {
    ptr[i] = (unsigned __int64)v9;
    v9 = ((long double)*(signed int *)(a1 + 104) - (long double)*(signed int *)(a1 + 96))
       / (long double)(*(_DWORD *)(a1 + 100) - *(_DWORD *)(a1 + 92))
       + v9;
    ++i;
  }
  v10 = (long double)*(signed int *)(a1 + 104);
  while ( i < 256 )
  {
    ptr[i] = (unsigned __int64)v10;
    v10 = v10 - (long double)*(signed int *)(a1 + 104) / (long double)(256 - *(_DWORD *)(a1 + 100));
    ++i;
  }
  v13 = (long double)*(signed int *)(a1 + 52);
  v6 = (long double)*(signed int *)(a1 + 28);
  v17 = (long double)*(signed int *)(a1 + 76);
  if ( *(double *)(a1 + 16) == 0.0 )
    v5 = 0.0;
  else
    v5 = 256.0 / ((long double)*(signed int *)(a1 + 4) / *(double *)(a1 + 16));
  if ( *(double *)(a1 + 40) == 0.0 )
    v12 = 0.0;
  else
    v12 = 256.0 / ((long double)*(signed int *)(a1 + 4) / *(double *)(a1 + 40));
  if ( *(double *)(a1 + 64) == 0.0 )
    v11 = 0.0;
  else
    v11 = 256.0 / ((long double)*(signed int *)(a1 + 4) / *(double *)(a1 + 64));
  for ( i = 0; i < *(_DWORD *)(a1 + 4); ++i )
  {
    v16 = (signed int)(unsigned __int64)v6 % 256;
    v2 = (signed int)(unsigned __int64)v13 % 256;
    *(_BYTE *)(i + a2) = (char)ptr[(unsigned __int64)((long double)(i << 8) / (long double)*(signed int *)(a1 + 4))]
                       * (*(_DWORD *)(a1 + 24)
                        * (signed int)byte_4A4F00[256 * *(_DWORD *)(a1 + 8) + v16]
                        / 64
                        * (*(_DWORD *)(a1 + 72)
                         * (signed int)byte_4A4F00[256 * *(_DWORD *)(a1 + 56) + (signed int)(unsigned __int64)v17 % 256]
                         / 64
                         + 64)
                        / 64)
                       / 64
                       + -128;
    if ( byte_4A4F00[256 * *(_DWORD *)(a1 + 32) + v2] >= 0 )
      v3 = (v5 + v5)
         * (long double)byte_4A4F00[256 * *(_DWORD *)(a1 + 32) + (signed int)(unsigned __int64)v13 % 256]
         * (long double)*(signed int *)(a1 + 48)
         / 64.0
         / 64.0
         + v5
         + v6;
    else
      v3 = v5
         - v5
         * 0.5
         * (long double)-byte_4A4F00[256 * *(_DWORD *)(a1 + 32) + v2]
         * (long double)*(signed int *)(a1 + 48)
         / 64.0
         / 64.0
         + v6;
    v6 = v3;
    v13 = v13 + v12;
    v17 = v17 + v11;
  }
  return 1;
}

//----- (0041CFC0) --------------------------------------------------------
bool checkForProfileDat(void)
{
  char str; // [esp+0h] [ebp-110h]
  HANDLE hObject; // [esp+10Ch] [ebp-4h]

  sprintf(&str, "%s\\%s", exePath, defaultProfileName);
  hObject = CreateFileA(&str, 0, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
  if ( hObject == (HANDLE)INVALID_HANDLE_VALUE )
    return 0;
  CloseHandle(hObject);
  return 1;
}

//----- (0041D040) --------------------------------------------------------
signed int __cdecl saveProfile(const char *name)
{
  char string[108]; // [esp+0h] [ebp-720h]
  ProfileFile profile; // [esp+108h] [ebp-618h]
  FILE *stream; // [esp+718h] [ebp-8h]
  void *FLAG; // [esp+71Ch] [ebp-4h]

  FLAG = "FLAG";
  if ( name )
    sprintf(string, "%s\\%s", exePath, name);
  else
    sprintf(string, "%s\\%s", exePath, defaultProfileName);
  stream = fopen(string, "wb");
  if ( !stream )
    return 0;
  memset(&profile, 0, 1540u);
  memcpy(&profile, pProfileCheck, 8u);
  memcpy(profile.FLAG, FLAG, 4u);
  profile.stageNumber = currentStageNumber;
  profile.songNumber = currentSongNumber;
  profile.XPos = quote.XPos;
  profile.YPos = quote.YPos;
  profile.direction = quote.direction;
  profile.maxHP = quote.Max_Health;
  profile.HP = quote.Health;
  profile.star = quote.star;
  profile.selectedWeapon = selectedWeapon;
  profile.selectedItem = selectedItem;
  profile.equippedItems = quote.equippedItems;
  profile.unit = quote.isInFishBattle;
  profile.gameTime = gameTime;
  memcpy(profile.weapons, gWeapons, 0xA0u);
  memcpy(profile.inventory, quoteInventory, 0x80u);
  memcpy(profile.unlockedStages, unlockedStages, 0x40u);
  memcpy(profile.mapFlagArray, mapFlagArray, 0x80u);
  memcpy(profile.eventFlags, eventFlags, 0x3E8u);
  fwrite(&profile, 1540u, 1u, stream);
  fclose(stream);
  return 1;
}
// 499C68: using guessed type int selectedWeapon;
// 499C6C: using guessed type int selectedItem;
// 49E1EC: using guessed type int gameTime;
// 4A57F0: using guessed type int currentStageNumber;
// 4A57F4: using guessed type int currentSongNumber;

//----- (0041D260) --------------------------------------------------------
signed int __cdecl loadProfileDat(const char *path)
{
  char str; // [esp+0h] [ebp-718h]
  ProfileFile profile; // [esp+108h] [ebp-610h]
  FILE *offset; // [esp+714h] [ebp-4h]

  if ( path )
    sprintf(&str, "%s", path);
  else
    sprintf(&str, "%s\\%s", exePath, defaultProfileName);
  offset = fopen(&str, "rb");
  if ( !offset )
    return 0;
  fread(&profile, 8u, 1u, offset);
  if ( memcmp(&profile, pProfileCheck, 8u) )
    return 0;
  fseek((int)offset, 0, 0);
  memset(&profile, 0, 0x604u);
  fread(&profile, 0x604u, 1u, offset);
  fclose(offset);
  selectedWeapon = profile.selectedWeapon;
  selectedItem = profile.selectedItem;
  gameTime = profile.gameTime;
  memcpy(gWeapons, profile.weapons, 0xA0u);
  memcpy(quoteInventory, profile.inventory, 0x80u);
  memcpy(unlockedStages, profile.unlockedStages, 0x40u);
  memcpy(mapFlagArray, profile.mapFlagArray, 0x80u);
  memcpy(eventFlags, profile.eventFlags, 0x3E8u);
  changeMusic((musics)profile.songNumber);
  setQuoteinitialValues();
  if ( !changeStage(profile.stageNumber, 0, 0, 1) )
    return 0;
  quote.equippedItems = profile.equippedItems;
  quote.isInFishBattle = profile.unit;
  quote.direction = profile.direction;
  quote.Max_Health = profile.maxHP;
  quote.Health = profile.HP;
  quote.star = profile.star;
  quote.flags = -128;
  quote.Air = 1000;
  quote.Life_Bar = profile.HP;
  quote.XPos = profile.XPos;
  quote.YPos = profile.YPos;
  quote.Rect_Weapon.left = 24 * (gWeapons[selectedWeapon].weaponID % 10);
  quote.Rect_Weapon.right = quote.Rect_Weapon.left + 24;
  quote.Rect_Weapon.top = 32 * (gWeapons[selectedWeapon].weaponID / 10);
  quote.Rect_Weapon.bottom = quote.Rect_Weapon.top + 16;
  resetFadeVars();
  setCameraQuote();
  setCameraTargetQuote(16);
  initBossLife();
  cutNoise();
  initWhimsicalStar();
  clearValueView();
  superXPos = 0;
  return 1;
}
// 499C68: using guessed type int selectedWeapon;
// 499C6C: using guessed type int selectedItem;
// 49E1EC: using guessed type int gameTime;
// 4BBA2C: using guessed type int superXPos;

//----- (0041D550) --------------------------------------------------------
// <INI : INItialise game
int __cdecl initialiseGame(HWND hWnd)
{
  int result; // eax

  setQuoteinitialValues();
  selectedWeapon = 0;
  selectedItem = 0;
  gameTime = 0;
  clearWeaponData();
  clearItemData();
  clearUnlockedStages();
  clearMapFlagArray();
  clearEventFlags();
  if ( changeStage(13, 200, 10, 8) )
  {
    resetFadeVars();
    setCameraQuote();
    setCameraTargetQuote(16);
    initBossLife();
    cutNoise();
    clearValueView();
    superXPos = 0;
    setFadeMask();
    setCameraTargetQuote(16);
    result = 1;
  }
  else
  {
    MessageBoxA(hWnd, "Xe\x81[W\x8Ds", "G\x81[", 0);
    result = 0;
  }
  return result;
}
// 499C68: using guessed type int selectedWeapon;
// 499C6C: using guessed type int selectedItem;
// 49E1EC: using guessed type int gameTime;
// 4BBA2C: using guessed type int superXPos;

//----- (0041D610) --------------------------------------------------------
void *clearUnlockedStages()
{
  return memset(unlockedStages, 0, 0x40u);
}

//----- (0041D630) --------------------------------------------------------
signed int __cdecl addPermitStage(int index, int event)
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 8 && unlockedStages[i].index != index && unlockedStages[i].index; ++i )
    ;
  if ( i == 8 )
    return 0;
  unlockedStages[i].index = index;
  unlockedStages[i].event = event;
  return 1;
}

//----- (0041D6A0) --------------------------------------------------------
signed int __cdecl Remove_Unlocked_Stage(int a1)
{
  int v2; // ecx
  signed int i; // [esp+0h] [ebp-4h]
  int ia; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 8 && unlockedStages[i].index != a1; ++i )
    ;
  if ( i == 32 )
    return 0;
  for ( ia = i + 1; ia < 8; ++ia )
  {
    v2 = unlockedStages[ia].event;
    dword_4A54F8[2 * ia] = unlockedStages[ia].index;
    dword_4A54FC[2 * ia] = v2;
  }
  dword_4A54F8[2 * ia] = 0;
  dword_4A54FC[2 * ia] = 0;
  return 1;
}
// 4A54F8: using guessed type int dword_4A54F8[];
// 4A54FC: using guessed type int dword_4A54FC[];

//----- (0041D740) --------------------------------------------------------
void __cdecl moveStageSelectCursor()
{
  int i; // [esp+0h] [ebp-8h]

  for ( i = 0; unlockedStages[i].index; ++i )
    ;
  if ( i )
  {
    if ( keyLeft & keyPressed )
      --selectedSurface;
    if ( keyRight & keyPressed )
      ++selectedSurface;
    if ( selectedSurface < 0 )
      selectedSurface = i - 1;
    if ( selectedSurface > i - 1 )
      selectedSurface = 0;
    if ( keyPressed & (keyRight | keyLeft) )
      startTSCEvent(unlockedStages[selectedSurface].index + 1000);
    if ( keyPressed & (keyRight | keyLeft) )
      playSoundEffect(SFXYNChangeChoice, 1);
  }
}
// 493630: using guessed type int keyLeft;
// 493638: using guessed type int keyRight;
// 49E214: using guessed type int keyPressed;
// 4A5544: using guessed type int selectedSurface;

//----- (0041D840) --------------------------------------------------------
void drawTeleporterMenu()
{
  RECT v0; // [esp+0h] [ebp-5Ch]
  RECT RectView; // [esp+10h] [ebp-4Ch]
  int j; // [esp+20h] [ebp-3Ch]
  RECT RectCur[2]; // [esp+24h] [ebp-38h]
  RECT RectTitle_1; // [esp+44h] [ebp-18h]
  int v5; // [esp+54h] [ebp-8h]
  int i; // [esp+58h] [ebp-4h]

  RectView.left = 0;
  RectView.top = 0;
  RectView.right = 320;
  RectView.bottom = 240;
  RectCur[0].left = 80;
  RectCur[0].top = 88;
  RectCur[0].right = 112;
  RectCur[0].bottom = 104;
  RectCur[1].left = 80;
  RectCur[1].top = 104;
  RectCur[1].right = 112;
  RectCur[1].bottom = 120;
  RectTitle_1.left = 80;
  RectTitle_1.top = 64;
  RectTitle_1.right = 144;
  RectTitle_1.bottom = 72;
  if ( teleporterYPos > 46 )
    --teleporterYPos;
  drawBitmapWithTransparency(&RectView, 128, teleporterYPos, &RectTitle_1, 26);
  for ( j = 0; unlockedStages[j].index; ++j )
    ;
  ++dword_4A5548;
  if ( j )
  {
    v5 = (320 - 40 * j) / 2;
    drawBitmapWithTransparency(
      &RectView,
      v5 + 40 * selectedSurface,
      64,
      &RectCur[((unsigned int)dword_4A5548 >> 1) % 2],
      26);
    for ( i = 0; i < 8 && unlockedStages[i].index; ++i )
    {
      v0.left = 32 * (unlockedStages[i].index % 8);
      v0.right = v0.left + 32;
      v0.top = 16 * (unlockedStages[i].index / 8);
      v0.bottom = v0.top + 16;
      drawBitmapWithTransparency(&RectView, v5 + 40 * i, 64, &v0, 14);
    }
  }
}
// 4A5544: using guessed type int selectedSurface;
// 4A5548: using guessed type int dword_4A5548;

//----- (0041DA00) --------------------------------------------------------
signed int __cdecl gameLoopStageSelect(_DWORD *p_event)
{
  int TSCParsetRet; // [esp+0h] [ebp-128h]
  int callOnEscapeRet; // [esp+4h] [ebp-124h]
  char oldScriptPath[272]; // [esp+8h] [ebp-120h]
  RECT rcView; // [esp+118h] [ebp-10h]

  rcView.left = 0;
  rcView.top = 0;
  rcView.right = 320;
  rcView.bottom = 240;
  selectedSurface = 0;
  backupSurface(10, &rect);
  getTextScriptPath(oldScriptPath);
  loadSpecialTSC("StageSelect.tsc");
  teleporterYPos = 54;
  startTSCEvent(unlockedStages[selectedSurface].index + 1000);
  do
  {
    getKeys();
    if ( keyHeld & 0x8000 )
    {
      callOnEscapeRet = callOnEscape(appWinHandle);
      if ( !callOnEscapeRet )
        return 0;
      if ( callOnEscapeRet == 2 )
        return 2;
    }
    moveStageSelectCursor();
    TSCParsetRet = TSCParser();
    if ( !TSCParsetRet )
      return 0;
    if ( TSCParsetRet == 2 )
      return 2;
    drawBitmapWithTransparency(&rcView, 0, 0, &rcView, 10);
    drawTeleporterMenu();
    drawTextBox();
    if ( keyOk & keyPressed )
    {
      stopTSC();
      loadTSCScript(oldScriptPath);
      *p_event = unlockedStages[selectedSurface].event;
      return 1;
    }
    if ( keyCancel & keyPressed )
    {
      stopTSC();
      loadTSCScript(oldScriptPath);
      *p_event = 0;
      return 1;
    }
    displayFPSCounter();
  }
  while ( drawWindow(appWinHandle) );
  return 0;
}
// 493628: using guessed type int keyOk;
// 49362C: using guessed type int keyCancel;
// 49E210: using guessed type int keyHeld;
// 49E214: using guessed type int keyPressed;
// 4A5544: using guessed type int selectedSurface;

//----- (0041DBD0) --------------------------------------------------------
void __cdecl shootSnake(int Level)
{
  bullets BulletID; // [esp+4h] [ebp-4h]

  switch ( Level )
  {
    case 1:
      BulletID = bulletSnakeLevel1;
      break;
    case 2:
      BulletID = bulletSnakeLevel2;
      break;
    case 3:
      BulletID = bulletSnakeLevel3;
      break;
  }
  if ( countBullets(bulletSnakeLevel1) <= 3 && keyShoot & keyPressed )
  {
    if ( useAmmo(1) )
    {
      if ( quote.isFacingUp )
      {
        if ( quote.direction )
        {
          createBullet(BulletID, quote.XPos + 1536, quote.YPos - 5120, up);
          createEffect(quote.XPos + 1536, quote.YPos - 5120, effectStar, 0);
        }
        else
        {
          createBullet(BulletID, quote.XPos - 1536, quote.YPos - 5120, up);
          createEffect(quote.XPos - 1536, quote.YPos - 5120, effectStar, 0);
        }
      }
      else if ( quote.isFacingDown )
      {
        if ( quote.direction )
        {
          createBullet(BulletID, quote.XPos + 1536, quote.YPos + 5120, down);
          createEffect(quote.XPos + 1536, quote.YPos + 5120, effectStar, 0);
        }
        else
        {
          createBullet(BulletID, quote.XPos - 1536, quote.YPos + 5120, down);
          createEffect(quote.XPos - 1536, quote.YPos + 5120, effectStar, 0);
        }
      }
      else if ( quote.direction )
      {
        createBullet(BulletID, quote.XPos + 3072, quote.YPos + 1024, right);
        createEffect(quote.XPos + 6144, quote.YPos + 1024, effectStar, 0);
      }
      else
      {
        createBullet(BulletID, quote.XPos - 3072, quote.YPos + 1024, 0);
        createEffect(quote.XPos - 6144, quote.YPos + 1024, effectStar, 0);
      }
      playSoundEffect(SFXFireballShoot, 1);
    }
    else
    {
      resetSelectedWeapon();
    }
  }
}
// 493614: using guessed type int keyShoot;
// 49E214: using guessed type int keyPressed;

//----- (0041DE60) --------------------------------------------------------
void __cdecl shootPolarStar(int Level)
{
  int BulletID; // [esp+4h] [ebp-4h]

  switch ( Level )
  {
    case 1:
      BulletID = 4;
      break;
    case 2:
      BulletID = 5;
      break;
    case 3:
      BulletID = 6;
      break;
  }
  if ( countBullets(bulletSnakeLevel2) <= 1 && keyShoot & keyPressed )
  {
    if ( useAmmo(1) )
    {
      if ( quote.isFacingUp )
      {
        if ( quote.direction )
        {
          createBullet((bullets)BulletID, quote.XPos + 512, quote.YPos - 4096, up);
          createEffect(quote.XPos + 512, quote.YPos - 4096, effectStar, 0);
        }
        else
        {
          createBullet((bullets)BulletID, quote.XPos - 512, quote.YPos - 4096, up);
          createEffect(quote.XPos - 512, quote.YPos - 4096, effectStar, 0);
        }
      }
      else if ( quote.isFacingDown )
      {
        if ( quote.direction )
        {
          createBullet((bullets)BulletID, quote.XPos + 512, quote.YPos + 4096, down);
          createEffect(quote.XPos + 512, quote.YPos + 4096, effectStar, 0);
        }
        else
        {
          createBullet((bullets)BulletID, quote.XPos - 512, quote.YPos + 4096, down);
          createEffect(quote.XPos - 512, quote.YPos + 4096, effectStar, 0);
        }
      }
      else if ( quote.direction )
      {
        createBullet((bullets)BulletID, quote.XPos + 3072, quote.YPos + 1536, right);
        createEffect(quote.XPos + 6144, quote.YPos + 1536, effectStar, 0);
      }
      else
      {
        createBullet((bullets)BulletID, quote.XPos - 3072, quote.YPos + 1536, 0);
        createEffect(quote.XPos - 6144, quote.YPos + 1536, effectStar, 0);
      }
      if ( Level == 3 )
        playSoundEffect(SFXPolarStarShootLevel3, 1);
      else
        playSoundEffect(SFXPolarStarShootLevel12, 1);
    }
    else
    {
      playSoundEffect(SFXNoAmmo, 1);
    }
  }
}
// 493614: using guessed type int keyShoot;
// 49E214: using guessed type int keyPressed;

//----- (0041E110) --------------------------------------------------------
void __cdecl shootFireball(int a1)
{
  int BulletID; // [esp+4h] [ebp-4h]

  switch ( a1 )
  {
    case 1:
      if ( countBullets(bulletSnakeLevel3) > 1 )
        return;
      BulletID = 7;
      break;
    case 2:
      if ( countBullets(bulletSnakeLevel3) > 2 )
        return;
      BulletID = 8;
      break;
    case 3:
      if ( countBullets(bulletSnakeLevel3) > 3 )
        return;
      BulletID = 9;
      break;
  }
  if ( keyShoot & keyPressed )
  {
    if ( useAmmo(1) )
    {
      if ( quote.isFacingUp )
      {
        if ( quote.direction )
        {
          createBullet((bullets)BulletID, quote.XPos + 2048, quote.YPos - 4096, up);
          createEffect(quote.XPos + 2048, quote.YPos - 4096, effectStar, 0);
        }
        else
        {
          createBullet((bullets)BulletID, quote.XPos - 2048, quote.YPos - 4096, up);
          createEffect(quote.XPos - 2048, quote.YPos - 4096, effectStar, 0);
        }
      }
      else if ( quote.isFacingDown )
      {
        if ( quote.direction )
        {
          createBullet((bullets)BulletID, quote.XPos + 2048, quote.YPos + 4096, down);
          createEffect(quote.XPos + 2048, quote.YPos + 4096, effectStar, 0);
        }
        else
        {
          createBullet((bullets)BulletID, quote.XPos - 2048, quote.YPos + 4096, down);
          createEffect(quote.XPos - 2048, quote.YPos + 4096, effectStar, 0);
        }
      }
      else if ( quote.direction )
      {
        createBullet((bullets)BulletID, quote.XPos + 3072, quote.YPos + 1024, right);
        createEffect(quote.XPos + 6144, quote.YPos + 1024, effectStar, 0);
      }
      else
      {
        createBullet((bullets)BulletID, quote.XPos - 3072, quote.YPos + 1024, 0);
        createEffect(quote.XPos - 6144, quote.YPos + 1024, effectStar, 0);
      }
      playSoundEffect(SFXFireballBounce, 1);
    }
    else
    {
      resetSelectedWeapon();
    }
  }
}
// 493614: using guessed type int keyShoot;
// 49E214: using guessed type int keyPressed;

//----- (0041E3D0) --------------------------------------------------------
void __cdecl shootMachineGun(int Level)
{
  int BulletID; // [esp+4h] [ebp-4h]

  if ( countBullets(bulletPolarStarLevel1) <= 4 )
  {
    switch ( Level )
    {
      case 1:
        BulletID = 10;
        break;
      case 2:
        BulletID = 11;
        break;
      case 3:
        BulletID = 12;
        break;
    }
    if ( !(keyShoot & keyHeld) )
      quote.Time_Between_Shots = 6;
    if ( keyShoot & keyHeld )
    {
      ++quote.Time_Between_Shots;
      if ( (signed int)quote.Time_Between_Shots >= 6 )
      {
        quote.Time_Between_Shots = 0;
        if ( useAmmo(1) )
        {
          if ( quote.isFacingUp )
          {
            if ( Level == 3 )
              quote.YVel += 256;
            if ( quote.direction )
            {
              createBullet((bullets)BulletID, quote.XPos + 1536, quote.YPos - 4096, up);
              createEffect(quote.XPos + 1536, quote.YPos - 4096, effectStar, 0);
            }
            else
            {
              createBullet((bullets)BulletID, quote.XPos - 1536, quote.YPos - 4096, up);
              createEffect(quote.XPos - 1536, quote.YPos - 4096, effectStar, 0);
            }
          }
          else if ( quote.isFacingDown )
          {
            if ( Level == 3 )
            {
              if ( quote.YVel > 0 )
                quote.YVel /= 2;
              if ( quote.YVel > -1024 )
              {
                quote.YVel -= 512;
                if ( quote.YVel < -1024 )
                  quote.YVel = -1024;
              }
            }
            if ( quote.direction )
            {
              createBullet((bullets)BulletID, quote.XPos + 1536, quote.YPos + 4096, down);
              createEffect(quote.XPos + 1536, quote.YPos + 4096, effectStar, 0);
            }
            else
            {
              createBullet((bullets)BulletID, quote.XPos - 1536, quote.YPos + 4096, down);
              createEffect(quote.XPos - 1536, quote.YPos + 4096, effectStar, 0);
            }
          }
          else if ( quote.direction )
          {
            createBullet((bullets)BulletID, quote.XPos + 6144, quote.YPos + 1536, right);
            createEffect(quote.XPos + 6144, quote.YPos + 1536, effectStar, 0);
          }
          else
          {
            createBullet((bullets)BulletID, quote.XPos - 6144, quote.YPos + 1536, 0);
            createEffect(quote.XPos - 6144, quote.YPos + 1536, effectStar, 0);
          }
          if ( Level == 3 )
            playSoundEffect(SFXPolarStarShootLevel3, 1);
          else
            playSoundEffect(SFXPolarStarShootLevel12, 1);
        }
        else
        {
          playSoundEffect(SFXNoAmmo, 1);
          if ( !emptyEffectTimer )
          {
            createEffect(quote.XPos, quote.YPos, effectPushJumpKey, 0);
            emptyEffectTimer = 50;
          }
        }
      }
    }
    else
    {
      ++Machine_Gun_Reload_Timer;
      if ( quote.equippedItems & 8 )
      {
        if ( Machine_Gun_Reload_Timer > 1 )
        {
          Machine_Gun_Reload_Timer = 0;
          addAmmo(1);
        }
      }
      else if ( Machine_Gun_Reload_Timer > 4 )
      {
        Machine_Gun_Reload_Timer = 0;
        addAmmo(1);
      }
    }
  }
}
// 493614: using guessed type int keyShoot;
// 49E210: using guessed type int keyHeld;
// 4A554C: using guessed type int emptyEffectTimer;
// 4A5554: using guessed type int Machine_Gun_Reload_Timer;

//----- (0041E7B0) --------------------------------------------------------
void __cdecl shootMissileLauncher(int level, bool isSuper)
{
  int BulletID; // [esp+10h] [ebp-4h]

  if ( isSuper )
  {
    // Check Super Missile level
    switch ( level )
    {
      case 1:
        BulletID = 28;
        break;
      case 2:
        BulletID = 29;
        break;
      case 3:
        BulletID = 30;
        break;
    }
    if ( level == 1 )
    {
      if ( countBullets(bulletMachineGunLevel1) > 0 || countBullets(bulletMachineGunLevel2) > 0 )
        return;
    }
    else if ( level == 2 )
    {
      if ( countBullets(bulletMachineGunLevel1) > 1 || countBullets(bulletMachineGunLevel2) > 1 )
        return;
    }
    else if ( level == 3 && (countBullets(bulletMachineGunLevel1) > 3 || countBullets(bulletMachineGunLevel2) > 3) )
    {
      return;
    }
  }
  else
  {
    // Normal missile launcher
    switch ( level )
    {
      case 1:
        BulletID = 13;
        break;
      case 2:
        BulletID = 14;
        break;
      case 3:
        BulletID = 15;
        break;
    }
    if ( level == 1 )
    {
      if ( countBullets(bulletPolarStarLevel2) > 0 || countBullets(bulletPolarStarLevel3) > 0 )
        return;
    }
    else if ( level == 2 )
    {
      if ( countBullets(bulletPolarStarLevel2) > 1 || countBullets(bulletPolarStarLevel3) > 1 )
        return;
    }
    else if ( level == 3 && (countBullets(bulletPolarStarLevel2) > 3 || countBullets(bulletPolarStarLevel3) > 3) )
    {
      return;
    }
  }
  if ( !(keyShoot & keyPressed) )
    return;
  if ( level < 3 )
  {
    if ( !useAmmo(1) )
    {
      playSoundEffect(SFXNoAmmo, 1);
      if ( !emptyEffectTimer )
      {
        createEffect(quote.XPos, quote.YPos, effectPushJumpKey, 0);
        emptyEffectTimer = 50;
      }
      return;
    }
    if ( quote.isFacingUp )
    {
      if ( quote.direction )
      {
        createBullet((bullets)BulletID, quote.XPos + 512, quote.YPos - 4096, up);
        createEffect(quote.XPos + 512, quote.YPos - 4096, effectStar, 0);
      }
      else
      {
        createBullet((bullets)BulletID, quote.XPos - 512, quote.YPos - 4096, up);
        createEffect(quote.XPos - 512, quote.YPos - 4096, effectStar, 0);
      }
    }
    else if ( quote.isFacingDown )
    {
      if ( quote.direction )
      {
        createBullet((bullets)BulletID, quote.XPos + 512, quote.YPos + 4096, down);
        createEffect(quote.XPos + 512, quote.YPos + 4096, effectStar, 0);
      }
      else
      {
        createBullet((bullets)BulletID, quote.XPos - 512, quote.YPos + 4096, down);
        createEffect(quote.XPos - 512, quote.YPos + 4096, effectStar, 0);
      }
    }
    else if ( quote.direction )
    {
      createBullet((bullets)BulletID, quote.XPos + 3072, quote.YPos, right);
      createEffect(quote.XPos + 6144, quote.YPos, effectStar, 0);
    }
    else
    {
      createBullet((bullets)BulletID, quote.XPos - 3072, quote.YPos, 0);
      createEffect(quote.XPos - 6144, quote.YPos, effectStar, 0);
    }
LABEL_78:
    playSoundEffect(SFXPolarStarShootLevel12, 1);
    return;
  }
  if ( useAmmo(1) )
  {
    if ( quote.isFacingUp )
    {
      if ( quote.direction )
      {
        createBullet((bullets)BulletID, quote.XPos + 512, quote.YPos - 4096, up);
        createEffect(quote.XPos + 512, quote.YPos - 4096, effectStar, 0);
      }
      else
      {
        createBullet((bullets)BulletID, quote.XPos - 512, quote.YPos - 4096, up);
        createEffect(quote.XPos - 512, quote.YPos - 4096, effectStar, 0);
      }
      createBullet((bullets)BulletID, quote.XPos + 1536, quote.YPos, up);
      createBullet((bullets)BulletID, quote.XPos - 1536, quote.YPos, up);
    }
    else if ( quote.isFacingDown )
    {
      if ( quote.direction )
      {
        createBullet((bullets)BulletID, quote.XPos + 512, quote.YPos + 4096, down);
        createEffect(quote.XPos + 512, quote.YPos + 4096, effectStar, 0);
        createBullet((bullets)BulletID, quote.XPos - 1536, quote.YPos, down);
        createBullet((bullets)BulletID, quote.XPos + 1536, quote.YPos, down);
      }
      else
      {
        createBullet((bullets)BulletID, quote.XPos - 512, quote.YPos + 4096, down);
        createEffect(quote.XPos - 512, quote.YPos + 4096, effectStar, 0);
        createBullet((bullets)BulletID, quote.XPos + 1536, quote.YPos, down);
        createBullet((bullets)BulletID, quote.XPos - 1536, quote.YPos, down);
      }
    }
    else if ( quote.direction )
    {
      createBullet((bullets)BulletID, quote.XPos + 3072, quote.YPos + 512, right);
      createEffect(quote.XPos + 6144, quote.YPos + 512, effectStar, 0);
      createBullet((bullets)BulletID, quote.XPos, quote.YPos - 4096, right);
      createBullet((bullets)BulletID, quote.XPos - 2048, quote.YPos - 512, right);
    }
    else
    {
      createBullet((bullets)BulletID, quote.XPos - 3072, quote.YPos + 512, 0);
      createEffect(quote.XPos - 6144, quote.YPos + 512, effectStar, 0);
      createBullet((bullets)BulletID, quote.XPos, quote.YPos - 4096, 0);
      createBullet((bullets)BulletID, quote.XPos + 2048, quote.YPos - 512, 0);
    }
    goto LABEL_78;
  }
  playSoundEffect(SFXNoAmmo, 1);
  if ( !emptyEffectTimer )
  {
    createEffect(quote.XPos, quote.YPos, effectPushJumpKey, 0);
    emptyEffectTimer = 50;
  }
}
// 493614: using guessed type int keyShoot;
// 49E214: using guessed type int keyPressed;
// 4A554C: using guessed type int emptyEffectTimer;

//----- (0041EFD0) --------------------------------------------------------
void shootBubblerLevel1()
{
  // Shot limit : 3
  if ( countBullets(bulletFireballLevel1) <= 3 )
  {
    if ( keyShoot & keyPressed )
    {
      // Spend 1 bullet per ammo
      if ( useAmmo(1) )
      {
        if ( quote.isFacingUp )
        {
          if ( quote.direction )
          {
            createBullet(bulletBubblerLevel1, quote.XPos + 512, quote.YPos - 1024, up);
            createEffect(quote.XPos + 512, quote.YPos - 1024, effectStar, left);
          }
          else
          {
            createBullet(bulletBubblerLevel1, quote.XPos - 512, quote.YPos - 1024, up);
            createEffect(quote.XPos - 512, quote.YPos - 1024, effectStar, left);
          }
        }
        else if ( quote.isFacingDown )
        {
          if ( quote.direction )
          {
            createBullet(bulletBubblerLevel1, quote.XPos + 512, quote.YPos + 1024, down);
            createEffect(quote.XPos + 512, quote.YPos + 1024, effectStar, left);
          }
          else
          {
            createBullet(bulletBubblerLevel1, quote.XPos - 512, quote.YPos + 1024, down);
            createEffect(quote.XPos - 512, quote.YPos + 1024, effectStar, left);
          }
        }
        else if ( quote.direction )
        {
          createBullet(bulletBubblerLevel1, quote.XPos + 3072, quote.YPos + 1536, right);
          createEffect(quote.XPos + 6144, quote.YPos + 1536, effectStar, left);
        }
        else
        {
          createBullet(bulletBubblerLevel1, quote.XPos - 3072, quote.YPos + 1536, left);
          createEffect(quote.XPos - 6144, quote.YPos + 1536, effectStar, left);
        }
        playSoundEffect(SFXBubblerShoot, 1);
      }
      else
      {
        // No ammo left
        playSoundEffect(SFXNoAmmo, 1);
        if ( !emptyEffectTimer )
        {
          createEffect(quote.XPos, quote.YPos, effectPushJumpKey, left);
          emptyEffectTimer = 50;
        }
      }
    }
    else if ( ++Bubbler_Lvl_1_Refill_Timer > 20 )
    {
      Bubbler_Lvl_1_Refill_Timer = 0;
      addAmmo(1);
    }
  }
}
// 493614: using guessed type int keyShoot;
// 49E214: using guessed type int keyPressed;
// 4A554C: using guessed type int emptyEffectTimer;
// 4A5558: using guessed type int Bubbler_Lvl_1_Refill_Timer;

//----- (0041F280) --------------------------------------------------------
void __cdecl shootBubblerLevel2_3(int Level)
{
  int BulletID; // [esp+8h] [ebp+8h]

  if ( countBullets(bulletFireballLevel1) <= 15 )
  {
    BulletID = Level + 18;
    if ( !(keyShoot & keyHeld) )
      quote.Time_Between_Shots = 6;
    if ( keyShoot & keyHeld )
    {
      ++quote.Time_Between_Shots;
      if ( (signed int)quote.Time_Between_Shots >= 7 )
      {
        quote.Time_Between_Shots = 0;
        if ( useAmmo(1) )
        {
          if ( quote.isFacingUp )
          {
            if ( quote.direction )
            {
              createBullet((bullets)BulletID, quote.XPos + 1536, quote.YPos - 4096, up);
              createEffect(quote.XPos + 1536, quote.YPos - 0x2000, effectStar, 0);
            }
            else
            {
              createBullet((bullets)BulletID, quote.XPos - 1536, quote.YPos - 4096, up);
              createEffect(quote.XPos - 1536, quote.YPos - 0x2000, effectStar, 0);
            }
          }
          else if ( quote.isFacingDown )
          {
            if ( quote.direction )
            {
              createBullet((bullets)BulletID, quote.XPos + 1536, quote.YPos + 4096, down);
              createEffect(quote.XPos + 1536, quote.YPos + 0x2000, effectStar, 0);
            }
            else
            {
              createBullet((bullets)BulletID, quote.XPos - 1536, quote.YPos + 4096, down);
              createEffect(quote.XPos - 1536, quote.YPos + 0x2000, effectStar, 0);
            }
          }
          else if ( quote.direction )
          {
            createBullet((bullets)BulletID, quote.XPos + 3072, quote.YPos + 1536, right);
            createEffect(quote.XPos + 6144, quote.YPos + 1536, effectStar, 0);
          }
          else
          {
            createBullet((bullets)BulletID, quote.XPos - 3072, quote.YPos + 1536, 0);
            createEffect(quote.XPos - 6144, quote.YPos + 1536, effectStar, 0);
          }
          playSoundEffect(SFXBubblerShoot, 1);
        }
        else
        {
          playSoundEffect(SFXNoAmmo, 1);
          if ( !emptyEffectTimer )
          {
            createEffect(quote.XPos, quote.YPos, effectPushJumpKey, 0);
            emptyEffectTimer = 50;
          }
        }
      }
    }
    else if ( ++dword_4A555C > 1 )
    {
      dword_4A555C = 0;
      addAmmo(1);
    }
  }
}
// 493614: using guessed type int keyShoot;
// 49E210: using guessed type int keyHeld;
// 4A554C: using guessed type int emptyEffectTimer;
// 4A555C: using guessed type int dword_4A555C;

//----- (0041F580) --------------------------------------------------------
void __cdecl shootBlade(int level)
{
  bullets BulletID; // [esp+4h] [ebp-4h]

  if ( countBullets(bulletFireballLevel3) <= 0 )
  {
    switch ( level )
    {
      case 1:
        BulletID = bulletBladeLevel1;
        break;
      case 2:
        BulletID = bulletBladeLevel2;
        break;
      case 3:
        BulletID = bulletBladeLevel3;
        break;
    }
    if ( keyShoot & keyPressed )
    {
      if ( quote.isFacingUp )
      {
        if ( quote.direction )
          createBullet(BulletID, quote.XPos + 512, quote.YPos + 2048, up);
        else
          createBullet(BulletID, quote.XPos - 512, quote.YPos + 2048, up);
      }
      else if ( quote.isFacingDown )
      {
        if ( quote.direction )
          createBullet(BulletID, quote.XPos + 512, quote.YPos - 3072, down);
        else
          createBullet(BulletID, quote.XPos - 512, quote.YPos - 3072, down);
      }
      else if ( quote.direction )
      {
        createBullet(BulletID, quote.XPos - 3072, quote.YPos - 1536, right);
      }
      else
      {
        createBullet(BulletID, quote.XPos + 3072, quote.YPos - 1536, 0);
      }
      playSoundEffect(SFXFireballBounce, 1);
    }
  }
}
// 493614: using guessed type int keyShoot;
// 49E214: using guessed type int keyPressed;

//----- (0041F710) --------------------------------------------------------
void __cdecl shootNemesis(int Bullet_Level)
{
  int BulletID; // [esp+8h] [ebp-4h]

  switch ( Bullet_Level )
  {
    case 1:
      BulletID = 34;
      break;
    case 2:
      BulletID = 35;
      break;
    case 3:
      BulletID = 36;
      break;
  }
  if ( countBullets(bulletMachineGunLevel3) <= 1 && keyShoot & keyPressed )
  {
    if ( useAmmo(1) )
    {
      if ( quote.isFacingUp )
      {
        if ( quote.direction )
        {
          createBullet((bullets)BulletID, quote.XPos + 512, quote.YPos - 6144, up);
          createEffect(quote.XPos + 512, quote.YPos - 6144, effectStar, 0);
        }
        else
        {
          createBullet((bullets)BulletID, quote.XPos - 512, quote.YPos - 6144, up);
          createEffect(quote.XPos - 512, quote.YPos - 6144, effectStar, 0);
        }
      }
      else if ( quote.isFacingDown )
      {
        if ( quote.direction )
        {
          createBullet((bullets)BulletID, quote.XPos + 512, quote.YPos + 6144, down);
          createEffect(quote.XPos + 512, quote.YPos + 6144, effectStar, 0);
        }
        else
        {
          createBullet((bullets)BulletID, quote.XPos - 512, quote.YPos + 6144, down);
          createEffect(quote.XPos - 512, quote.YPos + 6144, effectStar, 0);
        }
      }
      else if ( quote.direction )
      {
        createBullet((bullets)BulletID, quote.XPos + 11264, quote.YPos + 1536, right);
        createEffect(quote.XPos + 0x2000, quote.YPos + 1536, effectStar, 0);
      }
      else
      {
        createBullet((bullets)BulletID, quote.XPos - 11264, quote.YPos + 1536, 0);
        createEffect(quote.XPos - 0x2000, quote.YPos + 1536, effectStar, 0);
      }
      switch ( Bullet_Level )
      {
        case 1:
          playSoundEffect(SFXNemesisShot, 1);
          break;
        case 2:
          playSoundEffect(SFXPolarStarShootLevel3, 1);
          break;
        case 3:
          playSoundEffect(SFXSpurChargeLevel2, 1);
          break;
      }
    }
    else
    {
      playSoundEffect(SFXNoAmmo, 1);
    }
  }
}
// 493614: using guessed type int keyShoot;
// 49E214: using guessed type int keyPressed;

//----- (0041F9E0) --------------------------------------------------------
void resetSpurCharge()
{
  dword_4A5550 = 0;
  if ( gWeapons[selectedWeapon].weaponID == weaponSpur )
    resetSelectedWeaponLevel();
}
// 499C68: using guessed type int selectedWeapon;
// 4A5550: using guessed type int dword_4A5550;

//----- (0041FA10) --------------------------------------------------------
void __cdecl shootSpur(int level)
{
  signed int v1; // [esp+Ch] [ebp-8h]
  int BulletID; // [esp+10h] [ebp-4h]

  v1 = 0;
  if ( keyShoot & keyHeld )
  {
    if ( quote.equippedItems & 8 )
      Add_Weapon_EXP(3);
    else
      Add_Weapon_EXP(2);
    if ( ++dword_4A5550 / 2 % 2 )
    {
      if ( level == 1 )
      {
        playSoundEffect(SFXSpurChargeLevel1, 1);
      }
      else if ( level == 2 )
      {
        playSoundEffect(SFXSpurChargeLevel2, 1);
      }
      else if ( level == 3 && !Check_Weapon_MAX() )
      {
        playSoundEffect(SFXSpurChargeLevel3, 1);
      }
    }
  }
  else
  {
    if ( dword_4A5550 )
      v1 = 1;
    dword_4A5550 = 0;
  }
  if ( Check_Weapon_MAX() )
  {
    if ( !dword_4A5560 )
    {
      dword_4A5560 = 1;
      playSoundEffect(SFXSpurChargeMAX, 1);
    }
  }
  else
  {
    dword_4A5560 = 0;
  }
  if ( !(keyShoot & keyHeld) )
    resetSelectedWeaponLevel();
  switch ( level )
  {
    case 1:
      BulletID = 6;
      v1 = 0;
      break;
    case 2:
      BulletID = 37;
      break;
    case 3:
      if ( dword_4A5560 )
        BulletID = 39;
      else
        BulletID = 38;
      break;
  }
  if ( countBullets(bulletMissileLauncherLevel1) <= 0
    && countBullets(bulletMissileLauncherLevel2) <= 0
    && (keyShoot & keyPressed || v1) )
  {
    if ( useAmmo(1) )
    {
      if ( quote.isFacingUp )
      {
        if ( quote.direction )
        {
          createBullet((bullets)BulletID, quote.XPos + 512, quote.YPos - 4096, up);
          createEffect(quote.XPos + 512, quote.YPos - 4096, effectStar, 0);
        }
        else
        {
          createBullet((bullets)BulletID, quote.XPos - 512, quote.YPos - 4096, up);
          createEffect(quote.XPos - 512, quote.YPos - 4096, effectStar, 0);
        }
      }
      else if ( quote.isFacingDown )
      {
        if ( quote.direction )
        {
          createBullet((bullets)BulletID, quote.XPos + 512, quote.YPos + 4096, down);
          createEffect(quote.XPos + 512, quote.YPos + 4096, effectStar, 0);
        }
        else
        {
          createBullet((bullets)BulletID, quote.XPos - 512, quote.YPos + 4096, down);
          createEffect(quote.XPos - 512, quote.YPos + 4096, effectStar, 0);
        }
      }
      else if ( quote.direction )
      {
        createBullet((bullets)BulletID, quote.XPos + 3072, quote.YPos + 1536, right);
        createEffect(quote.XPos + 6144, quote.YPos + 1536, effectStar, 0);
      }
      else
      {
        createBullet((bullets)BulletID, quote.XPos - 3072, quote.YPos + 1536, 0);
        createEffect(quote.XPos - 6144, quote.YPos + 1536, effectStar, 0);
      }
      switch ( BulletID )
      {
        case 6:
          playSoundEffect(SFXPolarStarShootLevel3, 1);
          break;
        case 37:
          playSoundEffect(SFXSpurShootLevel1, 1);
          break;
        case 38:
          playSoundEffect(SFXSpurShootLevel2, 1);
          break;
        case 39:
          playSoundEffect(SFXSpurShootLevel3, 1);
          break;
        default:
          return;
      }
    }
    else
    {
      playSoundEffect(SFXNoAmmo, 1);
    }
  }
}
// 493614: using guessed type int keyShoot;
// 49E210: using guessed type int keyHeld;
// 49E214: using guessed type int keyPressed;
// 4A5550: using guessed type int dword_4A5550;
// 4A5560: using guessed type int dword_4A5560;

//----- (0041FE70) --------------------------------------------------------
void shootBullet()
{
  int v0; // [esp+0h] [ebp-Ch]
  int weaponLevel; // [esp+4h] [ebp-8h]

  if ( emptyEffectTimer )
    --emptyEffectTimer;
  if ( dword_4A5564 )
    --dword_4A5564;
  if ( keyShoot & keyPressed )
  {
    if ( dword_4A5564 )
      return;
    dword_4A5564 = 4;
  }
  if ( !(quote.flags & 2) )
  {
    // Shoot the selected weapon (initialise the bullets and do things on shooting)
    switch ( gWeapons[selectedWeapon].weaponID )
    {
      case weaponSnake:
        shootSnake(gWeapons[selectedWeapon].level);
        break;
      case weaponPolarStar:
        shootPolarStar(gWeapons[selectedWeapon].level);
        break;
      case weaponFireball:
        shootFireball(gWeapons[selectedWeapon].level);
        break;
      case weaponMachineGun:
        shootMachineGun(gWeapons[selectedWeapon].level);
        break;
      case weaponMissileLauncher:
        shootMissileLauncher(gWeapons[selectedWeapon].level, 0);
        break;
      case weaponBubbler:
        weaponLevel = gWeapons[selectedWeapon].level;
        switch ( weaponLevel )
        {
          case 1:
            shootBubblerLevel1();
            break;
          case 2:
            shootBubblerLevel2_3(2);
            break;
          case 3:
            shootBubblerLevel2_3(3);
            break;
        }
        break;
      case weaponBlade:
        v0 = gWeapons[selectedWeapon].level;
        switch ( v0 )
        {
          case 1:
            shootBlade(1);
            break;
          case 2:
            shootBlade(2);
            break;
          case 3:
            shootBlade(3);
            break;
        }
        break;
      case 0xA:
        shootMissileLauncher(gWeapons[selectedWeapon].level, 1);
        break;
      case weaponNemesis:
        shootNemesis(gWeapons[selectedWeapon].level);
        break;
      case weaponSpur:
        shootSpur(gWeapons[selectedWeapon].level);
        break;
      default:
        return;
    }
  }
}
// 493614: using guessed type int keyShoot;
// 499C68: using guessed type int selectedWeapon;
// 49E214: using guessed type int keyPressed;
// 4A554C: using guessed type int emptyEffectTimer;
// 4A5564: using guessed type int dword_4A5564;

//----- (004200C0) --------------------------------------------------------
BOOL __cdecl initDirectSound(HWND hwnd)
{
  BOOL result; // eax
  DSBUFFERDESC dsbd; // [esp+0h] [ebp-18h]
  int i; // [esp+14h] [ebp-4h]

  // Initialise direct draw
  if ( DirectSoundCreate(0, &lpDS, 0) )
  {
    lpDS = 0;
    startOrganya();
    result = 0;
  }
  else
  {
    lpDS->lpVtbl->SetCooperativeLevel(lpDS, hwnd, 3);
    // Initialise primary buffer
    memset(&dsbd, 0, 20u);
    dsbd.dwSize = 20;
    dsbd.dwFlags = DSBCAPS_CTRLVOLUME|DSBCAPS_CTRLPAN|DSBCAPS_PRIMARYBUFFER;
    lpDS->lpVtbl->CreateSoundBuffer(lpDS, &dsbd, &lpPRIMARYBUFFER, NULL);
    for ( i = 0; i < 160; ++i )
      secondaryBuffer[i] = 0;
    startOrganya();
    result = 1;
  }
  return result;
}

//----- (004201A0) --------------------------------------------------------
// Direct Sound termination
void __cdecl deleteDirectSound()
{
  signed int i; // [esp+0h] [ebp-4h]

  if ( lpDS )
  {
    deleteOrganya();
    for ( i = 0; i < 160; ++i )
    {
      if ( secondaryBuffer[i] )
        secondaryBuffer[i]->lpVtbl->Release(secondaryBuffer[i]);
    }
    if ( lpPRIMARYBUFFER )
      lpPRIMARYBUFFER->lpVtbl->Release(lpPRIMARYBUFFER);
    if ( lpDS )
      lpDS->lpVtbl->Release(lpDS);
    lpDS = 0;
  }
}

//----- (00420240) --------------------------------------------------------
// Unused
signed int __cdecl loadWAVFile(LPCSTR resourceName, int bufferIndex)
{
  HGLOBAL temp1; // eax
  void *lpbuf2; // [esp+0h] [ebp-2Ch]
  HRSRC hrscr; // [esp+4h] [ebp-28h]
  size_t dwbuf1; // [esp+8h] [ebp-24h]
  DSBUFFERDESC dsbd; // [esp+Ch] [ebp-20h]
  DWORD *lpdword; // [esp+20h] [ebp-Ch] Resource address
  void *lpbuf1; // [esp+24h] [ebp-8h]
  size_t dwbuf2; // [esp+28h] [ebp-4h]

  if ( !lpDS )
    return 1;
  // Search for resources
  hrscr = FindResourceA(0, resourceName, "WAVE");
  if ( !hrscr )
    return 0;
  // Get resource address
  temp1 = LoadResource(0, hrscr);
  lpdword = (DWORD *)LockResource(temp1);
  // Generate secondary buffer
  memset(&dsbd, 0, 20u);
  dsbd.dwSize = 20;
  dsbd.dwFlags = DSBCAPS_CTRLVOLUME|DSBCAPS_CTRLPAN|DSBCAPS_CTRLFREQUENCY|DSBCAPS_STATIC|0x8000;
  dsbd.dwBufferBytes = *(DWORD *)((char *)lpdword + 0x36);
  dsbd.lpwfxFormat = (LPWAVEFORMATEX)(lpdword + 5);
  if ( lpDS->lpVtbl->CreateSoundBuffer(lpDS, &dsbd, &secondaryBuffer[bufferIndex], 0) )
    return 0;
  // Lock secondary buffer
  secondaryBuffer[bufferIndex]->lpVtbl->Lock(
    secondaryBuffer[bufferIndex],
    0,
    *(DWORD *)((char *)lpdword + 0x36),
    &lpbuf1,
    &dwbuf1,
    &lpbuf2,
    &dwbuf2,
    0);
  // Setting of sound source data
  memcpy(lpbuf1, (char *)lpdword + 58, dwbuf1);
  if ( dwbuf2 )
    memcpy(lpbuf2, (char *)lpdword + dwbuf1 + 58, dwbuf2);
  // Unlock secondary buffer
  secondaryBuffer[bufferIndex]->lpVtbl->Unlock(secondaryBuffer[bufferIndex], lpbuf1, dwbuf1, lpbuf2, dwbuf2);
  return 1;
}

//----- (00420390) --------------------------------------------------------
// Unused
BOOL __cdecl loadSoundObject(char *fileName, int num)
{
  LPVOID lpbuf2; // [esp+0h] [ebp-184h]
  char str; // [esp+4h] [ebp-180h]
  char check_box[58]; // [esp+10Ch] [ebp-78h]
  int hr; // [esp+14Ch] [ebp-38h]
  DWORD dwbuf1; // [esp+150h] [ebp-34h]
  DSBUFFERDESC dsbd; // [esp+154h] [ebp-30h]
  HANDLE hFile; // [esp+168h] [ebp-1Ch]
  LPVOID lpbuf1; // [esp+16Ch] [ebp-18h]
  void *wp; // [esp+170h] [ebp-14h]
  FILE *fp; // [esp+174h] [ebp-10h]
  DWORD dwbuf2; // [esp+178h] [ebp-Ch]
  size_t i; // [esp+17Ch] [ebp-8h]
  size_t file_size; // [esp+180h] [ebp-4h]

  file_size = 0;
  sprintf(&str, "%s\\%s", exePath, fileName);
  if ( !lpDS )
    return 1;
  hFile = CreateFileA(&str, 0x80000000, 0, 0, 3u, 0x80u, 0);
  if ( hFile == (HANDLE)-1 )
    return 0;
  file_size = GetFileSize(hFile, 0);
  CloseHandle(hFile);
  fp = fopen(&str, "rb");
  if ( !fp )
    return 0;
  for ( i = 0; i < 58; ++i )
    fread(&check_box[i], 1u, 1u, fp);
  if ( check_box[0] != 'R' )
    return 0;
  if ( check_box[1] != 'I' )
    return 0;
  if ( check_box[2] != 'F' )
    return 0;
  if ( check_box[3] != 'F' )
    return 0;
  wp = malloc(file_size);                       // Make a file workspace
  fseek((int)fp, 0, 0);
  for ( i = 0; i < file_size; ++i )
    fread((char *)wp + i, 1u, 1u, fp);
  fclose(fp);
  // Generate secondary buffer
  memset(&dsbd, 0, 20u);
  dsbd.dwSize = 20;
  dsbd.dwFlags = DSBCAPS_CTRLVOLUME|DSBCAPS_CTRLPAN|DSBCAPS_CTRLFREQUENCY|DSBCAPS_STATIC|0x8000;
  dsbd.dwBufferBytes = *(_DWORD *)((char *)wp + 0x36);// WAVE data size
  dsbd.lpwfxFormat = (LPWAVEFORMATEX)((char *)wp + 20);
  if ( lpDS->lpVtbl->CreateSoundBuffer(lpDS, &dsbd, &secondaryBuffer[num], 0) )
    return 0;
  hr = secondaryBuffer[num]->lpVtbl->Lock(
         secondaryBuffer[num],
         0,
         *(_DWORD *)((char *)wp + 54),
         &lpbuf1,
         &dwbuf1,
         &lpbuf2,
         &dwbuf2,
         0);
  if ( hr )
    return 0;
  memcpy(lpbuf1, (char *)wp + 58, dwbuf1);      // head of data
  if ( dwbuf2 )
    memcpy(lpbuf2, (char *)wp + dwbuf1 + 58, dwbuf2);
  secondaryBuffer[num]->lpVtbl->Unlock(secondaryBuffer[num], lpbuf1, dwbuf1, lpbuf2, dwbuf2);
  free(wp);
  return 1;
}

//----- (00420640) --------------------------------------------------------
// Play sound
void __cdecl playSoundEffect(soundEffects bufferIndex, int mode)
{
  if ( lpDS && secondaryBuffer[bufferIndex] )
  {
    if ( mode == -1 )
    {
      // Play loop
      secondaryBuffer[bufferIndex]->lpVtbl->Play(secondaryBuffer[bufferIndex], 0, 0, DSBPLAY_LOOPING);
    }
    else if ( mode )
    {
      if ( mode == 1 )
      {
        // Playback
        secondaryBuffer[bufferIndex]->lpVtbl->Stop(secondaryBuffer[bufferIndex]);
        secondaryBuffer[bufferIndex]->lpVtbl->SetCurrentPosition(secondaryBuffer[bufferIndex], 0);
        secondaryBuffer[bufferIndex]->lpVtbl->Play(secondaryBuffer[bufferIndex], 0, 0, 0);
      }
    }
    else
    {
      // Stop
      secondaryBuffer[bufferIndex]->lpVtbl->Stop(secondaryBuffer[bufferIndex]);
    }
  }
}

//----- (00420720) --------------------------------------------------------
void __cdecl changeSoundFrequency(int bufferIndex, DWORD frequency)
{
  if ( lpDS )
    secondaryBuffer[bufferIndex]->lpVtbl->SetFrequency(secondaryBuffer[bufferIndex], 10 * frequency + 100);
}

//----- (00420760) --------------------------------------------------------
void __cdecl changeSoundVolume(int bufferIndex, int volume)
{
  if ( lpDS )
    secondaryBuffer[bufferIndex]->lpVtbl->SetVolume(secondaryBuffer[bufferIndex], 8 * volume - 2400);
}

//----- (004207A0) --------------------------------------------------------
void __cdecl changeSoundPan(int bufferIndex, int pan)
{
  if ( lpDS )
    secondaryBuffer[bufferIndex]->lpVtbl->SetPan(secondaryBuffer[bufferIndex], 10 * (pan - 256));
}

//----- (004207E0) --------------------------------------------------------
size_t __cdecl makePixtoneObject(int *ptrSound, int channel, int bufferIndex)
{
  size_t result; // eax
  size_t num; // [esp+0h] [ebp-7Ch]
  int j; // [esp+4h] [ebp-78h]
  void *v6; // [esp+8h] [ebp-74h]
  void *v7; // [esp+Ch] [ebp-70h]
  int ptr; // [esp+10h] [ebp-6Ch]
  int v9; // [esp+14h] [ebp-68h]
  size_t v10; // [esp+18h] [ebp-64h]
  int *v11; // [esp+20h] [ebp-5Ch]
  void *v12; // [esp+24h] [ebp-58h]
  void *source; // [esp+28h] [ebp-54h]
  void *src; // [esp+2Ch] [ebp-50h]
  size_t size; // [esp+30h] [ebp-4Ch]
  void *v16; // [esp+34h] [ebp-48h]
  int i; // [esp+38h] [ebp-44h]
  void *dest; // [esp+3Ch] [ebp-40h]
  void *pBlock; // [esp+40h] [ebp-3Ch]
  size_t count; // [esp+44h] [ebp-38h]
  int *v21; // [esp+48h] [ebp-34h]
  int destination; // [esp+4Ch] [ebp-30h]
  int v23; // [esp+50h] [ebp-2Ch]
  int v24; // [esp+54h] [ebp-28h]
  int dst; // [esp+58h] [ebp-24h]
  int v26; // [esp+5Ch] [ebp-20h]
  int v27; // [esp+60h] [ebp-1Ch]
  int v28; // [esp+64h] [ebp-18h]
  int v29; // [esp+68h] [ebp-14h]
  __int16 v30; // [esp+6Ch] [ebp-10h]
  __int16 v31; // [esp+6Eh] [ebp-Eh]
  int v32; // [esp+70h] [ebp-Ch]
  int v33; // [esp+74h] [ebp-8h]

  if ( !lpDS )
    return 0;
  source = "RIFF";
  src = "fmt ";
  v16 = "WAVE";
  v7 = "data";
  v31 = 8;
  v28 = 22050;
  v27 = 65537;
  v26 = 16;
  memcpy(&destination, "RIFF", 4u);
  memcpy(&dst, "fmt ", 4u);
  memcpy(&v24, "WAVE", 4u);
  memcpy(&v32, "data", 4u);
  v30 = 1;
  v29 = 22050;
  v33 = ptrSound[1];
  v23 = v33 + 36;
  v21 = ptrSound;
  size = 0;
  for ( i = 0; i < channel; ++i )
  {
    if ( v21[1] > (signed int)size )
      size = v21[1];
    v21 += 28;
  }
  memset(&ptr, 0, 0x14u);
  ptr = 20;
  v9 = 32994;
  v10 = size;
  v11 = &v27;
  if ( lpDS->lpVtbl->CreateSoundBuffer(
         lpDS,
         (DSBUFFERDESC *)&ptr,
         (LPDIRECTSOUNDBUFFER *)(4 * bufferIndex + 4871528),
         0) )
  {
    return -1;
  }
  pBlock = 0;
  dest = 0;
  dest = malloc(size);
  pBlock = malloc(size);
  if ( dest && pBlock )
  {
    memset(dest, 128, size);
    memset(pBlock, 128, size);
    v21 = ptrSound;
    for ( i = 0; i < channel; ++i )
    {
      if ( !MakePixelWaveData((int)v21, (int)dest) )
      {
        if ( dest )
          free(dest);
        if ( pBlock )
          free(pBlock);
        return -1;
      }
      for ( j = 0; j < v21[1]; ++j )
      {
        if ( *((unsigned __int8 *)dest + j) + *((unsigned __int8 *)pBlock + j) - 256 >= -127 )
        {
          if ( *((unsigned __int8 *)dest + j) + *((unsigned __int8 *)pBlock + j) - 256 <= 127 )
            *((_BYTE *)pBlock + j) += *((_BYTE *)dest + j) + -128;
          else
            *((_BYTE *)pBlock + j) = -1;
        }
        else
        {
          *((_BYTE *)pBlock + j) = 0;
        }
      }
      v21 += 28;
    }
    *(_BYTE *)pBlock = *(_BYTE *)pBlock;
    *((char *)pBlock + size - 1) = *((char *)pBlock + size - 1);
    secondaryBuffer[bufferIndex]->lpVtbl->Lock(secondaryBuffer[bufferIndex], 0, size, &v6, &num, &v12, &count, 0);
    memcpy(v6, pBlock, num);
    if ( count )
      memcpy(v12, (char *)pBlock + num, count);
    secondaryBuffer[bufferIndex]->lpVtbl->Unlock(secondaryBuffer[bufferIndex], v6, num, v12, count);
    if ( dest )
      free(dest);
    if ( pBlock )
      free(pBlock);
    result = size;
  }
  else
  {
    if ( dest )
      free(dest);
    if ( pBlock )
      free(pBlock);
    result = -1;
  }
  return result;
}

//----- (00420BE0) --------------------------------------------------------
// Load stage
signed int __cdecl changeStage(int number, int event, int XPos, int YPos)
{
  char path[260]; // [esp+0h] [ebp-128h]
  int bError; // [esp+10Ch] [ebp-1Ch]
  char pathDir[20]; // [esp+110h] [ebp-18h]

  // Change player's position
  setQuotePosition(XPos << 13, YPos << 13);
  bError = 0;
  strcpy(pathDir, "stage");
  sprintf(path, "%s\\Prt%s", pathDir, &mapHeaders[number]);
  if ( !reloadBitmapFromFile(path, 2) )
    bError = 1;
  sprintf(path, "%s\\%s.pxa", pathDir, &mapHeaders[number]);
  if ( !loadAttributeData(path) )
    bError = 1;
  sprintf(path, "%s\\%s.pxm", pathDir, mapHeaders[number].map);
  if ( !loadMapData(path) )
    bError = 1;
  sprintf(path, "%s\\%s.pxe", pathDir, mapHeaders[number].map);
  if ( !Load_Event(path) )
    bError = 1;
  sprintf(path, "%s\\%s.tsc", pathDir, mapHeaders[number].map);
  if ( !loadTSCScript(path) )
    bError = 1;
  sprintf(path, "%s", mapHeaders[number].backgroundFile);
  if ( !initBackground(path, mapHeaders[number].backgroundType) )
    bError = 1;
  strcpy(pathDir, "Npc");
  sprintf(path, "%s\\Npc%s", pathDir, mapHeaders[number].NPCFile);
  if ( !reloadBitmapFromFile(path, 21) )
    bError = 1;
  sprintf(path, "%s\\Npc%s", pathDir, mapHeaders[number].bossFile);
  if ( !reloadBitmapFromFile(path, 22) )
    bError = 1;
  if ( bError )
    return 0;
  readyMapName(mapHeaders[number].name);
  startTSCEvent(event);
  setCameraQuote();
  resetBullets();
  initEffects();
  clearValueView();
  resetQuake();
  initRoomBoss(mapHeaders[number].bossNumber);
  resetFlash();
  currentStageNumber = number;
  return 1;
}
// 4A57F0: using guessed type int currentStageNumber;

//----- (00420EE0) --------------------------------------------------------
// CMU : Change MUsic
// Change playing music to Music_To_Play
void __cdecl changeMusic(musics musicID)
{
  if ( musicID == musicSilence || musicID != currentSongNumber )
  {
    oldSongPosition = getOrganyaPosition();
    oldSongNumber = currentSongNumber;
    stopOrganyaMusic();
    loadOrganya(songNames[musicID]);
    changeOrganyaVolume(100);
    setOrganyaPosition(0);
    startOrganyaPlayback();
    currentSongNumber = musicID;
  }
}
// 4A57F4: using guessed type int currentSongNumber;
// 4A57F8: using guessed type int oldSongPosition;
// 4A57FC: using guessed type int oldSongNumber;

//----- (00420F50) --------------------------------------------------------
// RMU : Play pRevious MUsic
void __cdecl recallMusic()
{
  stopOrganyaMusic();
  loadOrganya(songNames[oldSongNumber]);
  setOrganyaPosition(oldSongPosition);
  changeOrganyaVolume(100);
  startOrganyaPlayback();
  currentSongNumber = oldSongNumber;
}
// 4A57F4: using guessed type int currentSongNumber;
// 4A57F8: using guessed type int oldSongPosition;
// 4A57FC: using guessed type int oldSongNumber;

//----- (00420FA0) --------------------------------------------------------
// Move whimsical star to Quote's position
void __cdecl initWhimsicalStar()
{
  memset(whimsicalStars, 0, 0xCCu);
  whimsicalStars[0].XPos = quote.XPos;
  whimsicalStars[0].YPos = quote.YPos;
  whimsicalStars[1].XPos = quote.XPos;
  whimsicalStars[1].YPos = quote.YPos;
  whimsicalStars[2].XPos = quote.XPos;
  whimsicalStars[2].YPos = quote.YPos;
  whimsicalStars[0].XVel = 1024;
  whimsicalStars[0].YVel = -512;
  whimsicalStars[1].XVel = -512;
  whimsicalStars[1].YVel = 1024;
  whimsicalStars[2].XVel = 512;
  whimsicalStars[2].YVel = 512;
}

//----- (00421040) --------------------------------------------------------
int doWhimsicalStar()
{
  int result; // eax
  int v1; // ecx
  int v2; // ecx
  int v3; // eax
  int v4; // edx
  signed int i; // [esp+0h] [ebp-4h]

  result = ++CurrentStarID / 3;
  CurrentStarID %= 3;
  for ( i = 0; i < 3; ++i )
  {
    if ( i )
    {
      if ( whimsicalStars[i - 1].XPos >= whimsicalStars[i].XPos )
        v1 = whimsicalStars[i].XVel + 128;
      else
        v1 = whimsicalStars[i].XVel - 128;
      whimsicalStars[i].XVel = v1;
      if ( whimsicalStars[i - 1].YPos >= whimsicalStars[i].YPos )
        v2 = whimsicalStars[i].YVel + 170;
      else
        v2 = whimsicalStars[i].YVel - 170;
      whimsicalStars[i].YVel = v2;
    }
    else
    {
      if ( quote.XPos >= whimsicalStars[0].XPos )
        v3 = whimsicalStars[0].XVel + 128;
      else
        v3 = whimsicalStars[0].XVel - 128;
      whimsicalStars[0].XVel = v3;
      if ( quote.YPos >= whimsicalStars[0].YPos )
        v4 = whimsicalStars[0].YVel + 170;
      else
        v4 = whimsicalStars[0].YVel - 170;
      whimsicalStars[0].YVel = v4;
    }
    if ( whimsicalStars[i].XVel > 2560 )
      whimsicalStars[i].XVel = 2560;
    if ( whimsicalStars[i].XVel < -2560 )
      whimsicalStars[i].XVel = -2560;
    if ( whimsicalStars[i].YVel > 2560 )
      whimsicalStars[i].YVel = 2560;
    if ( whimsicalStars[i].YVel < -2560 )
      whimsicalStars[i].YVel = -2560;
    if ( whimsicalStars[i].XVel > 2560 )
      whimsicalStars[i].XVel = 2560;
    if ( whimsicalStars[i].XVel < -2560 )
      whimsicalStars[i].XVel = -2560;
    if ( whimsicalStars[i].YVel > 2560 )
      whimsicalStars[i].YVel = 2560;
    if ( whimsicalStars[i].YVel < -2560 )
      whimsicalStars[i].YVel = -2560;
    whimsicalStars[i].XPos += whimsicalStars[i].XVel;
    result = 68 * i;
    whimsicalStars[i].YPos += whimsicalStars[i].YVel;
    if ( i < quote.star )
    {
      if ( quote.equippedItems & 0x80 )
      {
        result = gameFlags & 2;
        if ( gameFlags & 2 )
        {
          if ( CurrentStarID == i )
            createBullet(bulletSpurLevel3, whimsicalStars[CurrentStarID].XPos, whimsicalStars[CurrentStarID].YPos, 0);
        }
      }
    }
  }
  return result;
}
// 49E1E8: using guessed type int gameFlags;
// 4A58CC: using guessed type int CurrentStarID;

//----- (004213B0) --------------------------------------------------------
void __cdecl drawWhimsicalStar(signed int a1, signed int a2)
{
  signed int i; // [esp+0h] [ebp-34h]
  RECT rect; // [esp+4h] [ebp-30h]
  int v4; // [esp+14h] [ebp-20h]
  int v5; // [esp+18h] [ebp-1Ch]
  int v6; // [esp+1Ch] [ebp-18h]
  int v7; // [esp+20h] [ebp-14h]
  int v8; // [esp+24h] [ebp-10h]
  int v9; // [esp+28h] [ebp-Ch]
  int v10; // [esp+2Ch] [ebp-8h]
  int v11; // [esp+30h] [ebp-4h]

  rect.left = 192;
  rect.top = 0;
  rect.right = 200;
  rect.bottom = 8;
  v4 = 192;
  v5 = 8;
  v6 = 200;
  v7 = 16;
  v8 = 192;
  v9 = 16;
  v10 = 200;
  v11 = 24;
  if ( !(quote.flags & 2) && quote.equippedItems & 0x80 )
  {
    for ( i = 0; i < 3; ++i )
    {
      if ( i < quote.star )
        drawBitmapWithTransparency(
          &gameRect,
          whimsicalStars[i].XPos / 512 - a1 / 512 - 4,
          whimsicalStars[i].YPos / 512 - a2 / 512 - 4,
          &rect + i,
          16);
    }
  }
}

//----- (004214E0) --------------------------------------------------------
// Allocates memory for script and makes bitmaps for text display
void __cdecl initTSC()
{
  signed int i; // [esp+0h] [ebp-4h]

  byte_4A5ADC = 0;
  gameFlags &= -5u;
  for ( i = 0; i < 4; ++i )
    makeBlankSurface(unk_498298, unk_49829C, i + 30, 0);
  memset(&textBuffer, 0, 0x100u);
  scriptBuffer = (__int8 *)malloc(0x5000u);
}
// 49E1E8: using guessed type int gameFlags;
// 4A5ADC: using guessed type char byte_4A5ADC;

//----- (00421570) --------------------------------------------------------
// Frees script buffer and bitmap objects for text display
void deleteTSC()
{
  signed int i; // [esp+0h] [ebp-4h]

  free(scriptBuffer);
  destroyBitmapObjectsMaybe(26);
  for ( i = 0; i < 4; ++i )
    destroyBitmapObjectsMaybe(i + 30);
}

//----- (004215C0) --------------------------------------------------------
void __cdecl decryptTSCScript(unsigned __int8 *TSCData, signed int dataSize)
{
  int val1; // [esp+0h] [ebp-10h]
  signed int i; // [esp+8h] [ebp-8h]
  int half; // [esp+Ch] [ebp-4h]

  half = dataSize / 2;
  if ( TSCData[dataSize / 2] )
    val1 = -(TSCData[half] % 256);
  else
    LOBYTE(val1) = -7;
  for ( i = 0; i < dataSize; ++i )
  {
    if ( i != half )
      TSCData[i] += val1;
  }
}

//----- (00421660) --------------------------------------------------------
int __cdecl loadSpecialTSC(char *source)
{
  char str; // [esp+0h] [ebp-110h]
  FILE *stream; // [esp+10Ch] [ebp-4h]

  sprintf(&str, "%s\\%s", dataPath, source);
  size = getFileSize(&str);
  if ( size == -1 )
    return 0;
  stream = fopen(&str, "rb");
  if ( !stream )
    return 0;
  fread(scriptBuffer, 1u, size, stream);
  scriptBuffer[size] = 0;
  fclose(stream);
  strcpy(&textBuffer.path[256], source);
  decryptTSCScript((unsigned __int8 *)scriptBuffer, size);
  return 1;
}

//----- (00421750) --------------------------------------------------------
signed int __cdecl loadTSCScript(char *scriptName)
{
  char path[260]; // [esp+0h] [ebp-118h]
  size_t headSize; // [esp+10Ch] [ebp-Ch]
  FILE *stream; // [esp+110h] [ebp-8h]
  size_t bodySize; // [esp+114h] [ebp-4h]

  sprintf(path, "%s\\%s", dataPath, "Head.tsc");
  headSize = getFileSize(path);
  if ( headSize == -1 )
    return 0;
  stream = fopen(path, "rb");
  if ( !stream )
    return 0;
  fread(scriptBuffer, 1u, headSize, stream);
  decryptTSCScript((unsigned __int8 *)scriptBuffer, headSize);
  scriptBuffer[headSize] = 0;
  fclose(stream);
  sprintf(path, "%s\\%s", dataPath, scriptName);
  bodySize = getFileSize(path);
  if ( bodySize == -1 )
    return 0;
  stream = fopen(path, "rb");
  if ( !stream )
    return 0;
  fread(&scriptBuffer[headSize], 1u, bodySize, stream);
  decryptTSCScript((unsigned __int8 *)&scriptBuffer[headSize], bodySize);
  scriptBuffer[bodySize + headSize] = 0;
  fclose(stream);
  size = bodySize + headSize;
  strcpy(&textBuffer.path[256], scriptName);
  return 1;
}

//----- (00421900) --------------------------------------------------------
// Getting 4 decimal digits from a TSC file and converting to hexadecimal number (why didn't Pixel just use atoi ???)
int __cdecl getTSCNumber(int num)
{
  return 1000 * (scriptBuffer[num] - '0')
       + 100 * (scriptBuffer[num + 1] - '0')
       + 10 * (scriptBuffer[num + 2] - '0')
       + scriptBuffer[num + 3]
       - '0';
}

//----- (00421990) --------------------------------------------------------
signed int __cdecl startTSCEvent(int event)
{
  int Event_Num; // [esp+0h] [ebp-4h]

  byte_4A5ADC = 1;
  gameFlags |= 5u;
  dword_4A5AE8[0] = 0;
  textColumn = 0;
  dword_4A5AFC = 4;
  byte_4A5ADD = 0;
  byte_4A5B30 = 0;
  faceNumber = 0;
  dword_4A5B14 = 0;
  dword_4A5B2C = 0;
  quote.Invincibility_Timer = 0;                // Resets the invincibility timer. You may want to remove this
  rcView.left = 52;
  rcView.top = 184;
  rcView.right = 268;
  rcView.bottom = 232;
  for ( scriptPosition = 0; ; ++scriptPosition )
  {
    if ( !scriptBuffer[scriptPosition] )
      return 0;
    if ( scriptBuffer[scriptPosition] != 35 )
      continue;
    Event_Num = getTSCNumber(++scriptPosition);
    if ( event == Event_Num )
      break;
    if ( event < Event_Num )
      return 0;
  }
  while ( scriptBuffer[scriptPosition] != 10 )
    ++scriptPosition;
  ++scriptPosition;
  return 1;
}
// 49E1E8: using guessed type int gameFlags;
// 4A5ADC: using guessed type char byte_4A5ADC;
// 4A5ADD: using guessed type char byte_4A5ADD;
// 4A5AE4: using guessed type int textColumn;
// 4A5AFC: using guessed type int dword_4A5AFC;
// 4A5B0C: using guessed type int faceNumber;
// 4A5B14: using guessed type int dword_4A5B14;
// 4A5B2C: using guessed type int dword_4A5B2C;
// 4A5B30: using guessed type char byte_4A5B30;

//----- (00421AF0) --------------------------------------------------------
signed int __cdecl changeEvent(int newEvent)
{
  int eventNumber; // [esp+0h] [ebp-8h]
  signed int i; // [esp+4h] [ebp-4h]

  byte_4A5ADC = 1;
  gameFlags |= 4u;
  dword_4A5AE8[0] = 0;
  textColumn = 0;
  dword_4A5AFC = 4;
  byte_4A5B30 = 0;
  for ( i = 0; i < 4; ++i )
  {
    dword_4A5AEC[i] = 16 * i;
    drawColorFillOntoSurface(&unk_498290, 0, i + 30);
    memset((char *)&textBuffer + 64 * i, 0, 0x40u);
  }
  for ( scriptPosition = 0; ; ++scriptPosition )
  {
    if ( !scriptBuffer[scriptPosition] )
      return 0;
    if ( scriptBuffer[scriptPosition] != 35 )
      continue;
    eventNumber = getTSCNumber(++scriptPosition);
    if ( newEvent == eventNumber )
      break;
    if ( newEvent < eventNumber )
      return 0;
  }
  while ( scriptBuffer[scriptPosition] != 10 )
    ++scriptPosition;
  ++scriptPosition;
  return 1;
}
// 49E1E8: using guessed type int gameFlags;
// 4A5ADC: using guessed type char byte_4A5ADC;
// 4A5AE4: using guessed type int textColumn;
// 4A5AEC: using guessed type int dword_4A5AEC[];
// 4A5AFC: using guessed type int dword_4A5AFC;
// 4A5B30: using guessed type char byte_4A5B30;

//----- (00421C50) --------------------------------------------------------
void __cdecl stopTSC()
{
  byte_4A5ADC = 0;
  gameFlags &= ~4u;
  gameFlags |= 3u;
  byte_4A5ADD = 0;
}
// 49E1E8: using guessed type int gameFlags;
// 4A5ADC: using guessed type char byte_4A5ADC;
// 4A5ADD: using guessed type char byte_4A5ADD;

//----- (00421C80) --------------------------------------------------------
void __cdecl checkNewLine()
{
  if ( dword_4A5AEC[(signed __int32)dword_4A5AE8[0] % 4] == 48 )
  {
    byte_4A5ADC = 3;
    gameFlags |= 4u;
    drawColorFillOntoSurface(&unk_498290, 0, (signed __int32)dword_4A5AE8[0] % 4 + 30);
    memset((char *)&textBuffer + 64 * ((signed __int32)dword_4A5AE8[0] % 4), 0, 0x40u);
  }
}
// 49E1E8: using guessed type int gameFlags;
// 4A5ADC: using guessed type char byte_4A5ADC;
// 4A5AEC: using guessed type int dword_4A5AEC[];

//----- (00421D10) --------------------------------------------------------
void __cdecl printNumber(int index)
{
  char string[5]; // [esp+0h] [ebp-2Ch]
  int bZero; // [esp+Ch] [ebp-20h]
  int b; // [esp+10h] [ebp-1Ch]
  int table[3]; // [esp+14h] [ebp-18h]
  int offset; // [esp+20h] [ebp-Ch]
  int i; // [esp+24h] [ebp-8h]
  int a; // [esp+28h] [ebp-4h]

  table[0] = 1000;
  table[1] = 100;
  table[2] = 10;
  a = numberTextScript[index];
  bZero = 0;
  offset = 0;
  for ( i = 0; i < 3; ++i )
  {
    if ( a / table[i] || bZero )
    {
      b = a / table[i];
      string[offset] = b + 48;
      bZero = 1;
      a -= table[i] * b;
      ++offset;
    }
  }
  string[offset] = a + 48;
  string[offset + 1] = 0;
  drawStringOntoSurface(6 * textColumn, 0, string, 0xFEFFFFu, (signed __int32)dword_4A5AE8[0] % 4 + 30);
  strcat(&textBuffer.path[64 * ((signed __int32)dword_4A5AE8[0] % 4)], string);
  playSoundEffect(SFXMessageTyping, 1);
  byte_4A5B30 = 0;
  textColumn += strlen(string);
  if ( textColumn >= 35 )
  {
    textColumn = 0;
    ++dword_4A5AE8[0];
    checkNewLine();
  }
}
// 4A5AE4: using guessed type int textColumn;
// 4A5B30: using guessed type char byte_4A5B30;

//----- (00421E90) --------------------------------------------------------
void __cdecl clearTextLine()
{
  signed int i; // [esp+0h] [ebp-4h]

  dword_4A5AE8[0] = 0;
  textColumn = 0;
  dword_4A5B2C = 0;
  for ( i = 0; i < 4; ++i )
  {
    dword_4A5AEC[i] = 16 * i;
    drawColorFillOntoSurface(&unk_498290, 0, i + 30);
    memset((char *)&textBuffer + 64 * i, 0, 0x40u);
  }
}
// 4A5AE4: using guessed type int textColumn;
// 4A5AEC: using guessed type int dword_4A5AEC[];
// 4A5B2C: using guessed type int dword_4A5B2C;

//----- (00421F10) --------------------------------------------------------
void drawTextBox()
{
  int v0; // edx
  RECT v1; // [esp+0h] [ebp-C8h]
  RECT rect; // [esp+10h] [ebp-B8h]
  RECT v3; // [esp+20h] [ebp-A8h]
  RECT v4; // [esp+30h] [ebp-98h]
  RECT v5; // [esp+40h] [ebp-88h]
  RECT v6; // [esp+50h] [ebp-78h]
  RECT v7; // [esp+60h] [ebp-68h]
  RECT v8; // [esp+70h] [ebp-58h]
  RECT v9; // [esp+80h] [ebp-48h]
  int YPos; // [esp+90h] [ebp-38h]
  RECT v11; // [esp+94h] [ebp-34h]
  RECT Ptr_Img_Rects; // [esp+A4h] [ebp-24h]
  int v13; // [esp+B4h] [ebp-14h]
  RECT v14; // [esp+B8h] [ebp-10h]

  if ( byte_4A5ADC && byte_4A5ADD & 1 )
  {
    if ( byte_4A5ADD & 0x20 )
    {
      rcView.top = 32;
      rcView.bottom = 80;
    }
    else
    {
      rcView.top = 184;
      rcView.bottom = 232;
    }
    if ( byte_4A5ADD & 2 )
    {
      rect.left = 0;
      rect.top = 0;
      rect.right = 244;
      rect.bottom = 8;
      v3.left = 0;
      v3.top = 8;
      v3.right = 244;
      v3.bottom = 16;
      v1.left = 0;
      v1.top = 16;
      v1.right = 244;
      v1.bottom = 24;
      drawBitmapWithTransparency(&::rect, 38, rcView.top - 10, &rect, 26);
      for ( YPos = 1; YPos < 7; ++YPos )
        drawBitmapWithTransparency(&::rect, 38, rcView.top + 8 * YPos - 10, &v3, 26);
      drawBitmapWithTransparency(&::rect, 38, rcView.top + 8 * YPos - 10, &v1, 26);
    }
    v4.left = 48 * (faceNumber % 6);
    v4.top = 48 * (faceNumber / 6);
    v4.right = 48 * (faceNumber % 6) + 48;
    v4.bottom = 48 * (faceNumber / 6) + 48;
    if ( dword_4A5B10 < 26624 )
      dword_4A5B10 += 4096;
    drawBitmapWithTransparency(&rcView, dword_4A5B10 / 512, rcView.top - 3, &v4, 27);
    if ( faceNumber )
      v13 = 56;
    else
      v13 = 0;
    for ( YPos = 0; YPos < 4; ++YPos )
      drawBitmapWithTransparency(
        &rcView,
        v13 + 52,
        dword_4A5B2C + dword_4A5AEC[YPos] + rcView.top,
        &unk_498290,
        YPos + 30);
    v0 = (unsigned __int8)byte_4A5B30++ % 20;
    if ( v0 > 12 && byte_4A5ADC == 2 )
    {
      Ptr_Img_Rects.left = 6 * textColumn + v13 + 52;
      Ptr_Img_Rects.top = dword_4A5B2C + rcView.top + dword_4A5AEC[(signed __int32)dword_4A5AE8[0] % 4];
      Ptr_Img_Rects.right = 6 * textColumn + v13 + 57;
      Ptr_Img_Rects.bottom = Ptr_Img_Rects.top + 11;
      drawColorFill(&Ptr_Img_Rects, 16711679);
    }
    v14.left = 0;
    v14.top = 0;
    v14.right = 72;
    v14.bottom = 16;
    v9.left = 0;
    v9.top = 8;
    v9.right = 72;
    v9.bottom = 24;
    v5.left = 240;
    v5.top = 0;
    v5.right = 244;
    v5.bottom = 8;
    v7.left = 240;
    v7.top = 8;
    v7.right = 244;
    v7.bottom = 16;
    v6.left = 240;
    v6.top = 16;
    v6.right = 244;
    v6.bottom = 24;
    if ( dword_4A5B14 )
    {
      drawBitmapWithTransparency(&::rect, 120, 128, &v14, 26);
      drawBitmapWithTransparency(&::rect, 120, 144, &v9, 26);
      drawBitmapWithTransparency(&::rect, 192, 128, &v5, 26);
      drawBitmapWithTransparency(&::rect, 192, 136, &v7, 26);
      drawBitmapWithTransparency(&::rect, 192, 144, &v7, 26);
      drawBitmapWithTransparency(&::rect, 192, 152, &v6, 26);
      if ( textBoxRelatedYPos < 136 )
        ++textBoxRelatedYPos;
      if ( dword_4A5B14 >= 1000 )
      {
        Ptr_Img_Rects.left = 32 * ((dword_4A5B14 - 1000) % 8);
        Ptr_Img_Rects.right = Ptr_Img_Rects.left + 32;
        Ptr_Img_Rects.top = 16 * ((dword_4A5B14 - 1000) / 8);
        Ptr_Img_Rects.bottom = 16 * ((dword_4A5B14 - 1000) / 8) + 16;
        drawBitmapWithTransparency(&::rect, 140, textBoxRelatedYPos, &Ptr_Img_Rects, 8);
      }
      else
      {
        Ptr_Img_Rects.left = 16 * (dword_4A5B14 % 16);
        Ptr_Img_Rects.right = Ptr_Img_Rects.left + 16;
        Ptr_Img_Rects.top = 16 * (dword_4A5B14 / 16);
        Ptr_Img_Rects.bottom = 16 * (dword_4A5B14 / 16) + 16;
        drawBitmapWithTransparency(&::rect, 148, textBoxRelatedYPos, &Ptr_Img_Rects, 12);
      }
    }
    v8.left = 152;
    v8.top = 48;
    v8.right = 244;
    v8.bottom = 80;
    v11.left = 112;
    v11.top = 88;
    v11.right = 128;
    v11.bottom = 104;
    if ( byte_4A5ADC == 6 )
    {
      if ( dword_4A5AFC >= 2 )
        YPos = 144;
      else
        YPos = 4 * (2 - dword_4A5AFC) + 144;
      drawBitmapWithTransparency(&::rect, 216, YPos, &v8, 26);
      if ( dword_4A5AFC == 16 )
        drawBitmapWithTransparency(&::rect, 41 * byte_4A5B08 + 211, 154, &v11, 26);
    }
  }
}
// 4A5ADC: using guessed type char byte_4A5ADC;
// 4A5ADD: using guessed type char byte_4A5ADD;
// 4A5AE4: using guessed type int textColumn;
// 4A5AEC: using guessed type int dword_4A5AEC[];
// 4A5AFC: using guessed type int dword_4A5AFC;
// 4A5B08: using guessed type char byte_4A5B08;
// 4A5B0C: using guessed type int faceNumber;
// 4A5B10: using guessed type int dword_4A5B10;
// 4A5B14: using guessed type int dword_4A5B14;
// 4A5B2C: using guessed type int dword_4A5B2C;
// 4A5B30: using guessed type char byte_4A5B30;

//----- (00422510) --------------------------------------------------------
int TSCParser(void)
{
  int sceneDownIslandRet; // [esp+0h] [ebp-C8h]
  signed int gameLoopStageSelectRet; // [esp+4h] [ebp-C4h]
  signed int gameLoopMapRet; // [esp+8h] [ebp-C0h]
  const char text[64]; // [esp+10h] [ebp-B8h]
  char format[72]; // [esp+50h] [ebp-78h]
  bool exitLoop; // [esp+9Ch] [ebp-2Ch]
  char source; // [esp+A0h] [ebp-28h]
  char v8; // [esp+A1h] [ebp-27h]
  char v9; // [esp+A2h] [ebp-26h]
  int TSCArg3; // [esp+A4h] [ebp-24h]
  RECT RectSymbol; // [esp+A8h] [ebp-20h]
  int i; // [esp+B8h] [ebp-10h]
  signed int TSCArg1; // [esp+BCh] [ebp-Ch]
  size_t TSCArg2; // [esp+C0h] [ebp-8h]
  int NPCID; // [esp+C4h] [ebp-4h]

  RectSymbol.left = 64;
  RectSymbol.top = 48;
  RectSymbol.right = 72;
  RectSymbol.bottom = 56;
  switch ( byte_4A5ADC )
  {
    case 1:
      ++dword_4A5AFC;
      if ( !(gameFlags & 2) && keyHeld & (keyCancel | keyOk) )
        dword_4A5AFC += 4;
      if ( dword_4A5AFC < 4 )
        goto default;
      dword_4A5AFC = 0;
      exitLoop = 0;
      break;
    case 2:
      if ( keyPressed & (keyCancel | keyOk) )
        byte_4A5ADC = 1;
      goto default;
    case 3:
      for ( i = 0; i < 4; ++i )
      {
        dword_4A5AEC[i] -= 4;
        if ( !dword_4A5AEC[i] )
          byte_4A5ADC = 1;
        if ( dword_4A5AEC[i] == -16 )
          dword_4A5AEC[i] = 48;
      }
      goto default;
    case 4:
      if ( dword_4A5B00 != 9999 )
      {
        if ( dword_4A5AFC != 9999 )
          ++dword_4A5AFC;
        if ( dword_4A5AFC >= dword_4A5B00 )
        {
          byte_4A5ADC = 1;
          byte_4A5B30 = 0;
        }
      }
      goto default;
    case 5:
      if ( !getFadeMode() )
      {
        byte_4A5ADC = 1;
        byte_4A5B30 = 0;
      }
      goto default;
    case 6:
      if ( dword_4A5AFC >= 16 )
      {
        if ( keyOk & keyPressed )
        {
          playSoundEffect(SFXYNConfirm, 1);
          if ( byte_4A5B08 == 1 )
          {
            changeEvent(dword_4A5B04);
          }
          else
          {
            byte_4A5ADC = 1;
            byte_4A5B30 = 0;
          }
        }
        else if ( keyLeft & keyPressed )
        {
          byte_4A5B08 = 0;
          playSoundEffect(SFXYNChangeChoice, 1);
        }
        else if ( keyRight & keyPressed )
        {
          byte_4A5B08 = 1;
          playSoundEffect(SFXYNChangeChoice, 1);
        }
      }
      else
      {
        ++dword_4A5AFC;
      }
      goto default;
    case 7:
      if ( quote.collisionFlags & 8 )
      {
        byte_4A5ADC = 1;
        byte_4A5B30 = 0;
      }
      goto default;
    default:
default:
      if ( byte_4A5ADC )
        gameFlags |= 4u;
      else
        gameFlags &= 0xFFFFFFFB;
      return 1;
  }
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              while ( 1 )
              {
                while ( 1 )
                {
                  while ( 1 )
                  {
                    while ( 1 )
                    {
                      while ( 1 )
                      {
                        while ( 1 )
                        {
                          while ( 1 )
                          {
                            while ( 1 )
                            {
                              while ( 1 )
                              {
                                while ( 1 )
                                {
                                  while ( 1 )
                                  {
                                    while ( 1 )
                                    {
                                      while ( 1 )
                                      {
                                        while ( 1 )
                                        {
                                          while ( 1 )
                                          {
                                            while ( 1 )
                                            {
                                              while ( 1 )
                                              {
                                                while ( 1 )
                                                {
                                                  while ( 1 )
                                                  {
                                                    while ( 1 )
                                                    {
                                                      while ( 1 )
                                                      {
                                                        while ( 1 )
                                                        {
                                                          while ( 1 )
                                                          {
                                                            while ( 1 )
                                                            {
                                                              while ( 1 )
                                                              {
                                                                while ( 1 )
                                                                {
                                                                  while ( 1 )
                                                                  {
                                                                    while ( 1 )
                                                                    {
                                                                      while ( 1 )
                                                                      {
                                                                        while ( 1 )
                                                                        {
                                                                          while ( 1 )
                                                                          {
                                                                            while ( 1 )
                                                                            {
                                                                              while ( 1 )
                                                                              {
                                                                                while ( 1 )
                                                                                {
                                                                                  while ( 1 )
                                                                                  {
                                                                                    while ( 1 )
                                                                                    {
                                                                                      while ( 1 )
                                                                                      {
                                                                                        while ( 1 )
                                                                                        {
                                                                                          while ( 1 )
                                                                                          {
                                                                                            while ( 1 )
                                                                                            {
                                                                                              while ( 1 )
                                                                                              {
                                                                                                while ( 1 )
                                                                                                {
                                                                                                  while ( 1 )
                                                                                                  {
                                                                                                    while ( 1 )
                                                                                                    {
                                                                                                      while ( 1 )
                                                                                                      {
                                                                                                        while ( 1 )
                                                                                                        {
                                                                                                          while ( 1 )
                                                                                                          {
                                                                                                            while ( 1 )
                                                                                                            {
                                                                                                              while ( 1 )
                                                                                                              {
                                                                                                                while ( 1 )
                                                                                                                {
                                                                                                                  while ( 1 )
                                                                                                                  {
                                                                                                                    while ( 1 )
                                                                                                                    {
                                                                                                                      while ( 1 )
                                                                                                                      {
                                                                                                                        while ( 1 )
                                                                                                                        {
                                                                                                                          while ( 1 )
                                                                                                                          {
                                                                                                                            while ( 1 )
                                                                                                                            {
                                                                                                                              while ( 1 )
                                                                                                                              {
                                                                                                                                while ( 1 )
                                                                                                                                {
                                                                                                                                  while ( 1 )
                                                                                                                                  {
                                                                                                                                    while ( 1 )
                                                                                                                                    {
                                                                                                                                      while ( 1 )
                                                                                                                                      {
                                                                                                                                        while ( 1 )
                                                                                                                                        {
                                                                                                                                          while ( 1 )
                                                                                                                                          {
                                                                                                                                            while ( 1 )
                                                                                                                                            {
                                                                                                                                              while ( 1 )
                                                                                                                                              {
                                                                                                                                                while ( 1 )
                                                                                                                                                {
                                                                                                                                                  while ( 1 )
                                                                                                                                                  {
                                                                                                                                                    while ( 1 )
                                                                                                                                                    {
                                                                                                                                                      while ( 1 )
                                                                                                                                                      {
                                                                                                                                                        while ( 1 )
                                                                                                                                                        {
                                                                                                                                                          while ( 1 )
                                                                                                                                                          {
                                                                                                                                                            while ( 1 )
                                                                                                                                                            {
                                                                                                                                                              while ( 1 )
                                                                                                                                                              {
                                                                                                                                                                while ( 1 )
                                                                                                                                                                {
                                                                                                                                                                  while ( 1 )
                                                                                                                                                                  {
                                                                                                                                                                    while ( 1 )
                                                                                                                                                                    {
                                                                                                                                                                      while ( 1 )
                                                                                                                                                                      {
                                                                                                                                                                        while ( 1 )
                                                                                                                                                                        {
                                                                                                                                                                          while ( 1 )
                                                                                                                                                                          {
                                                                                                                                                                            while ( 1 )
                                                                                                                                                                            {
                                                                                                                                                                              while ( 1 )
                                                                                                                                                                              {
                                                                                                                                                                                while ( 1 )
                                                                                                                                                                                {
                                                                                                                                                                                  while ( 1 )
                                                                                                                                                                                  {
                                                                                                                                                                                    while ( 1 )
                                                                                                                                                                                    {
                                                                                                                                                                                      while ( 1 )
                                                                                                                                                                                      {
                                                                                                                                                                                        while ( 1 )
                                                                                                                                                                                        {
                                                                                                                                                                                          if ( exitLoop )
                                                                                                                                                                                            goto default;
                                                                                                                                                                                          if ( scriptBuffer[scriptPosition] == '<' )
                                                                                                                                                                                            break;
                                                                                                                                                                                          if ( scriptBuffer[scriptPosition] == '\r' )
                                                                                                                                                                                          {
                                                                                                                                                                                            scriptPosition += 2;
                                                                                                                                                                                            textColumn = 0;
                                                                                                                                                                                            if ( byte_4A5ADD & 1 )
                                                                                                                                                                                            {
                                                                                                                                                                                              ++dword_4A5AE8[0];
                                                                                                                                                                                              checkNewLine();
                                                                                                                                                                                            }
                                                                                                                                                                                          }
                                                                                                                                                                                          else if ( byte_4A5ADD & 0x10 )
                                                                                                                                                                                          {
                                                                                                                                                                                            for ( TSCArg1 = scriptPosition;
                                                                                                                                                                                                  scriptBuffer[TSCArg1] != 60 && scriptBuffer[TSCArg1] != '\r';
                                                                                                                                                                                                  ++TSCArg1 )
                                                                                                                                                                                            {
                                                                                                                                                                                              if ( scriptBuffer[TSCArg1] & 0x80 )
                                                                                                                                                                                                ++TSCArg1;
                                                                                                                                                                                            }
                                                                                                                                                                                            TSCArg2 = TSCArg1 - scriptPosition;
                                                                                                                                                                                            memcpy(format, &scriptBuffer[scriptPosition], TSCArg1 - scriptPosition);
                                                                                                                                                                                            format[TSCArg2] = 0;
                                                                                                                                                                                            textColumn = TSCArg1;
                                                                                                                                                                                            drawStringOntoSurface(0, 0, format, 0xFEFFFFu, (signed __int32)dword_4A5AE8[0] % 4 + 30);
                                                                                                                                                                                            sprintf(&textBuffer.path[64 * ((signed __int32)dword_4A5AE8[0] % 4)], format);
                                                                                                                                                                                            scriptPosition += TSCArg2;
                                                                                                                                                                                            if ( textColumn >= 35 )
                                                                                                                                                                                              checkNewLine();
                                                                                                                                                                                            exitLoop = 1;
                                                                                                                                                                                          }
                                                                                                                                                                                          else
                                                                                                                                                                                          {
                                                                                                                                                                                            source = scriptBuffer[scriptPosition];
                                                                                                                                                                                            if ( source & 0x80 )
                                                                                                                                                                                            {
                                                                                                                                                                                              v8 = scriptBuffer[scriptPosition + 1];
                                                                                                                                                                                              v9 = 0;
                                                                                                                                                                                            }
                                                                                                                                                                                            else
                                                                                                                                                                                            {
                                                                                                                                                                                              v8 = 0;
                                                                                                                                                                                            }
                                                                                                                                                                                            if ( source == 61 )
                                                                                                                                                                                              drawSpriteOntoSurface(6 * textColumn, 2, &RectSymbol, (signed __int32)dword_4A5AE8[0] % 4 + 30, 26);
                                                                                                                                                                                            else
                                                                                                                                                                                              drawStringOntoSurface(6 * textColumn, 0, &source, 0xFEFFFFu, (signed __int32)dword_4A5AE8[0] % 4 + 30);
                                                                                                                                                                                            strcat(&textBuffer.path[64 * ((signed __int32)dword_4A5AE8[0] % 4)], &source);
                                                                                                                                                                                            playSoundEffect(SFXMessageTyping, 1);
                                                                                                                                                                                            byte_4A5B30 = 0;
                                                                                                                                                                                            if ( source & 0x80 )
                                                                                                                                                                                            {
                                                                                                                                                                                              scriptPosition += 2;
                                                                                                                                                                                              textColumn += 2;
                                                                                                                                                                                            }
                                                                                                                                                                                            else
                                                                                                                                                                                            {
                                                                                                                                                                                              ++scriptPosition;
                                                                                                                                                                                              ++textColumn;
                                                                                                                                                                                            }
                                                                                                                                                                                            if ( textColumn >= 35 )
                                                                                                                                                                                            {
                                                                                                                                                                                              checkNewLine();
                                                                                                                                                                                              textColumn = 0;
                                                                                                                                                                                              ++dword_4A5AE8[0];
                                                                                                                                                                                              checkNewLine();
                                                                                                                                                                                            }
                                                                                                                                                                                            exitLoop = 1;
                                                                                                                                                                                          }
                                                                                                                                                                                        }
                                                                                                                                                                                        if ( scriptBuffer[scriptPosition + 1] != 'E' || scriptBuffer[scriptPosition + 2] != 'N' || scriptBuffer[scriptPosition + 3] != 'D' )
                                                                                                                                                                                          break;
                                                                                                                                                                                        byte_4A5ADC = 0;
                                                                                                                                                                                        quote.flags &= 0xFEu;
                                                                                                                                                                                        gameFlags |= 3u;
                                                                                                                                                                                        faceNumber = 0;
                                                                                                                                                                                        exitLoop = 1;
                                                                                                                                                                                      }
                                                                                                                                                                                      if ( scriptBuffer[scriptPosition + 1] != 'L' || scriptBuffer[scriptPosition + 2] != 'I' || scriptBuffer[scriptPosition + 3] != '+' )
                                                                                                                                                                                        break;
                                                                                                                                                                                      TSCArg1 = getTSCNumber(scriptPosition + 4);
                                                                                                                                                                                      addLifePlayer(TSCArg1);
                                                                                                                                                                                      scriptPosition += 8;
                                                                                                                                                                                    }
                                                                                                                                                                                    if ( scriptBuffer[scriptPosition + 1] != 'M' || scriptBuffer[scriptPosition + 2] != 'L' || scriptBuffer[scriptPosition + 3] != '+' )
                                                                                                                                                                                      break;
                                                                                                                                                                                    TSCArg3 = getTSCNumber(scriptPosition + 4);
                                                                                                                                                                                    addMaxLifePlayer(TSCArg3);
                                                                                                                                                                                    scriptPosition += 8;
                                                                                                                                                                                  }
                                                                                                                                                                                  if ( scriptBuffer[scriptPosition + 1] != 'A' || scriptBuffer[scriptPosition + 2] != 'E' || scriptBuffer[scriptPosition + 3] != '+' )
                                                                                                                                                                                    break;
                                                                                                                                                                                  fillWeaponAmmo();
                                                                                                                                                                                  scriptPosition += 4;
                                                                                                                                                                                }
                                                                                                                                                                                if ( scriptBuffer[scriptPosition + 1] != 'I' || scriptBuffer[scriptPosition + 2] != 'T' || scriptBuffer[scriptPosition + 3] != '+' )
                                                                                                                                                                                  break;
                                                                                                                                                                                TSCArg1 = getTSCNumber(scriptPosition + 4);
                                                                                                                                                                                playSoundEffect(SFXItemGet, 1);
                                                                                                                                                                                addItemData(TSCArg1);
                                                                                                                                                                                scriptPosition += 8;
                                                                                                                                                                              }
                                                                                                                                                                              if ( scriptBuffer[scriptPosition + 1] != 'I' || scriptBuffer[scriptPosition + 2] != 'T' || scriptBuffer[scriptPosition + 3] != '-' )
                                                                                                                                                                                break;
                                                                                                                                                                              TSCArg3 = getTSCNumber(scriptPosition + 4);
                                                                                                                                                                              subItemData(TSCArg3);
                                                                                                                                                                              scriptPosition += 8;
                                                                                                                                                                            }
                                                                                                                                                                            if ( scriptBuffer[scriptPosition + 1] != 'E' || scriptBuffer[scriptPosition + 2] != 'Q' || scriptBuffer[scriptPosition + 3] != '+' )
                                                                                                                                                                              break;
                                                                                                                                                                            TSCArg3 = getTSCNumber(scriptPosition + 4);
                                                                                                                                                                            equipItem(TSCArg3, 1);
                                                                                                                                                                            scriptPosition += 8;
                                                                                                                                                                          }
                                                                                                                                                                          if ( scriptBuffer[scriptPosition + 1] != 'E' || scriptBuffer[scriptPosition + 2] != 'Q' || scriptBuffer[scriptPosition + 3] != '-' )
                                                                                                                                                                            break;
                                                                                                                                                                          TSCArg3 = getTSCNumber(scriptPosition + 4);
                                                                                                                                                                          equipItem(TSCArg3, 0);
                                                                                                                                                                          scriptPosition += 8;
                                                                                                                                                                        }
                                                                                                                                                                        if ( scriptBuffer[scriptPosition + 1] != 'A' || scriptBuffer[scriptPosition + 2] != 'M' || scriptBuffer[scriptPosition + 3] != '+' )
                                                                                                                                                                          break;
                                                                                                                                                                        NPCID = getTSCNumber(scriptPosition + 4);
                                                                                                                                                                        TSCArg1 = getTSCNumber(scriptPosition + 9);
                                                                                                                                                                        numberTextScript[0] = TSCArg1;
                                                                                                                                                                        numberTextScript[1] = TSCArg3;
                                                                                                                                                                        playSoundEffect(SFXItemGet, 1);
                                                                                                                                                                        addWeapon(NPCID, TSCArg1);
                                                                                                                                                                        scriptPosition += 13;
                                                                                                                                                                      }
                                                                                                                                                                      if ( scriptBuffer[scriptPosition + 1] != 'A' || scriptBuffer[scriptPosition + 2] != 'M' || scriptBuffer[scriptPosition + 3] != '-' )
                                                                                                                                                                        break;
                                                                                                                                                                      TSCArg3 = getTSCNumber(scriptPosition + 4);
                                                                                                                                                                      loseWeapon(TSCArg3);
                                                                                                                                                                      scriptPosition += 8;
                                                                                                                                                                    }
                                                                                                                                                                    if ( scriptBuffer[scriptPosition + 1] != 'Z' || scriptBuffer[scriptPosition + 2] != 'A' || scriptBuffer[scriptPosition + 3] != 'M' )
                                                                                                                                                                      break;
                                                                                                                                                                    resetAllWeaponEXP();
                                                                                                                                                                    scriptPosition += 4;
                                                                                                                                                                  }
                                                                                                                                                                  if ( scriptBuffer[scriptPosition + 1] != 'T' || scriptBuffer[scriptPosition + 2] != 'A' || scriptBuffer[scriptPosition + 3] != 'M' )
                                                                                                                                                                    break;
                                                                                                                                                                  TSCArg1 = getTSCNumber(scriptPosition + 4);
                                                                                                                                                                  TSCArg2 = getTSCNumber(scriptPosition + 9);
                                                                                                                                                                  TSCArg3 = getTSCNumber(scriptPosition + 14);
                                                                                                                                                                  tradeWeapon(TSCArg1, TSCArg2, TSCArg3);
                                                                                                                                                                  scriptPosition += 18;
                                                                                                                                                                }
                                                                                                                                                                if ( scriptBuffer[scriptPosition + 1] != 'P' || scriptBuffer[scriptPosition + 2] != 'S' || scriptBuffer[scriptPosition + 3] != '+' )
                                                                                                                                                                  break;
                                                                                                                                                                TSCArg1 = getTSCNumber(scriptPosition + 4);
                                                                                                                                                                TSCArg2 = getTSCNumber(scriptPosition + 9);
                                                                                                                                                                addPermitStage(TSCArg1, TSCArg2);
                                                                                                                                                                scriptPosition += 13;
                                                                                                                                                              }
                                                                                                                                                              if ( scriptBuffer[scriptPosition + 1] != 'M' || scriptBuffer[scriptPosition + 2] != 'P' || scriptBuffer[scriptPosition + 3] != '+' )
                                                                                                                                                                break;
                                                                                                                                                              TSCArg1 = getTSCNumber(scriptPosition + 4);
                                                                                                                                                              setMapFlag(TSCArg1);
                                                                                                                                                              scriptPosition += 8;
                                                                                                                                                            }
                                                                                                                                                            if ( scriptBuffer[scriptPosition + 1] != 'U' || scriptBuffer[scriptPosition + 2] != 'N' || scriptBuffer[scriptPosition + 3] != 'I' )
                                                                                                                                                              break;
                                                                                                                                                            TSCArg3 = getTSCNumber(scriptPosition + 4);
                                                                                                                                                            changeUniverse(TSCArg3);
                                                                                                                                                            scriptPosition += 8;
                                                                                                                                                          }
                                                                                                                                                          if ( scriptBuffer[scriptPosition + 1] != 'S' || scriptBuffer[scriptPosition + 2] != 'T' || scriptBuffer[scriptPosition + 3] != 'C' )
                                                                                                                                                            break;
                                                                                                                                                          saveHellCounter();
                                                                                                                                                          scriptPosition += 4;
                                                                                                                                                        }
                                                                                                                                                        if ( scriptBuffer[scriptPosition + 1] != 'T' || scriptBuffer[scriptPosition + 2] != 'R' || scriptBuffer[scriptPosition + 3] != 'A' )
                                                                                                                                                          break;
                                                                                                                                                        TSCArg3 = getTSCNumber(scriptPosition + 4);
                                                                                                                                                        NPCID = getTSCNumber(scriptPosition + 9);
                                                                                                                                                        TSCArg1 = getTSCNumber(scriptPosition + 14);
                                                                                                                                                        TSCArg2 = getTSCNumber(scriptPosition + 19);
                                                                                                                                                        if ( !changeStage(TSCArg3, NPCID, TSCArg1, TSCArg2) )
                                                                                                                                                        {
                                                                                                                                                          MessageBoxA(appWinHandle, "Xe\x81[W\x8Ds", "G\x81[", 0);
                                                                                                                                                          return 0;
                                                                                                                                                        }
                                                                                                                                                      }
                                                                                                                                                      if ( scriptBuffer[scriptPosition + 1] != 'M' || scriptBuffer[scriptPosition + 2] != 'O' || scriptBuffer[scriptPosition + 3] != 'V' )
                                                                                                                                                        break;
                                                                                                                                                      TSCArg1 = getTSCNumber(scriptPosition + 4);
                                                                                                                                                      TSCArg2 = getTSCNumber(scriptPosition + 9);
                                                                                                                                                      setQuotePosition(TSCArg1 << 13, TSCArg2 << 13);
                                                                                                                                                      scriptPosition += 13;
                                                                                                                                                    }
                                                                                                                                                    if ( scriptBuffer[scriptPosition + 1] != 'H' || scriptBuffer[scriptPosition + 2] != 'M' || scriptBuffer[scriptPosition + 3] != 'C' )
                                                                                                                                                      break;
                                                                                                                                                    showHidePlayer(0);
                                                                                                                                                    scriptPosition += 4;
                                                                                                                                                  }
                                                                                                                                                  if ( scriptBuffer[scriptPosition + 1] != 'S' || scriptBuffer[scriptPosition + 2] != 'M' || scriptBuffer[scriptPosition + 3] != 'C' )
                                                                                                                                                    break;
                                                                                                                                                  showHidePlayer(1);
                                                                                                                                                  scriptPosition += 4;
                                                                                                                                                }
                                                                                                                                                if ( scriptBuffer[scriptPosition + 1] != 'F' || scriptBuffer[scriptPosition + 2] != 'L' || scriptBuffer[scriptPosition + 3] != '+' )
                                                                                                                                                  break;
                                                                                                                                                TSCArg3 = getTSCNumber(scriptPosition + 4);
                                                                                                                                                Set_NPC_Flag(TSCArg3);
                                                                                                                                                scriptPosition += 8;
                                                                                                                                              }
                                                                                                                                              if ( scriptBuffer[scriptPosition + 1] != 'F' || scriptBuffer[scriptPosition + 2] != 'L' || scriptBuffer[scriptPosition + 3] != '-' )
                                                                                                                                                break;
                                                                                                                                              TSCArg3 = getTSCNumber(scriptPosition + 4);
                                                                                                                                              unsetNPCFlag(TSCArg3);
                                                                                                                                              scriptPosition += 8;
                                                                                                                                            }
                                                                                                                                            if ( scriptBuffer[scriptPosition + 1] != 'S' || scriptBuffer[scriptPosition + 2] != 'K' || scriptBuffer[scriptPosition + 3] != '+' )
                                                                                                                                              break;
                                                                                                                                            TSCArg3 = getTSCNumber(scriptPosition + 4);
                                                                                                                                            setSkipFlag(TSCArg3);
                                                                                                                                            scriptPosition += 8;
                                                                                                                                          }
                                                                                                                                          if ( scriptBuffer[scriptPosition + 1] != 'S' || scriptBuffer[scriptPosition + 2] != 'K' || scriptBuffer[scriptPosition + 3] != '-' )
                                                                                                                                            break;
                                                                                                                                          TSCArg3 = getTSCNumber(scriptPosition + 4);
                                                                                                                                          unsetSkipFlag(TSCArg3);
                                                                                                                                          scriptPosition += 8;
                                                                                                                                        }
                                                                                                                                        if ( scriptBuffer[scriptPosition + 1] != 'K' || scriptBuffer[scriptPosition + 2] != 'E' || scriptBuffer[scriptPosition + 3] != 'Y' )
                                                                                                                                          break;
                                                                                                                                        gameFlags &= ~2u;
                                                                                                                                        gameFlags |= 1u;
                                                                                                                                        quote.isFacingUp = 0;
                                                                                                                                        quote.Invincibility_Timer = 0;
                                                                                                                                        scriptPosition += 4;
                                                                                                                                      }
                                                                                                                                      if ( scriptBuffer[scriptPosition + 1] != 'P' || scriptBuffer[scriptPosition + 2] != 'R' || scriptBuffer[scriptPosition + 3] != 'I' )
                                                                                                                                        break;
                                                                                                                                      gameFlags &= ~3u;
                                                                                                                                      quote.Invincibility_Timer = 0;
                                                                                                                                      scriptPosition += 4;
                                                                                                                                    }
                                                                                                                                    if ( scriptBuffer[scriptPosition + 1] != 'F' || scriptBuffer[scriptPosition + 2] != 'R' || scriptBuffer[scriptPosition + 3] != 'E' )
                                                                                                                                      break;
                                                                                                                                    gameFlags |= 3u;
                                                                                                                                    scriptPosition += 4;
                                                                                                                                  }
                                                                                                                                  if ( scriptBuffer[scriptPosition + 1] != 'N' || scriptBuffer[scriptPosition + 2] != 'O' || scriptBuffer[scriptPosition + 3] != 'D' )
                                                                                                                                    break;
                                                                                                                                  byte_4A5ADC = 2;
                                                                                                                                  scriptPosition += 4;
                                                                                                                                  exitLoop = 1;
                                                                                                                                }
                                                                                                                                if ( scriptBuffer[scriptPosition + 1] != 'C' || scriptBuffer[scriptPosition + 2] != 'L' || scriptBuffer[scriptPosition + 3] != 'R' )
                                                                                                                                  break;
                                                                                                                                clearTextLine();
                                                                                                                                scriptPosition += 4;
                                                                                                                              }
                                                                                                                              if ( scriptBuffer[scriptPosition + 1] != 'M' || scriptBuffer[scriptPosition + 2] != 'S' || scriptBuffer[scriptPosition + 3] != 'G' )
                                                                                                                                break;
                                                                                                                              clearTextLine();
                                                                                                                              byte_4A5ADD |= 3u;
                                                                                                                              byte_4A5ADD &= ~0x30u;
                                                                                                                              if ( byte_4A5ADD & 0x40 )
                                                                                                                                byte_4A5ADD |= 0x10u;
                                                                                                                              scriptPosition += 4;
                                                                                                                              exitLoop = 1;
                                                                                                                            }
                                                                                                                            if ( scriptBuffer[scriptPosition + 1] != 'M' || scriptBuffer[scriptPosition + 2] != 'S' || scriptBuffer[scriptPosition + 3] != '2' )
                                                                                                                              break;
                                                                                                                            clearTextLine();
                                                                                                                            byte_4A5ADD &= 0xEDu;
                                                                                                                            byte_4A5ADD |= 0x21u;
                                                                                                                            if ( byte_4A5ADD & 0x40 )
                                                                                                                              byte_4A5ADD |= 0x10u;
                                                                                                                            faceNumber = 0;
                                                                                                                            scriptPosition += 4;
                                                                                                                            exitLoop = 1;
                                                                                                                          }
                                                                                                                          if ( scriptBuffer[scriptPosition + 1] != 'M' || scriptBuffer[scriptPosition + 2] != 'S' || scriptBuffer[scriptPosition + 3] != '3' )
                                                                                                                            break;
                                                                                                                          clearTextLine();
                                                                                                                          byte_4A5ADD &= 0xEFu;
                                                                                                                          byte_4A5ADD |= 0x23u;
                                                                                                                          if ( byte_4A5ADD & 0x40 )
                                                                                                                            byte_4A5ADD |= 0x10u;
                                                                                                                          scriptPosition += 4;
                                                                                                                          exitLoop = 1;
                                                                                                                        }
                                                                                                                        if ( scriptBuffer[scriptPosition + 1] != 'W' || scriptBuffer[scriptPosition + 2] != 'A' || scriptBuffer[scriptPosition + 3] != 'I' )
                                                                                                                          break;
                                                                                                                        byte_4A5ADC = 4;
                                                                                                                        dword_4A5B00 = getTSCNumber(scriptPosition + 4);
                                                                                                                        scriptPosition += 8;
                                                                                                                        exitLoop = 1;
                                                                                                                      }
                                                                                                                      if ( scriptBuffer[scriptPosition + 1] != 'W' || scriptBuffer[scriptPosition + 2] != 'A' || scriptBuffer[scriptPosition + 3] != 83 )
                                                                                                                        break;
                                                                                                                      byte_4A5ADC = 7;
                                                                                                                      scriptPosition += 4;
                                                                                                                      exitLoop = 1;
                                                                                                                    }
                                                                                                                    if ( scriptBuffer[scriptPosition + 1] != 'T' || scriptBuffer[scriptPosition + 2] != 'U' || scriptBuffer[scriptPosition + 3] != 'R' )
                                                                                                                      break;
                                                                                                                    scriptPosition += 4;
                                                                                                                    byte_4A5ADD |= 0x10u;
                                                                                                                  }
                                                                                                                  if ( scriptBuffer[scriptPosition + 1] != 'S' || scriptBuffer[scriptPosition + 2] != 'A' || scriptBuffer[scriptPosition + 3] != 'T' )
                                                                                                                    break;
                                                                                                                  scriptPosition += 4;
                                                                                                                  byte_4A5ADD |= 0x40u;
                                                                                                                }
                                                                                                                if ( scriptBuffer[scriptPosition + 1] != 'C' || scriptBuffer[scriptPosition + 2] != 'A' || scriptBuffer[scriptPosition + 3] != 'T' )
                                                                                                                  break;
                                                                                                                scriptPosition += 4;
                                                                                                                byte_4A5ADD |= 0x40u;
                                                                                                              }
                                                                                                              if ( scriptBuffer[scriptPosition + 1] != 'C' || scriptBuffer[scriptPosition + 2] != 'L' || scriptBuffer[scriptPosition + 3] != 'O' )
                                                                                                                break;
                                                                                                              byte_4A5ADD &= 0xCCu;
                                                                                                              scriptPosition += 4;
                                                                                                            }
                                                                                                            if ( scriptBuffer[scriptPosition + 1] != 'E' || scriptBuffer[scriptPosition + 2] != 'V' || scriptBuffer[scriptPosition + 3] != 'E' )
                                                                                                              break;
                                                                                                            TSCArg3 = getTSCNumber(scriptPosition + 4);
                                                                                                            changeEvent(TSCArg3);
                                                                                                          }
                                                                                                          if ( scriptBuffer[scriptPosition + 1] != 'Y' || scriptBuffer[scriptPosition + 2] != 'N' || scriptBuffer[scriptPosition + 3] != 'J' )
                                                                                                            break;
                                                                                                          dword_4A5B04 = getTSCNumber(scriptPosition + 4);
                                                                                                          scriptPosition += 8;
                                                                                                          byte_4A5ADC = 6;
                                                                                                          playSoundEffect(SFXYNPrompt, 1);
                                                                                                          dword_4A5AFC = 0;
                                                                                                          byte_4A5B08 = 0;
                                                                                                          exitLoop = 1;
                                                                                                        }
                                                                                                        if ( scriptBuffer[scriptPosition + 1] != 'F' || scriptBuffer[scriptPosition + 2] != 'L' || scriptBuffer[scriptPosition + 3] != 'J' )
                                                                                                          break;
                                                                                                        TSCArg1 = getTSCNumber(scriptPosition + 4);
                                                                                                        TSCArg3 = getTSCNumber(scriptPosition + 9);
                                                                                                        if ( getNPCFlag(TSCArg1) )
                                                                                                          changeEvent(TSCArg3);
                                                                                                        else
                                                                                                          scriptPosition += 13;
                                                                                                      }
                                                                                                      if ( scriptBuffer[scriptPosition + 1] != 'S' || scriptBuffer[scriptPosition + 2] != 'K' || scriptBuffer[scriptPosition + 3] != 'J' )
                                                                                                        break;
                                                                                                      TSCArg1 = getTSCNumber(scriptPosition + 4);
                                                                                                      TSCArg3 = getTSCNumber(scriptPosition + 9);
                                                                                                      if ( getSkipFlag(TSCArg1) )
                                                                                                        changeEvent(TSCArg3);
                                                                                                      else
                                                                                                        scriptPosition += 13;
                                                                                                    }
                                                                                                    if ( scriptBuffer[scriptPosition + 1] != 'I' || scriptBuffer[scriptPosition + 2] != 'T' || scriptBuffer[scriptPosition + 3] != 'J' )
                                                                                                      break;
                                                                                                    TSCArg1 = getTSCNumber(scriptPosition + 4);
                                                                                                    TSCArg3 = getTSCNumber(scriptPosition + 9);
                                                                                                    if ( checkForItem(TSCArg1) )
                                                                                                      changeEvent(TSCArg3);
                                                                                                    else
                                                                                                      scriptPosition += 13;
                                                                                                  }
                                                                                                  if ( scriptBuffer[scriptPosition + 1] != 'A' || scriptBuffer[scriptPosition + 2] != 'M' || scriptBuffer[scriptPosition + 3] != 'J' )
                                                                                                    break;
                                                                                                  TSCArg1 = getTSCNumber(scriptPosition + 4);
                                                                                                  TSCArg3 = getTSCNumber(scriptPosition + 9);
                                                                                                  if ( checkForWeapon(TSCArg1) )
                                                                                                    changeEvent(TSCArg3);
                                                                                                  else
                                                                                                    scriptPosition += 13;
                                                                                                }
                                                                                                if ( scriptBuffer[scriptPosition + 1] != 'U' || scriptBuffer[scriptPosition + 2] != 'N' || scriptBuffer[scriptPosition + 3] != 'J' )
                                                                                                  break;
                                                                                                TSCArg1 = getTSCNumber(scriptPosition + 4);
                                                                                                TSCArg3 = getTSCNumber(scriptPosition + 9);
                                                                                                if ( isInFishBattle() == TSCArg1 )
                                                                                                  changeEvent(TSCArg3);
                                                                                                else
                                                                                                  scriptPosition += 13;
                                                                                              }
                                                                                              if ( scriptBuffer[scriptPosition + 1] != 'E'
                                                                                                || scriptBuffer[scriptPosition + 2] != 'C'
                                                                                                || scriptBuffer[scriptPosition + 3] != 'J' )
                                                                                              {
                                                                                                break;
                                                                                              }
                                                                                              TSCArg1 = getTSCNumber(scriptPosition + 4);
                                                                                              TSCArg3 = getTSCNumber(scriptPosition + 9);
                                                                                              if ( checkNPCAlive(TSCArg1) )
                                                                                                changeEvent(TSCArg3);
                                                                                              else
                                                                                                scriptPosition += 13;
                                                                                            }
                                                                                            if ( scriptBuffer[scriptPosition + 1] != 'N'
                                                                                              || scriptBuffer[scriptPosition + 2] != 'C'
                                                                                              || scriptBuffer[scriptPosition + 3] != 'J' )
                                                                                            {
                                                                                              break;
                                                                                            }
                                                                                            TSCArg1 = getTSCNumber(scriptPosition + 4);
                                                                                            TSCArg3 = getTSCNumber(scriptPosition + 9);
                                                                                            if ( isNPCType(TSCArg1) )
                                                                                              changeEvent(TSCArg3);
                                                                                            else
                                                                                              scriptPosition += 13;
                                                                                          }
                                                                                          if ( scriptBuffer[scriptPosition + 1] != 'M'
                                                                                            || scriptBuffer[scriptPosition + 2] != 'P'
                                                                                            || scriptBuffer[scriptPosition + 3] != 'J' )
                                                                                          {
                                                                                            break;
                                                                                          }
                                                                                          TSCArg1 = getTSCNumber(scriptPosition + 4);
                                                                                          if ( checkMapFlag() )
                                                                                            changeEvent(TSCArg1);
                                                                                          else
                                                                                            scriptPosition += 8;
                                                                                        }
                                                                                        if ( scriptBuffer[scriptPosition + 1] != 'S'
                                                                                          || scriptBuffer[scriptPosition + 2] != 'S'
                                                                                          || scriptBuffer[scriptPosition + 3] != 'S' )
                                                                                        {
                                                                                          break;
                                                                                        }
                                                                                        TSCArg1 = getTSCNumber(scriptPosition + 4);
                                                                                        setNoise(1, TSCArg1);
                                                                                        scriptPosition += 8;
                                                                                      }
                                                                                      if ( scriptBuffer[scriptPosition + 1] != 'C'
                                                                                        || scriptBuffer[scriptPosition + 2] != 'S'
                                                                                        || scriptBuffer[scriptPosition + 3] != 'S' )
                                                                                      {
                                                                                        break;
                                                                                      }
                                                                                      cutNoise();
                                                                                      scriptPosition += 4;
                                                                                    }
                                                                                    if ( scriptBuffer[scriptPosition + 1] != 'S'
                                                                                      || scriptBuffer[scriptPosition + 2] != 'P'
                                                                                      || scriptBuffer[scriptPosition + 3] != 'S' )
                                                                                    {
                                                                                      break;
                                                                                    }
                                                                                    setNoise(2, TSCArg1);
                                                                                    scriptPosition += 4;
                                                                                  }
                                                                                  if ( scriptBuffer[scriptPosition + 1] != 'C'
                                                                                    || scriptBuffer[scriptPosition + 2] != 'P'
                                                                                    || scriptBuffer[scriptPosition + 3] != 'S' )
                                                                                  {
                                                                                    break;
                                                                                  }
                                                                                  cutNoise();
                                                                                  scriptPosition += 4;
                                                                                }
                                                                                if ( scriptBuffer[scriptPosition + 1] != 'Q'
                                                                                  || scriptBuffer[scriptPosition + 2] != 'U'
                                                                                  || scriptBuffer[scriptPosition + 3] != 'A' )
                                                                                {
                                                                                  break;
                                                                                }
                                                                                TSCArg3 = getTSCNumber(scriptPosition + 4);
                                                                                setQuake(TSCArg3);
                                                                                scriptPosition += 8;
                                                                              }
                                                                              if ( scriptBuffer[scriptPosition + 1] != 'F'
                                                                                || scriptBuffer[scriptPosition + 2] != 'L'
                                                                                || scriptBuffer[scriptPosition + 3] != 'A' )
                                                                              {
                                                                                break;
                                                                              }
                                                                              startFlash(0, 0, 2);
                                                                              scriptPosition += 4;
                                                                            }
                                                                            if ( scriptBuffer[scriptPosition + 1] != 'F'
                                                                              || scriptBuffer[scriptPosition + 2] != 'A'
                                                                              || scriptBuffer[scriptPosition + 3] != 'I' )
                                                                            {
                                                                              break;
                                                                            }
                                                                            TSCArg3 = getTSCNumber(scriptPosition + 4);
                                                                            startFadeIn(TSCArg3);
                                                                            byte_4A5ADC = 5;
                                                                            scriptPosition += 8;
                                                                            exitLoop = 1;
                                                                          }
                                                                          if ( scriptBuffer[scriptPosition + 1] != 'F'
                                                                            || scriptBuffer[scriptPosition + 2] != 'A'
                                                                            || scriptBuffer[scriptPosition + 3] != 'O' )
                                                                          {
                                                                            break;
                                                                          }
                                                                          TSCArg3 = getTSCNumber(scriptPosition + 4);
                                                                          startFadeOut(TSCArg3);
                                                                          byte_4A5ADC = 5;
                                                                          scriptPosition += 8;
                                                                          exitLoop = 1;
                                                                        }
                                                                        if ( scriptBuffer[scriptPosition + 1] != 'M'
                                                                          || scriptBuffer[scriptPosition + 2] != 'N'
                                                                          || scriptBuffer[scriptPosition + 3] != 'A' )
                                                                        {
                                                                          break;
                                                                        }
                                                                        startMapName();
                                                                        scriptPosition += 4;
                                                                      }
                                                                      if ( scriptBuffer[scriptPosition + 1] != 'F'
                                                                        || scriptBuffer[scriptPosition + 2] != 'O'
                                                                        || scriptBuffer[scriptPosition + 3] != 'M' )
                                                                      {
                                                                        break;
                                                                      }
                                                                      TSCArg3 = getTSCNumber(scriptPosition + 4);
                                                                      setCameraTargetQuote(TSCArg3);
                                                                      scriptPosition += 8;
                                                                    }
                                                                    if ( scriptBuffer[scriptPosition + 1] != 'F'
                                                                      || scriptBuffer[scriptPosition + 2] != 'O'
                                                                      || scriptBuffer[scriptPosition + 3] != 'N' )
                                                                    {
                                                                      break;
                                                                    }
                                                                    TSCArg1 = getTSCNumber(scriptPosition + 4);
                                                                    TSCArg2 = getTSCNumber(scriptPosition + 9);
                                                                    setCameraMoveTicks(TSCArg1, TSCArg2);
                                                                    scriptPosition += 13;
                                                                  }
                                                                  if ( scriptBuffer[scriptPosition + 1] != 'F'
                                                                    || scriptBuffer[scriptPosition + 2] != 'O'
                                                                    || scriptBuffer[scriptPosition + 3] != 'B' )
                                                                  {
                                                                    break;
                                                                  }
                                                                  TSCArg1 = getTSCNumber(scriptPosition + 4);
                                                                  TSCArg2 = getTSCNumber(scriptPosition + 9);
                                                                  TSC_FOB(TSCArg1, TSCArg2);
                                                                  scriptPosition += 13;
                                                                }
                                                                if ( scriptBuffer[scriptPosition + 1] != 'S'
                                                                  || scriptBuffer[scriptPosition + 2] != 'O'
                                                                  || scriptBuffer[scriptPosition + 3] != 'U' )
                                                                {
                                                                  break;
                                                                }
                                                                TSCArg3 = getTSCNumber(scriptPosition + 4);
                                                                playSoundEffect((soundEffects)TSCArg3, 1);
                                                                scriptPosition += 8;
                                                              }
                                                              if ( scriptBuffer[scriptPosition + 1] != 'C'
                                                                || scriptBuffer[scriptPosition + 2] != 'M'
                                                                || scriptBuffer[scriptPosition + 3] != 'U' )
                                                              {
                                                                break;
                                                              }
                                                              TSCArg3 = getTSCNumber(scriptPosition + 4);
                                                              changeMusic((musics)TSCArg3);
                                                              scriptPosition += 8;
                                                            }
                                                            if ( scriptBuffer[scriptPosition + 1] != 'F'
                                                              || scriptBuffer[scriptPosition + 2] != 'M'
                                                              || scriptBuffer[scriptPosition + 3] != 'U' )
                                                            {
                                                              break;
                                                            }
                                                            fadeMusic();
                                                            scriptPosition += 4;
                                                          }
                                                          if ( scriptBuffer[scriptPosition + 1] != 'R'
                                                            || scriptBuffer[scriptPosition + 2] != 'M'
                                                            || scriptBuffer[scriptPosition + 3] != 'U' )
                                                          {
                                                            break;
                                                          }
                                                          recallMusic();
                                                          scriptPosition += 4;
                                                        }
                                                        if ( scriptBuffer[scriptPosition + 1] != 'M'
                                                          || scriptBuffer[scriptPosition + 2] != 'L'
                                                          || scriptBuffer[scriptPosition + 3] != 'P' )
                                                        {
                                                          break;
                                                        }
                                                        scriptPosition += 4;
                                                        exitLoop = 1;
                                                        gameLoopMapRet = gameLoopMap();
                                                        if ( !gameLoopMapRet )
                                                          return 0;
                                                        if ( gameLoopMapRet == 2 )
                                                          return 2;
                                                      }
                                                      if ( scriptBuffer[scriptPosition + 1] != 'S'
                                                        || scriptBuffer[scriptPosition + 2] != 'L'
                                                        || scriptBuffer[scriptPosition + 3] != 'P' )
                                                      {
                                                        break;
                                                      }
                                                      exitLoop = 1;
                                                      gameLoopStageSelectRet = gameLoopStageSelect(&TSCArg3);
                                                      if ( !gameLoopStageSelectRet )
                                                        return 0;
                                                      if ( gameLoopStageSelectRet == 2 )
                                                        return 2;
                                                      changeEvent(TSCArg3);
                                                      gameFlags &= 0xFFFFFFFC;
                                                    }
                                                    if ( scriptBuffer[scriptPosition + 1] != 'D'
                                                      || scriptBuffer[scriptPosition + 2] != 'N'
                                                      || scriptBuffer[scriptPosition + 3] != 'P' )
                                                    {
                                                      break;
                                                    }
                                                    TSCArg3 = getTSCNumber(scriptPosition + 4);
                                                    deleteNPCEvent(TSCArg3);
                                                    scriptPosition += 8;
                                                  }
                                                  if ( scriptBuffer[scriptPosition + 1] != 'D'
                                                    || scriptBuffer[scriptPosition + 2] != 'N'
                                                    || scriptBuffer[scriptPosition + 3] != 'A' )
                                                  {
                                                    break;
                                                  }
                                                  TSCArg3 = getTSCNumber(scriptPosition + 4);
                                                  killNPC(TSCArg3, 1);
                                                  scriptPosition += 8;
                                                }
                                                if ( scriptBuffer[scriptPosition + 1] != 'B'
                                                  || scriptBuffer[scriptPosition + 2] != 'O'
                                                  || scriptBuffer[scriptPosition + 3] != 'A' )
                                                {
                                                  break;
                                                }
                                                TSCArg3 = getTSCNumber(scriptPosition + 4);
                                                setBossScriptState(TSCArg3);
                                                scriptPosition += 8;
                                              }
                                              if ( scriptBuffer[scriptPosition + 1] != 'C'
                                                || scriptBuffer[scriptPosition + 2] != 'N'
                                                || scriptBuffer[scriptPosition + 3] != 'P' )
                                              {
                                                break;
                                              }
                                              TSCArg1 = getTSCNumber(scriptPosition + 4);
                                              TSCArg2 = getTSCNumber(scriptPosition + 9);
                                              TSCArg3 = getTSCNumber(scriptPosition + 14);
                                              spawnNPC(TSCArg1, TSCArg2, TSCArg3);
                                              scriptPosition += 18;
                                            }
                                            if ( scriptBuffer[scriptPosition + 1] != 'A'
                                              || scriptBuffer[scriptPosition + 2] != 'N'
                                              || scriptBuffer[scriptPosition + 3] != 'P' )
                                            {
                                              break;
                                            }
                                            TSCArg1 = getTSCNumber(scriptPosition + 4);
                                            TSCArg2 = getTSCNumber(scriptPosition + 9);
                                            TSCArg3 = getTSCNumber(scriptPosition + 14);
                                            setNPCState(TSCArg1, TSCArg2, TSCArg3);
                                            scriptPosition += 18;
                                          }
                                          if ( scriptBuffer[scriptPosition + 1] != 'I'
                                            || scriptBuffer[scriptPosition + 2] != 'N'
                                            || scriptBuffer[scriptPosition + 3] != 'P' )
                                          {
                                            break;
                                          }
                                          TSCArg1 = getTSCNumber(scriptPosition + 4);
                                          TSCArg2 = getTSCNumber(scriptPosition + 9);
                                          TSCArg3 = getTSCNumber(scriptPosition + 14);
                                          changeCheckableNPCByEvent(TSCArg1, TSCArg2, TSCArg3);
                                          scriptPosition += 18;
                                        }
                                        if ( scriptBuffer[scriptPosition + 1] != 'S'
                                          || scriptBuffer[scriptPosition + 2] != 'N'
                                          || scriptBuffer[scriptPosition + 3] != 'P' )
                                        {
                                          break;
                                        }
                                        NPCID = getTSCNumber(scriptPosition + 4);
                                        TSCArg1 = getTSCNumber(scriptPosition + 9);
                                        TSCArg2 = getTSCNumber(scriptPosition + 14);
                                        TSCArg3 = getTSCNumber(scriptPosition + 19);
                                        createNPC(
                                          (NPCNames)NPCID,
                                          TSCArg1 << 13,
                                          TSCArg2 << 13,
                                          0,
                                          0,
                                          (Directions)TSCArg3,
                                          0,
                                          256);
                                        scriptPosition += 23;
                                      }
                                      if ( scriptBuffer[scriptPosition + 1] != 'M'
                                        || scriptBuffer[scriptPosition + 2] != 'N'
                                        || scriptBuffer[scriptPosition + 3] != 'P' )
                                      {
                                        break;
                                      }
                                      NPCID = getTSCNumber(scriptPosition + 4);
                                      TSCArg1 = getTSCNumber(scriptPosition + 9);
                                      TSCArg2 = getTSCNumber(scriptPosition + 14);
                                      TSCArg3 = getTSCNumber(scriptPosition + 19);
                                      moveNPC(NPCID, TSCArg1 << 13, TSCArg2 << 13, TSCArg3);
                                      scriptPosition += 23;
                                    }
                                    if ( scriptBuffer[scriptPosition + 1] != 'S'
                                      || scriptBuffer[scriptPosition + 2] != 'M'
                                      || scriptBuffer[scriptPosition + 3] != 'P' )
                                    {
                                      break;
                                    }
                                    TSCArg1 = getTSCNumber(scriptPosition + 4);
                                    TSCArg2 = getTSCNumber(scriptPosition + 9);
                                    shiftMapParts(TSCArg1, TSCArg2);
                                    scriptPosition += 13;
                                  }
                                  if ( scriptBuffer[scriptPosition + 1] != 'C'
                                    || scriptBuffer[scriptPosition + 2] != 'M'
                                    || scriptBuffer[scriptPosition + 3] != 'P' )
                                  {
                                    break;
                                  }
                                  TSCArg1 = getTSCNumber(scriptPosition + 4);
                                  TSCArg2 = getTSCNumber(scriptPosition + 9);
                                  TSCArg3 = getTSCNumber(scriptPosition + 14);
                                  changeMapParts(TSCArg1, TSCArg2, TSCArg3);
                                  scriptPosition += 18;
                                }
                                if ( scriptBuffer[scriptPosition + 1] != 'B'
                                  || scriptBuffer[scriptPosition + 2] != 'S'
                                  || scriptBuffer[scriptPosition + 3] != 'L' )
                                {
                                  break;
                                }
                                TSCArg3 = getTSCNumber(scriptPosition + 4);
                                if ( TSCArg3 )
                                  startBossLife(TSCArg3);
                                else
                                  startBossLife2();
                                scriptPosition += 8;
                              }
                              if ( scriptBuffer[scriptPosition + 1] != 'M'
                                || scriptBuffer[scriptPosition + 2] != 'Y'
                                || scriptBuffer[scriptPosition + 3] != 'D' )
                              {
                                break;
                              }
                              TSCArg3 = getTSCNumber(scriptPosition + 4);
                              setPlayerDirection(TSCArg3);
                              scriptPosition += 8;
                            }
                            if ( scriptBuffer[scriptPosition + 1] != 'M'
                              || scriptBuffer[scriptPosition + 2] != 'Y'
                              || scriptBuffer[scriptPosition + 3] != 'B' )
                            {
                              break;
                            }
                            TSCArg3 = getTSCNumber(scriptPosition + 4);
                            backStepPlayer(TSCArg3);
                            scriptPosition += 8;
                          }
                          if ( scriptBuffer[scriptPosition + 1] != 'M'
                            || scriptBuffer[scriptPosition + 2] != 'M'
                            || scriptBuffer[scriptPosition + 3] != '0' )
                          {
                            break;
                          }
                          makeQuoteXVel0();
                          scriptPosition += 4;
                        }
                        if ( scriptBuffer[scriptPosition + 1] != 'I'
                          || scriptBuffer[scriptPosition + 2] != 'N'
                          || scriptBuffer[scriptPosition + 3] != 'I' )
                        {
                          break;
                        }
                        initialiseGame(appWinHandle);
                        scriptPosition += 4;
                      }
                      if ( scriptBuffer[scriptPosition + 1] != 'S'
                        || scriptBuffer[scriptPosition + 2] != 'V'
                        || scriptBuffer[scriptPosition + 3] != 'P' )
                      {
                        break;
                      }
                      saveProfile(0);
                      scriptPosition += 4;
                    }
                    if ( scriptBuffer[scriptPosition + 1] != 'L'
                      || scriptBuffer[scriptPosition + 2] != 'D'
                      || scriptBuffer[scriptPosition + 3] != 'P' )
                    {
                      break;
                    }
                    if ( !loadProfileDat(0) )
                      initialiseGame(appWinHandle);
                  }
                  if ( scriptBuffer[scriptPosition + 1] != 'F'
                    || scriptBuffer[scriptPosition + 2] != 'A'
                    || scriptBuffer[scriptPosition + 3] != 'C' )
                  {
                    break;
                  }
                  TSCArg3 = getTSCNumber(scriptPosition + 4);
                  if ( faceNumber != (char)TSCArg3 )
                  {
                    faceNumber = (char)TSCArg3;
                    dword_4A5B10 = 2048;
                  }
                  scriptPosition += 8;
                }
                if ( scriptBuffer[scriptPosition + 1] != 'F'
                  || scriptBuffer[scriptPosition + 2] != 'A'
                  || scriptBuffer[scriptPosition + 3] != 'C' )
                {
                  break;
                }
                TSCArg3 = getTSCNumber(scriptPosition + 4);
                if ( faceNumber != (char)TSCArg3 )
                {
                  faceNumber = (char)TSCArg3;
                  dword_4A5B10 = 2048;
                }
                scriptPosition += 8;
              }
              if ( scriptBuffer[scriptPosition + 1] != 'G'
                || scriptBuffer[scriptPosition + 2] != 'I'
                || scriptBuffer[scriptPosition + 3] != 'T' )
              {
                break;
              }
              TSCArg3 = getTSCNumber(scriptPosition + 4);
              dword_4A5B14 = TSCArg3;
              textBoxRelatedYPos = 128;
              scriptPosition += 8;
            }
            if ( scriptBuffer[scriptPosition + 1] != 'N'
              || scriptBuffer[scriptPosition + 2] != 'U'
              || scriptBuffer[scriptPosition + 3] != 'M' )
            {
              break;
            }
            TSCArg3 = getTSCNumber(scriptPosition + 4);
            printNumber(TSCArg3);
            scriptPosition += 8;
          }
          if ( scriptBuffer[scriptPosition + 1] != 'C'
            || scriptBuffer[scriptPosition + 2] != 'R'
            || scriptBuffer[scriptPosition + 3] != 'E' )
          {
            break;
          }
          gameFlags |= 8u;
          startCreditsScript();
          scriptPosition += 4;
        }
        if ( scriptBuffer[scriptPosition + 1] != 'S'
          || scriptBuffer[scriptPosition + 2] != 'I'
          || scriptBuffer[scriptPosition + 3] != 'L' )
        {
          break;
        }
        TSCArg3 = getTSCNumber(scriptPosition + 4);
        setCreditIllustration(TSCArg3);
        scriptPosition += 8;
      }
      if ( scriptBuffer[scriptPosition + 1] != 'C'
        || scriptBuffer[scriptPosition + 2] != 'I'
        || scriptBuffer[scriptPosition + 3] != 'L' )
      {
        break;
      }
      cutCreditIllustration();
      scriptPosition += 4;
    }
    if ( scriptBuffer[scriptPosition + 1] != 'X'
      || scriptBuffer[scriptPosition + 2] != 'X'
      || scriptBuffer[scriptPosition + 3] != '1' )
    {
      break;
    }
    exitLoop = 1;
    TSCArg3 = getTSCNumber(scriptPosition + 4);
    sceneDownIslandRet = sceneIslandCrash(appWinHandle, TSCArg3);
    if ( !sceneDownIslandRet )
      return 0;
    if ( sceneDownIslandRet == 2 )
      return 2;
    scriptPosition += 8;
  }
  if ( scriptBuffer[scriptPosition + 1] == 'E'
    && scriptBuffer[scriptPosition + 2] == 'S'
    && scriptBuffer[scriptPosition + 3] == 'C' )
  {
    return 2;
  }
  sprintf(
    (char *)text,
    "sR\x81[h:<%c%c%c",
    scriptBuffer[scriptPosition + 1],
    scriptBuffer[scriptPosition + 2],
    scriptBuffer[scriptPosition + 3]);
  MessageBoxA(0, text, "G\x81[", 0);
  return 0;
}
// 493628: using guessed type int keyOk;
// 49362C: using guessed type int keyCancel;
// 493630: using guessed type int keyLeft;
// 493638: using guessed type int keyRight;
// 49E1E8: using guessed type int gameFlags;
// 49E210: using guessed type int keyHeld;
// 49E214: using guessed type int keyPressed;
// 4A5ADC: using guessed type char byte_4A5ADC;
// 4A5ADD: using guessed type char byte_4A5ADD;
// 4A5AE4: using guessed type int textColumn;
// 4A5AEC: using guessed type int dword_4A5AEC[];
// 4A5AFC: using guessed type int dword_4A5AFC;
// 4A5B00: using guessed type int dword_4A5B00;
// 4A5B04: using guessed type int dword_4A5B04;
// 4A5B08: using guessed type char byte_4A5B08;
// 4A5B0C: using guessed type int faceNumber;
// 4A5B10: using guessed type int dword_4A5B10;
// 4A5B14: using guessed type int dword_4A5B14;
// 4A5B30: using guessed type char byte_4A5B30;
// 422510: using guessed type char format[72];

//----- (00425790) --------------------------------------------------------
int drawTextToTextBoxSurfaces()
{
  int result; // eax
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 4; ++i )
  {
    drawColorFillOntoSurface(&unk_498290, 0, i + 30);
    drawStringOntoSurface(0, 0, &textBuffer.path[64 * i], 0xFEFFFFu, i + 30);
    result = i + 1;
  }
  return result;
}

//----- (004257F0) --------------------------------------------------------
void initTriangleTable()
{
  sin((long double)0 * 6.2832 / 256.0);
}

//----- (004258B0) --------------------------------------------------------
int __cdecl getSin(unsigned __int8 degree)
{
  return sinTable[degree];
}
// 4A5B48: using guessed type int sinTable[];

//----- (004258C0) --------------------------------------------------------
int __cdecl getCos(unsigned __int8 deg)
{
  return sinTable[(unsigned __int8)(deg + 64)];
}
// 4A5B48: using guessed type int sinTable[];

//----- (004258E0) --------------------------------------------------------
// Returns a value in degrees
unsigned __int8 __cdecl getArcTan(int XPos, int YPos)
{
  unsigned __int8 a; // [esp+7h] [ebp-1h]
  int negXPos; // [esp+10h] [ebp+8h]
  int negYPos; // [esp+14h] [ebp+Ch]

  negXPos = -XPos;
  negYPos = -YPos;
  a = 0;
  if ( negXPos <= 0 )
  {
    if ( negYPos <= 0 )
    {
      if ( -negXPos <= -negYPos )
      {
        while ( (signed __int16)(-8192 * negXPos / -negYPos) > gTan[a] )
          ++a;
        a = -64 - a;
      }
      else
      {
        while ( (signed __int16)(-8192 * negYPos / -negXPos) > gTan[a] )
          ++a;
        a += -128;
      }
    }
    else if ( -negXPos <= negYPos )
    {
      while ( (signed __int16)(-8192 * negXPos / negYPos) > gTan[a] )
        ++a;
      a += 64;
    }
    else
    {
      while ( (signed __int16)((negYPos << 13) / -negXPos) > gTan[a] )
        ++a;
      a = -128 - a;
    }
  }
  else if ( negYPos <= 0 )
  {
    if ( negXPos <= -negYPos )
    {
      while ( (signed __int16)((negXPos << 13) / -negYPos) > gTan[a] )
        ++a;
      a -= 64;
    }
    else
    {
      while ( (signed __int16)(-8192 * negYPos / negXPos) > gTan[a] )
        ++a;
      a = -a;
    }
  }
  else if ( negXPos <= negYPos )
  {
    while ( (signed __int16)((negXPos << 13) / negYPos) > gTan[a] )
      ++a;
    a = 64 - a;
  }
  else
  {
    while ( (signed __int16)((negYPos << 13) / negXPos) > gTan[a] )
      ++a;
  }
  return a;
}
// 4A5F48: using guessed type __int16 gTan[];

//----- (00425B40) --------------------------------------------------------
// Microsoft VisualC 2-11/net runtime
void __cdecl callCallCos(float a1)
{
  callCos(a1);
}

//----- (00425B60) --------------------------------------------------------
void __cdecl callCos(float degree)
{
  cos(degree);
}

//----- (00425B80) --------------------------------------------------------
// Mcrosoft VisualC 2-11/net runtime
void __cdecl callCallSin(float a1)
{
  callSin(a1);
}

//----- (00425BA0) --------------------------------------------------------
void __cdecl callSin(float a1)
{
  sin(a1);
}

//----- (00425BC0) --------------------------------------------------------
void clearValueView(void)
{
  memset(&eventInUse, 0, 0x280u);
  eventIndex = 0;
}
// 4A5F90: using guessed type int eventIndex;

//----- (00425BF0) --------------------------------------------------------
int __cdecl setValueView(__int32 a1, __int32 a2, __int32 a3)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-19Ch]
  int v5; // [esp+4h] [ebp-198h]
  int v6; // [esp+8h] [ebp-194h]
  int v7; // [esp+Ch] [ebp-190h]
  int v8; // [esp+10h] [ebp-18Ch]
  int v9; // [esp+14h] [ebp-188h]
  int v10; // [esp+18h] [ebp-184h]
  int v11; // [esp+1Ch] [ebp-180h]
  int v12; // [esp+20h] [ebp-17Ch]
  int v13; // [esp+24h] [ebp-178h]
  int v14[4]; // [esp+28h] [ebp-174h]
  int v15; // [esp+38h] [ebp-164h]
  int v16; // [esp+3Ch] [ebp-160h]
  int i; // [esp+40h] [ebp-15Ch]
  int v18; // [esp+44h] [ebp-158h]
  int v19; // [esp+48h] [ebp-154h]
  int v20; // [esp+4Ch] [ebp-150h]
  int v21; // [esp+50h] [ebp-14Ch]
  int v22; // [esp+54h] [ebp-148h]
  int v23; // [esp+58h] [ebp-144h]
  int v24; // [esp+5Ch] [ebp-140h]
  int v25; // [esp+60h] [ebp-13Ch]
  int v26; // [esp+64h] [ebp-138h]
  int v27; // [esp+68h] [ebp-134h]
  int v28; // [esp+6Ch] [ebp-130h]
  int v29; // [esp+70h] [ebp-12Ch]
  int v30; // [esp+74h] [ebp-128h]
  int v31; // [esp+78h] [ebp-124h]
  int v32; // [esp+7Ch] [ebp-120h]
  int v33; // [esp+80h] [ebp-11Ch]
  int v34; // [esp+84h] [ebp-118h]
  int v35; // [esp+88h] [ebp-114h]
  int v36; // [esp+8Ch] [ebp-110h]
  int v37; // [esp+90h] [ebp-10Ch]
  int v38; // [esp+94h] [ebp-108h]
  int v39; // [esp+98h] [ebp-104h]
  int v40; // [esp+9Ch] [ebp-100h]
  int v41; // [esp+A0h] [ebp-FCh]
  int v42; // [esp+A4h] [ebp-F8h]
  int v43; // [esp+A8h] [ebp-F4h]
  int v44; // [esp+ACh] [ebp-F0h]
  int v45; // [esp+B0h] [ebp-ECh]
  int v46; // [esp+B4h] [ebp-E8h]
  int v47; // [esp+B8h] [ebp-E4h]
  int v48; // [esp+BCh] [ebp-E0h]
  int v49; // [esp+C0h] [ebp-DCh]
  int v50; // [esp+C4h] [ebp-D8h]
  int v51; // [esp+C8h] [ebp-D4h]
  int v52; // [esp+CCh] [ebp-D0h]
  int v53; // [esp+D0h] [ebp-CCh]
  int v54; // [esp+D4h] [ebp-C8h]
  int v55; // [esp+D8h] [ebp-C4h]
  int v56; // [esp+DCh] [ebp-C0h]
  int v57; // [esp+E0h] [ebp-BCh]
  int v58; // [esp+E4h] [ebp-B8h]
  int v59; // [esp+E8h] [ebp-B4h]
  int v60; // [esp+ECh] [ebp-B0h]
  int v61; // [esp+F0h] [ebp-ACh]
  int v62; // [esp+F4h] [ebp-A8h]
  int v63; // [esp+F8h] [ebp-A4h]
  int v64; // [esp+FCh] [ebp-A0h]
  int v65; // [esp+100h] [ebp-9Ch]
  int v66; // [esp+104h] [ebp-98h]
  int v67; // [esp+108h] [ebp-94h]
  int v68; // [esp+10Ch] [ebp-90h]
  int v69; // [esp+110h] [ebp-8Ch]
  int v70; // [esp+114h] [ebp-88h]
  int v71; // [esp+118h] [ebp-84h]
  int v72; // [esp+11Ch] [ebp-80h]
  int v73; // [esp+120h] [ebp-7Ch]
  int v74; // [esp+124h] [ebp-78h]
  int v75; // [esp+128h] [ebp-74h]
  int v76; // [esp+12Ch] [ebp-70h]
  int v77; // [esp+130h] [ebp-6Ch]
  int v78; // [esp+134h] [ebp-68h]
  int v79; // [esp+138h] [ebp-64h]
  int v80; // [esp+13Ch] [ebp-60h]
  int v81; // [esp+140h] [ebp-5Ch]
  int v82; // [esp+144h] [ebp-58h]
  int v83; // [esp+148h] [ebp-54h]
  int v84; // [esp+14Ch] [ebp-50h]
  int v85; // [esp+150h] [ebp-4Ch]
  int v86; // [esp+154h] [ebp-48h]
  int v87; // [esp+158h] [ebp-44h]
  int v88; // [esp+15Ch] [ebp-40h]
  int v89; // [esp+160h] [ebp-3Ch]
  int v90; // [esp+164h] [ebp-38h]
  int v91; // [esp+168h] [ebp-34h]
  int v92; // [esp+16Ch] [ebp-30h]
  int v93; // [esp+170h] [ebp-2Ch]
  int v94; // [esp+174h] [ebp-28h]
  int v95; // [esp+178h] [ebp-24h]
  int v96; // [esp+17Ch] [ebp-20h]
  int v97; // [esp+180h] [ebp-1Ch]
  int v98; // [esp+188h] [ebp-14h]
  int v99; // [esp+18Ch] [ebp-10h]
  int v100; // [esp+190h] [ebp-Ch]
  int v101; // [esp+194h] [ebp-8h]
  int v102; // [esp+198h] [ebp-4h]

  for ( i = 0;
        i < 16
     && (!*((_DWORD *)&eventInUse + 10 * i)
      || eventCollision[10 * i] != a1
      || (eventXVel[10 * i] >= 0 || a3 >= 0) && (eventXVel[10 * i] <= 0 || a3 <= 0));
        ++i )
  {
    ;
  }
  if ( i == 16 )
  {
    v15 = eventIndex++;
    if ( eventIndex == 16 )
      eventIndex = 0;
    eventYVel[10 * v15] = 0;
    eventYPos[10 * v15] = 0;
    eventXVel[10 * v15] = a3;
  }
  else
  {
    v15 = i;
    eventYVel[10 * i] = 32;
    eventXVel[10 * v15] += a3;
    a3 = eventXVel[10 * v15];
  }
  if ( a3 >= 0 )
  {
    v16 = 0;
  }
  else
  {
    a3 = -a3;
    v16 = 1;
  }
  v98 = a3;
  if ( a3 <= 999 )
  {
    if ( a3 <= 99 )
    {
      if ( a3 <= 9 )
        v13 = 16;
      else
        v13 = 24;
    }
    else
    {
      v13 = 32;
    }
  }
  else
  {
    v13 = 40;
  }
  *((_DWORD *)&eventInUse + 10 * v15) = 1;
  eventCollision[10 * v15] = a1;
  eventXPos[10 * v15] = a2;
  eventAltXVel[10 * v15] = 40 - v13;
  eventAltYVel[10 * v15] = 8 * v15;
  eventUnknown1[10 * v15] = 40;
  eventUnknown2[10 * v15] = 8 * v15 + 8;
  v18 = 0;
  v19 = 56;
  v20 = 8;
  v21 = 64;
  v22 = 8;
  v23 = 56;
  v24 = 16;
  v25 = 64;
  v26 = 16;
  v27 = 56;
  v28 = 24;
  v29 = 64;
  v30 = 24;
  v31 = 56;
  v32 = 32;
  v33 = 64;
  v34 = 32;
  v35 = 56;
  v36 = 40;
  v37 = 64;
  v38 = 40;
  v39 = 56;
  v40 = 48;
  v41 = 64;
  v42 = 48;
  v43 = 56;
  v44 = 56;
  v45 = 64;
  v46 = 56;
  v47 = 56;
  v48 = 64;
  v49 = 64;
  v50 = 64;
  v51 = 56;
  v52 = 72;
  v53 = 64;
  v54 = 72;
  v55 = 56;
  v56 = 80;
  v57 = 64;
  v58 = 0;
  v59 = 64;
  v60 = 8;
  v61 = 72;
  v62 = 8;
  v63 = 64;
  v64 = 16;
  v65 = 72;
  v66 = 16;
  v67 = 64;
  v68 = 24;
  v69 = 72;
  v70 = 24;
  v71 = 64;
  v72 = 32;
  v73 = 72;
  v74 = 32;
  v75 = 64;
  v76 = 40;
  v77 = 72;
  v78 = 40;
  v79 = 64;
  v80 = 48;
  v81 = 72;
  v82 = 48;
  v83 = 64;
  v84 = 56;
  v85 = 72;
  v86 = 56;
  v87 = 64;
  v88 = 64;
  v89 = 72;
  v90 = 64;
  v91 = 64;
  v92 = 72;
  v93 = 72;
  v94 = 72;
  v95 = 64;
  v96 = 80;
  v97 = 72;
  v99 = 1;
  v100 = 10;
  v101 = 100;
  v102 = 1000;
  for ( i = 3; i >= 0; --i )
  {
    v14[i] = 0;
    while ( v98 >= *(&v99 + i) )
    {
      v98 -= *(&v99 + i);
      ++v14[i];
    }
  }
  v12 = 0;
  v8 = 32;
  v9 = 48;
  v10 = 40;
  v11 = 56;
  v4 = 40;
  v5 = 48;
  v6 = 48;
  v7 = 56;
  drawColorFillOntoSurface((RECT *)&eventAltXVel[10 * v15], 0, 29);
  if ( v16 )
    result = drawSpriteOntoSurface(eventAltXVel[10 * v15], eventAltYVel[10 * v15], (RECT *)&v4, 29, 26);
  else
    result = drawSpriteOntoSurface(eventAltXVel[10 * v15], eventAltYVel[10 * v15], (RECT *)&v8, 29, 26);
  for ( i = 3; i >= 0; --i )
  {
    if ( v12 || !i || v14[i] )
    {
      v12 = 1;
      if ( v16 )
        v14[i] += 10;
      drawSpriteOntoSurface(8 * (3 - i) + 8, eventAltYVel[10 * v15], (RECT *)&v18 + v14[i], 29, 26);
    }
    result = i - 1;
  }
  return result;
}
// 4A5F90: using guessed type int eventIndex;
// 4A5F9C: using guessed type int eventCollision[];
// 4A5FA0: using guessed type int eventXPos[];
// 4A5FA4: using guessed type int eventYPos[];
// 4A5FA8: using guessed type int eventXVel[];
// 4A5FAC: using guessed type int eventYVel[];
// 4A5FB0: using guessed type int eventAltXVel[];
// 4A5FB4: using guessed type int eventAltYVel[];
// 4A5FB8: using guessed type int eventUnknown1[];
// 4A5FBC: using guessed type int eventUnknown2[];
// 425BF0: using guessed type int var_174[4];

//----- (00426360) --------------------------------------------------------
int actValueView()
{
  int result; // eax
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 16; ++i )
  {
    if ( *((_DWORD *)&eventInUse + 10 * i) )
    {
      if ( ++eventYVel[10 * i] < 32 )
        eventYPos[10 * i] -= 256;
      if ( eventYVel[10 * i] > 72 )
        ++eventAltYVel[10 * i];
      if ( eventYVel[10 * i] > 80 )
        *((_DWORD *)&eventInUse + 10 * i) = 0;
    }
    result = i + 1;
  }
  return result;
}
// 4A5FA4: using guessed type int eventYPos[];
// 4A5FAC: using guessed type int eventYVel[];
// 4A5FB4: using guessed type int eventAltYVel[];

//----- (00426430) --------------------------------------------------------
int __cdecl putValueView(int cameraXPos, int cameraYPos)
{
  int result; // eax
  signed int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i < 16; ++i )
  {
    if ( *((_DWORD *)&eventInUse + 10 * i) )
      drawBitmapWithTransparency(
        &gameRect,
        *(_DWORD *)eventCollision[10 * i] / 512 - (eventUnknown1[10 * i] - eventAltXVel[10 * i]) / 2 - cameraXPos / 512,
        *(_DWORD *)eventXPos[10 * i] / 512 + eventYPos[10 * i] / 512 - 4 - cameraYPos / 512,
        (RECT *)&eventAltXVel[10 * i],
        29);
    result = i + 1;
  }
  return result;
}
// 4A5F9C: using guessed type int eventCollision[];
// 4A5FA0: using guessed type int eventXPos[];
// 4A5FA4: using guessed type int eventYPos[];
// 4A5FB0: using guessed type int eventAltXVel[];
// 4A5FB8: using guessed type int eventUnknown1[];

//----- (00426530) --------------------------------------------------------
// NPC 0 : Nothing.
// This NPC does basically nothing.
void __cdecl NPC0_Nothing(NPC *npc)
{
  RECT *npc_Rect; // eax

  if ( !npc->currentState )
  {
    npc->currentState = 1;
    if ( npc->direction == right )
      npc->YPos += 0x2000;                      // If NPC facing right, make it 1 block lower
  }
  npc_Rect = &npc->rect;
  npc_Rect->left = 0;
  npc_Rect->top = 0;
  npc_Rect->right = 16;
  npc_Rect->bottom = 16;
}

//----- (004265B0) --------------------------------------------------------
// NPC 1 : Weapon Energy
// Gives you EXP
void __cdecl NPC1_WeaponEnergy(NPC *npc)
{
  int v1; // edx
  RECT *npc_Rect; // eax
  int npx_Exp_Amount; // [esp+0h] [ebp-74h]
  RECT Rects[6]; // [esp+14h] [ebp-60h]

  if ( currentBackground.mode != 5 && currentBackground.mode != 6 )
  {
    if ( !npc->currentState )                   // If uninitialised
    {
      npc->currentState = 1;
      npc->animationNumber = random(0, 4);
      npc->XVel = random(-512, 512);
      npc->YVel = random(-1024, 0);
      if ( random(0, 1) )                       // Direction is random
        npc->direction = 0;
      else
        npc->direction = 2;
    }
    if ( npc->collisionFlags & 0x100 )
      v1 = npc->YVel + 21;
    else
      v1 = npc->YVel + 42;
    npc->YVel = v1;
    if ( npc->collisionFlags & 1 && npc->XVel < 0 )
      npc->XVel = -npc->XVel;
    if ( npc->collisionFlags & 4 && npc->XVel > 0 )
      npc->XVel = -npc->XVel;
    if ( npc->collisionFlags & 2 && npc->YVel < 0 )
      npc->YVel = -npc->YVel;
    if ( npc->collisionFlags & 8 )
    {
      playSoundEffect(SFXEXPBounce, 1);
      npc->YVel = -640;
      npc->XVel = 2 * npc->XVel / 3;
    }
    if ( npc->collisionFlags & 0xD )
    {
      playSoundEffect(SFXEXPBounce, 1);
      if ( ++npc->count2 > 2 )
        npc->YPos -= 512;
    }
    else
    {
      npc->count2 = 0;
    }
    if ( npc->XVel < -1535 )
      npc->XVel = -1535;
    if ( npc->XVel > 1535 )
      npc->XVel = 1535;
    if ( npc->YVel < -1535 )
      npc->YVel = -1535;
    if ( npc->YVel > 1535 )
      npc->YVel = 1535;
  }
  else
  {
    if ( !npc->currentState )
    {
      npc->currentState = 1;
      npc->YVel = random(-128, 128);
      npc->XVel = random(127, 256);
    }
    npc->XVel -= 8;
    if ( npc->XPos < 40960 )
      npc->isAlive = 0;
    if ( npc->XPos < -1536 )
      npc->XPos = -1536;
    if ( npc->collisionFlags & 1 )
      npc->XVel = 256;
    if ( npc->collisionFlags & 2 )
      npc->YVel = 64;
    if ( npc->collisionFlags & 8 )
      npc->YVel = -64;
  }
  npc->YPos += npc->YVel;
  npc->XPos += npc->XVel;
  Rects[0].left = 0;
  Rects[0].top = 16;
  Rects[0].right = 16;
  Rects[0].bottom = 32;
  Rects[1].left = 16;
  Rects[1].top = 16;
  Rects[1].right = 32;
  Rects[1].bottom = 32;
  Rects[2].left = 32;
  Rects[2].top = 16;
  Rects[2].right = 48;
  Rects[2].bottom = 32;
  Rects[3].left = 48;
  Rects[3].top = 16;
  Rects[3].right = 64;
  Rects[3].bottom = 32;
  Rects[4].left = 64;
  Rects[4].top = 16;
  Rects[4].right = 80;
  Rects[4].bottom = 32;
  Rects[5].left = 80;
  Rects[5].top = 16;
  Rects[5].right = 96;
  Rects[5].bottom = 32;
  ++npc->animationTimer;
  if ( npc->direction )
  {
    if ( npc->animationTimer > 2 )
    {
      npc->animationTimer = 0;
      if ( --npc->animationNumber < 0 )
        npc->animationNumber = 5;
    }
  }
  else if ( npc->animationTimer > 2 )
  {
    npc->animationTimer = 0;
    if ( ++npc->animationNumber > 5 )
      npc->animationNumber = 0;
  }
  npc->rect = Rects[npc->animationNumber];
  if ( npc->currentState )
  {
    npx_Exp_Amount = npc->EXPAmount;
    if ( npx_Exp_Amount == 5 )
    {
      npc->rect.top += 16;
      npc->rect.bottom += 16;
    }
    else if ( npx_Exp_Amount == 20 )
    {
      npc->rect.top += 32;
      npc->rect.bottom += 32;
    }
    npc->currentState = 1;
  }
  if ( ++npc->count1 > 500 && npc->animationNumber == 5 && npc->animationTimer == 2 )
    npc->isAlive = 0;
  if ( npc->count1 > 400 )
  {
    if ( npc->count1 / 2 % 2 )
    {
      npc_Rect = &npc->rect;
      npc_Rect->left = 0;
      npc_Rect->top = 0;
      npc_Rect->right = 0;
      npc_Rect->bottom = 0;
    }
  }
}

//----- (00426AF0) --------------------------------------------------------
// NPC 2 : Behemoth (Enemy)
// Appears in the Egg Corridor.
void __cdecl NPC2_EnemyBehemoth(NPC *npc)
{
  RECT *Chosen_Rect; // eax
  int npc_Current_State; // [esp+0h] [ebp-E4h]
  RECT Rects_Right[7]; // [esp+4h] [ebp-E0h]
  RECT Rects_Left[7]; // [esp+74h] [ebp-70h]

  Rects_Left[0].left = 32;
  Rects_Left[0].top = 0;
  Rects_Left[0].right = 64;
  Rects_Left[0].bottom = 24;
  Rects_Left[1].left = 0;
  Rects_Left[1].top = 0;
  Rects_Left[1].right = 32;
  Rects_Left[1].bottom = 24;
  Rects_Left[2].left = 32;
  Rects_Left[2].top = 0;
  Rects_Left[2].right = 64;
  Rects_Left[2].bottom = 24;
  Rects_Left[3].left = 64;
  Rects_Left[3].top = 0;
  Rects_Left[3].right = 96;
  Rects_Left[3].bottom = 24;
  Rects_Left[4].left = 96;
  Rects_Left[4].top = 0;
  Rects_Left[4].right = 128;
  Rects_Left[4].bottom = 24;
  Rects_Left[5].left = 128;
  Rects_Left[5].top = 0;
  Rects_Left[5].right = 160;
  Rects_Left[5].bottom = 24;
  Rects_Left[6].left = 160;
  Rects_Left[6].top = 0;
  Rects_Left[6].right = 192;
  Rects_Left[6].bottom = 24;
  Rects_Right[0].left = 32;
  Rects_Right[0].top = 24;
  Rects_Right[0].right = 64;
  Rects_Right[0].bottom = 48;
  Rects_Right[1].left = 0;
  Rects_Right[1].top = 24;
  Rects_Right[1].right = 32;
  Rects_Right[1].bottom = 48;
  Rects_Right[2].left = 32;
  Rects_Right[2].top = 24;
  Rects_Right[2].right = 64;
  Rects_Right[2].bottom = 48;
  Rects_Right[3].left = 64;
  Rects_Right[3].top = 24;
  Rects_Right[3].right = 96;
  Rects_Right[3].bottom = 48;
  Rects_Right[4].left = 96;
  Rects_Right[4].top = 24;
  Rects_Right[4].right = 128;
  Rects_Right[4].bottom = 48;
  Rects_Right[5].left = 128;
  Rects_Right[5].top = 24;
  Rects_Right[5].right = 160;
  Rects_Right[5].bottom = 48;
  Rects_Right[6].left = 160;
  Rects_Right[6].top = 24;
  Rects_Right[6].right = 192;
  Rects_Right[6].bottom = 48;
  if ( npc->collisionFlags & 1 )
  {
    npc->direction = 2;
  }
  else if ( npc->collisionFlags & 4 )
  {
    npc->direction = 0;
  }
  npc_Current_State = npc->currentState;
  if ( npc_Current_State )
  {
    if ( npc_Current_State == 1 )
    {
      npc->XVel = 7 * npc->XVel / 8;
      if ( ++npc->count1 > 40 )
      {
        if ( npc->isBeingHit )
        {
          npc->count1 = 0;
          npc->currentState = 2;
          npc->animationNumber = 6;
          npc->animationTimer = 0;
          npc->damage = 5;
        }
        else
        {
          npc->currentState = 0;
          npc->animationTimer = 0;
        }
      }
    }
    else if ( npc_Current_State == 2 )
    {
      if ( npc->direction )
        npc->XVel = 1024;
      else
        npc->XVel = -1024;
      if ( ++npc->count1 > 200 )
      {
        npc->currentState = 0;
        npc->damage = 1;
      }
      if ( ++npc->animationTimer > 5 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 6 )
      {
        npc->animationNumber = 5;
        playSoundEffect(SFXLargeObjectHitGround, 1);
        createNPC(NPCSmoke, npc->XPos, npc->YPos + 1536, 0, 0, 0, 0, 256);
        setQuake(8);
      }
    }
  }
  else
  {
    if ( npc->direction )
      npc->XVel = 256;
    else
      npc->XVel = -256;
    if ( ++npc->animationTimer > 8 )
    {
      npc->animationTimer = 0;
      ++npc->animationNumber;
    }
    if ( npc->animationNumber > 3 )
      npc->animationNumber = 0;
    if ( npc->isBeingHit )
    {
      npc->count1 = 0;
      npc->currentState = 1;
      npc->animationNumber = 4;
    }
  }
  npc->YVel += 64;
  if ( npc->YVel > 1535 )
    npc->YVel = 1535;
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  if ( npc->direction )
    Chosen_Rect = &Rects_Right[npc->animationNumber];
  else
    Chosen_Rect = &Rects_Left[npc->animationNumber];
  npc->rect = *Chosen_Rect;
}

//----- (00426FD0) --------------------------------------------------------
// NPC 3 : Nothing?
// This NPC deletes itself
void __cdecl NPC3_DeletesItself(NPC *npc)
{
  RECT *npc_Rect; // edx

  if ( ++npc->count1 > 100 )
    npc->isAlive = 0;
  npc_Rect = &npc->rect;
  npc_Rect->left = 0;
  npc_Rect->top = 0;
  npc_Rect->right = 0;
  npc_Rect->bottom = 0;
}

//----- (00427040) --------------------------------------------------------
// NPC 4 : Smoke
// This NPC simply is smoke.
void __cdecl NPC4_Smoke(NPC *npc)
{
  int v1; // esi
  int v2; // esi
  RECT Rects_Left_Right[8]; // [esp+0h] [ebp-108h]
  RECT Rects_Up[8]; // [esp+80h] [ebp-88h]
  unsigned __int8 v5; // [esp+107h] [ebp-1h]

  Rects_Left_Right[0].left = 16;
  Rects_Left_Right[0].top = 0;
  Rects_Left_Right[0].right = 17;
  Rects_Left_Right[0].bottom = 1;
  Rects_Left_Right[1].left = 16;
  Rects_Left_Right[1].top = 0;
  Rects_Left_Right[1].right = 32;
  Rects_Left_Right[1].bottom = 16;
  Rects_Left_Right[2].left = 32;
  Rects_Left_Right[2].top = 0;
  Rects_Left_Right[2].right = 48;
  Rects_Left_Right[2].bottom = 16;
  Rects_Left_Right[3].left = 48;
  Rects_Left_Right[3].top = 0;
  Rects_Left_Right[3].right = 64;
  Rects_Left_Right[3].bottom = 16;
  Rects_Left_Right[4].left = 64;
  Rects_Left_Right[4].top = 0;
  Rects_Left_Right[4].right = 80;
  Rects_Left_Right[4].bottom = 16;
  Rects_Left_Right[5].left = 80;
  Rects_Left_Right[5].top = 0;
  Rects_Left_Right[5].right = 96;
  Rects_Left_Right[5].bottom = 16;
  Rects_Left_Right[6].left = 96;
  Rects_Left_Right[6].top = 0;
  Rects_Left_Right[6].right = 112;
  Rects_Left_Right[6].bottom = 16;
  Rects_Left_Right[7].left = 112;
  Rects_Left_Right[7].top = 0;
  Rects_Left_Right[7].right = 128;
  Rects_Left_Right[7].bottom = 16;
  Rects_Up[0].left = 16;
  Rects_Up[0].top = 0;
  Rects_Up[0].right = 17;
  Rects_Up[0].bottom = 1;
  Rects_Up[1].left = 80;
  Rects_Up[1].top = 48;
  Rects_Up[1].right = 96;
  Rects_Up[1].bottom = 64;
  Rects_Up[2].left = 0;
  Rects_Up[2].top = 128;
  Rects_Up[2].right = 16;
  Rects_Up[2].bottom = 144;
  Rects_Up[3].left = 16;
  Rects_Up[3].top = 128;
  Rects_Up[3].right = 32;
  Rects_Up[3].bottom = 144;
  Rects_Up[4].left = 32;
  Rects_Up[4].top = 128;
  Rects_Up[4].right = 48;
  Rects_Up[4].bottom = 144;
  Rects_Up[5].left = 48;
  Rects_Up[5].top = 128;
  Rects_Up[5].right = 64;
  Rects_Up[5].bottom = 144;
  Rects_Up[6].left = 64;
  Rects_Up[6].top = 128;
  Rects_Up[6].right = 80;
  Rects_Up[6].bottom = 144;
  Rects_Up[7].left = 80;
  Rects_Up[7].top = 128;
  Rects_Up[7].right = 96;
  Rects_Up[7].bottom = 144;
  if ( npc->currentState )
  {
    npc->XVel = 20 * npc->XVel / 21;
    npc->YVel = 20 * npc->YVel / 21;
    npc->XPos += npc->XVel;
    npc->YPos += npc->YVel;
  }
  else
  {
    if ( !npc->direction || npc->direction == 1 )
    {
      v5 = random(0, 255);
      v1 = getCos(v5);
      npc->XVel = v1 * random(512, 1535) / 512;
      v2 = getSin(v5);
      npc->YVel = v2 * random(512, 1535) / 512;
    }
    npc->animationNumber = random(0, 4);
    npc->animationTimer = random(0, 3);
    npc->currentState = 1;
  }
  if ( ++npc->animationTimer > 4 )
  {
    npc->animationTimer = 0;
    ++npc->animationNumber;
  }
  if ( npc->animationNumber <= 7 )
  {
    if ( npc->direction == up )
      npc->rect = Rects_Up[npc->animationNumber];
    if ( !npc->direction )
      npc->rect = Rects_Left_Right[npc->animationNumber];
    if ( npc->direction == right )
      npc->rect = Rects_Left_Right[npc->animationNumber];
  }
  else
  {
    npc->isAlive = 0;
  }
}

//----- (00427480) --------------------------------------------------------
// NPC 5 : Critter (Enemy) (Hopping, Green)
// Appears in the Egg Corridor.
void __cdecl NPC5_EnemyCritterHoppingGreen(NPC *npc)
{
  RECT *Chosen_Rect; // eax
  RECT Rects_Right[3]; // [esp+4h] [ebp-60h]
  RECT Rects_Left[3]; // [esp+34h] [ebp-30h]

  Rects_Left[0].left = 0;
  Rects_Left[0].top = 48;
  Rects_Left[0].right = 16;
  Rects_Left[0].bottom = 64;
  Rects_Left[1].left = 16;
  Rects_Left[1].top = 48;
  Rects_Left[1].right = 32;
  Rects_Left[1].bottom = 64;
  Rects_Left[2].left = 32;
  Rects_Left[2].top = 48;
  Rects_Left[2].right = 48;
  Rects_Left[2].bottom = 64;
  Rects_Right[0].left = 0;
  Rects_Right[0].top = 64;
  Rects_Right[0].right = 16;
  Rects_Right[0].bottom = 80;
  Rects_Right[1].left = 16;
  Rects_Right[1].top = 64;
  Rects_Right[1].right = 32;
  Rects_Right[1].bottom = 80;
  Rects_Right[2].left = 32;
  Rects_Right[2].top = 64;
  Rects_Right[2].right = 48;
  Rects_Right[2].bottom = 80;
  switch ( npc->currentState )
  {
    case 0:
      npc->YPos += 1536;
      npc->currentState = 1;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( npc->XPos <= quote.XPos )
        npc->direction = 2;
      else
        npc->direction = 0;
      if ( npc->waitTimer < 8
        || npc->XPos - 57344 >= quote.XPos
        || npc->XPos + 57344 <= quote.XPos
        || npc->YPos - 40960 >= quote.YPos
        || npc->YPos + 40960 <= quote.YPos )
      {
        if ( npc->waitTimer < 8 )
          ++npc->waitTimer;
        npc->animationNumber = 0;
      }
      else
      {
        npc->animationNumber = 1;
      }
      if ( npc->isBeingHit )
      {
        npc->currentState = 2;
        npc->animationNumber = 0;
        npc->waitTimer = 0;
      }
      if ( npc->waitTimer >= 8
        && npc->XPos - 24576 < quote.XPos
        && npc->XPos + 24576 > quote.XPos
        && npc->YPos - 40960 < quote.YPos
        && npc->YPos + 24576 > quote.YPos )
      {
        npc->currentState = 2;
        npc->animationNumber = 0;
        npc->waitTimer = 0;
      }
      break;
    case 2:
      if ( ++npc->waitTimer > 8 )
      {
        npc->currentState = 3;
        npc->animationNumber = 2;
        npc->YVel = -1535;
        playSoundEffect(SFXCritterHop, 1);
        if ( npc->direction )
          npc->XVel = 256;
        else
          npc->XVel = -256;
      }
      break;
    case 3:
      if ( npc->collisionFlags & 8 )
      {
        npc->XVel = 0;
        npc->waitTimer = 0;
        npc->animationNumber = 0;
        npc->currentState = 1;
        playSoundEffect(SFXQuoteHitGround, 1);
      }
      break;
    default:
      break;
  }
  npc->YVel += 64;
  if ( npc->YVel > 1535 )
    npc->YVel = 1535;
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  if ( npc->direction )                         // If direction == Left
    Chosen_Rect = &Rects_Right[npc->animationNumber];
  else
    Chosen_Rect = &Rects_Left[npc->animationNumber];
  npc->rect = *Chosen_Rect;
}

//----- (00427820) --------------------------------------------------------
// NPC 6 : Beetle (Enemy) (Horizontal, Green)
// Appears in the Egg Corridor.
void __cdecl NPC6_EnemyBeetleHorizontalGreen(NPC *npc)
{
  RECT *v1; // ecx
  RECT Rects_Left[5]; // [esp+4h] [ebp-A0h]
  RECT Rects_Right[5]; // [esp+54h] [ebp-50h]

  Rects_Right[0].left = 0;
  Rects_Right[0].top = 80;
  Rects_Right[0].right = 16;
  Rects_Right[0].bottom = 96;
  Rects_Right[1].left = 16;
  Rects_Right[1].top = 80;
  Rects_Right[1].right = 32;
  Rects_Right[1].bottom = 96;
  Rects_Right[2].left = 32;
  Rects_Right[2].top = 80;
  Rects_Right[2].right = 48;
  Rects_Right[2].bottom = 96;
  Rects_Right[3].left = 48;
  Rects_Right[3].top = 80;
  Rects_Right[3].right = 64;
  Rects_Right[3].bottom = 96;
  Rects_Right[4].left = 64;
  Rects_Right[4].top = 80;
  Rects_Right[4].right = 80;
  Rects_Right[4].bottom = 96;
  Rects_Left[0].left = 0;
  Rects_Left[0].top = 96;
  Rects_Left[0].right = 16;
  Rects_Left[0].bottom = 112;
  Rects_Left[1].left = 16;
  Rects_Left[1].top = 96;
  Rects_Left[1].right = 32;
  Rects_Left[1].bottom = 112;
  Rects_Left[2].left = 32;
  Rects_Left[2].top = 96;
  Rects_Left[2].right = 48;
  Rects_Left[2].bottom = 112;
  Rects_Left[3].left = 48;
  Rects_Left[3].top = 96;
  Rects_Left[3].right = 64;
  Rects_Left[3].bottom = 112;
  Rects_Left[4].left = 64;
  Rects_Left[4].top = 96;
  Rects_Left[4].right = 80;
  Rects_Left[4].bottom = 112;
  switch ( npc->currentState )
  {
    case 0:
      npc->currentState = 1;
      if ( npc->direction )
        npc->currentState = 3;
      else
        npc->currentState = 1;
      break;
    case 1:
      npc->XVel -= 16;
      if ( npc->XVel < -1024 )
        npc->XVel = -1024;
      if ( npc->isBeingHit )
        npc->XPos += npc->XVel / 2;
      else
        npc->XPos += npc->XVel;
      if ( ++npc->animationTimer > 1 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 2 )
        npc->animationNumber = 1;
      if ( npc->collisionFlags & 1 )
      {
        npc->currentState = 2;
        npc->waitTimer = 0;
        npc->animationNumber = 0;
        npc->XVel = 0;
        npc->direction = 2;
      }
      break;
    case 2:
      if ( ++npc->waitTimer > 60 )
      {
        npc->currentState = 3;
        npc->animationTimer = 0;
        npc->animationNumber = 1;
      }
      break;
    case 3:
      npc->XVel += 16;
      if ( npc->XVel > 1024 )
        npc->XVel = 1024;
      if ( npc->isBeingHit )
        npc->XPos += npc->XVel / 2;
      else
        npc->XPos += npc->XVel;
      if ( ++npc->animationTimer > 1 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 2 )
        npc->animationNumber = 1;
      if ( npc->collisionFlags & 4 )
      {
        npc->currentState = 4;
        npc->waitTimer = 0;
        npc->animationNumber = 0;
        npc->XVel = 0;
        npc->direction = 0;
      }
      break;
    case 4:
      if ( ++npc->waitTimer > 60 )
      {
        npc->currentState = 1;
        npc->animationTimer = 0;
        npc->animationNumber = 1;
      }
      break;
    default:
      break;
  }
  if ( npc->direction )
    v1 = &Rects_Left[npc->animationNumber];
  else
    v1 = &Rects_Right[npc->animationNumber];
  npc->rect = *v1;
}

//----- (00427C60) --------------------------------------------------------
// NPC 6 : Beetle (Enemy) (Horizontal, Green)
// Appears in the Egg Corridor.
void __cdecl NPC7_EnemyBasil(NPC *npc)
{
  RECT *Chosen_Rect; // eax
  int npc_act_no; // [esp+0h] [ebp-64h]
  RECT Rects_Right[3]; // [esp+4h] [ebp-60h]
  RECT Rects_Left[3]; // [esp+34h] [ebp-30h]

  Rects_Left[0].left = 256;
  Rects_Left[0].top = 64;
  Rects_Left[0].right = 288;
  Rects_Left[0].bottom = 80;
  Rects_Left[1].left = 256;
  Rects_Left[1].top = 80;
  Rects_Left[1].right = 288;
  Rects_Left[1].bottom = 96;
  Rects_Left[2].left = 256;
  Rects_Left[2].top = 96;
  Rects_Left[2].right = 288;
  Rects_Left[2].bottom = 112;
  Rects_Right[0].left = 288;
  Rects_Right[0].top = 64;
  Rects_Right[0].right = 320;
  Rects_Right[0].bottom = 80;
  Rects_Right[1].left = 288;
  Rects_Right[1].top = 80;
  Rects_Right[1].right = 320;
  Rects_Right[1].bottom = 96;
  Rects_Right[2].left = 288;
  Rects_Right[2].top = 96;
  Rects_Right[2].right = 320;
  Rects_Right[2].bottom = 112;
  npc_act_no = npc->currentState;
  if ( npc_act_no )
  {
    if ( npc_act_no == 1 )
    {
      npc->XVel -= 64;
      if ( npc->XPos < quote.XPos - 98304 )
        npc->currentState = 2;
      if ( npc->collisionFlags & 1 )
      {
        npc->XVel = 0;
        npc->currentState = 2;
      }
    }
    else if ( npc_act_no == 2 )
    {
      npc->XVel += 64;
      if ( npc->XPos > quote.XPos + 98304 )
        npc->currentState = 1;
      if ( npc->collisionFlags & 4 )
      {
        npc->XVel = 0;
        npc->currentState = 1;
      }
    }
  }
  else
  {
    npc->XPos = quote.XPos;
    if ( npc->direction )
      npc->currentState = 2;
    else
      npc->currentState = 1;
  }
  if ( npc->XVel >= 0 )
    npc->direction = 2;
  else
    npc->direction = 0;
  if ( npc->XVel > 1535 )
    npc->XVel = 1535;
  if ( npc->XVel < -1535 )
    npc->XVel = -1535;
  npc->XPos += npc->XVel;
  if ( ++npc->animationTimer > 1 )
  {
    npc->animationTimer = 0;
    ++npc->animationNumber;
  }
  if ( npc->animationNumber > 2 )
    npc->animationNumber = 0;
  if ( npc->direction )
    Chosen_Rect = &Rects_Right[npc->animationNumber];
  else
    Chosen_Rect = &Rects_Left[npc->animationNumber];
  npc->rect = *Chosen_Rect;
}

//----- (00427F00) --------------------------------------------------------
// NPC 8 : Beetle (Enemy) (Follow 1)
// Appears in the Egg Corridor.
void __cdecl NPC8_EnemyBeetleFollow1(NPC *npc)
{
  int v1; // edx
  RECT *Chosen_Rect; // eax
  int npc_Current_State; // [esp+0h] [ebp-44h]
  RECT Rects_Right[2]; // [esp+4h] [ebp-40h]
  RECT Rects_Left[2]; // [esp+24h] [ebp-20h]

  Rects_Left[0].left = 80;
  Rects_Left[0].top = 80;
  Rects_Left[0].right = 96;
  Rects_Left[0].bottom = 96;
  Rects_Left[1].left = 96;
  Rects_Left[1].top = 80;
  Rects_Left[1].right = 112;
  Rects_Left[1].bottom = 96;
  Rects_Right[0].left = 80;
  Rects_Right[0].top = 96;
  Rects_Right[0].right = 96;
  Rects_Right[0].bottom = 112;
  Rects_Right[1].left = 96;
  Rects_Right[1].top = 96;
  Rects_Right[1].right = 112;
  Rects_Right[1].bottom = 112;
  npc_Current_State = npc->currentState;
  if ( npc_Current_State )
  {
    if ( npc_Current_State == 1 )
    {
      if ( npc->XPos <= quote.XPos )
      {
        npc->direction = 2;
        npc->XVel += 16;
      }
      else
      {
        npc->direction = 0;
        npc->XVel -= 16;
      }
      if ( npc->XVel > 767 )
        npc->XVel = 767;
      if ( npc->XVel < -767 )
        npc->XVel = -767;
      if ( npc->YPos >= npc->curlyTargetY )
        v1 = npc->YVel - 8;
      else
        v1 = npc->YVel + 8;
      npc->YVel = v1;
      if ( npc->YVel > 256 )
        npc->YVel = 256;
      if ( npc->YVel < -256 )
        npc->YVel = -256;
      if ( npc->isBeingHit )
      {
        npc->XPos += npc->XVel / 2;
        npc->YPos += npc->YVel / 2;
      }
      else
      {
        npc->XPos += npc->XVel;
        npc->YPos += npc->YVel;
      }
    }
  }
  else
  {
    if ( quote.XPos >= npc->XPos + 0x2000 || quote.XPos <= npc->XPos - 0x2000 )
    {
      npc->entityFlags &= 0xFFDFu;
      npc->rect.right = 0;
      npc->damage = 0;
      npc->XVel = 0;
      npc->YVel = 0;
      return;
    }
    npc->entityFlags |= 0x20u;
    npc->YVel = -256;
    npc->curlyTargetY = npc->YPos;
    npc->currentState = 1;
    npc->damage = 2;
    if ( npc->direction )
    {
      npc->XPos = quote.XPos - 0x20000;
      npc->XVel = 767;
    }
    else
    {
      npc->XPos = quote.XPos + 0x20000;
      npc->XVel = -767;
    }
  }
  if ( ++npc->animationTimer > 1 )
  {
    npc->animationTimer = 0;
    ++npc->animationNumber;
  }
  if ( npc->animationNumber > 1 )
    npc->animationNumber = 0;
  if ( npc->direction )
    Chosen_Rect = &Rects_Right[npc->animationNumber];
  else
    Chosen_Rect = &Rects_Left[npc->animationNumber];
  npc->rect = *Chosen_Rect;
}

//----- (00428260) --------------------------------------------------------
// NPC 9 : Balrog (drops in)
void __cdecl NPC9_BalrogDropIn(NPC *npc)
{
  int Child_Y_Vel; // ST10_4
  int Child_X_Vel; // ST0C_4
  int Child_Y_Pos; // ST08_4
  int X_Pos_Modifier; // eax
  RECT *Chosen_Rect; // eax
  int npc_Current_State; // [esp+0h] [ebp-68h]
  RECT Rects_Right[3]; // [esp+4h] [ebp-64h]
  RECT Rects_Left[3]; // [esp+34h] [ebp-34h]
  int i; // [esp+64h] [ebp-4h]

  npc_Current_State = npc->currentState;
  if ( npc_Current_State )
  {
    if ( npc_Current_State != 1 )
    {
      if ( npc_Current_State == 2 && ++npc->waitTimer > 16 )
      {
        npc->currentState = 3;
        npc->animationNumber = 0;
        npc->animationTimer = 0;
      }
      goto LABEL_17;
    }
  }
  else
  {
    npc->currentState = 1;
    npc->animationNumber = 2;
  }
  npc->YVel += 32;
  if ( npc->count1 >= 40 )
  {
    npc->entityFlags &= 0xFFF7u;
    npc->entityFlags |= 1u;
  }
  else
  {
    ++npc->count1;
  }
  if ( npc->collisionFlags & 8 )
  {
    for ( i = 0; i < 4; ++i )
    {
      Child_Y_Vel = random(-1536, 0);
      Child_X_Vel = random(-341, 341);
      Child_Y_Pos = npc->YPos + (random(-12, 12) << 9);
      X_Pos_Modifier = random(-12, 12);
      createNPC(NPCSmoke, npc->XPos + (X_Pos_Modifier << 9), Child_Y_Pos, Child_X_Vel, Child_Y_Vel, 0, 0, 256);
    }
    npc->currentState = 2;
    npc->animationNumber = 1;
    npc->waitTimer = 0;
    playSoundEffect(SFXLargeObjectHitGround, 1);
    setQuake(30);
  }
LABEL_17:
  if ( npc->YVel > 1535 )
    npc->YVel = 1535;
  if ( npc->YVel < -1535 )
    npc->YVel = -1535;
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  Rects_Left[0].left = 0;
  Rects_Left[0].top = 0;
  Rects_Left[0].right = 40;
  Rects_Left[0].bottom = 24;
  Rects_Left[1].left = 80;
  Rects_Left[1].top = 0;
  Rects_Left[1].right = 120;
  Rects_Left[1].bottom = 24;
  Rects_Left[2].left = 120;
  Rects_Left[2].top = 0;
  Rects_Left[2].right = 160;
  Rects_Left[2].bottom = 24;
  Rects_Right[0].left = 0;
  Rects_Right[0].top = 24;
  Rects_Right[0].right = 40;
  Rects_Right[0].bottom = 48;
  Rects_Right[1].left = 80;
  Rects_Right[1].top = 24;
  Rects_Right[1].right = 120;
  Rects_Right[1].bottom = 48;
  Rects_Right[2].left = 120;
  Rects_Right[2].top = 24;
  Rects_Right[2].right = 160;
  Rects_Right[2].bottom = 48;
  if ( npc->direction )
    Chosen_Rect = &Rects_Right[npc->animationNumber];
  else
    Chosen_Rect = &Rects_Left[npc->animationNumber];
  npc->rect = *Chosen_Rect;
}

//----- (00428540) --------------------------------------------------------
// NPC 10 : Balrog (Boss) (Shooting)
// Balrog when he is shooting an energy shot.
// azertyuiop
void __cdecl NPC10_BossBalrogShooting(NPC *npc)
{
  RECT *Chosen_Rect; // eax
  RECT Rects_Right[4]; // [esp+4h] [ebp-90h]
  int Child_Y_Vel; // [esp+44h] [ebp-50h]
  int Child_X_Vel; // [esp+48h] [ebp-4Ch]
  RECT Rects_Left[4]; // [esp+4Ch] [ebp-48h]
  unsigned __int8 deg; // [esp+93h] [ebp-1h]

  switch ( npc->currentState )                  // Balrog (Shoot) Turret Behavior
                                                // State 0 and 1 do the default behavior.
                                                // State 2 makes Balrog stand in place and shoot his 
                                                // mouth shots for 43.52 years
                                                // State 3 makes Balrog wait 3 frames then jump towards Quote and 
                                                // then reset to normal behaviour
                                                // State 4 makes Balrog act as if he was flying, just without 
                                                // velocity and with the wrong rect.
                                                // State 5 makes Balrog wait 3 frames then reset to state 1
                                                // Other values make him just stand in place doing nothing
  {
    case 0:
      npc->currentState = 1;                    // On init
      goto case_1;
    case 1:
case_1:
      if ( ++npc->waitTimer > 12 )              // Wait 12 frames
      {
        npc->currentState = 2;
        npc->waitTimer = 0;
        npc->count1 = 3;                        // Shoot 3 orbs at Quote
        npc->animationNumber = 1;
      }
      break;
    case 2:
      if ( ++npc->waitTimer > 16 )              // Wait 16 frames per orb
      {
        --npc->count1;                          // Fail : Counter is decreased before checking for it being equal 
                                                // to 0. This means that if the counter is initiated at 0, Balrog 
                                                // will shoot at Quote for 68719476480 frames, or 1374389529.6 
                                                // seconds, or 22906492.16 minutes, or 381774.72 hours, or 
                                                // 15907.2 days, or 43.52 years
        npc->waitTimer = 0;
        deg = getArcTan(npc->XPos - quote.XPos, npc->YPos + 2048 - quote.YPos);
        deg += random(-16, 16);                 // Shoot an orb at Quote
        Child_Y_Vel = getSin(deg);
        Child_X_Vel = getCos(deg);
        createNPC(NPCProjectileBalrogEnemyBounce, npc->XPos, npc->YPos + 2048, Child_X_Vel, Child_Y_Vel, 0, 0, 256);
        playSoundEffect(SFXEnemyShootProjectile, 1);
        if ( !npc->count1 )
        {
          npc->currentState = 3;
          npc->waitTimer = 0;
        }
      }
      break;
    case 3:
      if ( ++npc->waitTimer > 3 )               // Jump towards Quote
      {
        npc->currentState = 4;
        npc->waitTimer = 0;
        npc->XVel = (quote.XPos - npc->XPos) / 100;
        npc->YVel = -1536;
        npc->animationNumber = 3;
      }
      break;
    case 4:
      if ( npc->collisionFlags & 5 )            // When touching a wall, stop
        npc->XVel = 0;
      if ( npc->YPos + 0x2000 >= quote.YPos )
        npc->damage = 0;
      else
        npc->damage = 5;
      if ( npc->collisionFlags & 8 )
      {
        npc->currentState = 5;
        npc->waitTimer = 0;
        npc->animationNumber = 2;
        playSoundEffect(SFXLargeObjectHitGround, 1);
        setQuake(30);
        npc->damage = 0;
      }
      break;
    case 5:
      npc->XVel = 0;
      if ( ++npc->waitTimer > 3 )               // Wait 3 frames, then reset 
      {
        npc->currentState = 1;
        npc->waitTimer = 0;
      }
      break;
    default:
      break;
  }
  npc->YVel += 32;
  if ( npc->YVel > 1535 )
    npc->YVel = 1535;
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  Rects_Left[0].left = 0;
  Rects_Left[0].top = 0;
  Rects_Left[0].right = 40;
  Rects_Left[0].bottom = 24;
  Rects_Left[1].left = 40;
  Rects_Left[1].top = 0;
  Rects_Left[1].right = 80;
  Rects_Left[1].bottom = 24;
  Rects_Left[2].left = 80;
  Rects_Left[2].top = 0;
  Rects_Left[2].right = 120;
  Rects_Left[2].bottom = 24;
  Rects_Left[3].left = 120;
  Rects_Left[3].top = 0;
  Rects_Left[3].right = 160;
  Rects_Left[3].bottom = 24;
  Rects_Right[0].left = 0;
  Rects_Right[0].top = 24;
  Rects_Right[0].right = 40;
  Rects_Right[0].bottom = 48;
  Rects_Right[1].left = 40;
  Rects_Right[1].top = 24;
  Rects_Right[1].right = 80;
  Rects_Right[1].bottom = 48;
  Rects_Right[2].left = 80;
  Rects_Right[2].top = 24;
  Rects_Right[2].right = 120;
  Rects_Right[2].bottom = 48;
  Rects_Right[3].left = 120;
  Rects_Right[3].top = 24;
  Rects_Right[3].right = 160;
  Rects_Right[3].bottom = 48;
  if ( npc->XPos >= quote.XPos )
    npc->direction = 0;
  else
    npc->direction = 2;
  if ( npc->direction )
    Chosen_Rect = &Rects_Right[npc->animationNumber];
  else
    Chosen_Rect = &Rects_Left[npc->animationNumber];
  npc->rect = *Chosen_Rect;
}

//----- (004289B0) --------------------------------------------------------
// NPC 11 : Balrog (Projectile) (energy bounce)
// The projectile Balrog 2 shoots.
void __cdecl NPC11_ProjectileBalrogEnergyBounce(NPC *npc)
{
  RECT Rects[3]; // [esp+0h] [ebp-30h]

  if ( npc->collisionFlags & 0xFF )
  {
    npc->isAlive = 0;
    createEffect(npc->XPos, npc->YPos, effectRisingDisc, 0);
  }
  npc->YPos += npc->YVel;
  npc->XPos += npc->XVel;
  Rects[0].left = 208;
  Rects[0].top = 104;
  Rects[0].right = 224;
  Rects[0].bottom = 120;
  Rects[1].left = 224;
  Rects[1].top = 104;
  Rects[1].right = 240;
  Rects[1].bottom = 120;
  Rects[2].left = 240;
  Rects[2].top = 104;
  Rects[2].right = 256;
  Rects[2].bottom = 120;
  if ( ++npc->animationTimer > 1 )
  {
    npc->animationTimer = 0;
    if ( ++npc->animationNumber > 2 )
      npc->animationNumber = 0;
  }
  npc->rect = Rects[npc->animationNumber];
  if ( ++npc->count1 > 150 )
  {
    createEffect(npc->XPos, npc->YPos, effectRisingDisc, 0);
    npc->isAlive = 0;
  }
}

//----- (00428B10) --------------------------------------------------------
// NPC 12 : Balrog (cutscene)
// Balrog when he is in a cutscene.
void __cdecl NPC12_BalrogCutscene(NPC *npc)
{
  int v1; // ST10_4
  int v2; // ST0C_4
  int v3; // ST08_4
  int v4; // eax
  int v5; // edx
  int v6; // edx
  int v7; // ST10_4
  int v8; // ST0C_4
  int v9; // ST08_4
  int v10; // eax
  RECT *Chosen_Rect; // ecx
  RECT Rects_Right[14]; // [esp+4h] [ebp-1D0h]
  RECT Rects_Left[14]; // [esp+E4h] [ebp-F0h]
  int i; // [esp+1C8h] [ebp-Ch]
  int X_Pos; // [esp+1CCh] [ebp-8h]
  int Y_Pos; // [esp+1D0h] [ebp-4h]

  switch ( npc->currentState )
  {
    case 0:
      if ( npc->direction == 4 )
      {
        if ( npc->XPos <= quote.XPos )
          npc->direction = 2;
        else
          npc->direction = 0;
      }
      npc->currentState = 1;
      npc->animationNumber = 0;
      goto LABEL_7;
    case 1:
LABEL_7:
      if ( !random(0, 100) )
      {
        npc->currentState = 2;
        npc->waitTimer = 0;
        npc->animationNumber = 1;
      }
      break;
    case 2:
      if ( ++npc->waitTimer > 16 )
      {
        npc->currentState = 1;
        npc->animationNumber = 0;
      }
      break;
    case 0xA:
      if ( npc->direction == 4 )
      {
        if ( npc->XPos <= quote.XPos )
          npc->direction = 2;
        else
          npc->direction = 0;
      }
      npc->currentState = 11;
      npc->animationNumber = 2;
      npc->waitTimer = 0;
      npc->curlyTargetX = 0;
      goto LABEL_18;
    case 0xB:
LABEL_18:
      if ( ++npc->waitTimer > 30 )
      {
        npc->currentState = 12;
        npc->waitTimer = 0;
        npc->animationNumber = 3;
        npc->YVel = -2048;
        npc->entityFlags |= 8u;
      }
      break;
    case 0xC:
      if ( npc->collisionFlags & 5 )
        npc->XVel = 0;
      if ( npc->YPos < 0 )
      {
        npc->entityType = 0;
        playSoundEffect(SFXLargeObjectHitGround, 1);
        setQuake(30);
      }
      break;
    case 0x14:
      if ( npc->direction == 4 )
      {
        if ( npc->XPos <= quote.XPos )
          npc->direction = 2;
        else
          npc->direction = 0;
      }
      npc->currentState = 21;
      npc->animationNumber = 5;
      npc->waitTimer = 0;
      npc->count1 = 0;
      for ( i = 0; i < 4; ++i )
      {
        v1 = random(-1536, 0);
        v2 = random(-341, 341);
        v3 = npc->YPos + (random(-12, 12) << 9);
        v4 = random(-12, 12);
        createNPC(NPCSmoke, npc->XPos + (v4 << 9), v3, v2, v1, 0, 0, 256);
      }
      playSoundEffect(SFXExplosion, 1);
      goto LABEL_34;
    case 0x15:
LABEL_34:
      npc->curlyTargetX = 1;
      if ( npc->collisionFlags & 8 )
        ++npc->waitTimer;
      if ( ++npc->count1 / 2 % 2 )
        v5 = npc->XPos + 512;
      else
        v5 = npc->XPos - 512;
      npc->XPos = v5;
      if ( npc->waitTimer > 100 )
      {
        npc->currentState = 11;
        npc->waitTimer = 0;
        npc->animationNumber = 2;
      }
      npc->YVel += 32;
      if ( npc->YVel > 1535 )
        npc->YVel = 1535;
      break;
    case 0x1E:
      npc->animationNumber = 4;
      if ( ++npc->waitTimer > 100 )
      {
        npc->currentState = 0;
        npc->animationNumber = 0;
      }
      break;
    case 0x28:
      if ( npc->direction == 4 )
      {
        if ( npc->XPos <= quote.XPos )
          npc->direction = 2;
        else
          npc->direction = 0;
      }
      npc->currentState = 41;
      npc->waitTimer = 0;
      npc->animationNumber = 5;
      goto LABEL_52;
    case 0x29:
LABEL_52:
      if ( ++npc->animationTimer / 2 % 2 )
        npc->animationNumber = 5;
      else
        npc->animationNumber = 6;
      break;
    case 0x2A:
      if ( npc->direction == 4 )
      {
        if ( npc->XPos <= quote.XPos )
          npc->direction = 2;
        else
          npc->direction = 0;
      }
      npc->currentState = 43;
      npc->waitTimer = 0;
      npc->animationNumber = 6;
      goto LABEL_61;
    case 0x2B:
LABEL_61:
      if ( ++npc->animationTimer / 2 % 2 )
        npc->animationNumber = 7;
      else
        npc->animationNumber = 6;
      break;
    case 0x32:
      npc->animationNumber = 8;
      npc->XVel = 0;
      break;
    case 0x3C:
      npc->currentState = 61;
      npc->animationNumber = 9;
      npc->animationTimer = 0;
      goto LABEL_67;
    case 0x3D:
LABEL_67:
      if ( ++npc->animationTimer > 3 )
      {
        npc->animationTimer = 0;
        if ( ++npc->animationNumber == 10 || npc->animationNumber == 11 )
          playSoundEffect(SFXQuoteHitGround, 1);
      }
      if ( npc->animationNumber > 12 )
        npc->animationNumber = 9;
      if ( npc->direction )
        npc->XVel = 512;
      else
        npc->XVel = -512;
      break;
    case 0x46:
      npc->currentState = 71;
      npc->waitTimer = 64;
      playSoundEffect(SFXTeleport, 1);
      npc->animationNumber = 13;
      goto LABEL_78;
    case 0x47:
LABEL_78:
      if ( !--npc->waitTimer )
        npc->isAlive = 0;
      break;
    case 0x50:
      npc->count1 = 0;
      npc->currentState = 81;
      goto LABEL_82;
    case 0x51:
LABEL_82:
      if ( ++npc->count1 / 2 % 2 )
        v6 = npc->XPos + 512;
      else
        v6 = npc->XPos - 512;
      npc->XPos = v6;
      npc->animationNumber = 5;
      npc->XVel = 0;
      npc->YVel += 32;
      break;
    case 0x64:
      npc->currentState = 101;
      npc->waitTimer = 0;
      npc->animationNumber = 2;
      goto LABEL_87;
    case 0x65:
LABEL_87:
      if ( ++npc->waitTimer > 20 )
      {
        npc->currentState = 102;
        npc->waitTimer = 0;
        npc->animationNumber = 3;
        npc->YVel = -2048;
        npc->entityFlags |= 8u;
        killNPC(150, 0);
        killNPC(117, 0);
        createNPC((NPCNames)355, 0, 0, 0, 0, 0, npc, 256);
        createNPC((NPCNames)355, 0, 0, 0, 0, up, npc, 256);
      }
      break;
    case 0x66:
      X_Pos = npc->XPos / 512 / 16;
      Y_Pos = npc->YPos / 512 / 16;
      if ( Y_Pos >= 0 && Y_Pos < 35 && changeMapParts(X_Pos, Y_Pos, 0) )
      {
        changeMapParts(X_Pos - 1, Y_Pos, 0);
        changeMapParts(X_Pos + 1, Y_Pos, 0);
        playSoundEffect(SFXMissileImpact, 1);
        setHardQuakeDuration(10);
      }
      if ( npc->YPos < -16384 )
      {
        npc->entityType = 0;
        setQuake(30);
      }
      break;
    default:
      break;
  }
  if ( npc->curlyTargetX && !random(0, 10) )
  {
    v7 = random(-1536, 0);
    v8 = random(-341, 341);
    v9 = npc->YPos + (random(-12, 12) << 9);
    v10 = random(-12, 12);
    createNPC(NPCSmoke, npc->XPos + (v10 << 9), v9, v8, v7, 0, 0, 256);
  }
  if ( npc->YVel > 1535 )
    npc->YVel = 1535;
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  Rects_Left[0].left = 0;
  Rects_Left[0].top = 0;
  Rects_Left[0].right = 40;
  Rects_Left[0].bottom = 24;
  Rects_Left[1].left = 160;
  Rects_Left[1].top = 0;
  Rects_Left[1].right = 200;
  Rects_Left[1].bottom = 24;
  Rects_Left[2].left = 80;
  Rects_Left[2].top = 0;
  Rects_Left[2].right = 120;
  Rects_Left[2].bottom = 24;
  Rects_Left[3].left = 120;
  Rects_Left[3].top = 0;
  Rects_Left[3].right = 160;
  Rects_Left[3].bottom = 24;
  Rects_Left[4].left = 240;
  Rects_Left[4].top = 0;
  Rects_Left[4].right = 280;
  Rects_Left[4].bottom = 24;
  Rects_Left[5].left = 200;
  Rects_Left[5].top = 0;
  Rects_Left[5].right = 240;
  Rects_Left[5].bottom = 24;
  Rects_Left[6].left = 280;
  Rects_Left[6].top = 0;
  Rects_Left[6].right = 320;
  Rects_Left[6].bottom = 24;
  Rects_Left[7].left = 0;
  Rects_Left[7].top = 0;
  Rects_Left[7].right = 0;
  Rects_Left[7].bottom = 0;
  Rects_Left[8].left = 80;
  Rects_Left[8].top = 48;
  Rects_Left[8].right = 120;
  Rects_Left[8].bottom = 72;
  Rects_Left[9].left = 0;
  Rects_Left[9].top = 48;
  Rects_Left[9].right = 40;
  Rects_Left[9].bottom = 72;
  Rects_Left[10].left = 0;
  Rects_Left[10].top = 0;
  Rects_Left[10].right = 40;
  Rects_Left[10].bottom = 24;
  Rects_Left[11].left = 40;
  Rects_Left[11].top = 48;
  Rects_Left[11].right = 80;
  Rects_Left[11].bottom = 72;
  Rects_Left[12].left = 0;
  Rects_Left[12].top = 0;
  Rects_Left[12].right = 40;
  Rects_Left[12].bottom = 24;
  Rects_Left[13].left = 280;
  Rects_Left[13].top = 0;
  Rects_Left[13].right = 320;
  Rects_Left[13].bottom = 24;
  Rects_Right[0].left = 0;
  Rects_Right[0].top = 24;
  Rects_Right[0].right = 40;
  Rects_Right[0].bottom = 48;
  Rects_Right[1].left = 160;
  Rects_Right[1].top = 24;
  Rects_Right[1].right = 200;
  Rects_Right[1].bottom = 48;
  Rects_Right[2].left = 80;
  Rects_Right[2].top = 24;
  Rects_Right[2].right = 120;
  Rects_Right[2].bottom = 48;
  Rects_Right[3].left = 120;
  Rects_Right[3].top = 24;
  Rects_Right[3].right = 160;
  Rects_Right[3].bottom = 48;
  Rects_Right[4].left = 240;
  Rects_Right[4].top = 24;
  Rects_Right[4].right = 280;
  Rects_Right[4].bottom = 48;
  Rects_Right[5].left = 200;
  Rects_Right[5].top = 24;
  Rects_Right[5].right = 240;
  Rects_Right[5].bottom = 48;
  Rects_Right[6].left = 280;
  Rects_Right[6].top = 24;
  Rects_Right[6].right = 320;
  Rects_Right[6].bottom = 48;
  Rects_Right[7].left = 0;
  Rects_Right[7].top = 0;
  Rects_Right[7].right = 0;
  Rects_Right[7].bottom = 0;
  Rects_Right[8].left = 80;
  Rects_Right[8].top = 72;
  Rects_Right[8].right = 120;
  Rects_Right[8].bottom = 96;
  Rects_Right[9].left = 0;
  Rects_Right[9].top = 72;
  Rects_Right[9].right = 40;
  Rects_Right[9].bottom = 96;
  Rects_Right[10].left = 0;
  Rects_Right[10].top = 24;
  Rects_Right[10].right = 40;
  Rects_Right[10].bottom = 48;
  Rects_Right[11].left = 40;
  Rects_Right[11].top = 72;
  Rects_Right[11].right = 80;
  Rects_Right[11].bottom = 96;
  Rects_Right[12].left = 0;
  Rects_Right[12].top = 24;
  Rects_Right[12].right = 40;
  Rects_Right[12].bottom = 48;
  Rects_Right[13].left = 280;
  Rects_Right[13].top = 24;
  Rects_Right[13].right = 320;
  Rects_Right[13].bottom = 48;
  if ( npc->direction )
    Chosen_Rect = &Rects_Right[npc->animationNumber];
  else
    Chosen_Rect = &Rects_Left[npc->animationNumber];
  npc->rect = *Chosen_Rect;
  if ( npc->currentState == 71 )
  {
    npc->rect.bottom = npc->rect.top + npc->waitTimer / 2;
    if ( npc->waitTimer % 2 )
      ++npc->rect.left;
  }
}

//----- (00429940) --------------------------------------------------------
// NPC 13 : Forcefield
void __cdecl NPC13_Forcefield(NPC *npc)
{
  RECT Rects[4]; // [esp+0h] [ebp-40h]

  Rects[0].left = 128;
  Rects[0].top = 0;
  Rects[0].right = 144;
  Rects[0].bottom = 16;
  Rects[1].left = 144;
  Rects[1].top = 0;
  Rects[1].right = 160;
  Rects[1].bottom = 16;
  Rects[2].left = 160;
  Rects[2].top = 0;
  Rects[2].right = 176;
  Rects[2].bottom = 16;
  Rects[3].left = 176;
  Rects[3].top = 0;
  Rects[3].right = 192;
  Rects[3].bottom = 16;
  if ( ++npc->animationTimer > 0 )
  {
    npc->animationTimer = 0;
    ++npc->animationNumber;
  }
  if ( npc->animationNumber > 3 )
    npc->animationNumber = 0;
  npc->rect = Rects[npc->animationNumber];
}

//----- (00429A30) --------------------------------------------------------
// NPC 14 : Santa's Key
// Can be found in Grasstown
void __cdecl NPC14_SantasKey(NPC *npc)
{
  int Rand_Y_Vel; // ST10_4
  int Rand_X_Vel; // ST0C_4
  int Rand_Y_Pos; // ST08_4
  int Rand_X_Pos; // eax
  signed int i; // [esp+4h] [ebp-34h]
  RECT Rects[3]; // [esp+8h] [ebp-30h]

  Rects[0].left = 192;
  Rects[0].top = 0;
  Rects[0].right = 208;
  Rects[0].bottom = 16;
  Rects[1].left = 208;
  Rects[1].top = 0;
  Rects[1].right = 224;
  Rects[1].bottom = 16;
  Rects[2].left = 224;
  Rects[2].top = 0;
  Rects[2].right = 240;
  Rects[2].bottom = 16;
  if ( !npc->currentState )
  {
    npc->currentState = 1;
    if ( npc->direction == 2 )
    {
      npc->YVel = -512;
      for ( i = 0; i < 4; ++i )
      {
        Rand_Y_Vel = random(-1536, 0);
        Rand_X_Vel = random(-341, 341);
        Rand_Y_Pos = npc->YPos + (random(-12, 12) << 9);
        Rand_X_Pos = random(-12, 12);
        createNPC(NPCSmoke, npc->XPos + (Rand_X_Pos << 9), Rand_Y_Pos, Rand_X_Vel, Rand_Y_Vel, 0, 0, 256);// Create some smoke
      }
    }
  }
  if ( ++npc->animationTimer > 1 )
  {
    npc->animationTimer = 0;
    ++npc->animationNumber;
  }
  if ( npc->animationNumber > 2 )
    npc->animationNumber = 0;
  npc->YVel += 64;
  if ( npc->YVel > 1535 )
    npc->YVel = 1535;
  npc->YPos += npc->YVel;
  npc->rect = Rects[npc->animationNumber];
}

//----- (00429BF0) --------------------------------------------------------
// NPC 15 : Treasure Chest, closed
void __cdecl NPC15_TreasureChestClosed(NPC *npc)
{
  int v1; // ST10_4
  int v2; // ST0C_4
  int v3; // ST08_4
  int v4; // eax
  int Npc_Current_State; // [esp+0h] [ebp-38h]
  signed int i; // [esp+4h] [ebp-34h]
  RECT Rects[3]; // [esp+8h] [ebp-30h]

  Rects[0].left = 240;
  Rects[0].top = 0;
  Rects[0].right = 256;
  Rects[0].bottom = 16;
  Rects[1].left = 256;
  Rects[1].top = 0;
  Rects[1].right = 272;
  Rects[1].bottom = 16;
  Rects[2].left = 272;
  Rects[2].top = 0;
  Rects[2].right = 288;
  Rects[2].bottom = 16;
  Npc_Current_State = npc->currentState;
  if ( Npc_Current_State )
  {
    if ( Npc_Current_State != 1 )
    {
      if ( Npc_Current_State == 2 )
      {
        if ( ++npc->animationTimer > 1 )
        {
          npc->animationTimer = 0;
          ++npc->animationNumber;
        }
        if ( npc->animationNumber > 2 )
        {
          npc->animationNumber = 0;
          npc->currentState = 1;
        }
      }
      goto LABEL_16;
    }
  }
  else
  {
    npc->currentState = 1;
    npc->entityFlags |= 0x2000u;
    if ( npc->direction == 2 )
    {
      npc->YVel = -512;
      for ( i = 0; i < 4; ++i )
      {
        v1 = random(-1536, 0);
        v2 = random(-341, 341);
        v3 = npc->YPos + (random(-12, 12) << 9);
        v4 = random(-12, 12);
        createNPC(NPCSmoke, npc->XPos + (v4 << 9), v3, v2, v1, 0, 0, 256);
      }
    }
  }
  npc->animationNumber = 0;
  if ( !random(0, 30) )
    npc->currentState = 2;
LABEL_16:
  npc->YVel += 64;
  if ( npc->YVel > 1535 )
    npc->YVel = 1535;
  npc->YPos += npc->YVel;
  npc->rect = Rects[npc->animationNumber];
}

//----- (00429E00) --------------------------------------------------------
void __cdecl NPC16_SavePoint(NPC *npc)
{
  int childYVel; // ST10_4
  int childXVel; // ST0C_4
  int childYPos; // ST08_4
  int childXPos; // eax
  RECT *v5; // edx MAPDST
  int currentState; // [esp+0h] [ebp-88h]
  signed int i; // [esp+4h] [ebp-84h]
  RECT Rects[8]; // [esp+8h] [ebp-80h]

  Rects[0].left = 96;
  Rects[0].top = 16;
  Rects[0].right = 112;
  Rects[0].bottom = 32;
  Rects[1].left = 112;
  Rects[1].top = 16;
  Rects[1].right = 128;
  Rects[1].bottom = 32;
  Rects[2].left = 128;
  Rects[2].top = 16;
  Rects[2].right = 144;
  Rects[2].bottom = 32;
  Rects[3].left = 144;
  Rects[3].top = 16;
  Rects[3].right = 160;
  Rects[3].bottom = 32;
  Rects[4].left = 160;
  Rects[4].top = 16;
  Rects[4].right = 176;
  Rects[4].bottom = 32;
  Rects[5].left = 176;
  Rects[5].top = 16;
  Rects[5].right = 192;
  Rects[5].bottom = 32;
  Rects[6].left = 192;
  Rects[6].top = 16;
  Rects[6].right = 208;
  Rects[6].bottom = 32;
  Rects[7].left = 208;
  Rects[7].top = 16;
  Rects[7].right = 224;
  Rects[7].bottom = 32;
  currentState = npc->currentState;
  if ( currentState )
  {
    if ( currentState != 1 )
      goto LABEL_10;
  }
  else
  {
    npc->entityFlags |= 0x2000u;
    npc->currentState = 1;
    if ( npc->direction == 2 )
    {
      npc->entityFlags &= 0xDFFFu;
      npc->YVel = -512;
      for ( i = 0; i < 4; ++i )
      {
        childYVel = random(-1536, 0);
        childXVel = random(-341, 341);
        childYPos = npc->YPos + (random(-12, 12) << 9);
        childXPos = random(-12, 12);
        createNPC(NPCSmoke, npc->XPos + (childXPos << 9), childYPos, childXVel, childYVel, 0, 0, 256);
      }
    }
  }
  if ( npc->collisionFlags & 8 )
    npc->entityFlags |= 0x2000u;
LABEL_10:
  if ( ++npc->animationTimer > 2 )
  {
    npc->animationTimer = 0;
    ++npc->animationNumber;
  }
  if ( npc->animationNumber > 7 )
    npc->animationNumber = 0;
  npc->YVel += 64;
  if ( npc->YVel > 1535 )
    npc->YVel = 1535;
  npc->YPos += npc->YVel;
  v5 = &Rects[npc->animationNumber];
  v5 = &npc->rect;
  v5->left = v5->left;
  v5->top = v5->top;
  v5->right = v5->right;
  v5->bottom = v5->bottom;
}

//----- (0042A0B0) --------------------------------------------------------
void __cdecl NPC17_HealthAmmoRefill(NPC *npc)
{
  int v1; // ST10_4
  int v2; // ST0C_4
  int v3; // ST08_4
  int v4; // eax
  RECT *Cur_Rect; // eax MAPDST
  signed int i; // [esp+24h] [ebp-4h]
  int ia; // [esp+24h] [ebp-4h]

  switch ( npc->currentState )
  {
    case 0:
      npc->currentState = 1;
      if ( npc->direction == 2 )
      {
        npc->YVel = -512;
        for ( i = 0; i < 4; ++i )
        {
          v1 = random(-1536, 0);
          v2 = random(-341, 341);
          v3 = npc->YPos + (random(-12, 12) << 9);
          v4 = random(-12, 12);
          createNPC(NPCSmoke, npc->XPos + (v4 << 9), v3, v2, v1, 0, 0, 256);
        }
      }
      goto LABEL_6;
    case 1:
LABEL_6:
      ia = random(0, 30);
      if ( ia >= 10 )
      {
        if ( ia >= 25 )
          npc->currentState = 4;
        else
          npc->currentState = 3;
      }
      else
      {
        npc->currentState = 2;
      }
      npc->waitTimer = random(16, 64);
      npc->animationTimer = 0;
      break;
    case 2:
      Cur_Rect = &npc->rect;
      Cur_Rect->left = 288;
      Cur_Rect->top = 0;
      Cur_Rect->right = 304;
      Cur_Rect->bottom = 16;
      if ( !--npc->waitTimer )
        npc->currentState = 1;
      break;
    case 3:
      if ( ++npc->animationTimer % 2 )
      {
        Cur_Rect = &npc->rect;
        Cur_Rect->left = 288;
        Cur_Rect->top = 0;
        Cur_Rect->right = 304;
      }
      else
      {
        Cur_Rect = &npc->rect;
        Cur_Rect->left = 304;
        Cur_Rect->top = 0;
        Cur_Rect->right = 320;
      }
      Cur_Rect->bottom = 16;
      if ( !--npc->waitTimer )
        npc->currentState = 1;
      break;
    case 4:
      Cur_Rect = &npc->rect;
      Cur_Rect->left = 304;
      Cur_Rect->top = 0;
      Cur_Rect->right = 320;
      Cur_Rect->bottom = 16;
      if ( !--npc->waitTimer )
        npc->currentState = 1;
      break;
    default:
      break;
  }
  npc->YVel += 64;
  if ( npc->YVel > 1535 )
    npc->YVel = 1535;
  npc->YPos += npc->YVel;
}

//----- (0042A360) --------------------------------------------------------
void __cdecl NPC18_Door(NPC *npc)
{
  int childYVel; // ST10_4
  int v4; // ST0C_4
  RECT *npcRect; // eax MAPDST
  int currentState; // [esp+0h] [ebp-28h]
  signed int i; // [esp+4h] [ebp-24h]

  currentState = npc->currentState;
  if ( currentState )
  {
    if ( currentState == 1 )
    {
      for ( i = 0; i < 4; ++i )
      {
        childYVel = random(-1536, 0);
        v4 = random(-341, 341);
        createNPC(NPCSmoke, npc->XPos, npc->YPos, v4, childYVel, 0, 0, 256);
      }
      npc->currentState = 0;
      npcRect = &npc->rect;
      npcRect->left = 224;
      npcRect->top = 16;
      npcRect->right = 240;
      npcRect->bottom = 40;
    }
  }
  else if ( npc->direction )
  {
    npcRect = &npc->rect;
    // Right Rects
    npcRect->left = 192;
    npcRect->top = 112;
    npcRect->right = 208;
    npcRect->bottom = 136;
  }
  else
  {
    npcRect = &npc->rect;
    // Left Rects
    npcRect->left = 224;
    npcRect->top = 16;
    npcRect->right = 240;
    npcRect->bottom = 40;
  }
}

//----- (0042A490) --------------------------------------------------------
void __cdecl NPC19_BalrogBustsIn(NPC *npc)
{
  int childYVel; // ST10_4
  int childXVel; // ST0C_4
  int childYPos; // ST08_4
  int childXPos; // eax
  RECT *v5; // ecx
  RECT rcRight[4]; // [esp+4h] [ebp-88h]
  RECT rcLeft[4]; // [esp+44h] [ebp-48h]
  int i; // [esp+88h] [ebp-4h]

  switch ( npc->currentState )
  {
    case 0:
      for ( i = 0; i < 16; ++i )
      {
        childYVel = random(-1536, 0);
        childXVel = random(-341, 341);
        childYPos = npc->YPos + (random(-12, 12) << 9);
        childXPos = random(-12, 12);
        createNPC(NPCSmoke, npc->XPos + (childXPos << 9), childYPos, childXVel, childYVel, 0, 0, 256);
      }
      npc->YPos += 5120;
      npc->currentState = 1;
      npc->animationNumber = 3;
      npc->YVel = -256;
      playSoundEffect(SFXDestroyBreakableBlock, 1);
      playSoundEffect(SFXLargeObjectHitGround, 1);
      setQuake(30);
      goto LABEL_6;
    case 1:
LABEL_6:
      npc->YVel += 16;
      if ( npc->YVel > 0 && npc->collisionFlags & 8 )
      {
        npc->currentState = 2;
        npc->animationNumber = 2;
        npc->waitTimer = 0;
        playSoundEffect(SFXLargeObjectHitGround, 1);
        setQuake(30);
      }
      break;
    case 2:
      if ( ++npc->waitTimer > 16 )
      {
        npc->currentState = 3;
        npc->animationNumber = 0;
        npc->animationTimer = 0;
      }
      break;
    case 3:
      if ( !random(0, 100) )
      {
        npc->currentState = 4;
        npc->waitTimer = 0;
        npc->animationNumber = 1;
      }
      break;
    case 4:
      if ( ++npc->waitTimer > 16 )
      {
        npc->currentState = 3;
        npc->animationNumber = 0;
      }
      break;
    default:
      break;
  }
  if ( npc->YVel > 1535 )
    npc->YVel = 1535;
  if ( npc->YVel < -1535 )
    npc->YVel = -1535;
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  rcLeft[0].left = 0;
  rcLeft[0].top = 0;
  rcLeft[0].right = 40;
  rcLeft[0].bottom = 24;
  rcLeft[1].left = 160;
  rcLeft[1].top = 0;
  rcLeft[1].right = 200;
  rcLeft[1].bottom = 24;
  rcLeft[2].left = 80;
  rcLeft[2].top = 0;
  rcLeft[2].right = 120;
  rcLeft[2].bottom = 24;
  rcLeft[3].left = 120;
  rcLeft[3].top = 0;
  rcLeft[3].right = 160;
  rcLeft[3].bottom = 24;
  rcRight[0].left = 0;
  rcRight[0].top = 24;
  rcRight[0].right = 40;
  rcRight[0].bottom = 48;
  rcRight[1].left = 160;
  rcRight[1].top = 24;
  rcRight[1].right = 200;
  rcRight[1].bottom = 48;
  rcRight[2].left = 80;
  rcRight[2].top = 24;
  rcRight[2].right = 120;
  rcRight[2].bottom = 48;
  rcRight[3].left = 120;
  rcRight[3].top = 24;
  rcRight[3].right = 160;
  rcRight[3].bottom = 48;
  if ( npc->direction )
    v5 = &rcRight[npc->animationNumber];
  else
    v5 = &rcLeft[npc->animationNumber];
  npc->rect = *v5;
}

//----- (0042A830) --------------------------------------------------------
void __cdecl NPC20_Computer(NPC *npc)
{
  RECT rcRight[3]; // [esp+0h] [ebp-40h]
  RECT rcLeft; // [esp+30h] [ebp-10h]

  rcLeft.left = 288;
  rcLeft.top = 16;
  rcLeft.right = 320;
  rcLeft.bottom = 40;
  rcRight[0].left = 288;
  rcRight[0].top = 40;
  rcRight[0].right = 320;
  rcRight[0].bottom = 64;
  rcRight[1].left = 288;
  rcRight[1].top = 40;
  rcRight[1].right = 320;
  rcRight[1].bottom = 64;
  rcRight[2].left = 288;
  rcRight[2].top = 64;
  rcRight[2].right = 320;
  rcRight[2].bottom = 88;
  if ( ++npc->animationTimer > 3 )
  {
    npc->animationTimer = 0;
    ++npc->animationNumber;
  }
  if ( npc->animationNumber > 2 )
    npc->animationNumber = 0;
  if ( npc->direction )
    npc->rect = rcRight[npc->animationNumber];
  else
    npc->rect = rcLeft;
}

//----- (0042A940) --------------------------------------------------------
void __cdecl NPC21_TreasureChestOpen(NPC *npc)
{
  RECT *npc_Rect; // eax

  if ( !npc->currentState )
  {
    npc->currentState = 1;
    if ( npc->direction == 2 )
      npc->YPos += 0x2000;
  }
  npc_Rect = &npc->rect;
  npc_Rect->left = 224;
  npc_Rect->top = 40;
  npc_Rect->right = 240;
  npc_Rect->bottom = 48;
}

//----- (0042A9C0) --------------------------------------------------------
void __cdecl NPC22_Teleporter(NPC *npc)
{
  int currentState; // [esp+0h] [ebp-24h]
  RECT rcNPC[2]; // [esp+4h] [ebp-20h]

  rcNPC[0].left = 240;
  rcNPC[0].top = 16;
  rcNPC[0].right = 264;
  rcNPC[0].bottom = 48;
  rcNPC[1].left = 248;
  rcNPC[1].top = 152;
  rcNPC[1].right = 272;
  rcNPC[1].bottom = 184;
  currentState = npc->currentState;
  if ( currentState )
  {
    if ( currentState == 1 && ++npc->animationNumber > 1 )
      npc->animationNumber = 0;
  }
  else
  {
    npc->animationNumber = 0;
  }
  npc->rect = rcNPC[npc->animationNumber];
}

//----- (0042AA70) --------------------------------------------------------
void __cdecl NPC23_TeleporterLights(NPC *npc)
{
  RECT rcNPC[8]; // [esp+0h] [ebp-80h]

  rcNPC[0].left = 264;
  rcNPC[0].top = 16;
  rcNPC[0].right = 288;
  rcNPC[0].bottom = 20;
  rcNPC[1].left = 264;
  rcNPC[1].top = 20;
  rcNPC[1].right = 288;
  rcNPC[1].bottom = 24;
  rcNPC[2].left = 264;
  rcNPC[2].top = 24;
  rcNPC[2].right = 288;
  rcNPC[2].bottom = 28;
  rcNPC[3].left = 264;
  rcNPC[3].top = 28;
  rcNPC[3].right = 288;
  rcNPC[3].bottom = 32;
  rcNPC[4].left = 264;
  rcNPC[4].top = 32;
  rcNPC[4].right = 288;
  rcNPC[4].bottom = 36;
  rcNPC[5].left = 264;
  rcNPC[5].top = 36;
  rcNPC[5].right = 288;
  rcNPC[5].bottom = 40;
  rcNPC[6].left = 264;
  rcNPC[6].top = 40;
  rcNPC[6].right = 288;
  rcNPC[6].bottom = 44;
  rcNPC[7].left = 264;
  rcNPC[7].top = 44;
  rcNPC[7].right = 288;
  rcNPC[7].bottom = 48;
  if ( ++npc->animationTimer > 1 )
  {
    npc->animationTimer = 0;
    ++npc->animationNumber;
  }
  if ( npc->animationNumber > 7 )
    npc->animationNumber = 0;
  npc->rect = rcNPC[npc->animationNumber];
}

//----- (0042ABD0) --------------------------------------------------------
void __cdecl NPC24_PowerCritter(NPC *npc)
{
  int v1; // eax
  int v2; // eax
  RECT *v3; // eax
  RECT rcRight[6]; // [esp+4h] [ebp-C0h]
  RECT rcLeft[6]; // [esp+64h] [ebp-60h]

  rcLeft[0].left = 0;
  rcLeft[0].top = 0;
  rcLeft[0].right = 24;
  rcLeft[0].bottom = 24;
  rcLeft[1].left = 24;
  rcLeft[1].top = 0;
  rcLeft[1].right = 48;
  rcLeft[1].bottom = 24;
  rcLeft[2].left = 48;
  rcLeft[2].top = 0;
  rcLeft[2].right = 72;
  rcLeft[2].bottom = 24;
  rcLeft[3].left = 72;
  rcLeft[3].top = 0;
  rcLeft[3].right = 96;
  rcLeft[3].bottom = 24;
  rcLeft[4].left = 96;
  rcLeft[4].top = 0;
  rcLeft[4].right = 120;
  rcLeft[4].bottom = 24;
  rcLeft[5].left = 120;
  rcLeft[5].top = 0;
  rcLeft[5].right = 144;
  rcLeft[5].bottom = 24;
  rcRight[0].left = 0;
  rcRight[0].top = 24;
  rcRight[0].right = 24;
  rcRight[0].bottom = 48;
  rcRight[1].left = 24;
  rcRight[1].top = 24;
  rcRight[1].right = 48;
  rcRight[1].bottom = 48;
  rcRight[2].left = 48;
  rcRight[2].top = 24;
  rcRight[2].right = 72;
  rcRight[2].bottom = 48;
  rcRight[3].left = 72;
  rcRight[3].top = 24;
  rcRight[3].right = 96;
  rcRight[3].bottom = 48;
  rcRight[4].left = 96;
  rcRight[4].top = 24;
  rcRight[4].right = 120;
  rcRight[4].bottom = 48;
  rcRight[5].left = 120;
  rcRight[5].top = 24;
  rcRight[5].right = 144;
  rcRight[5].bottom = 48;
  switch ( npc->currentState )
  {
    case 0:
      npc->YPos += 1536;
      npc->currentState = 1;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( npc->waitTimer < 8
        || npc->XPos - 0x10000 >= quote.XPos
        || npc->XPos + 0x10000 <= quote.XPos
        || npc->YPos - 0x10000 >= quote.YPos
        || npc->YPos + 0x6000 <= quote.YPos )
      {
        if ( npc->waitTimer < 8 )
          ++npc->waitTimer;
        npc->animationNumber = 0;
      }
      else
      {
        if ( npc->XPos <= quote.XPos )
          npc->direction = 2;
        else
          npc->direction = 0;
        npc->animationNumber = 1;
      }
      if ( npc->isBeingHit )
      {
        npc->currentState = 2;
        npc->animationNumber = 0;
        npc->waitTimer = 0;
      }
      if ( npc->waitTimer >= 8
        && npc->XPos - 0xC000 < quote.XPos
        && npc->XPos + 0xC000 > quote.XPos
        && npc->YPos - 0xC000 < quote.YPos
        && npc->YPos + 0x6000 > quote.YPos )
      {
        npc->currentState = 2;
        npc->animationNumber = 0;
        npc->waitTimer = 0;
      }
      break;
    case 2:
      if ( ++npc->waitTimer > 8 )
      {
        npc->currentState = 3;
        npc->animationNumber = 2;
        npc->YVel = -1535;
        playSoundEffect(SFXPowerCritterLargeEnemyJump, 1);
        if ( npc->XPos <= quote.XPos )
          npc->direction = 2;
        else
          npc->direction = 0;
        if ( npc->direction )
          npc->XVel = 256;
        else
          npc->XVel = -256;
      }
      break;
    case 3:
      if ( npc->YVel > 512 )
      {
        npc->curlyTargetY = npc->YPos;
        npc->currentState = 4;
        npc->animationNumber = 3;
        npc->waitTimer = 0;
        npc->waitTimer = 0;
      }
      break;
    case 4:
      if ( npc->XPos >= quote.XPos )
        npc->direction = 0;
      else
        npc->direction = 2;
      ++npc->waitTimer;
      if ( npc->collisionFlags & 7 || npc->waitTimer > 100 )
      {
        npc->damage = 12;
        npc->currentState = 5;
        npc->animationNumber = 2;
        npc->XVel /= 2;
      }
      else
      {
        if ( npc->waitTimer % 4 == 1 )
          playSoundEffect(SFXPowerCritterFlys, 1);
        if ( ++npc->animationTimer > 0 )
        {
          npc->animationTimer = 0;
          ++npc->animationNumber;
        }
        if ( npc->animationNumber > 5 )
          npc->animationNumber = 3;
      }
      break;
    case 5:
      if ( npc->collisionFlags & 8 )
      {
        npc->damage = 2;
        npc->XVel = 0;
        npc->waitTimer = 0;
        npc->animationNumber = 0;
        npc->currentState = 1;
        playSoundEffect(SFXLargeObjectHitGround, 1);
        setQuake(30);
      }
      break;
    default:
      break;
  }
  if ( npc->currentState == 4 )
  {
    if ( npc->XPos >= quote.XPos )
      v1 = npc->XVel - 32;
    else
      v1 = npc->XVel + 32;
    npc->XVel = v1;
    if ( npc->YPos <= npc->curlyTargetY )
      v2 = npc->YVel + 16;
    else
      v2 = npc->YVel - 16;
    npc->YVel = v2;
    if ( npc->YVel > 512 )
      npc->YVel = 512;
    if ( npc->YVel < -512 )
      npc->YVel = -512;
    if ( npc->XVel > 512 )
      npc->XVel = 512;
    if ( npc->XVel < -512 )
      npc->XVel = -512;
  }
  else
  {
    npc->YVel += 32;
    if ( npc->YVel > 1535 )
      npc->YVel = 1535;
  }
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  if ( npc->direction )
    v3 = &rcRight[npc->animationNumber];
  else
    v3 = &rcLeft[npc->animationNumber];
  npc->rect = *v3;
}

//----- (0042B280) --------------------------------------------------------
void __cdecl NPC25_LiftPlatform(NPC *npc)
{
  RECT *v1; // ecx MAPDST
  RECT rcNPC[2]; // [esp+8h] [ebp-20h]

  rcNPC[0].left = 256;
  rcNPC[0].top = 64;
  rcNPC[0].right = 288;
  rcNPC[0].bottom = 80;
  rcNPC[1].left = 256;
  rcNPC[1].top = 80;
  rcNPC[1].right = 288;
  rcNPC[1].bottom = 96;
  switch ( npc->currentState )
  {
    case 0:
      npc->currentState = 1;
      npc->animationNumber = 0;
      npc->animationTimer = 0;
      npc->XPos += 4096;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( ++npc->waitTimer > 150 )
      {
        npc->waitTimer = 0;
        ++npc->currentState;
      }
      break;
    case 2:
      if ( ++npc->waitTimer > 64 )
      {
        npc->waitTimer = 0;
        ++npc->currentState;
      }
      else
      {
        npc->YPos -= 512;
      }
      break;
    case 3:
      if ( ++npc->waitTimer > 150 )
      {
        npc->waitTimer = 0;
        ++npc->currentState;
      }
      break;
    case 4:
      if ( ++npc->waitTimer > 64 )
      {
        npc->waitTimer = 0;
        ++npc->currentState;
      }
      else
      {
        npc->YPos -= 512;
      }
      break;
    case 5:
      if ( ++npc->waitTimer > 150 )
      {
        npc->waitTimer = 0;
        ++npc->currentState;
      }
      break;
    case 6:
      if ( ++npc->waitTimer > 64 )
      {
        npc->waitTimer = 0;
        ++npc->currentState;
      }
      else
      {
        npc->YPos += 512;
      }
      break;
    case 7:
      if ( ++npc->waitTimer > 150 )
      {
        npc->waitTimer = 0;
        ++npc->currentState;
      }
      break;
    case 8:
      if ( ++npc->waitTimer > 64 )
      {
        npc->waitTimer = 0;
        npc->currentState = 1;
      }
      else
      {
        npc->YPos += 512;
      }
      break;
    default:
      break;
  }
  switch ( npc->currentState )
  {
    case 2:
    case 4:
    case 6:
    case 8:
      if ( ++npc->animationTimer > 1 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 1 )
        npc->animationNumber = 0;
      break;
    default:
      break;
  }
  v1 = &rcNPC[npc->animationNumber];
  v1 = &npc->rect;
  v1->left = v1->left;
  v1->top = v1->top;
  v1->right = v1->right;
  v1->bottom = v1->bottom;
}

//----- (0042B5E0) --------------------------------------------------------
void __cdecl NPC26_EnemyBatBlackCircling(NPC *npc)
{
  RECT *v1; // edx
  int currentState; // [esp+0h] [ebp-8Ch]
  RECT rcRight[4]; // [esp+4h] [ebp-88h]
  RECT rcLeft[4]; // [esp+44h] [ebp-48h]
  unsigned __int8 randYPos; // [esp+8Bh] [ebp-1h]

  currentState = npc->currentState;
  if ( currentState )
  {
    if ( currentState != 1 )
    {
      if ( currentState == 3 )
      {
        npc->YVel += 64;
        if ( npc->YVel > 1535 )
          npc->YVel = 1535;
        if ( npc->collisionFlags & 8 )
        {
          npc->YVel = 0;
          npc->XVel *= 2;
          npc->count1 = 0;
          npc->currentState = 1;
          npc->entityFlags |= 8u;
        }
      }
      goto LABEL_37;
    }
  }
  else
  {
    randYPos = random(0, 255);
    npc->XVel = getCos(randYPos);
    npc->curlyTargetX = npc->XPos + 8 * getCos(randYPos + 64);
    randYPos = random(0, 255);
    npc->YVel = getSin(randYPos);
    randYPos += 64;
    npc->curlyTargetY = npc->YPos + 8 * getSin(randYPos);
    npc->currentState = 1;
    npc->count1 = 120;
  }
  if ( quote.XPos >= npc->XPos )
    npc->direction = 2;
  else
    npc->direction = 0;
  if ( npc->curlyTargetX < npc->XPos )
    npc->XVel -= 16;
  if ( npc->curlyTargetX > npc->XPos )
    npc->XVel += 16;
  if ( npc->curlyTargetY < npc->YPos )
    npc->YVel -= 16;
  if ( npc->curlyTargetY > npc->YPos )
    npc->YVel += 16;
  if ( npc->XVel > 512 )
    npc->XVel = 512;
  if ( npc->XVel < -512 )
    npc->XVel = -512;
  if ( npc->YVel > 512 )
    npc->YVel = 512;
  if ( npc->YVel < -512 )
    npc->YVel = -512;
  if ( npc->count1 >= 120 )
  {
    if ( npc->XPos - 4096 < quote.XPos
      && npc->XPos + 4096 > quote.XPos
      && npc->YPos < quote.YPos
      && npc->YPos + 49152 > quote.YPos )
    {
      npc->XVel /= 2;
      npc->YVel = 0;
      npc->currentState = 3;
      npc->entityFlags &= 0xFFF7u;
    }
  }
  else
  {
    ++npc->count1;
  }
LABEL_37:
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  rcLeft[0].left = 32;
  rcLeft[0].top = 80;
  rcLeft[0].right = 48;
  rcLeft[0].bottom = 96;
  rcLeft[1].left = 48;
  rcLeft[1].top = 80;
  rcLeft[1].right = 64;
  rcLeft[1].bottom = 96;
  rcLeft[2].left = 64;
  rcLeft[2].top = 80;
  rcLeft[2].right = 80;
  rcLeft[2].bottom = 96;
  rcLeft[3].left = 80;
  rcLeft[3].top = 80;
  rcLeft[3].right = 96;
  rcLeft[3].bottom = 96;
  rcRight[0].left = 32;
  rcRight[0].top = 96;
  rcRight[0].right = 48;
  rcRight[0].bottom = 112;
  rcRight[1].left = 48;
  rcRight[1].top = 96;
  rcRight[1].right = 64;
  rcRight[1].bottom = 112;
  rcRight[2].left = 64;
  rcRight[2].top = 96;
  rcRight[2].right = 80;
  rcRight[2].bottom = 112;
  rcRight[3].left = 80;
  rcRight[3].top = 96;
  rcRight[3].right = 96;
  rcRight[3].bottom = 112;
  if ( npc->currentState == 3 )
  {
    npc->animationNumber = 3;
  }
  else
  {
    if ( ++npc->animationTimer > 1 )
    {
      npc->animationTimer = 0;
      ++npc->animationNumber;
    }
    if ( npc->animationNumber > 2 )
      npc->animationNumber = 0;
  }
  if ( npc->direction )
    v1 = &rcRight[npc->animationNumber];
  else
    v1 = &rcLeft[npc->animationNumber];
  npc->rect = *v1;
}

//----- (0042BA90) --------------------------------------------------------
void __cdecl NPC27_Deathtrap(NPC *npc)
{
  RECT rcNPC[1]; // [esp+0h] [ebp-10h]

  rcNPC[0].left = 96;
  rcNPC[0].top = 64;
  rcNPC[0].right = 128;
  rcNPC[0].bottom = 88;
  npc->rect = rcNPC[npc->animationNumber];
}

//----- (0042BAE0) --------------------------------------------------------
void __cdecl NPC28_EnemyCritterFlying(NPC *npc)
{
  int v1; // eax
  int v2; // eax
  RECT *v3; // eax
  RECT rcRight[6]; // [esp+4h] [ebp-C0h]
  RECT rcLeft[6]; // [esp+64h] [ebp-60h]

  rcLeft[0].left = 0;
  rcLeft[0].top = 48;
  rcLeft[0].right = 16;
  rcLeft[0].bottom = 64;
  rcLeft[1].left = 16;
  rcLeft[1].top = 48;
  rcLeft[1].right = 32;
  rcLeft[1].bottom = 64;
  rcLeft[2].left = 32;
  rcLeft[2].top = 48;
  rcLeft[2].right = 48;
  rcLeft[2].bottom = 64;
  rcLeft[3].left = 48;
  rcLeft[3].top = 48;
  rcLeft[3].right = 64;
  rcLeft[3].bottom = 64;
  rcLeft[4].left = 64;
  rcLeft[4].top = 48;
  rcLeft[4].right = 80;
  rcLeft[4].bottom = 64;
  rcLeft[5].left = 80;
  rcLeft[5].top = 48;
  rcLeft[5].right = 96;
  rcLeft[5].bottom = 64;
  rcRight[0].left = 0;
  rcRight[0].top = 64;
  rcRight[0].right = 16;
  rcRight[0].bottom = 80;
  rcRight[1].left = 16;
  rcRight[1].top = 64;
  rcRight[1].right = 32;
  rcRight[1].bottom = 80;
  rcRight[2].left = 32;
  rcRight[2].top = 64;
  rcRight[2].right = 48;
  rcRight[2].bottom = 80;
  rcRight[3].left = 48;
  rcRight[3].top = 64;
  rcRight[3].right = 64;
  rcRight[3].bottom = 80;
  rcRight[4].left = 64;
  rcRight[4].top = 64;
  rcRight[4].right = 80;
  rcRight[4].bottom = 80;
  rcRight[5].left = 80;
  rcRight[5].top = 64;
  rcRight[5].right = 96;
  rcRight[5].bottom = 80;
  switch ( npc->currentState )
  {
    case 0:
      npc->YPos += 1536;
      npc->currentState = 1;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( npc->waitTimer < 8
        || npc->XPos - 0x10000 >= quote.XPos
        || npc->XPos + 0x10000 <= quote.XPos
        || npc->YPos - 0x10000 >= quote.YPos
        || npc->YPos + 24576 <= quote.YPos )
      {
        if ( npc->waitTimer < 8 )
          ++npc->waitTimer;
        npc->animationNumber = 0;
      }
      else
      {
        if ( npc->XPos <= quote.XPos )
          npc->direction = 2;
        else
          npc->direction = 0;
        npc->animationNumber = 1;
      }
      if ( npc->isBeingHit )
      {
        npc->currentState = 2;
        npc->animationNumber = 0;
        npc->waitTimer = 0;
      }
      if ( npc->waitTimer >= 8
        && npc->XPos - 49152 < quote.XPos
        && npc->XPos + 49152 > quote.XPos
        && npc->YPos - 49152 < quote.YPos
        && npc->YPos + 24576 > quote.YPos )
      {
        npc->currentState = 2;
        npc->animationNumber = 0;
        npc->waitTimer = 0;
      }
      break;
    case 2:
      if ( ++npc->waitTimer > 8 )
      {
        npc->currentState = 3;
        npc->animationNumber = 2;
        npc->YVel = -1228;
        playSoundEffect(SFXCritterHop, 1);
        if ( npc->XPos <= quote.XPos )
          npc->direction = 2;
        else
          npc->direction = 0;
        if ( npc->direction )
          npc->XVel = 256;
        else
          npc->XVel = -256;
      }
      break;
    case 3:
      if ( npc->YVel > 256 )
      {
        npc->curlyTargetY = npc->YPos;
        npc->currentState = 4;
        npc->animationNumber = 3;
        npc->waitTimer = 0;
        npc->waitTimer = 0;
      }
      break;
    case 4:
      if ( npc->XPos >= quote.XPos )
        npc->direction = 0;
      else
        npc->direction = 2;
      ++npc->waitTimer;
      if ( npc->collisionFlags & 7 || npc->waitTimer > 100 )
      {
        npc->damage = 3;
        npc->currentState = 5;
        npc->animationNumber = 2;
        npc->XVel /= 2;
      }
      else
      {
        if ( npc->waitTimer % 4 == 1 )
          playSoundEffect(SFXCritterFly, 1);
        if ( npc->collisionFlags & 8 )
          npc->YVel = -512;
        if ( ++npc->animationTimer > 0 )
        {
          npc->animationTimer = 0;
          ++npc->animationNumber;
        }
        if ( npc->animationNumber > 5 )
          npc->animationNumber = 3;
      }
      break;
    case 5:
      if ( npc->collisionFlags & 8 )
      {
        npc->damage = 2;
        npc->XVel = 0;
        npc->waitTimer = 0;
        npc->animationNumber = 0;
        npc->currentState = 1;
        playSoundEffect(SFXQuoteHitGround, 1);
      }
      break;
    default:
      break;
  }
  if ( npc->currentState == 4 )
  {
    if ( npc->XPos >= quote.XPos )
      v1 = npc->XVel - 32;
    else
      v1 = npc->XVel + 32;
    npc->XVel = v1;
    if ( npc->YPos <= npc->curlyTargetY )
      v2 = npc->YVel + 16;
    else
      v2 = npc->YVel - 16;
    npc->YVel = v2;
    if ( npc->YVel > 512 )
      npc->YVel = 512;
    if ( npc->YVel < -512 )
      npc->YVel = -512;
    if ( npc->XVel > 512 )
      npc->XVel = 512;
    if ( npc->XVel < -512 )
      npc->XVel = -512;
  }
  else
  {
    npc->YVel += 64;
    if ( npc->YVel > 1535 )
      npc->YVel = 1535;
  }
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  if ( npc->direction )
    v3 = &rcRight[npc->animationNumber];
  else
    v3 = &rcLeft[npc->animationNumber];
  npc->rect = *v3;
}

//----- (0042C1A0) --------------------------------------------------------
void __cdecl NPC29_Cthulhu(NPC *npc)
{
  RECT *v1; // eax
  int currentState; // [esp+0h] [ebp-44h]
  RECT rcRight[2]; // [esp+4h] [ebp-40h]
  RECT rcLeft[2]; // [esp+24h] [ebp-20h]

  rcLeft[0].left = 0;
  rcLeft[0].top = 192;
  rcLeft[0].right = 16;
  rcLeft[0].bottom = 216;
  rcLeft[1].left = 16;
  rcLeft[1].top = 192;
  rcLeft[1].right = 32;
  rcLeft[1].bottom = 216;
  rcRight[0].left = 0;
  rcRight[0].top = 216;
  rcRight[0].right = 16;
  rcRight[0].bottom = 240;
  rcRight[1].left = 16;
  rcRight[1].top = 216;
  rcRight[1].right = 32;
  rcRight[1].bottom = 240;
  currentState = npc->currentState;
  if ( currentState )
  {
    if ( currentState != 1 )
      goto LABEL_11;
  }
  else
  {
    npc->currentState = 1;
    npc->animationNumber = 0;
    npc->animationTimer = 0;
  }
  npc->animationNumber = npc->XPos - 24576 < quote.XPos
                      && npc->XPos + 24576 > quote.XPos
                      && npc->YPos - 24576 < quote.YPos
                      && npc->YPos + 0x2000 > quote.YPos;
LABEL_11:
  if ( npc->direction )
    v1 = &rcRight[npc->animationNumber];
  else
    v1 = &rcLeft[npc->animationNumber];
  npc->rect = *v1;
}

//----- (0042C320) --------------------------------------------------------
void __cdecl NPC30_HermitGunsmith(NPC *npc)
{
  int currentState; // [esp+0h] [ebp-34h]
  RECT rcNPC[3]; // [esp+4h] [ebp-30h]

  rcNPC[0].left = 48;
  rcNPC[0].top = 0;
  rcNPC[0].right = 64;
  rcNPC[0].bottom = 16;
  rcNPC[1].left = 48;
  rcNPC[1].top = 16;
  rcNPC[1].right = 64;
  rcNPC[1].bottom = 32;
  rcNPC[2].left = 0;
  rcNPC[2].top = 32;
  rcNPC[2].right = 16;
  rcNPC[2].bottom = 48;
  if ( npc->direction )
  {
    if ( !npc->currentState )
    {
      npc->currentState = 1;
      npc->YPos += 0x2000;
      npc->animationNumber = 2;
    }
    if ( ++npc->waitTimer > 100 )
    {
      npc->waitTimer = 0;
      createEffect(npc->XPos, npc->YPos - 1024, effectZzZ, 0);
    }
  }
  else
  {
    currentState = npc->currentState;
    if ( currentState )
    {
      if ( currentState != 1 )
      {
        if ( currentState == 2 && ++npc->waitTimer > 8 )
        {
          npc->currentState = 1;
          npc->animationNumber = 0;
        }
        goto LABEL_17;
      }
    }
    else
    {
      npc->currentState = 1;
      npc->animationNumber = 0;
      npc->animationTimer = 0;
    }
    if ( random(0, 120) == 10 )
    {
      npc->currentState = 2;
      npc->waitTimer = 0;
      npc->animationNumber = 1;
    }
  }
LABEL_17:
  npc->rect = rcNPC[npc->animationNumber];
}

//----- (0042C4C0) --------------------------------------------------------
void __cdecl NPC31_EnemyBatBlackHanging(NPC *npc)
{
  RECT *v1; // edx
  RECT rcRight[5]; // [esp+4h] [ebp-A0h]
  RECT rcLeft[5]; // [esp+54h] [ebp-50h]

  rcLeft[0].left = 0;
  rcLeft[0].top = 80;
  rcLeft[0].right = 16;
  rcLeft[0].bottom = 96;
  rcLeft[1].left = 16;
  rcLeft[1].top = 80;
  rcLeft[1].right = 32;
  rcLeft[1].bottom = 96;
  rcLeft[2].left = 32;
  rcLeft[2].top = 80;
  rcLeft[2].right = 48;
  rcLeft[2].bottom = 96;
  rcLeft[3].left = 48;
  rcLeft[3].top = 80;
  rcLeft[3].right = 64;
  rcLeft[3].bottom = 96;
  rcLeft[4].left = 64;
  rcLeft[4].top = 80;
  rcLeft[4].right = 80;
  rcLeft[4].bottom = 96;
  rcRight[0].left = 0;
  rcRight[0].top = 96;
  rcRight[0].right = 16;
  rcRight[0].bottom = 112;
  rcRight[1].left = 16;
  rcRight[1].top = 96;
  rcRight[1].right = 32;
  rcRight[1].bottom = 112;
  rcRight[2].left = 32;
  rcRight[2].top = 96;
  rcRight[2].right = 48;
  rcRight[2].bottom = 112;
  rcRight[3].left = 48;
  rcRight[3].top = 96;
  rcRight[3].right = 64;
  rcRight[3].bottom = 112;
  rcRight[4].left = 64;
  rcRight[4].top = 96;
  rcRight[4].right = 80;
  rcRight[4].bottom = 112;
  switch ( npc->currentState )
  {
    case 0:
      npc->currentState = 1;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( random(0, 120) == 10 )
      {
        npc->currentState = 2;
        npc->waitTimer = 0;
        npc->animationNumber = 1;
      }
      if ( npc->XPos - 4096 < quote.XPos
        && npc->XPos + 4096 > quote.XPos
        && npc->YPos - 4096 < quote.YPos
        && npc->YPos + 49152 > quote.YPos )
      {
        npc->animationNumber = 0;
        npc->currentState = 3;
      }
      break;
    case 2:
      if ( ++npc->waitTimer > 8 )
      {
        npc->currentState = 1;
        npc->animationNumber = 0;
      }
      break;
    case 3:
      npc->animationNumber = 0;
      if ( npc->isBeingHit || npc->XPos - 10240 > quote.XPos || npc->XPos + 10240 < quote.XPos )
      {
        npc->animationNumber = 1;
        npc->animationTimer = 0;
        npc->currentState = 4;
        npc->waitTimer = 0;
      }
      break;
    case 4:
      npc->YVel += 32;
      if ( npc->YVel > 1535 )
        npc->YVel = 1535;
      if ( (++npc->waitTimer >= 20 || npc->collisionFlags & 8)
        && (npc->collisionFlags & 8 || npc->YPos > quote.YPos - 0x2000) )
      {
        npc->animationTimer = 0;
        npc->animationNumber = 2;
        npc->currentState = 5;
        npc->curlyTargetY = npc->YPos;
        if ( npc->collisionFlags & 8 )
          npc->YVel = -512;
      }
      break;
    case 5:
      if ( ++npc->animationTimer > 1 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 4 )
        npc->animationNumber = 2;
      if ( quote.XPos >= npc->XPos )
        npc->direction = 2;
      else
        npc->direction = 0;
      if ( quote.XPos < npc->XPos )
        npc->XVel -= 16;
      if ( quote.XPos > npc->XPos )
        npc->XVel += 16;
      if ( npc->curlyTargetY < npc->YPos )
        npc->YVel -= 16;
      if ( npc->curlyTargetY > npc->YPos )
        npc->YVel += 16;
      if ( npc->XVel > 512 )
        npc->XVel = 512;
      if ( npc->XVel < -512 )
        npc->XVel = -512;
      if ( npc->YVel > 512 )
        npc->YVel = 512;
      if ( npc->YVel < -512 )
        npc->YVel = -512;
      if ( npc->collisionFlags & 8 )
        npc->YVel = -512;
      if ( npc->collisionFlags & 2 )
        npc->YVel = 512;
      break;
    default:
      break;
  }
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  if ( npc->direction )
    v1 = &rcRight[npc->animationNumber];
  else
    v1 = &rcLeft[npc->animationNumber];
  npc->rect = *v1;
}

//----- (0042CA10) --------------------------------------------------------
void __cdecl NPC32_LifeCapsule(NPC *npc)
{
  RECT rcNPC[2]; // [esp+0h] [ebp-20h]

  rcNPC[0].left = 32;
  rcNPC[0].top = 96;
  rcNPC[0].right = 48;
  rcNPC[0].bottom = 112;
  rcNPC[1].left = 48;
  rcNPC[1].top = 96;
  rcNPC[1].right = 64;
  rcNPC[1].bottom = 112;
  if ( ++npc->animationTimer > 2 )
  {
    npc->animationTimer = 0;
    ++npc->animationNumber;
  }
  if ( npc->animationNumber > 1 )
    npc->animationNumber = 0;
  npc->rect = rcNPC[npc->animationNumber];
}

//----- (0042CAC0) --------------------------------------------------------
void __cdecl NPC33_ProjectileBalrogEnergyBounce(NPC *npc)
{
  RECT rcNPC[2]; // [esp+0h] [ebp-20h]

  if ( npc->collisionFlags & 5 )
  {
    createEffect(npc->XPos, npc->YPos, effectRisingDisc, 0);
    npc->isAlive = 0;
  }
  else if ( npc->collisionFlags & 8 )
  {
    npc->YVel = -1024;
  }
  npc->YVel += 42;
  npc->YPos += npc->YVel;
  npc->XPos += npc->XVel;
  rcNPC[0].left = 240;
  rcNPC[0].top = 64;
  rcNPC[0].right = 256;
  rcNPC[0].bottom = 80;
  rcNPC[1].left = 240;
  rcNPC[1].top = 80;
  rcNPC[1].right = 256;
  rcNPC[1].bottom = 96;
  if ( ++npc->animationTimer > 2 )
  {
    npc->animationTimer = 0;
    if ( ++npc->animationNumber > 1 )
      npc->animationNumber = 0;
  }
  npc->rect = rcNPC[npc->animationNumber];
  if ( ++npc->waitTimer > 250 )
  {
    createEffect(npc->XPos, npc->YPos, effectRisingDisc, 0);
    npc->isAlive = 0;                           // NPC suicides after 250 frames
  }
}

//----- (0042CC20) --------------------------------------------------------
void __cdecl NPC34_Bed(NPC *npc)
{
  RECT *npc_Rect; // ecx MAPDST

  if ( npc->direction )
  {
    npc_Rect = &npc->rect;
    npc_Rect->left = 192;
    npc_Rect->top = 184;
    npc_Rect->right = 224;
    npc_Rect->bottom = 200;
  }
  else
  {
    npc_Rect = &npc->rect;
    npc_Rect->left = 192;
    npc_Rect->top = 48;
    npc_Rect->right = 224;
    npc_Rect->bottom = 64;
  }
}

//----- (0042CCB0) --------------------------------------------------------
void __cdecl NPC35_EnemyMannan(NPC *npc)
{
  RECT *v1; // eax
  RECT rcRight[4]; // [esp+4h] [ebp-80h]
  RECT rcLeft[4]; // [esp+44h] [ebp-40h]

  if ( npc->currentState < 3 && npc->life < 90 )
  {
    playSoundEffect(SFXQuoteSmashIntoGround, 1);
    createDustClouds(npc->XPos, npc->YPos, npc->view.back, 8);
    Spawn_Exp(npc->XPos, npc->YPos, npc->EXPAmount);
    npc->currentState = 3;
    npc->waitTimer = 0;
    npc->animationNumber = 2;
    npc->entityFlags &= 0xFFDFu;
    npc->damage = 0;
  }
  switch ( npc->currentState )
  {
    case 0:
    case 1:
      if ( npc->isBeingHit )
      {
        if ( npc->direction )
          createNPC(NPCEnemyBasil|0x60, npc->XPos + 4096, npc->YPos + 4096, 0, 0, (Directions)npc->direction, 0, 256);
        else
          createNPC(NPCEnemyBasil|0x60, npc->XPos - 4096, npc->YPos + 4096, 0, 0, (Directions)npc->direction, 0, 256);
        npc->animationNumber = 1;
        npc->currentState = 2;
        npc->waitTimer = 0;
      }
      break;
    case 2:
      if ( ++npc->waitTimer > 20 )
      {
        npc->waitTimer = 0;
        npc->currentState = 1;
        npc->animationNumber = 0;
      }
      break;
    case 3:
      if ( ++npc->waitTimer == 50 || npc->waitTimer == 60 )
        npc->animationNumber = 3;
      if ( npc->waitTimer == 53 || npc->waitTimer == 63 )
        npc->animationNumber = 2;
      if ( npc->waitTimer > 100 )
        npc->currentState = 4;
      break;
    default:
      break;
  }
  rcLeft[0].left = 96;
  rcLeft[0].top = 64;
  rcLeft[0].right = 120;
  rcLeft[0].bottom = 96;
  rcLeft[1].left = 120;
  rcLeft[1].top = 64;
  rcLeft[1].right = 144;
  rcLeft[1].bottom = 96;
  rcLeft[2].left = 144;
  rcLeft[2].top = 64;
  rcLeft[2].right = 168;
  rcLeft[2].bottom = 96;
  rcLeft[3].left = 168;
  rcLeft[3].top = 64;
  rcLeft[3].right = 192;
  rcLeft[3].bottom = 96;
  rcRight[0].left = 96;
  rcRight[0].top = 96;
  rcRight[0].right = 120;
  rcRight[0].bottom = 128;
  rcRight[1].left = 120;
  rcRight[1].top = 96;
  rcRight[1].right = 144;
  rcRight[1].bottom = 128;
  rcRight[2].left = 144;
  rcRight[2].top = 96;
  rcRight[2].right = 168;
  rcRight[2].bottom = 128;
  rcRight[3].left = 168;
  rcRight[3].top = 96;
  rcRight[3].right = 192;
  rcRight[3].bottom = 128;
  if ( npc->direction )
    v1 = &rcRight[npc->animationNumber];
  else
    v1 = &rcLeft[npc->animationNumber];
  npc->rect = *v1;
}

//----- (0042D010) --------------------------------------------------------
void __cdecl NPC36_BossBalrogHovering(NPC *npc)
{
  int v1; // edx
  int v2; // ST10_4 MAPDST
  int v3; // ST0C_4 MAPDST
  int v4; // ST08_4 MAPDST
  int v5; // eax MAPDST
  RECT *v10; // ecx
  RECT rcRight[6]; // [esp+4h] [ebp-D0h]
  int childYVel; // [esp+64h] [ebp-70h]
  int childXVel; // [esp+68h] [ebp-6Ch]
  RECT rcLeft[6]; // [esp+6Ch] [ebp-68h]
  int i; // [esp+CCh] [ebp-8h]
  unsigned __int8 velRandomiser; // [esp+D3h] [ebp-1h]

  switch ( npc->currentState )
  {
    case 0:
      npc->currentState = 1;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( ++npc->waitTimer > 12 )
      {
        npc->currentState = 2;
        npc->waitTimer = 0;
        npc->count1 = 3;
        npc->animationNumber = 1;
      }
      break;
    case 2:
      if ( ++npc->waitTimer > 16 )
      {
        --npc->count1;
        npc->waitTimer = 0;
        velRandomiser = getArcTan(npc->XPos - quote.XPos, npc->YPos + 2048 - quote.YPos);
        velRandomiser += random(-16, 16);
        childYVel = getSin(velRandomiser);
        childXVel = getCos(velRandomiser);
        createNPC(NPCProjectileBalrogEnemyBounce, npc->XPos, npc->YPos + 2048, childXVel, childYVel, 0, 0, 256);
        playSoundEffect(SFXEnemyShootProjectile, 1);
        if ( !npc->count1 )
        {
          npc->currentState = 3;
          npc->waitTimer = 0;
        }
      }
      break;
    case 3:
      if ( ++npc->waitTimer > 3 )
      {
        npc->currentState = 4;
        npc->waitTimer = 0;
        npc->XVel = (quote.XPos - npc->XPos) / 100;
        npc->YVel = -1536;
        npc->animationNumber = 3;
      }
      break;
    case 4:
      if ( npc->YVel > -512 )
      {
        if ( npc->life <= 60 )
        {
          npc->currentState = 6;
        }
        else
        {
          npc->currentState = 5;
          npc->animationNumber = 4;
          npc->animationTimer = 0;
          npc->waitTimer = 0;
          npc->curlyTargetY = npc->YPos;
        }
      }
      break;
    case 5:
      if ( ++npc->animationTimer > 1 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 5 )
      {
        npc->animationNumber = 4;
        playSoundEffect(SFXStrangeClick, 1);
      }
      if ( ++npc->waitTimer > 100 )
      {
        npc->currentState = 6;
        npc->animationNumber = 3;
      }
      if ( npc->YPos >= npc->curlyTargetY )
        v1 = npc->YVel - 64;
      else
        v1 = npc->YVel + 64;
      npc->YVel = v1;
      if ( npc->YVel < -512 )
        npc->YVel = -512;
      if ( npc->YVel > 512 )
        npc->YVel = 512;
      break;
    case 6:
      if ( npc->YPos + 0x2000 >= quote.YPos )
        npc->damage = 0;
      else
        npc->damage = 10;
      if ( npc->collisionFlags & 8 )
      {
        npc->currentState = 7;
        npc->waitTimer = 0;
        npc->animationNumber = 2;
        playSoundEffect(SFXLargeObjectHitGround, 1);
        playSoundEffect(SFXSillyExplosion, 1);
        setQuake(30);
        npc->damage = 0;
        for ( i = 0; i < 8; ++i )
        {
          v2 = random(-1536, 0);
          v3 = random(-341, 341);
          v4 = npc->YPos + (random(-12, 12) << 9);
          v5 = random(-12, 12);
          createNPC(NPCSmoke, npc->XPos + (v5 << 9), v4, v3, v2, 0, 0, 256);
        }
        for ( i = 0; i < 8; ++i )
        {
          v2 = random(-1024, 0);
          v3 = random(-1024, 1024);
          v4 = npc->YPos + (random(-12, 12) << 9);
          v5 = random(-12, 12);
          createNPC((NPCNames)33, npc->XPos + (v5 << 9), v4, v3, v2, 0, 0, 256);
        }
      }
      break;
    case 7:
      npc->XVel = 0;
      if ( ++npc->waitTimer > 3 )
      {
        npc->currentState = 1;
        npc->waitTimer = 0;
      }
      break;
    default:
      break;
  }
  if ( npc->currentState != 5 )
  {
    npc->YVel += 51;
    if ( npc->XPos >= quote.XPos )
      npc->direction = 0;
    else
      npc->direction = 2;
  }
  if ( npc->YVel > 1535 )
    npc->YVel = 1535;
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  rcLeft[0].left = 0;
  rcLeft[0].top = 0;
  rcLeft[0].right = 40;
  rcLeft[0].bottom = 24;
  rcLeft[1].left = 40;
  rcLeft[1].top = 0;
  rcLeft[1].right = 80;
  rcLeft[1].bottom = 24;
  rcLeft[2].left = 80;
  rcLeft[2].top = 0;
  rcLeft[2].right = 120;
  rcLeft[2].bottom = 24;
  rcLeft[3].left = 120;
  rcLeft[3].top = 0;
  rcLeft[3].right = 160;
  rcLeft[3].bottom = 24;
  rcLeft[4].left = 160;
  rcLeft[4].top = 48;
  rcLeft[4].right = 200;
  rcLeft[4].bottom = 72;
  rcLeft[5].left = 200;
  rcLeft[5].top = 48;
  rcLeft[5].right = 240;
  rcLeft[5].bottom = 72;
  rcRight[0].left = 0;
  rcRight[0].top = 24;
  rcRight[0].right = 40;
  rcRight[0].bottom = 48;
  rcRight[1].left = 40;
  rcRight[1].top = 24;
  rcRight[1].right = 80;
  rcRight[1].bottom = 48;
  rcRight[2].left = 80;
  rcRight[2].top = 24;
  rcRight[2].right = 120;
  rcRight[2].bottom = 48;
  rcRight[3].left = 120;
  rcRight[3].top = 24;
  rcRight[3].right = 160;
  rcRight[3].bottom = 48;
  rcRight[4].left = 160;
  rcRight[4].top = 72;
  rcRight[4].right = 200;
  rcRight[4].bottom = 96;
  rcRight[5].left = 200;
  rcRight[5].top = 72;
  rcRight[5].right = 240;
  rcRight[5].bottom = 96;
  if ( npc->direction )
    v10 = &rcRight[npc->animationNumber];
  else
    v10 = &rcLeft[npc->animationNumber];
  npc->rect = *v10;
}

//----- (0042D760) --------------------------------------------------------
void __cdecl NPC37_Signpost(NPC *npc)
{
  RECT rcNPC[2]; // [esp+0h] [ebp-20h]

  rcNPC[0].left = 192;
  rcNPC[0].top = 64;
  rcNPC[0].right = 208;
  rcNPC[0].bottom = 80;
  rcNPC[1].left = 208;
  rcNPC[1].top = 64;
  rcNPC[1].right = 224;
  rcNPC[1].bottom = 80;
  if ( ++npc->animationTimer > 1 )
  {
    npc->animationTimer = 0;
    ++npc->animationNumber;
  }
  if ( npc->animationNumber > 1 )
    npc->animationNumber = 0;
  npc->rect = rcNPC[npc->animationNumber];
}

//----- (0042D810) --------------------------------------------------------
void __cdecl NPC38_FireplaceFire(NPC *npc)
{
  int currentState; // [esp+0h] [ebp-44h]
  RECT rcNPC[4]; // [esp+4h] [ebp-40h]

  rcNPC[0].left = 128;
  rcNPC[0].top = 64;
  rcNPC[0].right = 144;
  rcNPC[0].bottom = 80;
  rcNPC[1].left = 144;
  rcNPC[1].top = 64;
  rcNPC[1].right = 160;
  rcNPC[1].bottom = 80;
  rcNPC[2].left = 160;
  rcNPC[2].top = 64;
  rcNPC[2].right = 176;
  rcNPC[2].bottom = 80;
  rcNPC[3].left = 176;
  rcNPC[3].top = 64;
  rcNPC[3].right = 192;
  rcNPC[3].bottom = 80;
  currentState = npc->currentState;
  if ( currentState )
  {
    if ( currentState == 10 )
    {
      npc->currentState = 11;
      createDustClouds(npc->XPos, npc->YPos, npc->view.back, 8);
    }
    else if ( currentState != 11 )
    {
      return;
    }
    npc->rect.left = 0;
    npc->rect.right = 0;
    return;
  }
  if ( ++npc->animationTimer > 3 )
  {
    npc->animationTimer = 0;
    ++npc->animationNumber;
  }
  if ( npc->animationNumber > 3 )
    npc->animationNumber = 0;
  npc->rect = rcNPC[npc->animationNumber];
}

//----- (0042D960) --------------------------------------------------------
void __cdecl NPC39(NPC *npc)
{
  RECT Rects[2]; // [esp+0h] [ebp-20h]

  Rects[0].left = 224;
  Rects[0].top = 64;
  Rects[0].right = 240;
  Rects[0].bottom = 80;
  Rects[1].left = 240;
  Rects[1].top = 64;
  Rects[1].right = 256;
  Rects[1].bottom = 80;
  if ( npc->direction )
    npc->animationNumber = 1;
  else
    npc->animationNumber = 0;
  npc->rect = Rects[npc->animationNumber];
}

//----- (0042D9F0) --------------------------------------------------------
void __cdecl NPC40(NPC *npc)
{
  int v1; // eax
  RECT *Chosen_Rect; // eax
  RECT Rects_Right[7]; // [esp+4h] [ebp-E0h]
  RECT Rects_Left[7]; // [esp+74h] [ebp-70h]

  Rects_Left[0].left = 0;
  Rects_Left[0].top = 32;
  Rects_Left[0].right = 16;
  Rects_Left[0].bottom = 48;
  Rects_Left[1].left = 16;
  Rects_Left[1].top = 32;
  Rects_Left[1].right = 32;
  Rects_Left[1].bottom = 48;
  Rects_Left[2].left = 32;
  Rects_Left[2].top = 32;
  Rects_Left[2].right = 48;
  Rects_Left[2].bottom = 48;
  Rects_Left[3].left = 0;
  Rects_Left[3].top = 32;
  Rects_Left[3].right = 16;
  Rects_Left[3].bottom = 48;
  Rects_Left[4].left = 48;
  Rects_Left[4].top = 32;
  Rects_Left[4].right = 64;
  Rects_Left[4].bottom = 48;
  Rects_Left[5].left = 0;
  Rects_Left[5].top = 32;
  Rects_Left[5].right = 16;
  Rects_Left[5].bottom = 48;
  Rects_Left[6].left = 64;
  Rects_Left[6].top = 32;
  Rects_Left[6].right = 80;
  Rects_Left[6].bottom = 48;
  Rects_Right[0].left = 0;
  Rects_Right[0].top = 48;
  Rects_Right[0].right = 16;
  Rects_Right[0].bottom = 64;
  Rects_Right[1].left = 16;
  Rects_Right[1].top = 48;
  Rects_Right[1].right = 32;
  Rects_Right[1].bottom = 64;
  Rects_Right[2].left = 32;
  Rects_Right[2].top = 48;
  Rects_Right[2].right = 48;
  Rects_Right[2].bottom = 64;
  Rects_Right[3].left = 0;
  Rects_Right[3].top = 48;
  Rects_Right[3].right = 16;
  Rects_Right[3].bottom = 64;
  Rects_Right[4].left = 48;
  Rects_Right[4].top = 48;
  Rects_Right[4].right = 64;
  Rects_Right[4].bottom = 64;
  Rects_Right[5].left = 0;
  Rects_Right[5].top = 48;
  Rects_Right[5].right = 16;
  Rects_Right[5].bottom = 64;
  Rects_Right[6].left = 64;
  Rects_Right[6].top = 48;
  Rects_Right[6].right = 80;
  Rects_Right[6].bottom = 64;
  switch ( npc->currentState )
  {
    case 0:
      npc->currentState = 1;
      npc->animationNumber = 0;
      npc->animationTimer = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( random(0, 120) == 10 )
      {
        npc->currentState = 2;
        npc->waitTimer = 0;
        npc->animationNumber = 1;
      }
      if ( npc->XPos - 0x4000 < quote.XPos
        && npc->XPos + 0x4000 > quote.XPos
        && npc->YPos - 0x4000 < quote.YPos
        && npc->YPos + 0x2000 > quote.YPos )
      {
        if ( npc->XPos <= quote.XPos )
          npc->direction = right;
        else
          npc->direction = left;
      }
      break;
    case 2:
      if ( ++npc->waitTimer > 8 )
      {
        npc->currentState = 1;
        npc->animationNumber = 0;
      }
      break;
    case 3:
      npc->currentState = 4;
      npc->animationNumber = 2;
      npc->animationTimer = 0;
      goto LABEL_17;
    case 4:
LABEL_17:
      if ( ++npc->animationTimer > 4 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 5 )
        npc->animationNumber = 2;
      if ( npc->direction )
        v1 = npc->XPos + 512;
      else
        v1 = npc->XPos - 512;
      npc->XPos = v1;
      break;
    case 5:
      npc->animationNumber = 6;
      break;
    default:
      break;
  }
  if ( npc->direction )
    Chosen_Rect = &Rects_Right[npc->animationNumber];
  else
    Chosen_Rect = &Rects_Left[npc->animationNumber];
  npc->rect = *Chosen_Rect;
}

//----- (0042DE00) --------------------------------------------------------
void __cdecl NPC41(NPC *npc)
{
  RECT *npc_Rect; // ecx

  if ( !npc->currentState )
  {
    ++npc->currentState;
    npc->YPos -= 0x2000;
  }
  npc_Rect = &npc->rect;
  npc_Rect->left = 0;
  npc_Rect->top = 80;
  npc_Rect->right = 48;
  npc_Rect->bottom = 112;
}

//----- (0042DE70) --------------------------------------------------------
void __cdecl NPC42(NPC *npc)
{
  RECT *Chosen_Rect; // eax
  RECT Rects_Right[13]; // [esp+4h] [ebp-1A8h]
  int i; // [esp+D8h] [ebp-D4h]
  RECT Rects_Left[13]; // [esp+DCh] [ebp-D0h]

  Rects_Left[0].left = 0;
  Rects_Left[0].top = 0;
  Rects_Left[0].right = 16;
  Rects_Left[0].bottom = 16;
  Rects_Left[1].left = 16;
  Rects_Left[1].top = 0;
  Rects_Left[1].right = 32;
  Rects_Left[1].bottom = 16;
  Rects_Left[2].left = 32;
  Rects_Left[2].top = 0;
  Rects_Left[2].right = 48;
  Rects_Left[2].bottom = 16;
  Rects_Left[3].left = 0;
  Rects_Left[3].top = 0;
  Rects_Left[3].right = 16;
  Rects_Left[3].bottom = 16;
  Rects_Left[4].left = 48;
  Rects_Left[4].top = 0;
  Rects_Left[4].right = 64;
  Rects_Left[4].bottom = 16;
  Rects_Left[5].left = 0;
  Rects_Left[5].top = 0;
  Rects_Left[5].right = 16;
  Rects_Left[5].bottom = 16;
  Rects_Left[6].left = 64;
  Rects_Left[6].top = 0;
  Rects_Left[6].right = 80;
  Rects_Left[6].bottom = 16;
  Rects_Left[7].left = 80;
  Rects_Left[7].top = 32;
  Rects_Left[7].right = 96;
  Rects_Left[7].bottom = 48;
  Rects_Left[8].left = 96;
  Rects_Left[8].top = 32;
  Rects_Left[8].right = 112;
  Rects_Left[8].bottom = 48;
  Rects_Left[9].left = 128;
  Rects_Left[9].top = 32;
  Rects_Left[9].right = 144;
  Rects_Left[9].bottom = 48;
  Rects_Left[10].left = 0;
  Rects_Left[10].top = 0;
  Rects_Left[10].right = 16;
  Rects_Left[10].bottom = 16;
  Rects_Left[11].left = 112;
  Rects_Left[11].top = 32;
  Rects_Left[11].right = 128;
  Rects_Left[11].bottom = 48;
  Rects_Left[12].left = 160;
  Rects_Left[12].top = 32;
  Rects_Left[12].right = 176;
  Rects_Left[12].bottom = 48;
  Rects_Right[0].left = 0;
  Rects_Right[0].top = 16;
  Rects_Right[0].right = 16;
  Rects_Right[0].bottom = 32;
  Rects_Right[1].left = 16;
  Rects_Right[1].top = 16;
  Rects_Right[1].right = 32;
  Rects_Right[1].bottom = 32;
  Rects_Right[2].left = 32;
  Rects_Right[2].top = 16;
  Rects_Right[2].right = 48;
  Rects_Right[2].bottom = 32;
  Rects_Right[3].left = 0;
  Rects_Right[3].top = 16;
  Rects_Right[3].right = 16;
  Rects_Right[3].bottom = 32;
  Rects_Right[4].left = 48;
  Rects_Right[4].top = 16;
  Rects_Right[4].right = 64;
  Rects_Right[4].bottom = 32;
  Rects_Right[5].left = 0;
  Rects_Right[5].top = 16;
  Rects_Right[5].right = 16;
  Rects_Right[5].bottom = 32;
  Rects_Right[6].left = 64;
  Rects_Right[6].top = 16;
  Rects_Right[6].right = 80;
  Rects_Right[6].bottom = 32;
  Rects_Right[7].left = 80;
  Rects_Right[7].top = 48;
  Rects_Right[7].right = 96;
  Rects_Right[7].bottom = 64;
  Rects_Right[8].left = 96;
  Rects_Right[8].top = 48;
  Rects_Right[8].right = 112;
  Rects_Right[8].bottom = 64;
  Rects_Right[9].left = 128;
  Rects_Right[9].top = 48;
  Rects_Right[9].right = 144;
  Rects_Right[9].bottom = 64;
  Rects_Right[10].left = 0;
  Rects_Right[10].top = 16;
  Rects_Right[10].right = 16;
  Rects_Right[10].bottom = 32;
  Rects_Right[11].left = 112;
  Rects_Right[11].top = 48;
  Rects_Right[11].right = 128;
  Rects_Right[11].bottom = 64;
  Rects_Right[12].left = 160;
  Rects_Right[12].top = 48;
  Rects_Right[12].right = 176;
  Rects_Right[12].bottom = 64;
  switch ( npc->currentState )
  {
    case 0:
      npc->currentState = 1;
      npc->animationNumber = 0;
      npc->animationTimer = 0;
      npc->XVel = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( random(0, 120) == 10 )
      {
        npc->currentState = 2;
        npc->waitTimer = 0;
        npc->animationNumber = 1;
      }
      break;
    case 2:
      if ( ++npc->waitTimer > 8 )
      {
        npc->currentState = 1;
        npc->animationNumber = 0;
      }
      break;
    case 3:
      npc->currentState = 4;
      npc->animationNumber = 2;
      npc->animationTimer = 0;
      goto LABEL_10;
    case 4:
LABEL_10:
      if ( ++npc->animationTimer > 4 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 5 )
        npc->animationNumber = 2;
      if ( npc->direction )
        npc->XVel = 512;
      else
        npc->XVel = -512;
      break;
    case 5:
      npc->animationNumber = 6;
      npc->XVel = 0;
      break;
    case 6:
      playSoundEffect(SFXTorokoEnemySqueal, 1);
      npc->waitTimer = 0;
      npc->currentState = 7;
      npc->animationNumber = 7;
      goto LABEL_20;
    case 7:
LABEL_20:
      if ( ++npc->waitTimer > 10 )
        npc->currentState = 0;
      break;
    case 8:
      playSoundEffect(SFXTorokoEnemySqueal, 1);
      npc->waitTimer = 0;
      npc->currentState = 9;
      npc->animationNumber = 7;
      npc->YVel = -512;
      if ( npc->direction )
        npc->XVel = -1024;
      else
        npc->XVel = 1024;
      goto LABEL_26;
    case 9:
LABEL_26:
      if ( ++npc->waitTimer > 3 && npc->collisionFlags & 8 )
      {
        npc->currentState = 10;
        if ( npc->direction )
          npc->direction = 0;
        else
          npc->direction = 2;
      }
      break;
    case 0xA:
      npc->XVel = 0;
      npc->animationNumber = 8;
      break;
    case 0xB:
      npc->currentState = 12;
      npc->waitTimer = 0;
      npc->animationNumber = 9;
      npc->animationTimer = 0;
      npc->XVel = 0;
      goto LABEL_34;
    case 0xC:
LABEL_34:
      if ( ++npc->animationTimer > 8 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 10 )
        npc->animationNumber = 9;
      break;
    case 0xD:
      npc->animationNumber = 11;
      npc->XVel = 0;
      npc->YVel = 0;
      npc->currentState = 14;
      for ( i = 0; i < 512 && NPCObjects[i].entityEventNum != 501; ++i )
        ;
      if ( i == 512 )
      {
        npc->currentState = 0;
      }
      else
      {
        npc->parentNPC = &NPCObjects[i];
LABEL_46:
        if ( npc->parentNPC->direction )
          npc->direction = 0;
        else
          npc->direction = 2;
        if ( npc->parentNPC->direction )
          npc->XPos = npc->parentNPC->XPos + 3072;
        else
          npc->XPos = npc->parentNPC->XPos - 3072;
        npc->YPos = npc->parentNPC->YPos + 2048;
        if ( npc->parentNPC->animationNumber == 2 || npc->parentNPC->animationNumber == 4 )
          npc->YPos -= 512;
      }
      break;
    case 0xE:
      goto LABEL_46;
    case 0xF:
      npc->currentState = 16;
      createNPC((NPCNames)257, npc->XPos + 0x10000, npc->YPos, 0, 0, 0, 0, 0);
      createNPC((NPCNames)257, npc->XPos + 0x10000, npc->YPos, 0, 0, right, 0, 128);
      npc->XVel = 0;
      npc->animationNumber = 0;
      goto LABEL_57;
    case 0x10:
LABEL_57:
      superYPos = npc->XPos - 12288;
      curlyShootY = npc->YPos - 4096;
      break;
    case 0x11:
      npc->XVel = 0;
      npc->animationNumber = 12;
      superYPos = npc->XPos;
      curlyShootY = npc->YPos - 4096;
      break;
    case 0x14:
      npc->currentState = 21;
      npc->animationNumber = 2;
      npc->animationTimer = 0;
      goto LABEL_60;
    case 0x15:
LABEL_60:
      if ( ++npc->animationTimer > 2 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 5 )
        npc->animationNumber = 2;
      if ( npc->direction )
        npc->XVel = 1024;
      else
        npc->XVel = -1024;
      if ( npc->XPos < quote.XPos - 4096 )
      {
        npc->direction = 2;
        npc->currentState = 0;
      }
      break;
    case 0x1E:
      npc->currentState = 31;
      npc->animationNumber = 2;
      npc->animationTimer = 0;
      goto LABEL_71;
    case 0x1F:
LABEL_71:
      if ( ++npc->animationTimer > 2 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 5 )
        npc->animationNumber = 2;
      if ( npc->direction )
        npc->XVel = 1024;
      else
        npc->XVel = -1024;
      break;
    case 0x28:
      npc->currentState = 41;
      npc->animationNumber = 9;
      npc->YVel = -1024;
      break;
    default:
      break;
  }
  if ( npc->currentState != 14 )
  {
    npc->YVel += 64;
    if ( npc->XVel > 1024 )
      npc->XVel = 1024;
    if ( npc->XVel < -1024 )
      npc->XVel = -1024;
    if ( npc->YVel > 1535 )
      npc->YVel = 1535;
    npc->XPos += npc->XVel;
    npc->YPos += npc->YVel;
  }
  if ( npc->direction )
    Chosen_Rect = &Rects_Right[npc->animationNumber];
  else
    Chosen_Rect = &Rects_Left[npc->animationNumber];
  npc->rect = *Chosen_Rect;
}
// 4BBA28: using guessed type int curlyShootY;
// 4BBA30: using guessed type int superYPos;

//----- (0042E9F0) --------------------------------------------------------
void __cdecl NPC43(NPC *npc)
{
  RECT *npc_Rect; // ecx

  if ( !npc->currentState )
  {
    npc->currentState = 1;
    npc->YPos -= 0x2000;
  }
  if ( npc->direction )
  {
    npc_Rect = &npc->rect;
    npc_Rect->left = 168;
    npc_Rect->top = 80;
    npc_Rect->right = 208;
  }
  else
  {
    npc_Rect = &npc->rect;
    npc_Rect->left = 128;
    npc_Rect->top = 80;
    npc_Rect->right = 168;
  }
  npc_Rect->bottom = 112;
}

//----- (0042EAB0) --------------------------------------------------------
void __cdecl NPC44(NPC *npc)
{
  RECT *v1; // eax
  signed int i; // [esp+4h] [ebp-64h]
  RECT Rects_Right[3]; // [esp+8h] [ebp-60h]
  RECT Rects_Left[3]; // [esp+38h] [ebp-30h]

  Rects_Right[0].left = 0;
  Rects_Right[0].top = 0;
  Rects_Right[0].right = 32;
  Rects_Right[0].bottom = 32;
  Rects_Right[1].left = 32;
  Rects_Right[1].top = 0;
  Rects_Right[1].right = 64;
  Rects_Right[1].bottom = 32;
  Rects_Right[2].left = 64;
  Rects_Right[2].top = 0;
  Rects_Right[2].right = 96;
  Rects_Right[2].bottom = 32;
  Rects_Left[0].left = 0;
  Rects_Left[0].top = 0;
  Rects_Left[0].right = 32;
  Rects_Left[0].bottom = 32;
  Rects_Left[1].left = 96;
  Rects_Left[1].top = 0;
  Rects_Left[1].right = 128;
  Rects_Left[1].bottom = 32;
  Rects_Left[2].left = 128;
  Rects_Left[2].top = 0;
  Rects_Left[2].right = 160;
  Rects_Left[2].bottom = 32;
  switch ( npc->currentState )
  {
    case 0:
      npc->currentState = 1;
      goto LABEL_3;
    case 1:
LABEL_3:
      npc->animationNumber = 0;
      if ( npc->direction )
        npc->currentState = 2;
      else
        npc->currentState = 8;
      goto LABEL_6;
    case 2:
LABEL_6:
      npc->YVel += 32;
      if ( npc->YVel > 0 && npc->collisionFlags & 8 )
      {
        npc->YVel = -256;
        npc->XVel += 256;
      }
      if ( npc->collisionFlags & 4 )
        npc->currentState = 3;
      break;
    case 3:
      npc->XVel += 32;
      if ( npc->XVel > 0 && npc->collisionFlags & 4 )
      {
        npc->XVel = -256;
        npc->YVel -= 256;
      }
      if ( npc->collisionFlags & 2 )
        npc->currentState = 4;
      break;
    case 4:
      npc->YVel -= 32;
      if ( npc->YVel < 0 && npc->collisionFlags & 2 )
      {
        npc->YVel = 256;
        npc->XVel -= 256;
      }
      if ( npc->collisionFlags & 1 )
        npc->currentState = 5;
      break;
    case 5:
      npc->XVel -= 32;
      if ( npc->XVel < 0 && npc->collisionFlags & 1 )
      {
        npc->XVel = 256;
        npc->YVel += 256;
      }
      if ( npc->collisionFlags & 8 )
        npc->currentState = 2;
      break;
    case 6:
      npc->YVel += 32;
      if ( npc->YVel > 0 && npc->collisionFlags & 8 )
      {
        npc->YVel = -256;
        npc->XVel -= 256;
      }
      if ( npc->collisionFlags & 1 )
        npc->currentState = 7;
      break;
    case 7:
      npc->XVel -= 32;
      if ( npc->XVel < 0 && npc->collisionFlags & 1 )
      {
        npc->XVel = 256;
        npc->YVel -= 256;
      }
      if ( npc->collisionFlags & 2 )
        npc->currentState = 8;
      break;
    case 8:
      npc->YVel -= 32;
      if ( npc->YVel < 0 && npc->collisionFlags & 2 )
      {
        npc->YVel = 256;
        npc->XVel += 256;
      }
      if ( npc->collisionFlags & 4 )
        npc->currentState = 9;
      break;
    case 9:
      npc->XVel += 32;
      if ( npc->XVel > 0 && npc->collisionFlags & 4 )
      {
        npc->XVel = -256;
        npc->YVel += 256;
      }
      if ( npc->collisionFlags & 8 )
        npc->currentState = 6;
      break;
    default:
      break;
  }
  if ( npc->life <= 100 )
  {
    for ( i = 0; i < 10; ++i )
      createNPC(NPCForcefield|0x20, npc->XPos, npc->YPos, 0, 0, 0, 0, 256);
    createDustClouds(npc->XPos, npc->YPos, npc->view.back, 8);
    playSoundEffect(SFXSillyExplosion, 1);
    npc->isAlive = 0;
  }
  if ( npc->XVel > 512 )
    npc->XVel = 512;
  if ( npc->XVel < -512 )
    npc->XVel = -512;
  if ( npc->YVel > 512 )
    npc->YVel = 512;
  if ( npc->YVel < -512 )
    npc->YVel = -512;
  if ( npc->isBeingHit )
  {
    npc->XPos += npc->XVel / 2;
    npc->YPos += npc->YVel / 2;
  }
  else
  {
    npc->XPos += npc->XVel;
    npc->YPos += npc->YVel;
  }
  if ( npc->currentState >= 2 && npc->currentState <= 9 && ++npc->animationNumber > 2 )
    npc->animationNumber = 1;
  if ( npc->direction )
    v1 = &Rects_Right[npc->animationNumber];
  else
    v1 = &Rects_Left[npc->animationNumber];
  npc->rect = *v1;
}

//----- (0042F060) --------------------------------------------------------
void __cdecl NPC45(NPC *npc)
{
  int v1; // eax
  int v2; // eax
  RECT *v3; // ecx
  RECT *v4; // edx
  int npc_Current_State; // [esp+0h] [ebp-34h]
  RECT Rects[3]; // [esp+4h] [ebp-30h]

  Rects[0].left = 0;
  Rects[0].top = 32;
  Rects[0].right = 16;
  Rects[0].bottom = 48;
  Rects[1].left = 16;
  Rects[1].top = 32;
  Rects[1].right = 32;
  Rects[1].bottom = 48;
  Rects[2].left = 32;
  Rects[2].top = 32;
  Rects[2].right = 48;
  Rects[2].bottom = 48;
  npc_Current_State = npc->currentState;
  if ( npc_Current_State )
  {
    if ( npc_Current_State <= 0 || npc_Current_State > 2 )
      goto LABEL_14;
  }
  else
  {
    npc->currentState = 2;
    if ( random(0, 1) )
      v1 = random(-512, -256);
    else
      v1 = random(256, 512);
    npc->XVel = v1;
    if ( random(0, 1) )
      v2 = random(-512, -256);
    else
      v2 = random(256, 512);
    npc->YVel = v2;
    npc->XVel2 = npc->XVel;
    npc->YVel2 = npc->YVel;
  }
  if ( ++npc->animationNumber > 2 )
    npc->animationNumber = 1;
LABEL_14:
  if ( npc->XVel2 < 0 && npc->collisionFlags & 1 )
    npc->XVel2 = -npc->XVel2;
  if ( npc->XVel2 > 0 && npc->collisionFlags & 4 )
    npc->XVel2 = -npc->XVel2;
  if ( npc->YVel2 < 0 && npc->collisionFlags & 2 )
    npc->YVel2 = -npc->YVel2;
  if ( npc->YVel2 > 0 && npc->collisionFlags & 8 )
    npc->YVel2 = -npc->YVel2;
  if ( npc->XVel2 > 512 )
    npc->XVel2 = 512;
  if ( npc->XVel2 < -512 )
    npc->XVel2 = -512;
  if ( npc->YVel2 > 512 )
    npc->YVel2 = 512;
  if ( npc->YVel2 < -512 )
    npc->YVel2 = -512;
  if ( npc->isBeingHit )
  {
    npc->XPos += npc->XVel2 / 2;
    npc->YPos += npc->YVel2 / 2;
  }
  else
  {
    npc->XPos += npc->XVel2;
    npc->YPos += npc->YVel2;
  }
  v3 = &Rects[npc->animationNumber];
  v4 = &npc->rect;
  v4->left = v3->left;
  v4->top = v3->top;
  v4->right = v3->right;
  v4->bottom = v3->bottom;
}

//----- (0042F320) --------------------------------------------------------
void __cdecl NPC46(NPC *npc)
{
  int v1; // ecx
  int v2; // eax
  RECT *npc_Rect; // edx

  npc->entityFlags |= 0x100u;
  if ( npc->direction )
  {
    if ( npc->YPos >= quote.YPos )
      v2 = npc->YPos - 1535;
    else
      v2 = npc->YPos + 1535;
    npc->YPos = v2;
  }
  else
  {
    if ( npc->XPos >= quote.XPos )
      v1 = npc->XPos - 1535;
    else
      v1 = npc->XPos + 1535;
    npc->XPos = v1;
  }
  npc_Rect = &npc->rect;
  npc_Rect->left = 0;
  npc_Rect->top = 0;
  npc_Rect->right = 16;
  npc_Rect->bottom = 16;
}

//----- (0042F3F0) --------------------------------------------------------
void __cdecl NPC47(NPC *npc)
{
  RECT Rects[5]; // [esp+4h] [ebp-50h]

  switch ( npc->currentState )
  {
    case 0:
      npc->animationNumber = 0;
      npc->currentState = 1;
      npc->waitTimer = 0;
      npc->curlyTargetY = npc->YPos;
      npc->entityFlags &= 0xFFDFu;
      npc->entityFlags &= 0xFFFBu;
      npc->entityFlags &= 0xFFFEu;
      npc->entityFlags &= 0xFFF7u;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( quote.XPos > npc->XPos - 4096
        && quote.XPos < npc->XPos + 4096
        && quote.YPos > npc->YPos
        && quote.YPos < npc->YPos + 4096 )
      {
        npc->currentState = 2;
        npc->waitTimer = 0;
        playSoundEffect(SFXSandCroc, 1);
      }
      if ( npc->XPos < quote.XPos )
        npc->XPos += 1024;
      if ( npc->XPos > quote.XPos )
        npc->XPos -= 1024;
      break;
    case 2:
      if ( ++npc->animationTimer > 3 )
      {
        ++npc->animationNumber;
        npc->animationTimer = 0;
      }
      if ( npc->animationNumber == 3 )
        npc->damage = 10;
      if ( npc->animationNumber == 4 )
      {
        npc->entityFlags |= 0x20u;
        npc->currentState = 3;
        npc->waitTimer = 0;
      }
      break;
    case 3:
      npc->entityFlags |= 1u;
      npc->damage = 0;
      ++npc->waitTimer;
      if ( npc->isBeingHit )
      {
        npc->currentState = 4;
        npc->waitTimer = 0;
      }
      break;
    case 4:
      npc->entityFlags |= 8u;
      npc->YPos += 512;
      if ( ++npc->waitTimer == 32 )
      {
        npc->entityFlags &= 0xFFFEu;
        npc->entityFlags &= 0xFFDFu;
        npc->currentState = 5;
        npc->waitTimer = 0;
      }
      break;
    case 5:
      if ( npc->waitTimer >= 100 )
      {
        npc->YPos = npc->curlyTargetY;
        npc->animationNumber = 0;
        npc->currentState = 0;
      }
      else
      {
        ++npc->waitTimer;
      }
      break;
    default:
      break;
  }
  Rects[0].left = 0;
  Rects[0].top = 48;
  Rects[0].right = 48;
  Rects[0].bottom = 80;
  Rects[1].left = 48;
  Rects[1].top = 48;
  Rects[1].right = 96;
  Rects[1].bottom = 80;
  Rects[2].left = 96;
  Rects[2].top = 48;
  Rects[2].right = 144;
  Rects[2].bottom = 80;
  Rects[3].left = 144;
  Rects[3].top = 48;
  Rects[3].right = 192;
  Rects[3].bottom = 80;
  Rects[4].left = 192;
  Rects[4].top = 48;
  Rects[4].right = 240;
  Rects[4].bottom = 80;
  npc->rect = Rects[npc->animationNumber];
}

//----- (0042F780) --------------------------------------------------------
void __cdecl NPC48(NPC *npc)
{
  RECT *v1; // edx MAPDST
  RECT Rects_Right[2]; // [esp+0h] [ebp-40h]
  RECT Rects_Left[2]; // [esp+20h] [ebp-20h]

  if ( npc->collisionFlags & 1 && npc->XVel < 0 )
  {
    npc->XVel = -npc->XVel;
  }
  else if ( npc->collisionFlags & 4 && npc->XVel > 0 )
  {
    npc->XVel = -npc->XVel;
  }
  else if ( npc->collisionFlags & 8 )
  {
    if ( ++npc->count1 <= 2 && npc->direction != 2 )
    {
      npc->YVel = -256;
    }
    else
    {
      Vanish_NPC(npc);
      createEffect(npc->XPos, npc->YPos, effectRisingDisc, 0);
    }
  }
  if ( npc->direction == 2 )
  {
    npc->entityFlags &= 0xFFDFu;
    npc->entityFlags |= 4u;
  }
  npc->YVel += 5;
  npc->YPos += npc->YVel;
  npc->XPos += npc->XVel;
  Rects_Left[0].left = 288;
  Rects_Left[0].top = 88;
  Rects_Left[0].right = 304;
  Rects_Left[0].bottom = 104;
  Rects_Left[1].left = 304;
  Rects_Left[1].top = 88;
  Rects_Left[1].right = 320;
  Rects_Left[1].bottom = 104;
  Rects_Right[0].left = 288;
  Rects_Right[0].top = 104;
  Rects_Right[0].right = 304;
  Rects_Right[0].bottom = 120;
  Rects_Right[1].left = 304;
  Rects_Right[1].top = 104;
  Rects_Right[1].right = 320;
  Rects_Right[1].bottom = 120;
  if ( ++npc->animationTimer > 2 )
  {
    npc->animationTimer = 0;
    if ( ++npc->animationNumber > 1 )
      npc->animationNumber = 0;
  }
  if ( ++npc->waitTimer > 750 )
  {
    createEffect(npc->XPos, npc->YPos, effectRisingDisc, 0);
    npc->isAlive = 0;
  }
  if ( npc->direction )
    v1 = &Rects_Right[npc->animationNumber];
  else
    v1 = &Rects_Left[npc->animationNumber];
  v1 = &npc->rect;
  v1->left = v1->left;
  v1->top = v1->top;
  v1->right = v1->right;
  v1->bottom = v1->bottom;
}

//----- (0042F9E0) --------------------------------------------------------
void __cdecl NPC49(NPC *npc)
{
  int Y_Vel; // ST24_4
  RECT *v2; // eax
  RECT *v3; // ecx
  RECT Rects_Right[3]; // [esp+8h] [ebp-68h]
  int v5; // [esp+38h] [ebp-38h]
  RECT Rects_Left[3]; // [esp+3Ch] [ebp-34h]
  unsigned __int8 v7; // [esp+6Fh] [ebp-1h]

  if ( npc->currentState >= 10 && npc->parentNPC->entityType == 3 )
  {
    npc->currentState = 3;
    npc->XVel = 0;
    npc->YVel = 0;
    npc->count2 = 1;
  }
  if ( npc->collisionFlags & 1 )
  {
    npc->direction = 2;
    npc->XVel = 256;
  }
  if ( npc->collisionFlags & 4 )
  {
    npc->direction = 0;
    npc->XVel = -256;
  }
  switch ( npc->currentState )
  {
    case 0:
      if ( npc->parentNPC )
        npc->currentState = 10;
      else
        npc->currentState = 1;
      goto LABEL_12;
    case 1:
LABEL_12:
      if ( ++npc->waitTimer > 3 )
      {
        npc->YVel = -1024;
        npc->currentState = 3;
        npc->animationNumber = 2;
        if ( npc->count2 )
        {
          if ( npc->direction )
            npc->XVel = 512;
          else
            npc->XVel = -512;
        }
        else if ( npc->direction )
        {
          npc->XVel = 256;
        }
        else
        {
          npc->XVel = -256;
        }
      }
      npc->animationNumber = 1;
      break;
    case 3:
      if ( npc->collisionFlags & 8 )
      {
        npc->currentState = 1;
        npc->waitTimer = 0;
        npc->XVel = 0;
      }
      if ( npc->collisionFlags & 8 || npc->YVel > 0 )
        npc->animationNumber = 1;
      else
        npc->animationNumber = 2;
      break;
    case 0xA:
      if ( npc->count1 >= 50 )
      {
        if ( npc->XPos - 0x10000 < quote.XPos
          && npc->XPos + 0x10000 > quote.XPos
          && npc->YPos - 49152 < quote.YPos
          && npc->YPos + 49152 > quote.YPos )
        {
          npc->currentState = 11;
          npc->waitTimer = 0;
          npc->animationNumber = 2;
        }
      }
      else
      {
        ++npc->count1;
      }
      break;
    case 0xB:
      if ( ++npc->waitTimer == 30 || npc->waitTimer == 35 )
      {
        v7 = getArcTan(npc->XPos - quote.XPos, npc->YPos + 2048 - quote.YPos);
        Y_Vel = 2 * getSin(v7);
        v5 = 2 * getCos(v7);
        createNPC((NPCNames)50, npc->XPos, npc->YPos, v5, Y_Vel, 0, 0, 256);
        playSoundEffect(SFXEnemyShootProjectile, 1);
      }
      if ( npc->waitTimer > 50 )
      {
        npc->count1 = 0;
        npc->currentState = 10;
        npc->animationNumber = 1;
      }
      break;
    default:
      break;
  }
  if ( npc->currentState >= 10 )
  {
    npc->XPos = npc->parentNPC->XPos;
    npc->YPos = npc->parentNPC->YPos + 0x2000;
    npc->direction = npc->parentNPC->direction;
    --npc->parentNPC->count1;
  }
  npc->YVel += 64;
  if ( npc->YVel > 1535 )
    npc->YVel = 1535;
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  Rects_Left[0].left = 0;
  Rects_Left[0].top = 80;
  Rects_Left[0].right = 32;
  Rects_Left[0].bottom = 104;
  Rects_Left[1].left = 32;
  Rects_Left[1].top = 80;
  Rects_Left[1].right = 64;
  Rects_Left[1].bottom = 104;
  Rects_Left[2].left = 64;
  Rects_Left[2].top = 80;
  Rects_Left[2].right = 96;
  Rects_Left[2].bottom = 104;
  Rects_Right[0].left = 0;
  Rects_Right[0].top = 104;
  Rects_Right[0].right = 32;
  Rects_Right[0].bottom = 128;
  Rects_Right[1].left = 32;
  Rects_Right[1].top = 104;
  Rects_Right[1].right = 64;
  Rects_Right[1].bottom = 128;
  Rects_Right[2].left = 64;
  Rects_Right[2].top = 104;
  Rects_Right[2].right = 96;
  Rects_Right[2].bottom = 128;
  if ( npc->direction )
    v2 = &Rects_Right[npc->animationNumber];
  else
    v2 = &Rects_Left[npc->animationNumber];
  v3 = &npc->rect;
  v3->left = v2->left;
  v3->top = v2->top;
  v3->right = v2->right;
  v3->bottom = v2->bottom;
}

//----- (0042FEC0) --------------------------------------------------------
void __cdecl NPC50(NPC *npc)
{
  RECT *v1; // edx MAPDST
  int npc_Current_State; // [esp+0h] [ebp-44h]
  RECT Rects[4]; // [esp+4h] [ebp-40h]

  npc_Current_State = npc->currentState;
  if ( npc_Current_State )
  {
    if ( npc_Current_State != 1 )
    {
      if ( npc_Current_State == 2 )
      {
        npc->YVel += 64;
        npc->XPos += npc->XVel;
        npc->YPos += npc->YVel;
        if ( npc->collisionFlags & 8 )
        {
          if ( ++npc->count1 > 1 )
          {
            createEffect(npc->XPos, npc->YPos, effectRisingDisc, 0);
            npc->isAlive = 0;
          }
        }
      }
      goto LABEL_19;
    }
  }
  else if ( npc->direction == 2 )
  {
    npc->currentState = 2;
  }
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  if ( npc->collisionFlags & 1 )
  {
    npc->currentState = 2;
    npc->XVel = 512;
    ++npc->count1;
  }
  if ( npc->collisionFlags & 4 )
  {
    npc->currentState = 2;
    npc->XVel = -512;
    ++npc->count1;
  }
  if ( npc->collisionFlags & 2 )
  {
    npc->currentState = 2;
    npc->YVel = 512;
    ++npc->count1;
  }
  if ( npc->collisionFlags & 8 )
  {
    npc->currentState = 2;
    npc->YVel = -512;
    ++npc->count1;
  }
LABEL_19:
  if ( npc->YVel > 1535 )
    npc->YVel = 1535;
  if ( npc->YVel < -1535 )
    npc->YVel = -1535;
  Rects[0].left = 48;
  Rects[0].top = 32;
  Rects[0].right = 64;
  Rects[0].bottom = 48;
  Rects[1].left = 64;
  Rects[1].top = 32;
  Rects[1].right = 80;
  Rects[1].bottom = 48;
  Rects[2].left = 80;
  Rects[2].top = 32;
  Rects[2].right = 96;
  Rects[2].bottom = 48;
  Rects[3].left = 96;
  Rects[3].top = 32;
  Rects[3].right = 112;
  Rects[3].bottom = 48;
  if ( npc->direction )
  {
    if ( ++npc->animationTimer > 1 )
    {
      npc->animationTimer = 0;
      --npc->animationNumber;
    }
    if ( npc->animationNumber < 0 )
      npc->animationNumber = 3;
  }
  else
  {
    if ( ++npc->animationTimer > 1 )
    {
      npc->animationTimer = 0;
      ++npc->animationNumber;
    }
    if ( npc->animationNumber > 3 )
      npc->animationNumber = 0;
  }
  v1 = &Rects[npc->animationNumber];
  v1 = &npc->rect;
  v1->left = v1->left;
  v1->top = v1->top;
  v1->right = v1->right;
  v1->bottom = v1->bottom;
}

//----- (004301B0) --------------------------------------------------------
void __cdecl NPC51(NPC *npc)
{
  RECT *v1; // eax
  int npc_Current_State; // [esp+0h] [ebp-A4h]
  RECT Rects_Right[5]; // [esp+4h] [ebp-A0h]
  RECT Rects_Left[5]; // [esp+54h] [ebp-50h]

  npc_Current_State = npc->currentState;
  if ( npc_Current_State )
  {
    if ( npc_Current_State != 1 )
    {
      if ( npc_Current_State == 2 )
      {
        if ( quote.XPos >= npc->XPos )
          npc->direction = 2;
        else
          npc->direction = 0;
        if ( npc->YPos <= quote.YPos + 0x4000 )
        {
          if ( quote.XPos < npc->XPos )
            npc->XVel -= 16;
          if ( quote.XPos > npc->XPos )
            npc->XVel += 16;
        }
        else
        {
          if ( quote.XPos < npc->XPos )
            npc->XVel += 16;
          if ( quote.XPos > npc->XPos )
            npc->XVel -= 16;
        }
        if ( quote.YPos < npc->YPos )
          npc->YVel -= 16;
        if ( quote.YPos > npc->YPos )
          npc->YVel += 16;
        if ( npc->isBeingHit )
        {
          npc->YVel += 32;
          npc->XVel = 0;
        }
      }
      goto LABEL_45;
    }
  }
  else
  {
    if ( npc->XPos - 163840 >= quote.XPos
      || npc->XPos + 163840 <= quote.XPos
      || npc->YPos - 163840 >= quote.YPos
      || npc->YPos + 163840 <= quote.YPos )
    {
      goto LABEL_45;
    }
    npc->curlyTargetX = npc->XPos;
    npc->curlyTargetY = npc->YPos;
    npc->direction;
    npc->YVel = 1024;
    npc->currentState = 1;
    createNPC((NPCNames)49, 0, 0, 0, 0, 0, npc, 0);
  }
  if ( quote.XPos >= npc->XPos )
    npc->direction = 2;
  else
    npc->direction = 0;
  if ( npc->curlyTargetY < npc->YPos )
    npc->YVel -= 10;
  if ( npc->curlyTargetY > npc->YPos )
    npc->YVel += 10;
  if ( npc->YVel > 512 )
    npc->YVel = 512;
  if ( npc->YVel < -512 )
    npc->YVel = -512;
  if ( npc->count1 >= 10 )
    npc->currentState = 2;
  else
    ++npc->count1;
LABEL_45:
  if ( npc->XVel < 0 && npc->collisionFlags & 1 )
    npc->XVel = 256;
  if ( npc->XVel > 0 && npc->collisionFlags & 4 )
    npc->XVel = -256;
  if ( npc->YVel < 0 && npc->collisionFlags & 2 )
    npc->YVel = 256;
  if ( npc->YVel > 0 && npc->collisionFlags & 8 )
    npc->YVel = -256;
  if ( npc->XVel > 1024 )
    npc->XVel = 1024;
  if ( npc->XVel < -1024 )
    npc->XVel = -1024;
  if ( npc->YVel > 512 )
    npc->YVel = 512;
  if ( npc->YVel < -512 )
    npc->YVel = -512;
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  Rects_Left[0].left = 96;
  Rects_Left[0].top = 80;
  Rects_Left[0].right = 128;
  Rects_Left[0].bottom = 112;
  Rects_Left[1].left = 128;
  Rects_Left[1].top = 80;
  Rects_Left[1].right = 160;
  Rects_Left[1].bottom = 112;
  Rects_Left[2].left = 160;
  Rects_Left[2].top = 80;
  Rects_Left[2].right = 192;
  Rects_Left[2].bottom = 112;
  Rects_Left[3].left = 192;
  Rects_Left[3].top = 80;
  Rects_Left[3].right = 224;
  Rects_Left[3].bottom = 112;
  Rects_Left[4].left = 224;
  Rects_Left[4].top = 80;
  Rects_Left[4].right = 256;
  Rects_Left[4].bottom = 112;
  Rects_Right[0].left = 96;
  Rects_Right[0].top = 112;
  Rects_Right[0].right = 128;
  Rects_Right[0].bottom = 144;
  Rects_Right[1].left = 128;
  Rects_Right[1].top = 112;
  Rects_Right[1].right = 160;
  Rects_Right[1].bottom = 144;
  Rects_Right[2].left = 160;
  Rects_Right[2].top = 112;
  Rects_Right[2].right = 192;
  Rects_Right[2].bottom = 144;
  Rects_Right[3].left = 192;
  Rects_Right[3].top = 112;
  Rects_Right[3].right = 224;
  Rects_Right[3].bottom = 144;
  Rects_Right[4].left = 224;
  Rects_Right[4].top = 112;
  Rects_Right[4].right = 256;
  Rects_Right[4].bottom = 144;
  if ( npc->isBeingHit )
  {
    npc->animationNumber = 4;
  }
  else if ( npc->currentState != 2 || npc->YPos >= quote.YPos - 0x4000 )
  {
    if ( npc->currentState )
    {
      if ( ++npc->animationTimer > 1 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 1 )
        npc->animationNumber = 0;
    }
  }
  else
  {
    npc->animationNumber = 0;
  }
  if ( npc->direction )
    v1 = &Rects_Right[npc->animationNumber];
  else
    v1 = &Rects_Left[npc->animationNumber];
  npc->rect = *v1;
}

//----- (00430780) --------------------------------------------------------
// NPC 52 : Sitting Blue Bot
void __cdecl NPC52_Sitting_Blue_Bot(NPC *npc)
{
  RECT *npc_Rect; // eax

  npc_Rect = &npc->rect;
  npc_Rect->left = 240;
  npc_Rect->top = 96;
  npc_Rect->right = 256;
  npc_Rect->bottom = 112;
}

//----- (004307D0) --------------------------------------------------------
void __cdecl NPC53(NPC *npc)
{
  NPC *npc_Parent_NPC; // esi MAPDST
  RECT *v3; // eax
  RECT *v4; // ecx
  int npc_Current_State; // [esp+0h] [ebp-48h]
  RECT Rects_Right[2]; // [esp+4h] [ebp-44h]
  RECT Rects_Left[2]; // [esp+24h] [ebp-24h]
  unsigned __int8 Parent_Count_Plus_Parent_X_Vel; // [esp+47h] [ebp-1h]

  Rects_Left[0].left = 0;
  Rects_Left[0].top = 128;
  Rects_Left[0].right = 24;
  Rects_Left[0].bottom = 144;
  Rects_Left[1].left = 24;
  Rects_Left[1].top = 128;
  Rects_Left[1].right = 48;
  Rects_Left[1].bottom = 144;
  Rects_Right[0].left = 48;
  Rects_Right[0].top = 128;
  Rects_Right[0].right = 72;
  Rects_Right[0].bottom = 144;
  Rects_Right[1].left = 72;
  Rects_Right[1].top = 128;
  Rects_Right[1].right = 96;
  Rects_Right[1].bottom = 144;
  if ( npc->parentNPC->entityType == 3 )
  {
    Vanish_NPC(npc);
    createDustClouds(npc->XPos, npc->YPos, npc->view.back, 4);
    return;
  }
  npc_Current_State = npc->currentState;
  if ( !npc_Current_State )
  {
    npc->currentState = 1;
    npc->count1 = 10;
LABEL_7:
    if ( !npc->direction && npc->collisionFlags & 0x20 )
    {
      npc->parentNPC->YPos -= 1024;
      npc->parentNPC->YVel -= 256;
    }
    if ( npc->direction == 2 && npc->collisionFlags & 0x10 )
    {
      npc->parentNPC->YPos -= 1024;
      npc->parentNPC->YVel -= 256;
    }
    if ( npc->collisionFlags & 8 )
    {
      npc->parentNPC->YPos -= 1024;
      npc->parentNPC->YVel -= 256;
      if ( npc->parentNPC->direction )
        npc->parentNPC->XVel += 128;
      else
        npc->parentNPC->XVel -= 128;
    }
    Parent_Count_Plus_Parent_X_Vel = LOBYTE(npc->parentNPC->count2) + LOBYTE(npc->XVel);
    npc_Parent_NPC = npc->parentNPC;
    npc->XPos = npc_Parent_NPC->XPos + npc->count1 * getCos(Parent_Count_Plus_Parent_X_Vel);
    npc_Parent_NPC = npc->parentNPC;
    npc->YPos = npc_Parent_NPC->YPos + npc->count1 * getSin(Parent_Count_Plus_Parent_X_Vel);
    npc->direction = npc->parentNPC->direction;
    goto LABEL_18;
  }
  if ( npc_Current_State == 1 )
    goto LABEL_7;
LABEL_18:
  npc->direction = npc->parentNPC->direction;
  npc->animationNumber = (signed int)Parent_Count_Plus_Parent_X_Vel < 20
                      || (signed int)Parent_Count_Plus_Parent_X_Vel > 108;
  if ( npc->direction )
    v3 = &Rects_Right[npc->animationNumber];
  else
    v3 = &Rects_Left[npc->animationNumber];
  v4 = &npc->rect;
  v4->left = v3->left;
  v4->top = v3->top;
  v4->right = v3->right;
  v4->bottom = v3->bottom;
}

//----- (00430B00) --------------------------------------------------------
void __cdecl NPC54(NPC *npc)
{
  RECT *v1; // edx
  int npc_Current_State; // [esp+0h] [ebp-68h]
  RECT Rects_Right[3]; // [esp+4h] [ebp-64h]
  RECT Rects_Left[3]; // [esp+34h] [ebp-34h]
  unsigned __int8 npc_Count2; // [esp+67h] [ebp-1h]

  Rects_Left[0].left = 0;
  Rects_Left[0].top = 80;
  Rects_Left[0].right = 32;
  Rects_Left[0].bottom = 104;
  Rects_Left[1].left = 32;
  Rects_Left[1].top = 80;
  Rects_Left[1].right = 64;
  Rects_Left[1].bottom = 104;
  Rects_Left[2].left = 64;
  Rects_Left[2].top = 80;
  Rects_Left[2].right = 96;
  Rects_Left[2].bottom = 104;
  Rects_Right[0].left = 0;
  Rects_Right[0].top = 104;
  Rects_Right[0].right = 32;
  Rects_Right[0].bottom = 128;
  Rects_Right[1].left = 32;
  Rects_Right[1].top = 104;
  Rects_Right[1].right = 64;
  Rects_Right[1].bottom = 128;
  Rects_Right[2].left = 64;
  Rects_Right[2].top = 104;
  Rects_Right[2].right = 96;
  Rects_Right[2].bottom = 128;
  npc_Current_State = npc->currentState;
  if ( npc_Current_State )
  {
    if ( npc_Current_State != 1 )
    {
      if ( npc_Current_State == 2 )
      {
        ++npc->waitTimer;
        npc->isBeingHit += LOBYTE(npc->waitTimer);
        if ( npc->waitTimer > 50 )
        {
          Vanish_NPC(npc);
          createDustClouds(npc->XPos, npc->YPos, npc->view.back, 8);
          playSoundEffect(SFXSillyExplosion, 1);
        }
      }
      goto LABEL_28;
    }
  }
  else
  {
    createNPC((NPCNames)53, 0, 0, 0, 0, (Directions)npc->direction, npc, 256);
    createNPC((NPCNames)53, 0, 0, 128, 0, (Directions)npc->direction, npc, 0);
    npc->currentState = 1;
    npc->animationNumber = 1;
  }
  npc_Count2 = npc->count2;
  if ( npc->direction )
    npc_Count2 += 6;
  else
    npc_Count2 -= 6;
  npc->count2 = npc_Count2;
  if ( npc->collisionFlags & 8 )
  {
    npc->XVel = 3 * npc->XVel / 4;
    if ( ++npc->waitTimer > 60 )
    {
      npc->currentState = 2;
      npc->waitTimer = 0;
    }
  }
  else
  {
    npc->waitTimer = 0;
  }
  if ( npc->direction || !(npc->collisionFlags & 1) )
  {
    if ( npc->direction == 2 && npc->collisionFlags & 4 )
    {
      if ( ++npc->count1 > 8 )
      {
        npc->direction = 0;
        npc->XVel = -npc->XVel;
      }
    }
    else
    {
      npc->count1 = 0;
    }
  }
  else if ( ++npc->count1 > 8 )
  {
    npc->direction = 2;
    npc->XVel = -npc->XVel;
  }
LABEL_28:
  npc->YVel += 128;
  if ( npc->XVel > 767 )
    npc->XVel = 767;
  if ( npc->XVel < -767 )
    npc->XVel = -767;
  if ( npc->YVel > 767 )
    npc->YVel = 767;
  if ( npc->YVel < -767 )
    npc->YVel = -767;
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  if ( npc->direction )
    v1 = &Rects_Right[npc->animationNumber];
  else
    v1 = &Rects_Left[npc->animationNumber];
  npc->rect = *v1;
}

//----- (00430EB0) --------------------------------------------------------
void __cdecl NPC55(NPC *npc)
{
  int v1; // eax
  RECT *v2; // eax
  RECT Rects_Right[6]; // [esp+4h] [ebp-C0h]
  RECT Rects_Left[6]; // [esp+64h] [ebp-60h]

  Rects_Left[0].left = 192;
  Rects_Left[0].top = 192;
  Rects_Left[0].right = 208;
  Rects_Left[0].bottom = 216;
  Rects_Left[1].left = 208;
  Rects_Left[1].top = 192;
  Rects_Left[1].right = 224;
  Rects_Left[1].bottom = 216;
  Rects_Left[2].left = 192;
  Rects_Left[2].top = 192;
  Rects_Left[2].right = 208;
  Rects_Left[2].bottom = 216;
  Rects_Left[3].left = 224;
  Rects_Left[3].top = 192;
  Rects_Left[3].right = 240;
  Rects_Left[3].bottom = 216;
  Rects_Left[4].left = 192;
  Rects_Left[4].top = 192;
  Rects_Left[4].right = 208;
  Rects_Left[4].bottom = 216;
  Rects_Left[5].left = 240;
  Rects_Left[5].top = 192;
  Rects_Left[5].right = 256;
  Rects_Left[5].bottom = 216;
  Rects_Right[0].left = 192;
  Rects_Right[0].top = 216;
  Rects_Right[0].right = 208;
  Rects_Right[0].bottom = 240;
  Rects_Right[1].left = 208;
  Rects_Right[1].top = 216;
  Rects_Right[1].right = 224;
  Rects_Right[1].bottom = 240;
  Rects_Right[2].left = 192;
  Rects_Right[2].top = 216;
  Rects_Right[2].right = 208;
  Rects_Right[2].bottom = 240;
  Rects_Right[3].left = 224;
  Rects_Right[3].top = 216;
  Rects_Right[3].right = 240;
  Rects_Right[3].bottom = 240;
  Rects_Right[4].left = 192;
  Rects_Right[4].top = 216;
  Rects_Right[4].right = 208;
  Rects_Right[4].bottom = 240;
  Rects_Right[5].left = 240;
  Rects_Right[5].top = 216;
  Rects_Right[5].right = 256;
  Rects_Right[5].bottom = 240;
  switch ( npc->currentState )
  {
    case 0:
      npc->currentState = 1;
      npc->animationNumber = 0;
      npc->animationTimer = 0;
      break;
    case 3:
      npc->currentState = 4;
      npc->animationNumber = 1;
      npc->animationTimer = 0;
      goto LABEL_4;
    case 4:
LABEL_4:
      if ( ++npc->animationTimer > 4 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 4 )
        npc->animationNumber = 1;
      if ( npc->direction )
        v1 = npc->XPos + 512;
      else
        v1 = npc->XPos - 512;
      npc->XPos = v1;
      break;
    case 5:
      npc->animationNumber = 5;
      break;
    default:
      break;
  }
  npc->YVel += 32;
  if ( npc->YVel > 1535 )
    npc->YVel = 1535;
  npc->YPos += npc->YVel;
  if ( npc->direction )
    v2 = &Rects_Right[npc->animationNumber];
  else
    v2 = &Rects_Left[npc->animationNumber];
  npc->rect = *v2;
}

//----- (004311D0) --------------------------------------------------------
void __cdecl NPC56(NPC *npc)
{
  RECT *v1; // edx
  RECT Rects_Right[3]; // [esp+4h] [ebp-60h]
  RECT Rects_Left[3]; // [esp+34h] [ebp-30h]

  Rects_Left[0].left = 0;
  Rects_Left[0].top = 144;
  Rects_Left[0].right = 16;
  Rects_Left[0].bottom = 160;
  Rects_Left[1].left = 16;
  Rects_Left[1].top = 144;
  Rects_Left[1].right = 32;
  Rects_Left[1].bottom = 160;
  Rects_Left[2].left = 32;
  Rects_Left[2].top = 144;
  Rects_Left[2].right = 48;
  Rects_Left[2].bottom = 160;
  Rects_Right[0].left = 0;
  Rects_Right[0].top = 160;
  Rects_Right[0].right = 16;
  Rects_Right[0].bottom = 176;
  Rects_Right[1].left = 16;
  Rects_Right[1].top = 160;
  Rects_Right[1].right = 32;
  Rects_Right[1].bottom = 176;
  Rects_Right[2].left = 32;
  Rects_Right[2].top = 160;
  Rects_Right[2].right = 48;
  Rects_Right[2].bottom = 176;
  switch ( npc->currentState )
  {
    case 0:
      npc->currentState = 1;
      if ( npc->direction )
        npc->currentState = 3;
      else
        npc->currentState = 1;
      break;
    case 1:
      npc->XVel -= 16;
      if ( npc->XVel < -1024 )
        npc->XVel = -1024;
      if ( npc->isBeingHit )
        npc->XPos += npc->XVel / 2;
      else
        npc->XPos += npc->XVel;
      if ( ++npc->animationTimer > 1 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 2 )
        npc->animationNumber = 1;
      if ( npc->collisionFlags & 1 )
      {
        npc->currentState = 2;
        npc->waitTimer = 0;
        npc->animationNumber = 0;
        npc->XVel = 0;
        npc->direction = 2;
      }
      break;
    case 2:
      if ( npc->XPos < quote.XPos
        && npc->XPos > quote.XPos - 0x20000
        && npc->YPos < quote.YPos + 4096
        && npc->YPos > quote.YPos - 4096 )
      {
        npc->currentState = 3;
        npc->animationTimer = 0;
        npc->animationNumber = 1;
      }
      break;
    case 3:
      npc->XVel += 16;
      if ( npc->XVel > 1024 )
        npc->XVel = 1024;
      if ( npc->isBeingHit )
        npc->XPos += npc->XVel / 2;
      else
        npc->XPos += npc->XVel;
      if ( ++npc->animationTimer > 1 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 2 )
        npc->animationNumber = 1;
      if ( npc->collisionFlags & 4 )
      {
        npc->currentState = 4;
        npc->waitTimer = 0;
        npc->animationNumber = 0;
        npc->XVel = 0;
        npc->direction = 0;
      }
      break;
    case 4:
      if ( npc->XPos < quote.XPos + 0x20000
        && npc->XPos > quote.XPos
        && npc->YPos < quote.YPos + 4096
        && npc->YPos > quote.YPos - 4096 )
      {
        npc->currentState = 1;
        npc->animationTimer = 0;
        npc->animationNumber = 1;
      }
      break;
    default:
      break;
  }
  if ( npc->direction )
    v1 = &Rects_Right[npc->animationNumber];
  else
    v1 = &Rects_Left[npc->animationNumber];
  npc->rect = *v1;
}

//----- (004315E0) --------------------------------------------------------
void __cdecl NPC57(NPC *npc)
{
  RECT *v1; // edx
  int npc_Current_State; // [esp+0h] [ebp-ACh]
  RECT Rects_Right[5]; // [esp+4h] [ebp-A8h]
  RECT Rects_Left[5]; // [esp+54h] [ebp-58h]
  unsigned __int8 v5; // [esp+ABh] [ebp-1h]

  npc_Current_State = npc->currentState;
  if ( npc_Current_State )
  {
    if ( npc_Current_State != 1 )
    {
      if ( npc_Current_State == 2 )
      {
        if ( quote.XPos >= npc->XPos )
          npc->direction = 2;
        else
          npc->direction = 0;
        if ( npc->YPos <= quote.YPos + 24576 )
        {
          if ( quote.XPos < npc->XPos )
            npc->XVel -= 16;
          if ( quote.XPos > npc->XPos )
            npc->XVel += 16;
        }
        else
        {
          if ( quote.XPos < npc->XPos )
            npc->XVel += 16;
          if ( quote.XPos > npc->XPos )
            npc->XVel -= 16;
        }
        if ( quote.YPos < npc->YPos )
          npc->YVel -= 16;
        if ( quote.YPos > npc->YPos )
          npc->YVel += 16;
        if ( npc->isBeingHit )
        {
          npc->YVel += 32;
          npc->XVel = 0;
        }
        if ( npc->XVel < 0 && npc->collisionFlags & 1 )
          npc->XVel = 512;
        if ( npc->XVel > 0 && npc->collisionFlags & 4 )
          npc->XVel = -512;
        if ( npc->YVel < 0 && npc->collisionFlags & 2 )
          npc->YVel = 512;
        if ( npc->YVel > 0 && npc->collisionFlags & 8 )
          npc->YVel = -512;
        if ( npc->XVel > 1535 )
          npc->XVel = 1535;
        if ( npc->XVel < -1535 )
          npc->XVel = -1535;
        if ( npc->YVel > 1535 )
          npc->YVel = 1535;
        if ( npc->YVel < -1535 )
          npc->YVel = -1535;
      }
      goto LABEL_70;
    }
  }
  else
  {
    v5 = random(0, 255);
    npc->XVel = getCos(v5);
    npc->curlyTargetX = npc->XPos + 8 * getCos(v5 + 64);
    v5 = random(0, 255);
    npc->YVel = getSin(v5);
    v5 += 64;
    npc->curlyTargetY = npc->YPos + 8 * getSin(v5);
    npc->currentState = 1;
    npc->count1 = 120;
    npc->animationNumber = random(0, 1);
    npc->animationTimer = random(0, 4);
  }
  // npc-->Current_State == 1
  if ( quote.XPos >= npc->XPos )
    npc->direction = 2;
  else
    npc->direction = 0;
  if ( npc->curlyTargetX < npc->XPos )
    npc->XVel -= 16;
  if ( npc->curlyTargetX > npc->XPos )
    npc->XVel += 16;
  if ( npc->curlyTargetY < npc->YPos )
    npc->YVel -= 16;
  if ( npc->curlyTargetY > npc->YPos )
    npc->YVel += 16;
  if ( npc->XVel > 512 )
    npc->XVel = 512;
  if ( npc->XVel < -512 )
    npc->XVel = -512;
  if ( npc->YVel > 512 )
    npc->YVel = 512;
  if ( npc->YVel < -512 )
    npc->YVel = -512;
  if ( npc->isBeingHit )
  {
    npc->currentState = 2;
    npc->waitTimer = 0;
    if ( npc->direction == 2 )
      npc->XVel = -512;
    else
      npc->XVel = 512;
    npc->YVel = 0;
  }
LABEL_70:
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  Rects_Left[0].left = 96;
  Rects_Left[0].top = 80;
  Rects_Left[0].right = 128;
  Rects_Left[0].bottom = 112;
  Rects_Left[1].left = 128;
  Rects_Left[1].top = 80;
  Rects_Left[1].right = 160;
  Rects_Left[1].bottom = 112;
  Rects_Left[2].left = 160;
  Rects_Left[2].top = 80;
  Rects_Left[2].right = 192;
  Rects_Left[2].bottom = 112;
  Rects_Left[3].left = 192;
  Rects_Left[3].top = 80;
  Rects_Left[3].right = 224;
  Rects_Left[3].bottom = 112;
  Rects_Left[4].left = 224;
  Rects_Left[4].top = 80;
  Rects_Left[4].right = 256;
  Rects_Left[4].bottom = 112;
  Rects_Right[0].left = 96;
  Rects_Right[0].top = 112;
  Rects_Right[0].right = 128;
  Rects_Right[0].bottom = 144;
  Rects_Right[1].left = 128;
  Rects_Right[1].top = 112;
  Rects_Right[1].right = 160;
  Rects_Right[1].bottom = 144;
  Rects_Right[2].left = 160;
  Rects_Right[2].top = 112;
  Rects_Right[2].right = 192;
  Rects_Right[2].bottom = 144;
  Rects_Right[3].left = 192;
  Rects_Right[3].top = 112;
  Rects_Right[3].right = 224;
  Rects_Right[3].bottom = 144;
  Rects_Right[4].left = 224;
  Rects_Right[4].top = 112;
  Rects_Right[4].right = 256;
  Rects_Right[4].bottom = 144;
  if ( npc->isBeingHit )
  {
    npc->animationNumber = 4;
  }
  else
  {
    if ( ++npc->animationTimer > 1 )
    {
      npc->animationTimer = 0;
      ++npc->animationNumber;
    }
    if ( npc->animationNumber > 1 )
      npc->animationNumber = 0;
  }
  if ( npc->direction )
    v1 = &Rects_Right[npc->animationNumber];
  else
    v1 = &Rects_Left[npc->animationNumber];
  npc->rect = *v1;
}

//----- (00431C20) --------------------------------------------------------
void __cdecl NPC58(NPC *npc)
{
  int v1; // eax
  unsigned __int8 v2; // ST2F_1
  unsigned __int8 v3; // ST2F_1
  int Y_Vel; // ST24_4
  int X_Vel; // ST28_4
  RECT *v6; // edx
  int npc_Current_State; // [esp+0h] [ebp-70h]
  RECT Rects_Right[3]; // [esp+10h] [ebp-60h]
  RECT Rects_Left[3]; // [esp+40h] [ebp-30h]

  Rects_Left[0].left = 192;
  Rects_Left[0].top = 0;
  Rects_Left[0].right = 216;
  Rects_Left[0].bottom = 24;
  Rects_Left[1].left = 216;
  Rects_Left[1].top = 0;
  Rects_Left[1].right = 240;
  Rects_Left[1].bottom = 24;
  Rects_Left[2].left = 240;
  Rects_Left[2].top = 0;
  Rects_Left[2].right = 264;
  Rects_Left[2].bottom = 24;
  Rects_Right[0].left = 192;
  Rects_Right[0].top = 24;
  Rects_Right[0].right = 216;
  Rects_Right[0].bottom = 48;
  Rects_Right[1].left = 216;
  Rects_Right[1].top = 24;
  Rects_Right[1].right = 240;
  Rects_Right[1].bottom = 48;
  Rects_Right[2].left = 240;
  Rects_Right[2].top = 24;
  Rects_Right[2].right = 264;
  Rects_Right[2].bottom = 48;
  npc_Current_State = npc->currentState;
  if ( npc_Current_State )
  {
    if ( npc_Current_State != 1 )
      goto LABEL_59;
    if ( npc->XPos <= quote.XPos )
    {
      npc->direction = 2;
      npc->XVel += 16;
    }
    else
    {
      npc->direction = 0;
      npc->XVel -= 16;
    }
    if ( npc->collisionFlags & 1 )
      npc->XVel = 512;
    if ( npc->collisionFlags & 4 )
      npc->XVel = -512;
    if ( npc->YPos >= npc->curlyTargetY )
      v1 = npc->YVel - 8;
    else
      v1 = npc->YVel + 8;
    npc->YVel = v1;
    if ( npc->XVel > 767 )
      npc->XVel = 767;
    if ( npc->XVel < -767 )
      npc->XVel = -767;
    if ( npc->YVel > 256 )
      npc->YVel = 256;
    if ( npc->YVel < -256 )
      npc->YVel = -256;
    if ( npc->isBeingHit )
    {
      npc->XPos += npc->XVel / 2;
      npc->YPos += npc->YVel / 2;
    }
    else
    {
      npc->XPos += npc->XVel;
      npc->YPos += npc->YVel;
    }
    if ( quote.XPos <= npc->XPos + 204800 && quote.XPos >= npc->XPos - 204800 )
    {
LABEL_59:
      if ( npc->currentState )
      {
        if ( npc->waitTimer < 150 )
          ++npc->waitTimer;
        if ( npc->waitTimer == 150 )
        {
          if ( !(++npc->count2 % 8) && npc->XPos < quote.XPos + 81920 && npc->XPos > quote.XPos - 81920 )
          {
            v2 = getArcTan(npc->XPos - quote.XPos, npc->YPos - quote.YPos);
            v3 = random(-6, 6) + v2;
            Y_Vel = 2 * getSin(v3);
            X_Vel = 2 * getCos(v3);
            createNPC((NPCNames)84, npc->XPos, npc->YPos, X_Vel, Y_Vel, 0, 0, 256);
            playSoundEffect(SFXEnemyShootProjectile, 1);
          }
          if ( npc->count2 > 8 )
          {
            npc->waitTimer = 0;
            npc->count2 = 0;
          }
        }
      }
      if ( ++npc->animationTimer > 1 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 1 )
        npc->animationNumber = 0;
      if ( npc->waitTimer > 120 && npc->waitTimer / 2 % 2 == 1 && npc->animationNumber == 1 )
        npc->animationNumber = 2;
      if ( npc->direction )
        v6 = &Rects_Right[npc->animationNumber];
      else
        v6 = &Rects_Left[npc->animationNumber];
      npc->rect = *v6;
    }
    else
    {
      npc->currentState = 0;
      npc->XVel = 0;
      npc->direction = npc->count1;
      npc->XPos = npc->curlyTargetX;
      npc->rect.right = 0;
      npc->damage = 0;
    }
  }
  else if ( quote.XPos >= npc->XPos + 0x2000 || quote.XPos <= npc->XPos - 0x2000 )
  {
    npc->rect.right = 0;
    npc->damage = 0;
    npc->XVel = 0;
    npc->YVel = 0;
    npc->entityFlags &= 0xFFDFu;
  }
  else
  {
    npc->entityFlags |= 0x20u;
    npc->YVel = -256;
    npc->curlyTargetX = npc->XPos;
    npc->curlyTargetY = npc->YPos;
    npc->currentState = 1;
    npc->waitTimer = 0;
    npc->count1 = npc->direction;
    npc->count2 = 0;
    npc->damage = 6;
    if ( npc->direction )
    {
      npc->XPos = quote.XPos - 0x20000;
      npc->XVel = 767;
    }
    else
    {
      npc->XPos = quote.XPos + 0x20000;
      npc->XVel = -767;
    }
  }
}

//----- (004321F0) --------------------------------------------------------
void __cdecl NPC59(NPC *npc)
{
  RECT Rects_Normal[3]; // [esp+4h] [ebp-40h]
  RECT Rect_Hurt; // [esp+34h] [ebp-10h]

  Rects_Normal[0].left = 224;
  Rects_Normal[0].top = 16;
  Rects_Normal[0].right = 240;
  Rects_Normal[0].bottom = 40;
  Rects_Normal[1].left = 208;
  Rects_Normal[1].top = 80;
  Rects_Normal[1].right = 224;
  Rects_Normal[1].bottom = 104;
  Rects_Normal[2].left = 224;
  Rects_Normal[2].top = 80;
  Rects_Normal[2].right = 240;
  Rects_Normal[2].bottom = 104;
  Rect_Hurt.left = 240;
  Rect_Hurt.top = 80;
  Rect_Hurt.right = 256;
  Rect_Hurt.bottom = 104;
  switch ( npc->currentState )
  {
    case 0:
      npc->currentState = 1;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( npc->XPos - 0x8000 < quote.XPos
        && npc->XPos + 0x8000 > quote.XPos
        && npc->YPos - 0x8000 < quote.YPos
        && npc->YPos + 0x8000 > quote.YPos )
      {
        npc->currentState = 2;
        npc->animationTimer = 0;
      }
      break;
    case 2:
      if ( ++npc->animationTimer > 2 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber == 2 )
        npc->currentState = 3;
      break;
    case 3:
      if ( npc->XPos - 0x8000 >= quote.XPos
        || npc->XPos + 0x8000 <= quote.XPos
        || npc->YPos - 0x8000 >= quote.YPos
        || npc->YPos + 0x8000 <= quote.YPos )
      {
        npc->currentState = 4;
        npc->animationTimer = 0;
      }
      break;
    case 4:
      if ( ++npc->animationTimer > 2 )
      {
        npc->animationTimer = 0;
        --npc->animationNumber;
      }
      if ( !npc->animationNumber )
        npc->currentState = 1;
      break;
    default:
      break;
  }
  if ( npc->isBeingHit )
    npc->rect = Rect_Hurt;
  else
    npc->rect = Rects_Normal[npc->animationNumber];
}

//----- (00432460) --------------------------------------------------------
void __cdecl NPC60(NPC *npc)
{
  int v1; // edx
  int v2; // eax
  int v3; // eax
  RECT *v4; // eax
  RECT Rects_Right[8]; // [esp+4h] [ebp-100h]
  RECT Rects_Left[8]; // [esp+84h] [ebp-80h]

  Rects_Left[0].left = 0;
  Rects_Left[0].top = 64;
  Rects_Left[0].right = 16;
  Rects_Left[0].bottom = 80;
  Rects_Left[1].left = 16;
  Rects_Left[1].top = 64;
  Rects_Left[1].right = 32;
  Rects_Left[1].bottom = 80;
  Rects_Left[2].left = 32;
  Rects_Left[2].top = 64;
  Rects_Left[2].right = 48;
  Rects_Left[2].bottom = 80;
  Rects_Left[3].left = 16;
  Rects_Left[3].top = 64;
  Rects_Left[3].right = 32;
  Rects_Left[3].bottom = 80;
  Rects_Left[4].left = 48;
  Rects_Left[4].top = 64;
  Rects_Left[4].right = 64;
  Rects_Left[4].bottom = 80;
  Rects_Left[5].left = 16;
  Rects_Left[5].top = 64;
  Rects_Left[5].right = 32;
  Rects_Left[5].bottom = 80;
  Rects_Left[6].left = 112;
  Rects_Left[6].top = 64;
  Rects_Left[6].right = 128;
  Rects_Left[6].bottom = 80;
  Rects_Left[7].left = 128;
  Rects_Left[7].top = 64;
  Rects_Left[7].right = 144;
  Rects_Left[7].bottom = 80;
  Rects_Right[0].left = 0;
  Rects_Right[0].top = 80;
  Rects_Right[0].right = 16;
  Rects_Right[0].bottom = 96;
  Rects_Right[1].left = 16;
  Rects_Right[1].top = 80;
  Rects_Right[1].right = 32;
  Rects_Right[1].bottom = 96;
  Rects_Right[2].left = 32;
  Rects_Right[2].top = 80;
  Rects_Right[2].right = 48;
  Rects_Right[2].bottom = 96;
  Rects_Right[3].left = 16;
  Rects_Right[3].top = 80;
  Rects_Right[3].right = 32;
  Rects_Right[3].bottom = 96;
  Rects_Right[4].left = 48;
  Rects_Right[4].top = 80;
  Rects_Right[4].right = 64;
  Rects_Right[4].bottom = 96;
  Rects_Right[5].left = 16;
  Rects_Right[5].top = 80;
  Rects_Right[5].right = 32;
  Rects_Right[5].bottom = 96;
  Rects_Right[6].left = 112;
  Rects_Right[6].top = 80;
  Rects_Right[6].right = 128;
  Rects_Right[6].bottom = 96;
  Rects_Right[7].left = 128;
  Rects_Right[7].top = 80;
  Rects_Right[7].right = 144;
  Rects_Right[7].bottom = 96;
  switch ( npc->currentState )
  {
    case 0:
      npc->currentState = 1;
      npc->animationNumber = 0;
      npc->animationTimer = 0;
      npc->XVel = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( random(0, 120) == 10 )
      {
        npc->currentState = 2;
        npc->waitTimer = 0;
        npc->animationNumber = 1;
      }
      if ( npc->XPos - 0x2000 < quote.XPos
        && npc->XPos + 0x2000 > quote.XPos
        && npc->YPos - 0x2000 < quote.YPos
        && npc->YPos + 0x2000 > quote.YPos )
      {
        if ( npc->XPos <= quote.XPos )
          npc->direction = 2;
        else
          npc->direction = 0;
      }
      break;
    case 2:
      if ( ++npc->waitTimer > 8 )
      {
        npc->currentState = 1;
        npc->animationNumber = 0;
      }
      break;
    case 3:
      npc->currentState = 4;
      npc->animationNumber = 1;
      npc->animationTimer = 0;
      goto LABEL_17;
    case 4:
LABEL_17:
      if ( ++npc->animationTimer > 2 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 4 )
        npc->animationNumber = 1;
      if ( npc->collisionFlags & 1 )
      {
        npc->direction = 2;
        npc->XVel = 512;
      }
      if ( npc->collisionFlags & 4 )
      {
        npc->direction = 0;
        npc->XVel = -512;
      }
      if ( npc->direction )
        npc->XVel = 1024;
      else
        npc->XVel = -1024;
      break;
    case 6:
      npc->currentState = 7;
      npc->waitTimer = 0;
      npc->animationNumber = 1;
      npc->animationTimer = 0;
      npc->YVel = -1024;
      goto LABEL_30;
    case 7:
LABEL_30:
      if ( ++npc->animationTimer > 2 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 4 )
        npc->animationNumber = 1;
      if ( npc->direction )
        npc->XVel = 256;
      else
        npc->XVel = -256;
      v1 = npc->waitTimer++;
      if ( v1 && npc->collisionFlags & 8 )
        npc->currentState = 3;
      break;
    case 8:
      npc->animationNumber = 1;
      npc->waitTimer = 0;
      npc->currentState = 9;
      npc->YVel = -512;
      goto LABEL_42;
    case 9:
LABEL_42:
      v2 = npc->waitTimer++;
      if ( v2 && npc->collisionFlags & 8 )
        npc->currentState = 0;
      break;
    case 0xA:
      npc->currentState = 11;
      npc->animationNumber = 6;
      npc->YVel = -1024;
      playSoundEffect(SFXTorokoEnemySqueal, 1);
      if ( npc->direction )
        npc->XVel = 256;
      else
        npc->XVel = -256;
      break;
    case 0xB:
      v3 = npc->waitTimer++;
      if ( v3 && npc->collisionFlags & 8 )
      {
        npc->currentState = 12;
        npc->animationNumber = 7;
        npc->entityFlags |= 0x2000u;
      }
      break;
    case 0xC:
      npc->XVel = 0;
      break;
    default:
      break;
  }
  npc->YVel += 64;
  if ( npc->XVel > 1024 )
    npc->XVel = 1024;
  if ( npc->XVel < -1024 )
    npc->XVel = -1024;
  if ( npc->YVel > 1535 )
    npc->YVel = 1535;
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  if ( npc->direction )
    v4 = &Rects_Right[npc->animationNumber];
  else
    v4 = &Rects_Left[npc->animationNumber];
  npc->rect = *v4;
}

//----- (00432B50) --------------------------------------------------------
void __cdecl NPC61(NPC *npc)
{
  int npc_Wait_Timer; // ecx
  int v2; // ST10_4
  int v3; // ST0C_4
  int v4; // ST08_4
  int v5; // eax
  RECT *v6; // ecx
  RECT Rects_Right[11]; // [esp+4h] [ebp-168h]
  int i; // [esp+B8h] [ebp-B4h]
  RECT Rects_Left[11]; // [esp+BCh] [ebp-B0h]

  Rects_Left[0].left = 224;
  Rects_Left[0].top = 32;
  Rects_Left[0].right = 240;
  Rects_Left[0].bottom = 48;
  Rects_Left[1].left = 240;
  Rects_Left[1].top = 32;
  Rects_Left[1].right = 256;
  Rects_Left[1].bottom = 48;
  Rects_Left[2].left = 256;
  Rects_Left[2].top = 32;
  Rects_Left[2].right = 272;
  Rects_Left[2].bottom = 48;
  Rects_Left[3].left = 272;
  Rects_Left[3].top = 32;
  Rects_Left[3].right = 288;
  Rects_Left[3].bottom = 48;
  Rects_Left[4].left = 288;
  Rects_Left[4].top = 32;
  Rects_Left[4].right = 304;
  Rects_Left[4].bottom = 48;
  Rects_Left[5].left = 224;
  Rects_Left[5].top = 32;
  Rects_Left[5].right = 240;
  Rects_Left[5].bottom = 48;
  Rects_Left[6].left = 304;
  Rects_Left[6].top = 32;
  Rects_Left[6].right = 320;
  Rects_Left[6].bottom = 48;
  Rects_Left[7].left = 224;
  Rects_Left[7].top = 32;
  Rects_Left[7].right = 240;
  Rects_Left[7].bottom = 48;
  Rects_Left[8].left = 272;
  Rects_Left[8].top = 32;
  Rects_Left[8].right = 288;
  Rects_Left[8].bottom = 48;
  Rects_Left[9].left = 0;
  Rects_Left[9].top = 0;
  Rects_Left[9].right = 0;
  Rects_Left[9].bottom = 0;
  Rects_Left[10].left = 112;
  Rects_Left[10].top = 32;
  Rects_Left[10].right = 128;
  Rects_Left[10].bottom = 48;
  Rects_Right[0].left = 224;
  Rects_Right[0].top = 48;
  Rects_Right[0].right = 240;
  Rects_Right[0].bottom = 64;
  Rects_Right[1].left = 240;
  Rects_Right[1].top = 48;
  Rects_Right[1].right = 256;
  Rects_Right[1].bottom = 64;
  Rects_Right[2].left = 256;
  Rects_Right[2].top = 48;
  Rects_Right[2].right = 272;
  Rects_Right[2].bottom = 64;
  Rects_Right[3].left = 272;
  Rects_Right[3].top = 48;
  Rects_Right[3].right = 288;
  Rects_Right[3].bottom = 64;
  Rects_Right[4].left = 288;
  Rects_Right[4].top = 48;
  Rects_Right[4].right = 304;
  Rects_Right[4].bottom = 64;
  Rects_Right[5].left = 224;
  Rects_Right[5].top = 48;
  Rects_Right[5].right = 240;
  Rects_Right[5].bottom = 64;
  Rects_Right[6].left = 304;
  Rects_Right[6].top = 48;
  Rects_Right[6].right = 320;
  Rects_Right[6].bottom = 64;
  Rects_Right[7].left = 224;
  Rects_Right[7].top = 48;
  Rects_Right[7].right = 240;
  Rects_Right[7].bottom = 64;
  Rects_Right[8].left = 272;
  Rects_Right[8].top = 48;
  Rects_Right[8].right = 288;
  Rects_Right[8].bottom = 64;
  Rects_Right[9].left = 0;
  Rects_Right[9].top = 0;
  Rects_Right[9].right = 0;
  Rects_Right[9].bottom = 0;
  Rects_Right[10].left = 112;
  Rects_Right[10].top = 32;
  Rects_Right[10].right = 128;
  Rects_Right[10].bottom = 48;
  switch ( npc->currentState )
  {
    case 0:
      npc->currentState = 1;
      npc->animationNumber = 0;
      npc->animationTimer = 0;
      npc->XVel = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( random(0, 120) == 10 )
      {
        npc->currentState = 2;
        npc->waitTimer = 0;
        npc->animationNumber = 1;
      }
      break;
    case 2:
      if ( ++npc->waitTimer > 8 )
      {
        npc->currentState = 1;
        npc->animationNumber = 0;
      }
      break;
    case 5:
      npc->animationNumber = 3;
      npc->XVel = 0;
      break;
    case 6:
      npc->currentState = 7;
      npc->waitTimer = 0;
      npc->animationTimer = 0;
      npc->YVel = -1024;
      goto LABEL_11;
    case 7:
LABEL_11:
      npc->animationNumber = 2;
      if ( npc->direction )
        npc->XVel = 512;
      else
        npc->XVel = -512;
      npc_Wait_Timer = npc->waitTimer++;
      if ( npc_Wait_Timer && npc->collisionFlags & 8 )
        npc->currentState = 5;
      break;
    case 8:
      npc->currentState = 9;
      npc->animationNumber = 4;
      npc->animationTimer = 0;
      goto LABEL_19;
    case 9:
LABEL_19:
      if ( ++npc->animationTimer > 4 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 7 )
        npc->animationNumber = 4;
      if ( npc->direction )
        npc->XVel = 512;
      else
        npc->XVel = -512;
      break;
    case 0xA:
      npc->currentState = 11;
      npc->animationNumber = 4;
      npc->animationTimer = 0;
      goto LABEL_28;
    case 0xB:
LABEL_28:
      if ( ++npc->animationTimer > 2 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 7 )
        npc->animationNumber = 4;
      if ( npc->direction )
        npc->XVel = 1024;
      else
        npc->XVel = -1024;
      break;
    case 0x14:
      createNPC((NPCNames)145, 0, 0, 0, 0, right, npc, 256);
      npc->animationNumber = 0;
      npc->currentState = 0;
      break;
    case 0x1E:
      npc->currentState = 31;
      npc->waitTimer = 0;
      npc->animationTimer = 0;
      npc->YVel = 0;
      goto LABEL_38;
    case 0x1F:
LABEL_38:
      npc->animationNumber = 2;
      if ( npc->direction )
        npc->XVel = 1536;
      else
        npc->XVel = -1536;
      if ( npc->collisionFlags & 1 )
      {
        npc->direction = 2;
        npc->currentState = 7;
        npc->waitTimer = 0;
        npc->animationTimer = 0;
        npc->YVel = -1024;
        npc->XVel = 512;
        playSoundEffect(SFXQuoteSmashIntoGround, 1);
        createDustClouds(npc->XPos, npc->YPos, 2048, 4);
      }
      break;
    case 0x28:
      npc->currentState = 42;
      npc->waitTimer = 0;
      npc->animationNumber = 8;
      playSoundEffect(SFXTeleport, 1);
      goto LABEL_45;
    case 0x2A:
LABEL_45:
      if ( ++npc->animationNumber > 9 )
        npc->animationNumber = 8;
      if ( ++npc->waitTimer > 100 )
      {
        for ( i = 0; i < 4; ++i )
        {
          v2 = random(-1536, 0);
          v3 = random(-341, 341);
          v4 = npc->YPos + (random(-12, 12) << 9);
          v5 = random(-12, 12);
          createNPC(NPCSmoke, npc->XPos + (v5 << 9), v4, v3, v2, 0, 0, 256);
        }
        npc->currentState = 50;
        npc->entitySpritesheet = 20;
        npc->animationNumber = 10;
      }
      break;
    case 0x3C:
      npc->animationNumber = 6;
      npc->currentState = 61;
      npc->YVel = -1535;
      npc->XVel = 1024;
      npc->count2 = 1;
      break;
    case 0x3D:
      npc->YVel += 64;
      if ( npc->collisionFlags & 8 )
      {
        npc->currentState = 0;
        npc->count2 = 0;
        npc->XVel = 0;
      }
      break;
    default:
      break;
  }
  if ( npc->currentState < 30 || npc->currentState >= 40 )
  {
    npc->YVel += 64;
    if ( npc->XVel > 1024 )
      npc->XVel = 1024;
    if ( npc->XVel < -1024 )
      npc->XVel = -1024;
    if ( npc->YVel > 1535 )
      npc->YVel = 1535;
  }
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  if ( npc->direction )
    v6 = &Rects_Right[npc->animationNumber];
  else
    v6 = &Rects_Left[npc->animationNumber];
  npc->rect = *v6;
}

//----- (004334C0) --------------------------------------------------------
void __cdecl NPC62(NPC *npc)
{
  RECT Rects[3]; // [esp+4h] [ebp-30h]

  Rects[0].left = 272;
  Rects[0].top = 192;
  Rects[0].right = 288;
  Rects[0].bottom = 216;
  Rects[1].left = 288;
  Rects[1].top = 192;
  Rects[1].right = 304;
  Rects[1].bottom = 216;
  Rects[2].left = 304;
  Rects[2].top = 192;
  Rects[2].right = 320;
  Rects[2].bottom = 216;
  switch ( npc->currentState )
  {
    case 0:
      npc->XPos -= 2048;
      npc->YPos += 0x2000;
      npc->currentState = 1;
      npc->animationNumber = 0;
      npc->animationTimer = 0;
      goto case_1;
    case 1:
case_1:
      if ( ++npc->animationTimer > 2 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 1 )
        npc->animationNumber = 0;
      if ( random(0, 80) == 1 )
      {
        npc->currentState = 2;
        npc->waitTimer = 0;
        npc->animationNumber = 1;
      }
      if ( random(0, 120) == 10 )
      {
        npc->currentState = 3;
        npc->waitTimer = 0;
        npc->animationNumber = 2;
      }
      break;
    case 2:
      if ( ++npc->waitTimer > 40 )
      {
        npc->currentState = 3;
        npc->waitTimer = 0;
        npc->animationNumber = 2;
      }
      break;
    case 3:
      if ( ++npc->waitTimer > 80 )
      {
        npc->currentState = 1;
        npc->animationNumber = 0;
      }
      break;
    default:
      break;
  }
  npc->rect = Rects[npc->animationNumber];
}

//----- (004336C0) --------------------------------------------------------
void __cdecl NPC63(NPC *npc)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // ecx
  RECT *v4; // ecx
  RECT Rects_Right[6]; // [esp+4h] [ebp-C0h]
  RECT Rects_Left[6]; // [esp+64h] [ebp-60h]

  Rects_Left[0].left = 64;
  Rects_Left[0].top = 64;
  Rects_Left[0].right = 80;
  Rects_Left[0].bottom = 80;
  Rects_Left[1].left = 80;
  Rects_Left[1].top = 64;
  Rects_Left[1].right = 96;
  Rects_Left[1].bottom = 80;
  Rects_Left[2].left = 64;
  Rects_Left[2].top = 64;
  Rects_Left[2].right = 80;
  Rects_Left[2].bottom = 80;
  Rects_Left[3].left = 96;
  Rects_Left[3].top = 64;
  Rects_Left[3].right = 112;
  Rects_Left[3].bottom = 80;
  Rects_Left[4].left = 112;
  Rects_Left[4].top = 64;
  Rects_Left[4].right = 128;
  Rects_Left[4].bottom = 80;
  Rects_Left[5].left = 128;
  Rects_Left[5].top = 64;
  Rects_Left[5].right = 144;
  Rects_Left[5].bottom = 80;
  Rects_Right[0].left = 64;
  Rects_Right[0].top = 80;
  Rects_Right[0].right = 80;
  Rects_Right[0].bottom = 96;
  Rects_Right[1].left = 80;
  Rects_Right[1].top = 80;
  Rects_Right[1].right = 96;
  Rects_Right[1].bottom = 96;
  Rects_Right[2].left = 64;
  Rects_Right[2].top = 80;
  Rects_Right[2].right = 80;
  Rects_Right[2].bottom = 96;
  Rects_Right[3].left = 96;
  Rects_Right[3].top = 80;
  Rects_Right[3].right = 112;
  Rects_Right[3].bottom = 96;
  Rects_Right[4].left = 112;
  Rects_Right[4].top = 80;
  Rects_Right[4].right = 128;
  Rects_Right[4].bottom = 96;
  Rects_Right[5].left = 128;
  Rects_Right[5].top = 80;
  Rects_Right[5].right = 144;
  Rects_Right[5].bottom = 96;
  switch ( npc->currentState )
  {
    case 0:
      npc->currentState = 1;
      npc->waitTimer = 0;
      npc->animationTimer = 0;
      npc->YVel = -1024;
      goto case_1;
    case 1:
case_1:
      if ( npc->YVel > 0 )
        npc->entityFlags &= 0xFFF7u;
      if ( ++npc->animationTimer > 2 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 3 )
        npc->animationNumber = 0;
      if ( npc->direction )
        npc->XVel = 256;
      else
        npc->XVel = -256;
      v1 = npc->waitTimer++;
      if ( v1 && npc->collisionFlags & 8 )
        npc->currentState = 2;
      break;
    case 2:
      npc->currentState = 3;
      npc->waitTimer = 0;
      npc->animationNumber = 0;
      npc->animationTimer = 0;
      goto case_3;
    case 3:
case_3:
      if ( ++npc->animationTimer > 2 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 3 )
        npc->animationNumber = 0;
      if ( ++npc->waitTimer > 50 )
      {
        npc->waitTimer = 40;
        npc->XVel = -npc->XVel;
        if ( npc->direction )
          npc->direction = 0;
        else
          npc->direction = 2;
      }
      if ( npc->waitTimer > 35 )
        npc->entityFlags |= 0x20u;
      if ( npc->direction )
        v2 = npc->XVel + 64;
      else
        v2 = npc->XVel - 64;
      npc->XVel = v2;
      if ( npc->isBeingHit )
      {
        npc->currentState = 4;
        npc->animationNumber = 4;
        npc->YVel = -1024;
        npc->entityFlags &= 0xFFDFu;
        npc->damage = 0;
      }
      break;
    case 4:
      if ( npc->direction )
        npc->XVel = 256;
      else
        npc->XVel = -256;
      v3 = npc->waitTimer++;
      if ( v3 && npc->collisionFlags & 8 )
      {
        npc->currentState = 5;
        npc->entityFlags |= 0x2000u;
      }
      break;
    case 5:
      npc->XVel = 0;
      npc->animationNumber = 5;
      break;
    default:
      break;
  }
  npc->YVel += 64;
  if ( npc->XVel > 1024 )
    npc->XVel = 1024;
  if ( npc->XVel < -1024 )
    npc->XVel = -1024;
  if ( npc->YVel > 1535 )
    npc->YVel = 1535;
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  if ( npc->direction )
    v4 = &Rects_Right[npc->animationNumber];
  else
    v4 = &Rects_Left[npc->animationNumber];
  npc->rect = *v4;
}

//----- (00433C00) --------------------------------------------------------
void __cdecl NPC64(NPC *npc)
{
  RECT *v1; // edx
  RECT Rects_Right[3]; // [esp+4h] [ebp-60h]
  RECT Rects_Left[3]; // [esp+34h] [ebp-30h]

  Rects_Left[0].left = 0;
  Rects_Left[0].top = 0;
  Rects_Left[0].right = 16;
  Rects_Left[0].bottom = 16;
  Rects_Left[1].left = 16;
  Rects_Left[1].top = 0;
  Rects_Left[1].right = 32;
  Rects_Left[1].bottom = 16;
  Rects_Left[2].left = 32;
  Rects_Left[2].top = 0;
  Rects_Left[2].right = 48;
  Rects_Left[2].bottom = 16;
  Rects_Right[0].left = 0;
  Rects_Right[0].top = 16;
  Rects_Right[0].right = 16;
  Rects_Right[0].bottom = 32;
  Rects_Right[1].left = 16;
  Rects_Right[1].top = 16;
  Rects_Right[1].right = 32;
  Rects_Right[1].bottom = 32;
  Rects_Right[2].left = 32;
  Rects_Right[2].top = 16;
  Rects_Right[2].right = 48;
  Rects_Right[2].bottom = 32;
  switch ( npc->currentState )
  {
    case 0:
      npc->YPos += 1536;
      npc->currentState = 1;
      goto case_1;
    case 1:
case_1:
      if ( npc->XPos <= quote.XPos )
        npc->direction = 2;
      else
        npc->direction = 0;
      if ( npc->curlyTargetX < 100 )
        ++npc->curlyTargetX;
      if ( npc->waitTimer < 8
        || npc->XPos - 57344 >= quote.XPos
        || npc->XPos + 57344 <= quote.XPos
        || npc->YPos - 40960 >= quote.YPos
        || npc->YPos + 40960 <= quote.YPos )
      {
        if ( npc->waitTimer < 8 )
          ++npc->waitTimer;
        npc->animationNumber = 0;
      }
      else
      {
        npc->animationNumber = 1;
      }
      if ( npc->isBeingHit )
      {
        npc->currentState = 2;
        npc->animationNumber = 0;
        npc->waitTimer = 0;
      }
      if ( npc->waitTimer >= 8
        && npc->curlyTargetX >= 100
        && npc->XPos - 0x8000 < quote.XPos
        && npc->XPos + 0x8000 > quote.XPos
        && npc->YPos - 40960 < quote.YPos
        && npc->YPos + 24576 > quote.YPos )
      {
        npc->currentState = 2;
        npc->animationNumber = 0;
        npc->waitTimer = 0;
      }
      break;
    case 2:
      if ( ++npc->waitTimer > 8 )
      {
        npc->currentState = 3;
        npc->animationNumber = 2;
        npc->YVel = -1535;
        playSoundEffect(SFXCritterHop, 1);
        if ( npc->direction )
          npc->XVel = 256;
        else
          npc->XVel = -256;
      }
      break;
    case 3:
      if ( npc->collisionFlags & 8 )
      {
        npc->XVel = 0;
        npc->waitTimer = 0;
        npc->animationNumber = 0;
        npc->currentState = 1;
        playSoundEffect(SFXQuoteHitGround, 1);
      }
      break;
    default:
      break;
  }
  npc->YVel += 64;
  if ( npc->YVel > 1535 )
    npc->YVel = 1535;
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  if ( npc->direction )
    v1 = &Rects_Right[npc->animationNumber];
  else
    v1 = &Rects_Left[npc->animationNumber];
  npc->rect = *v1;
}

//----- (00433FC0) --------------------------------------------------------
void __cdecl NPC65(NPC *npc)
{
  RECT *v1; // edx
  int npc_Current_State; // [esp+0h] [ebp-84h]
  RECT Rects_Right[4]; // [esp+4h] [ebp-80h]
  RECT Rects_Left[4]; // [esp+44h] [ebp-40h]

  npc_Current_State = npc->currentState;
  if ( npc_Current_State )
  {
    if ( npc_Current_State != 1 )
    {
      if ( npc_Current_State == 2 )
      {
        if ( quote.XPos >= npc->XPos )
          npc->direction = 2;
        else
          npc->direction = 0;
        if ( npc->curlyTargetY < npc->YPos )
          npc->YVel -= 16;
        if ( npc->curlyTargetY > npc->YPos )
          npc->YVel += 16;
        if ( npc->YVel > 768 )
          npc->YVel = 768;
        if ( npc->YVel < -768 )
          npc->YVel = -768;
      }
      goto LABEL_19;
    }
  }
  else
  {
    npc->curlyTargetX = npc->XPos;
    npc->curlyTargetY = npc->YPos;
    npc->count1 = 120;
    npc->currentState = 1;
    npc->waitTimer = random(0, 50);
  }
  // npc->Current_State == 1
  if ( ++npc->waitTimer >= 50 )
  {
    npc->waitTimer = 0;
    npc->currentState = 2;
    npc->YVel = 768;
  }
LABEL_19:
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  Rects_Left[0].left = 32;
  Rects_Left[0].top = 32;
  Rects_Left[0].right = 48;
  Rects_Left[0].bottom = 48;
  Rects_Left[1].left = 48;
  Rects_Left[1].top = 32;
  Rects_Left[1].right = 64;
  Rects_Left[1].bottom = 48;
  Rects_Left[2].left = 64;
  Rects_Left[2].top = 32;
  Rects_Left[2].right = 80;
  Rects_Left[2].bottom = 48;
  Rects_Left[3].left = 80;
  Rects_Left[3].top = 32;
  Rects_Left[3].right = 96;
  Rects_Left[3].bottom = 48;
  Rects_Right[0].left = 32;
  Rects_Right[0].top = 48;
  Rects_Right[0].right = 48;
  Rects_Right[0].bottom = 64;
  Rects_Right[1].left = 48;
  Rects_Right[1].top = 48;
  Rects_Right[1].right = 64;
  Rects_Right[1].bottom = 64;
  Rects_Right[2].left = 64;
  Rects_Right[2].top = 48;
  Rects_Right[2].right = 80;
  Rects_Right[2].bottom = 64;
  Rects_Right[3].left = 80;
  Rects_Right[3].top = 48;
  Rects_Right[3].right = 96;
  Rects_Right[3].bottom = 64;
  if ( ++npc->animationTimer > 1 )
  {
    npc->animationTimer = 0;
    ++npc->animationNumber;
  }
  if ( npc->animationNumber > 2 )
    npc->animationNumber = 0;
  if ( npc->direction )
    v1 = &Rects_Right[npc->animationNumber];
  else
    v1 = &Rects_Left[npc->animationNumber];
  npc->rect = *v1;
}

//----- (004342B0) --------------------------------------------------------
void __cdecl NPC66(NPC *npc)
{
  unsigned __int8 Targeting_Thingy; // ST13_1
  RECT *v2; // ecx
  RECT *v3; // edx
  int npc_Current_State; // [esp+0h] [ebp-4Ch]
  int i; // [esp+4h] [ebp-48h]
  RECT Rects[4]; // [esp+Ch] [ebp-40h]

  Rects[0].left = 32;
  Rects[0].top = 192;
  Rects[0].right = 56;
  Rects[0].bottom = 216;
  Rects[1].left = 56;
  Rects[1].top = 192;
  Rects[1].right = 80;
  Rects[1].bottom = 216;
  Rects[2].left = 32;
  Rects[2].top = 216;
  Rects[2].right = 56;
  Rects[2].bottom = 240;
  Rects[3].left = 56;
  Rects[3].top = 216;
  Rects[3].right = 80;
  Rects[3].bottom = 240;
  npc_Current_State = npc->currentState;
  if ( npc_Current_State )
  {
    if ( npc_Current_State != 1 )
    {
      if ( npc_Current_State == 2 )
      {
        npc->XVel -= 32;
        npc->YVel -= 32;
        if ( npc->XVel < -1535 )
          npc->XVel = -1535;
        if ( npc->YVel < -1535 )
          npc->YVel = -1535;
        if ( npc->YPos < -4096 )
          npc->isAlive = 0;
        if ( ++npc->animationTimer > 3 )
        {
          npc->animationTimer = 0;
          ++npc->animationNumber;
        }
        if ( npc->animationNumber > 3 )
          npc->animationNumber = 2;
      }
      goto LABEL_31;
    }
  }
  else
  {
    for ( i = 0; i < 512 && NPCObjects[i].entityEventNum != 1000; ++i )
      ;
    if ( i == 512 )
      goto LABEL_31;
    npc->curlyTargetX = NPCObjects[i].XPos;
    npc->curlyTargetY = NPCObjects[i].YPos;
    npc->count1 = i;
    Targeting_Thingy = getArcTan(npc->XPos - npc->curlyTargetX, npc->YPos - npc->curlyTargetY);
    npc->XVel = 2 * getCos(Targeting_Thingy);
    npc->YVel = 2 * getSin(Targeting_Thingy);
    npc->currentState = 1;
  }
  if ( ++npc->animationTimer > 1 )
  {
    npc->animationTimer = 0;
    ++npc->animationNumber;
  }
  if ( npc->animationNumber > 1 )
    npc->animationNumber = 0;
  if ( npc->XPos - 1536 < npc->curlyTargetX
    && npc->XPos + 1536 > npc->curlyTargetX
    && npc->YPos - 1536 < npc->curlyTargetY
    && npc->YPos + 1536 > npc->curlyTargetY )
  {
    npc->currentState = 2;
    npc->animationNumber = 2;
    NPCObjects[npc->count1].isAlive = 0;
    playSoundEffect(SFXBubble, 1);
  }
LABEL_31:
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  v2 = &Rects[npc->animationNumber];
  v3 = &npc->rect;
  v3->left = v2->left;
  v3->top = v2->top;
  v3->right = v2->right;
  v3->bottom = v2->bottom;
}

//----- (004345E0) --------------------------------------------------------
void __cdecl NPC67(NPC *npc)
{
  RECT *v1; // eax
  RECT Rects_Right[8]; // [esp+4h] [ebp-100h]
  RECT Rects_Left[8]; // [esp+84h] [ebp-80h]

  switch ( npc->currentState )
  {
    case 0:
      npc->currentState = 1;
      npc->curlyTargetX = npc->XPos;
      npc->curlyTargetY = npc->YPos;
      npc->animationNumber = 0;
      playSoundEffect(SFXTeleport, 1);
      goto case_1;
    case 1:
case_1:
      npc->XPos = npc->curlyTargetX + (random(-1, 1) << 9);
      if ( ++npc->waitTimer == 32 )
        npc->currentState = 10;
      break;
    case 10:
      npc->currentState = 11;
      npc->waitTimer = 0;
      npc->animationNumber = 0;
      npc->YVel = 512;
      goto case_11;
    case 11:
case_11:
      if ( npc->curlyTargetY < npc->YPos )
        npc->YVel -= 16;
      if ( npc->curlyTargetY > npc->YPos )
        npc->YVel += 16;
      if ( npc->YVel > 256 )
        npc->YVel = 256;
      if ( npc->YVel < -256 )
        npc->YVel = -256;
      break;
    case 13:
      npc->animationNumber = 1;
      npc->YVel += 64;
      if ( npc->YVel > 1535 )
        npc->YVel = 1535;
      if ( npc->collisionFlags & 8 )
      {
        playSoundEffect(SFXQuoteHitGround, 1);
        npc->YVel = 0;
        npc->currentState = 14;
        npc->entityFlags |= 8u;
        npc->animationNumber = 2;
      }
      break;
    case 15:
      npc->currentState = 16;
      npc->waitTimer = 0;
      npc->animationNumber = 4;
      goto case_16;
    case 16:
case_16:
      if ( ++npc->waitTimer == 30 )
      {
        playSoundEffect(SFXBubble, 1);
        createNPC((NPCNames)66, npc->XPos, npc->YPos - 0x2000, 0, 0, 0, npc, 0);
      }
      if ( npc->waitTimer == 50 )
        npc->currentState = 14;
      break;
    case 20:
      npc->currentState = 21;
      npc->animationNumber = 0;
      npc->YVel = 0;
      npc->entityFlags |= 8u;
      goto case_21;
    case 21:
case_21:
      npc->YVel -= 32;
      if ( npc->YPos < -4096 )
        npc->isAlive = 0;
      break;
    case 25:
      npc->currentState = 26;
      npc->waitTimer = 0;
      npc->animationNumber = 5;
      npc->animationTimer = 0;
      goto case_26;
    case 26:
case_26:
      if ( ++npc->animationNumber > 7 )
        npc->animationNumber = 5;
      if ( ++npc->waitTimer == 30 )
      {
        playSoundEffect(SFXLightning, 1);
        startFlash(0, 0, 2);
        npc->currentState = 27;
        npc->animationNumber = 7;
      }
      break;
    case 27:
      if ( ++npc->waitTimer == 50 )
        npc->currentState = 14;
      break;
    default:
      break;
  }
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  Rects_Left[0].left = 80;
  Rects_Left[0].top = 0;
  Rects_Left[0].right = 96;
  Rects_Left[0].bottom = 16;
  Rects_Left[1].left = 96;
  Rects_Left[1].top = 0;
  Rects_Left[1].right = 112;
  Rects_Left[1].bottom = 16;
  Rects_Left[2].left = 112;
  Rects_Left[2].top = 0;
  Rects_Left[2].right = 128;
  Rects_Left[2].bottom = 16;
  Rects_Left[3].left = 128;
  Rects_Left[3].top = 0;
  Rects_Left[3].right = 144;
  Rects_Left[3].bottom = 16;
  Rects_Left[4].left = 144;
  Rects_Left[4].top = 0;
  Rects_Left[4].right = 160;
  Rects_Left[4].bottom = 16;
  Rects_Left[5].left = 160;
  Rects_Left[5].top = 0;
  Rects_Left[5].right = 176;
  Rects_Left[5].bottom = 16;
  Rects_Left[6].left = 176;
  Rects_Left[6].top = 0;
  Rects_Left[6].right = 192;
  Rects_Left[6].bottom = 16;
  Rects_Left[7].left = 144;
  Rects_Left[7].top = 0;
  Rects_Left[7].right = 160;
  Rects_Left[7].bottom = 16;
  Rects_Right[0].left = 80;
  Rects_Right[0].top = 16;
  Rects_Right[0].right = 96;
  Rects_Right[0].bottom = 32;
  Rects_Right[1].left = 96;
  Rects_Right[1].top = 16;
  Rects_Right[1].right = 112;
  Rects_Right[1].bottom = 32;
  Rects_Right[2].left = 112;
  Rects_Right[2].top = 16;
  Rects_Right[2].right = 128;
  Rects_Right[2].bottom = 32;
  Rects_Right[3].left = 128;
  Rects_Right[3].top = 16;
  Rects_Right[3].right = 144;
  Rects_Right[3].bottom = 32;
  Rects_Right[4].left = 144;
  Rects_Right[4].top = 16;
  Rects_Right[4].right = 160;
  Rects_Right[4].bottom = 32;
  Rects_Right[5].left = 160;
  Rects_Right[5].top = 16;
  Rects_Right[5].right = 176;
  Rects_Right[5].bottom = 32;
  Rects_Right[6].left = 176;
  Rects_Right[6].top = 16;
  Rects_Right[6].right = 192;
  Rects_Right[6].bottom = 32;
  Rects_Right[7].left = 144;
  Rects_Right[7].top = 16;
  Rects_Right[7].right = 160;
  Rects_Right[7].bottom = 32;
  if ( npc->currentState == 11 )
  {
    if ( npc->animationTimer )
    {
      --npc->animationTimer;
      npc->animationNumber = 1;
    }
    else
    {
      if ( random(0, 100) == 1 )
        npc->animationTimer = 30;
      npc->animationNumber = 0;
    }
  }
  if ( npc->currentState == 14 )
  {
    if ( npc->animationTimer )
    {
      --npc->animationTimer;
      npc->animationNumber = 3;
    }
    else
    {
      if ( random(0, 100) == 1 )
        npc->animationTimer = 30;
      npc->animationNumber = 2;
    }
  }
  if ( npc->direction )
    v1 = &Rects_Right[npc->animationNumber];
  else
    v1 = &Rects_Left[npc->animationNumber];
  npc->rect = *v1;
  if ( npc->currentState == 1 && npc->animationTimer < 32 )
    npc->rect.bottom = ++npc->animationTimer / 2 + npc->rect.bottom - 16;
}

//----- (00434D10) --------------------------------------------------------
void __cdecl NPC68(NPC *npc)
{
  int v1; // ecx
  RECT *v2; // eax
  RECT Rects_Right[9]; // [esp+4h] [ebp-120h]
  RECT Rects_Left[9]; // [esp+94h] [ebp-90h]

  switch ( npc->currentState )
  {
    case 0:
      npc->currentState = 1;
      npc->animationNumber = 0;
      npc->waitTimer = 30;
      if ( npc->XPos <= quote.XPos )
        npc->direction = 2;
      else
        npc->direction = 0;
      goto case_1;
    case 1:
case_1:
      if ( !--npc->waitTimer )
      {
        npc->currentState = 2;
        ++npc->count1;
      }
      break;
    case 2:
      npc->currentState = 3;
      npc->waitTimer = 0;
      npc->animationNumber = 1;
      npc->animationTimer = 0;
      goto case_3;
    case 3:
case_3:
      if ( ++npc->animationTimer > 3 )
      {
        npc->animationTimer = 0;
        if ( ++npc->animationNumber == 2 || npc->animationNumber == 4 )
          playSoundEffect(SFXQuoteHitGround, 1);
      }
      if ( npc->animationNumber > 4 )
        npc->animationNumber = 1;
      if ( npc->direction )
        v1 = npc->XVel + 16;
      else
        v1 = npc->XVel - 16;
      npc->XVel = v1;
      if ( npc->waitTimer < 8
        || npc->XPos - 6144 >= quote.XPos
        || npc->XPos + 6144 <= quote.XPos
        || npc->YPos - 6144 >= quote.YPos
        || npc->YPos + 4096 <= quote.YPos )
      {
        ++npc->waitTimer;
        if ( npc->collisionFlags & 5 || npc->waitTimer > 75 )
        {
          npc->currentState = 9;
          npc->animationNumber = 0;
        }
        else if ( !(npc->count1 % 3) && npc->waitTimer > 25 )
        {
          npc->currentState = 4;
          npc->animationNumber = 7;
          npc->YVel = -1024;
        }
      }
      else
      {
        npc->currentState = 10;
        npc->animationNumber = 5;
        quote.flags |= 2u;
        damagePlayer(2);
      }
      break;
    case 4:
      if ( npc->collisionFlags & 8 )
      {
        npc->currentState = 9;
        npc->animationNumber = 8;
        setQuake(30);
        playSoundEffect(SFXLargeObjectHitGround, 1);
      }
      if ( npc->waitTimer >= 8
        && npc->XPos - 6144 < quote.XPos
        && npc->XPos + 6144 > quote.XPos
        && npc->YPos - 6144 < quote.YPos
        && npc->YPos + 4096 > quote.YPos )
      {
        npc->currentState = 10;
        npc->animationNumber = 5;
        quote.flags |= 2u;
        damagePlayer(2);
      }
      break;
    case 9:
      npc->XVel = 4 * npc->XVel / 5;
      if ( !npc->XVel )
        npc->currentState = 0;
      break;
    case 10:
      quote.XPos = npc->XPos;
      quote.YPos = npc->YPos;
      npc->XVel = 4 * npc->XVel / 5;
      if ( !npc->XVel )
      {
        npc->currentState = 11;
        npc->waitTimer = 0;
        npc->animationNumber = 5;
        npc->animationTimer = 0;
      }
      break;
    case 11:
      quote.XPos = npc->XPos;
      quote.YPos = npc->YPos;
      if ( ++npc->animationTimer > 2 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 6 )
        npc->animationNumber = 5;
      if ( ++npc->waitTimer > 100 )
        npc->currentState = 20;
      break;
    case 20:
      playSoundEffect(SFXSillyExplosion, 1);
      quote.flags &= 0xFDu;
      if ( npc->direction )
      {
        quote.XPos -= 2048;
        quote.YPos -= 4096;
        quote.XVel = -1535;
        quote.YVel = -512;
        quote.direction = 0;
        npc->direction = 0;
      }
      else
      {
        quote.XPos += 2048;
        quote.YPos -= 4096;
        quote.XVel = 1535;
        quote.YVel = -512;
        quote.direction = 2;
        npc->direction = 2;
      }
      npc->currentState = 21;
      npc->waitTimer = 0;
      npc->animationNumber = 7;
      goto case_21;
    case 21:
case_21:
      if ( ++npc->waitTimer >= 50 )
        npc->currentState = 0;
      break;
    default:
      break;
  }
  npc->YVel += 32;
  if ( npc->XVel < -1024 )
    npc->XVel = -1024;
  if ( npc->XVel > 1024 )
    npc->XVel = 1024;
  if ( npc->YVel > 1535 )
    npc->YVel = 1535;
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  Rects_Left[0].left = 0;
  Rects_Left[0].top = 0;
  Rects_Left[0].right = 40;
  Rects_Left[0].bottom = 24;
  Rects_Left[1].left = 0;
  Rects_Left[1].top = 48;
  Rects_Left[1].right = 40;
  Rects_Left[1].bottom = 72;
  Rects_Left[2].left = 0;
  Rects_Left[2].top = 0;
  Rects_Left[2].right = 40;
  Rects_Left[2].bottom = 24;
  Rects_Left[3].left = 40;
  Rects_Left[3].top = 48;
  Rects_Left[3].right = 80;
  Rects_Left[3].bottom = 72;
  Rects_Left[4].left = 0;
  Rects_Left[4].top = 0;
  Rects_Left[4].right = 40;
  Rects_Left[4].bottom = 24;
  Rects_Left[5].left = 80;
  Rects_Left[5].top = 48;
  Rects_Left[5].right = 120;
  Rects_Left[5].bottom = 72;
  Rects_Left[6].left = 120;
  Rects_Left[6].top = 48;
  Rects_Left[6].right = 160;
  Rects_Left[6].bottom = 72;
  Rects_Left[7].left = 120;
  Rects_Left[7].top = 0;
  Rects_Left[7].right = 160;
  Rects_Left[7].bottom = 24;
  Rects_Left[8].left = 80;
  Rects_Left[8].top = 0;
  Rects_Left[8].right = 120;
  Rects_Left[8].bottom = 24;
  Rects_Right[0].left = 0;
  Rects_Right[0].top = 24;
  Rects_Right[0].right = 40;
  Rects_Right[0].bottom = 48;
  Rects_Right[1].left = 0;
  Rects_Right[1].top = 72;
  Rects_Right[1].right = 40;
  Rects_Right[1].bottom = 96;
  Rects_Right[2].left = 0;
  Rects_Right[2].top = 24;
  Rects_Right[2].right = 40;
  Rects_Right[2].bottom = 48;
  Rects_Right[3].left = 40;
  Rects_Right[3].top = 72;
  Rects_Right[3].right = 80;
  Rects_Right[3].bottom = 96;
  Rects_Right[4].left = 0;
  Rects_Right[4].top = 24;
  Rects_Right[4].right = 40;
  Rects_Right[4].bottom = 48;
  Rects_Right[5].left = 80;
  Rects_Right[5].top = 72;
  Rects_Right[5].right = 120;
  Rects_Right[5].bottom = 96;
  Rects_Right[6].left = 120;
  Rects_Right[6].top = 72;
  Rects_Right[6].right = 160;
  Rects_Right[6].bottom = 96;
  Rects_Right[7].left = 120;
  Rects_Right[7].top = 24;
  Rects_Right[7].right = 160;
  Rects_Right[7].bottom = 48;
  Rects_Right[8].left = 80;
  Rects_Right[8].top = 24;
  Rects_Right[8].right = 120;
  Rects_Right[8].bottom = 48;
  if ( npc->direction )
    v2 = &Rects_Right[npc->animationNumber];
  else
    v2 = &Rects_Left[npc->animationNumber];
  npc->rect = *v2;
}

//----- (004355F0) --------------------------------------------------------
void __cdecl NPC69(NPC *npc)
{
  RECT *v1; // edx
  int npc_Current_State; // [esp+0h] [ebp-C8h]
  RECT Rects_Right[6]; // [esp+8h] [ebp-C0h]
  RECT Rects_Left[6]; // [esp+68h] [ebp-60h]

  Rects_Left[0].left = 48;
  Rects_Left[0].top = 0;
  Rects_Left[0].right = 64;
  Rects_Left[0].bottom = 16;
  Rects_Left[1].left = 64;
  Rects_Left[1].top = 0;
  Rects_Left[1].right = 80;
  Rects_Left[1].bottom = 16;
  Rects_Left[2].left = 80;
  Rects_Left[2].top = 0;
  Rects_Left[2].right = 96;
  Rects_Left[2].bottom = 16;
  Rects_Left[3].left = 96;
  Rects_Left[3].top = 0;
  Rects_Left[3].right = 112;
  Rects_Left[3].bottom = 16;
  Rects_Left[4].left = 48;
  Rects_Left[4].top = 0;
  Rects_Left[4].right = 64;
  Rects_Left[4].bottom = 16;
  Rects_Left[5].left = 112;
  Rects_Left[5].top = 0;
  Rects_Left[5].right = 128;
  Rects_Left[5].bottom = 16;
  Rects_Right[0].left = 48;
  Rects_Right[0].top = 16;
  Rects_Right[0].right = 64;
  Rects_Right[0].bottom = 32;
  Rects_Right[1].left = 64;
  Rects_Right[1].top = 16;
  Rects_Right[1].right = 80;
  Rects_Right[1].bottom = 32;
  Rects_Right[2].left = 80;
  Rects_Right[2].top = 16;
  Rects_Right[2].right = 96;
  Rects_Right[2].bottom = 32;
  Rects_Right[3].left = 96;
  Rects_Right[3].top = 16;
  Rects_Right[3].right = 112;
  Rects_Right[3].bottom = 32;
  Rects_Right[4].left = 48;
  Rects_Right[4].top = 16;
  Rects_Right[4].right = 64;
  Rects_Right[4].bottom = 32;
  Rects_Right[5].left = 112;
  Rects_Right[5].top = 16;
  Rects_Right[5].right = 128;
  Rects_Right[5].bottom = 32;
  switch ( npc->currentState )
  {
    case 0:
      npc->currentState = 1;
      npc->animationNumber = 0;
      npc->animationTimer = 0;
      npc->XVel = 0;
      goto case_1;
    case 1:
case_1:
      if ( random(0, 100) == 1 )
      {
        npc->currentState = 2;
        npc->waitTimer = 0;
        npc->animationNumber = 1;
      }
      else
      {
        if ( random(0, 150) == 1 )
        {
          if ( npc->direction )
            npc->direction = 0;
          else
            npc->direction = 2;
        }
        if ( random(0, 150) == 1 )
        {
          npc->currentState = 3;
          npc->waitTimer = 50;
          npc->animationNumber = 0;
        }
      }
      break;
    case 2:
      if ( ++npc->waitTimer > 8 )
      {
        npc->currentState = 1;
        npc->animationNumber = 0;
      }
      break;
    case 3:
      npc->currentState = 4;
      npc->animationNumber = 2;
      npc->animationTimer = 0;
      goto case_4;
    case 4:
case_4:
      if ( !--npc->waitTimer )
        npc->currentState = 0;
      if ( ++npc->animationTimer > 2 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 4 )
        npc->animationNumber = 2;
      if ( npc->collisionFlags & 1 )
      {
        npc->direction = 2;
        npc->XVel = 512;
      }
      if ( npc->collisionFlags & 4 )
      {
        npc->direction = 0;
        npc->XVel = -512;
      }
      if ( npc->direction )
        npc->XVel = 256;
      else
        npc->XVel = -256;
      break;
    case 5:
      if ( npc->collisionFlags & 8 )
        npc->currentState = 0;
      break;
    default:
      break;
  }
  npc_Current_State = npc->currentState;
  if ( npc_Current_State > 0 && (npc_Current_State <= 2 || npc_Current_State == 4) && npc->isBeingHit )
  {
    npc->YVel = -512;
    npc->animationNumber = 5;
    npc->currentState = 5;
  }
  npc->YVel += 64;
  if ( npc->YVel > 1535 )
    npc->YVel = 1535;
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  if ( npc->direction )
    v1 = &Rects_Right[npc->animationNumber];
  else
    v1 = &Rects_Left[npc->animationNumber];
  npc->rect = *v1;
}

//----- (00435AB0) --------------------------------------------------------
void __cdecl NPC70(NPC *npc)
{
  RECT Rects[4]; // [esp+0h] [ebp-40h]

  Rects[0].left = 96;
  Rects[0].top = 48;
  Rects[0].right = 112;
  Rects[0].bottom = 64;
  Rects[1].left = 112;
  Rects[1].top = 48;
  Rects[1].right = 128;
  Rects[1].bottom = 64;
  Rects[2].left = 128;
  Rects[2].top = 48;
  Rects[2].right = 144;
  Rects[2].bottom = 64;
  Rects[3].left = 144;
  Rects[3].top = 48;
  Rects[3].right = 160;
  Rects[3].bottom = 64;
  if ( ++npc->animationTimer > 3 )
  {
    npc->animationTimer = 0;
    ++npc->animationNumber;
  }
  if ( npc->animationNumber > 3 )
    npc->animationNumber = 0;
  npc->rect = Rects[npc->animationNumber];
}

//----- (00435BA0) --------------------------------------------------------
void __cdecl NPC71(NPC *NPC)
{
  RECT *v1; // edx
  int NPC_Current_State; // [esp+0h] [ebp-64h]
  RECT Rects_Right[3]; // [esp+4h] [ebp-60h]
  RECT Rects_Left[3]; // [esp+34h] [ebp-30h]

  NPC_Current_State = NPC->currentState;
  if ( NPC_Current_State )
  {
    if ( NPC_Current_State != 1 )
      goto LABEL_13;
  }
  else
  {
    NPC->currentState = 1;
    NPC->curlyTargetX = NPC->XPos;
    NPC->curlyTargetY = NPC->YPos;
    NPC->YVel = 128;
  }
  // NPC->Current_State == 1
  if ( NPC->curlyTargetY < NPC->YPos )
    NPC->YVel -= 8;
  if ( NPC->curlyTargetY > NPC->YPos )
    NPC->YVel += 8;
  if ( NPC->YVel > 256 )
    NPC->YVel = 256;
  if ( NPC->YVel < -256 )
    NPC->YVel = -256;
LABEL_13:
  NPC->XPos += NPC->XVel;
  NPC->YPos += NPC->YVel;
  Rects_Left[0].left = 64;
  Rects_Left[0].top = 32;
  Rects_Left[0].right = 80;
  Rects_Left[0].bottom = 48;
  Rects_Left[1].left = 80;
  Rects_Left[1].top = 32;
  Rects_Left[1].right = 96;
  Rects_Left[1].bottom = 48;
  Rects_Left[2].left = 96;
  Rects_Left[2].top = 32;
  Rects_Left[2].right = 112;
  Rects_Left[2].bottom = 48;
  Rects_Right[0].left = 64;
  Rects_Right[0].top = 48;
  Rects_Right[0].right = 80;
  Rects_Right[0].bottom = 64;
  Rects_Right[1].left = 80;
  Rects_Right[1].top = 48;
  Rects_Right[1].right = 96;
  Rects_Right[1].bottom = 64;
  Rects_Right[2].left = 96;
  Rects_Right[2].top = 48;
  Rects_Right[2].right = 112;
  Rects_Right[2].bottom = 64;
  if ( ++NPC->animationTimer > 4 )
  {
    NPC->animationTimer = 0;
    ++NPC->animationNumber;
  }
  if ( NPC->animationNumber > 1 )
    NPC->animationNumber = 0;
  if ( NPC->isBeingHit )
    NPC->animationNumber = 2;
  if ( NPC->direction )
    v1 = &Rects_Right[NPC->animationNumber];
  else
    v1 = &Rects_Left[NPC->animationNumber];
  NPC->rect = *v1;
}

//----- (00435DE0) --------------------------------------------------------
void __cdecl NPC72(NPC *NPC)
{
  int Child_Y_Vel; // ST10_4 MAPDST
  int Child_X_Vel; // eax
  int v4; // ST0C_4
  RECT Rects[2]; // [esp+0h] [ebp-20h]

  if ( !NPC->direction )
  {
    if ( ++NPC->animationTimer > 1 )
    {
      NPC->animationTimer = 0;
      ++NPC->animationNumber;
    }
    if ( NPC->animationNumber > 1 )
    {
      NPC->animationNumber = 0;
      return;
    }
    if ( quote.XPos < NPC->XPos + 0x28000
      && quote.XPos > NPC->XPos - 0x28000
      && quote.YPos < NPC->YPos + 0x1E000
      && quote.YPos > NPC->YPos - 0x1E000 )
    {
      if ( ++NPC->currentState % 2 )
      {
        Child_Y_Vel = 3 * random(-512, 128);
        Child_X_Vel = random(-512, 512);
        createNPC(NPCBalrogDropIn|0x40, NPC->XPos, NPC->YPos, 2 * Child_X_Vel, Child_Y_Vel, 0, 0, 256);
      }
      Child_Y_Vel = 3 * random(-512, 128);
      v4 = 2 * random(-512, 512);
      createNPC(NPCBalrogDropIn|0x40, NPC->XPos, NPC->YPos, v4, Child_Y_Vel, 0, 0, 256);
    }
  }
  Rects[0].left = 224;
  Rects[0].top = 48;
  Rects[0].right = 240;
  Rects[0].bottom = 64;
  Rects[1].left = 240;
  Rects[1].top = 48;
  Rects[1].right = 256;
  Rects[1].bottom = 64;
  NPC->rect = Rects[NPC->animationNumber];
}

//----- (00435FC0) --------------------------------------------------------
void __cdecl NPC73(NPC *NPC)
{
  RECT Rects[5]; // [esp+0h] [ebp-50h]

  Rects[0].left = 72;
  Rects[0].top = 16;
  Rects[0].right = 74;
  Rects[0].bottom = 18;
  Rects[1].left = 74;
  Rects[1].top = 16;
  Rects[1].right = 76;
  Rects[1].bottom = 18;
  Rects[2].left = 76;
  Rects[2].top = 16;
  Rects[2].right = 78;
  Rects[2].bottom = 18;
  Rects[3].left = 78;
  Rects[3].top = 16;
  Rects[3].right = 80;
  Rects[3].bottom = 18;
  Rects[4].left = 80;
  Rects[4].top = 16;
  Rects[4].right = 82;
  Rects[4].bottom = 18;
  NPC->YVel += 32;
  NPC->animationNumber = random(0, 4);
  if ( NPC->YVel > 1535 )
    NPC->YVel = 1535;
  NPC->XPos += NPC->XVel;
  NPC->YPos += NPC->YVel;
  NPC->rect = Rects[NPC->animationNumber];
  if ( NPC->direction == 2 )
  {
    NPC->rect.top += 2;
    NPC->rect.bottom += 2;
  }
  if ( ++NPC->waitTimer > 10 )
  {
    if ( NPC->collisionFlags & 1 )
      NPC->isAlive = 0;
    if ( NPC->collisionFlags & 4 )
      NPC->isAlive = 0;
    if ( NPC->collisionFlags & 8 )
      NPC->isAlive = 0;
    if ( NPC->collisionFlags & 0x100 )
      NPC->isAlive = 0;
  }
  if ( NPC->YPos > currentMap.length << 13 )
    NPC->isAlive = 0;
}

//----- (00436180) --------------------------------------------------------
void __cdecl NPC74(NPC *NPC)
{
  RECT *v1; // ecx
  RECT Rects_Right[6]; // [esp+4h] [ebp-C0h]
  RECT Rects_Left[6]; // [esp+64h] [ebp-60h]

  Rects_Left[0].left = 64;
  Rects_Left[0].top = 0;
  Rects_Left[0].right = 80;
  Rects_Left[0].bottom = 16;
  Rects_Left[1].left = 80;
  Rects_Left[1].top = 0;
  Rects_Left[1].right = 96;
  Rects_Left[1].bottom = 16;
  Rects_Left[2].left = 96;
  Rects_Left[2].top = 0;
  Rects_Left[2].right = 112;
  Rects_Left[2].bottom = 16;
  Rects_Left[3].left = 64;
  Rects_Left[3].top = 0;
  Rects_Left[3].right = 80;
  Rects_Left[3].bottom = 16;
  Rects_Left[4].left = 112;
  Rects_Left[4].top = 0;
  Rects_Left[4].right = 128;
  Rects_Left[4].bottom = 16;
  Rects_Left[5].left = 64;
  Rects_Left[5].top = 0;
  Rects_Left[5].right = 80;
  Rects_Left[5].bottom = 16;
  Rects_Right[0].left = 64;
  Rects_Right[0].top = 16;
  Rects_Right[0].right = 80;
  Rects_Right[0].bottom = 32;
  Rects_Right[1].left = 80;
  Rects_Right[1].top = 16;
  Rects_Right[1].right = 96;
  Rects_Right[1].bottom = 32;
  Rects_Right[2].left = 96;
  Rects_Right[2].top = 16;
  Rects_Right[2].right = 112;
  Rects_Right[2].bottom = 32;
  Rects_Right[3].left = 64;
  Rects_Right[3].top = 16;
  Rects_Right[3].right = 80;
  Rects_Right[3].bottom = 32;
  Rects_Right[4].left = 112;
  Rects_Right[4].top = 16;
  Rects_Right[4].right = 128;
  Rects_Right[4].bottom = 32;
  Rects_Right[5].left = 64;
  Rects_Right[5].top = 16;
  Rects_Right[5].right = 80;
  Rects_Right[5].bottom = 32;
  switch ( NPC->currentState )
  {
    case 0:
      NPC->currentState = 1;
      NPC->animationNumber = 0;
      NPC->animationTimer = 0;
      NPC->XVel = 0;
      goto case_1;
    case 1:
case_1:
      if ( random(0, 120) == 10 )
      {
        NPC->currentState = 2;
        NPC->waitTimer = 0;
        NPC->animationNumber = 1;
      }
      break;
    case 2:
      if ( ++NPC->waitTimer > 8 )
      {
        NPC->currentState = 1;
        NPC->animationNumber = 0;
      }
      break;
    case 8:
      NPC->currentState = 9;
      NPC->animationNumber = 2;
      NPC->animationTimer = 0;
      goto case_9;
    case 9:
case_9:
      if ( ++NPC->animationTimer > 4 )
      {
        NPC->animationTimer = 0;
        ++NPC->animationNumber;
      }
      if ( NPC->animationNumber > 5 )
        NPC->animationNumber = 2;
      if ( NPC->direction )
        NPC->XVel = 512;
      else
        NPC->XVel = -512;
      break;
    default:
      break;
  }
  NPC->YVel += 64;
  if ( NPC->XVel > 1024 )
    NPC->XVel = 1024;
  if ( NPC->XVel < -1024 )
    NPC->XVel = -1024;
  if ( NPC->YVel > 1535 )
    NPC->YVel = 1535;
  NPC->XPos += NPC->XVel;
  NPC->YPos += NPC->YVel;
  if ( NPC->direction )
    v1 = &Rects_Right[NPC->animationNumber];
  else
    v1 = &Rects_Left[NPC->animationNumber];
  NPC->rect = *v1;
}

//----- (00436540) --------------------------------------------------------
void __cdecl NPC75(NPC *NPC)
{
  int NPC_Current_State; // [esp+0h] [ebp-24h]
  RECT Rects[2]; // [esp+4h] [ebp-20h]

  Rects[0].left = 272;
  Rects[0].top = 32;
  Rects[0].right = 296;
  Rects[0].bottom = 56;
  Rects[1].left = 296;
  Rects[1].top = 32;
  Rects[1].right = 320;
  Rects[1].bottom = 56;
  NPC_Current_State = NPC->currentState;
  if ( NPC_Current_State )
  {
    if ( NPC_Current_State != 1 )
      goto LABEL_11;
  }
  else
  {
    // NPC->Current_State == 1
    NPC->currentState = 1;
    NPC->animationNumber = 0;
    NPC->animationTimer = 0;
  }
  NPC->animationNumber = NPC->XPos - 24576 < quote.XPos
                      && NPC->XPos + 24576 > quote.XPos
                      && NPC->YPos - 24576 < quote.YPos
                      && NPC->YPos + 0x2000 > quote.YPos;
LABEL_11:
  NPC->rect = Rects[NPC->animationNumber];
}

//----- (00436650) --------------------------------------------------------
void __cdecl NPC76(NPC *NPC)
{
  NPC->rect.left = 16 * NPC->entityEventNum;    // Rects depend on the Entity's event number... Strange
  NPC->rect.top = 0;
  NPC->rect.right = NPC->rect.left + 16;
  NPC->rect.bottom = 16;
}

//----- (00436690) --------------------------------------------------------
// NPC 77 : Sandaim the farmer
void __cdecl NPC77_Sandaim_the_Farmer(NPC *NPC)
{
  int Script_State; // [esp+0h] [ebp-34h]
  RECT Rects_Left[2]; // [esp+4h] [ebp-30h]
  RECT Rect_Right; // [esp+24h] [ebp-10h]

  Rects_Left[0].left = 0;
  Rects_Left[0].top = 16;
  Rects_Left[0].right = 48;
  Rects_Left[0].bottom = 48;
  Rects_Left[1].left = 48;
  Rects_Left[1].top = 16;
  Rects_Left[1].right = 96;
  Rects_Left[1].bottom = 48;
  Rect_Right.left = 96;
  Rect_Right.top = 16;
  Rect_Right.right = 144;
  Rect_Right.bottom = 48;
  Script_State = NPC->currentState;
  if ( Script_State )
  {
    if ( Script_State != 1 )
    {
      if ( Script_State == 2 && ++NPC->waitTimer > 8 )
      {
        NPC->currentState = 1;
        NPC->animationNumber = 0;
      }
      goto LABEL_11;
    }
  }
  else
  {
    NPC->currentState = 1;
    NPC->animationNumber = 0;
    NPC->animationTimer = 0;
  }
  // NPC->Current_State == 1
  if ( random(0, 120) == 10 )
  {
    NPC->currentState = 2;
    NPC->waitTimer = 0;
    NPC->animationNumber = 1;
  }
LABEL_11:
  if ( NPC->direction )
    NPC->rect = Rect_Right;
  else
    NPC->rect = Rects_Left[NPC->animationNumber];
}

//----- (004367E0) --------------------------------------------------------
// NPC 78 : Pot
void __cdecl NPC78_Pot(NPC *NPC)
{
  RECT *v1; // ecx

  if ( NPC->direction )
  {
    v1 = &NPC->rect;
    v1->left = 176;
    v1->top = 48;
    v1->right = 192;
  }
  else
  {
    v1 = &NPC->rect;
    v1->left = 160;
    v1->top = 48;
    v1->right = 176;
  }
  v1->bottom = 64;
}

//----- (00436870) --------------------------------------------------------
void __cdecl NPC79(NPC *NPC)
{
  RECT *v1; // eax
  int NPC_Current_State; // [esp+0h] [ebp-64h]
  RECT Rects_Right[3]; // [esp+4h] [ebp-60h]
  RECT Rects_Left[3]; // [esp+34h] [ebp-30h]

  Rects_Left[0].left = 0;
  Rects_Left[0].top = 0;
  Rects_Left[0].right = 16;
  Rects_Left[0].bottom = 16;
  Rects_Left[1].left = 16;
  Rects_Left[1].top = 0;
  Rects_Left[1].right = 32;
  Rects_Left[1].bottom = 16;
  Rects_Left[2].left = 32;
  Rects_Left[2].top = 0;
  Rects_Left[2].right = 48;
  Rects_Left[2].bottom = 16;
  Rects_Right[0].left = 0;
  Rects_Right[0].top = 16;
  Rects_Right[0].right = 16;
  Rects_Right[0].bottom = 32;
  Rects_Right[1].left = 16;
  Rects_Right[1].top = 16;
  Rects_Right[1].right = 32;
  Rects_Right[1].bottom = 32;
  Rects_Right[2].left = 32;
  Rects_Right[2].top = 16;
  Rects_Right[2].right = 48;
  Rects_Right[2].bottom = 32;
  NPC_Current_State = NPC->currentState;
  if ( NPC_Current_State )
  {
    if ( NPC_Current_State == 2 )
    {
      NPC->animationNumber = 0;
      if ( random(0, 120) == 10 )
      {
        NPC->currentState = 3;
        NPC->waitTimer = 0;
        NPC->animationNumber = 1;
      }
      if ( NPC->XPos - 0x4000 < quote.XPos
        && NPC->XPos + 0x4000 > quote.XPos
        && NPC->YPos - 0x4000 < quote.YPos
        && NPC->YPos + 0x2000 > quote.YPos )
      {
        if ( NPC->XPos <= quote.XPos )
          NPC->direction = 2;
        else
          NPC->direction = 0;
      }
    }
    else if ( NPC_Current_State == 3 && ++NPC->waitTimer > 8 )
    {
      NPC->currentState = 2;
      NPC->animationNumber = 0;
    }
  }
  else
  {
    NPC->currentState = 1;
    NPC->animationNumber = 2;
    NPC->animationTimer = 0;
  }
  NPC->YVel += 64;
  if ( NPC->YVel > 1535 )
    NPC->YVel = 1535;
  NPC->YPos += NPC->YVel;
  if ( NPC->direction )
    v1 = &Rects_Right[NPC->animationNumber];
  else
    v1 = &Rects_Left[NPC->animationNumber];
  NPC->rect = *v1;
}

//----- (00436AE0) --------------------------------------------------------
void __cdecl NPC80(NPC *NPC)
{
  RECT *v1; // edx
  RECT Rects_Right[7]; // [esp+4h] [ebp-E0h]
  RECT Rects_Left[7]; // [esp+74h] [ebp-70h]

  Rects_Left[0].left = 0;
  Rects_Left[0].top = 64;
  Rects_Left[0].right = 24;
  Rects_Left[0].bottom = 88;
  Rects_Left[1].left = 24;
  Rects_Left[1].top = 64;
  Rects_Left[1].right = 48;
  Rects_Left[1].bottom = 88;
  Rects_Left[2].left = 0;
  Rects_Left[2].top = 64;
  Rects_Left[2].right = 24;
  Rects_Left[2].bottom = 88;
  Rects_Left[3].left = 48;
  Rects_Left[3].top = 64;
  Rects_Left[3].right = 72;
  Rects_Left[3].bottom = 88;
  Rects_Left[4].left = 72;
  Rects_Left[4].top = 64;
  Rects_Left[4].right = 96;
  Rects_Left[4].bottom = 88;
  Rects_Left[5].left = 96;
  Rects_Left[5].top = 64;
  Rects_Left[5].right = 120;
  Rects_Left[5].bottom = 88;
  Rects_Left[6].left = 120;
  Rects_Left[6].top = 64;
  Rects_Left[6].right = 144;
  Rects_Left[6].bottom = 88;
  Rects_Right[0].left = 0;
  Rects_Right[0].top = 88;
  Rects_Right[0].right = 24;
  Rects_Right[0].bottom = 112;
  Rects_Right[1].left = 24;
  Rects_Right[1].top = 88;
  Rects_Right[1].right = 48;
  Rects_Right[1].bottom = 112;
  Rects_Right[2].left = 0;
  Rects_Right[2].top = 88;
  Rects_Right[2].right = 24;
  Rects_Right[2].bottom = 112;
  Rects_Right[3].left = 48;
  Rects_Right[3].top = 88;
  Rects_Right[3].right = 72;
  Rects_Right[3].bottom = 112;
  Rects_Right[4].left = 72;
  Rects_Right[4].top = 88;
  Rects_Right[4].right = 96;
  Rects_Right[4].bottom = 112;
  Rects_Right[5].left = 96;
  Rects_Right[5].top = 88;
  Rects_Right[5].right = 120;
  Rects_Right[5].bottom = 112;
  Rects_Right[6].left = 120;
  Rects_Right[6].top = 88;
  Rects_Right[6].right = 144;
  Rects_Right[6].bottom = 112;
  switch ( NPC->currentState )
  {
    case 0:
      NPC->entityFlags &= 0xFFDFu;
      NPC->currentState = 1;
      NPC->damage = 0;
      NPC->hitbox.front = 2048;
      goto case_1;
    case 1:
case_1:
      NPC->animationNumber = 0;
      if ( NPC->XPos - 0x10000 < quote.XPos
        && NPC->XPos + 0x10000 > quote.XPos
        && NPC->YPos - 24576 < quote.YPos
        && NPC->YPos + 0x4000 > quote.YPos )
      {
        NPC->animationTimer = 0;
        NPC->currentState = 2;
      }
      if ( NPC->isBeingHit )
      {
        NPC->animationNumber = 1;
        NPC->animationTimer = 0;
        NPC->currentState = 2;
        NPC->entityFlags &= 0xFFDFu;
      }
      if ( quote.XPos >= NPC->XPos )
        NPC->direction = 2;
      else
        NPC->direction = 0;
      break;
    case 2:
      if ( ++NPC->animationTimer > 6 )
      {
        NPC->animationTimer = 0;
        ++NPC->animationNumber;
      }
      if ( NPC->animationNumber > 3 )
        NPC->animationNumber = 0;
      if ( NPC->XPos - 0x2000 < quote.XPos && NPC->XPos + 0x2000 > quote.XPos )
      {
        NPC->hitbox.front = 9216;
        NPC->waitTimer = 0;
        NPC->currentState = 3;
        NPC->entityFlags |= 0x20u;
        playSoundEffect(SFXFireballBounce, 1);
        if ( NPC->direction )
          NPC->XVel = 1024;
        else
          NPC->XVel = -1024;
      }
      if ( quote.XPos >= NPC->XPos )
      {
        NPC->direction = 2;
        NPC->XVel = 256;
      }
      else
      {
        NPC->direction = 0;
        NPC->XVel = -256;
      }
      break;
    case 3:
      NPC->XVel = 0;
      if ( ++NPC->waitTimer > 40 )
      {
        NPC->waitTimer = 0;
        NPC->currentState = 4;
        playSoundEffect(SFXSpinningProjectile, 1);
      }
      NPC->animationNumber = 4;
      break;
    case 4:
      NPC->damage = 10;
      if ( ++NPC->waitTimer > 2 )
      {
        NPC->waitTimer = 0;
        NPC->currentState = 5;
      }
      NPC->animationNumber = 5;
      break;
    case 5:
      NPC->animationNumber = 6;
      if ( ++NPC->waitTimer > 60 )
        NPC->currentState = 0;
      break;
    default:
      break;
  }
  if ( NPC->XVel < 0 && NPC->collisionFlags & 1 )
    NPC->XVel = 0;
  if ( NPC->XVel > 0 && NPC->collisionFlags & 4 )
    NPC->XVel = 0;
  NPC->YVel += 32;
  if ( NPC->XVel > 1024 )
    NPC->XVel = 1024;
  if ( NPC->XVel < -1024 )
    NPC->XVel = -1024;
  if ( NPC->YVel > 1535 )
    NPC->XVel = 1535;
  if ( NPC->YVel < -1535 )
    NPC->XVel = -1535;
  NPC->XPos += NPC->XVel;
  NPC->YPos += NPC->YVel;
  if ( NPC->direction )
    v1 = &Rects_Right[NPC->animationNumber];
  else
    v1 = &Rects_Left[NPC->animationNumber];
  NPC->rect = *v1;
}

//----- (004370F0) --------------------------------------------------------
void __cdecl NPC81(NPC *NPC)
{
  RECT *v1; // eax
  int NPC_Current_State; // [esp+0h] [ebp-C8h]
  RECT Rects_Right[6]; // [esp+8h] [ebp-C0h]
  RECT Rects_Left[6]; // [esp+68h] [ebp-60h]

  Rects_Left[0].left = 144;
  Rects_Left[0].top = 64;
  Rects_Left[0].right = 168;
  Rects_Left[0].bottom = 88;
  Rects_Left[1].left = 168;
  Rects_Left[1].top = 64;
  Rects_Left[1].right = 192;
  Rects_Left[1].bottom = 88;
  Rects_Left[2].left = 192;
  Rects_Left[2].top = 64;
  Rects_Left[2].right = 216;
  Rects_Left[2].bottom = 88;
  Rects_Left[3].left = 216;
  Rects_Left[3].top = 64;
  Rects_Left[3].right = 240;
  Rects_Left[3].bottom = 88;
  Rects_Left[4].left = 144;
  Rects_Left[4].top = 64;
  Rects_Left[4].right = 168;
  Rects_Left[4].bottom = 88;
  Rects_Left[5].left = 240;
  Rects_Left[5].top = 64;
  Rects_Left[5].right = 264;
  Rects_Left[5].bottom = 88;
  Rects_Right[0].left = 144;
  Rects_Right[0].top = 88;
  Rects_Right[0].right = 168;
  Rects_Right[0].bottom = 112;
  Rects_Right[1].left = 168;
  Rects_Right[1].top = 88;
  Rects_Right[1].right = 192;
  Rects_Right[1].bottom = 112;
  Rects_Right[2].left = 192;
  Rects_Right[2].top = 88;
  Rects_Right[2].right = 216;
  Rects_Right[2].bottom = 112;
  Rects_Right[3].left = 216;
  Rects_Right[3].top = 88;
  Rects_Right[3].right = 240;
  Rects_Right[3].bottom = 112;
  Rects_Right[4].left = 144;
  Rects_Right[4].top = 88;
  Rects_Right[4].right = 168;
  Rects_Right[4].bottom = 112;
  Rects_Right[5].left = 240;
  Rects_Right[5].top = 88;
  Rects_Right[5].right = 264;
  Rects_Right[5].bottom = 112;
  switch ( NPC->currentState )
  {
    case 0:
      NPC->currentState = 1;
      NPC->animationNumber = 0;
      NPC->animationTimer = 0;
      NPC->XVel = 0;
      goto case_1;
    case 1:
case_1:
      if ( random(0, 100) == 1 )
      {
        NPC->currentState = 2;
        NPC->waitTimer = 0;
        NPC->animationNumber = 1;
      }
      else
      {
        if ( random(0, 150) == 1 )
        {
          if ( NPC->direction )
            NPC->direction = 0;
          else
            NPC->direction = 2;
        }
        if ( random(0, 150) == 1 )
        {
          NPC->currentState = 3;
          NPC->waitTimer = 50;
          NPC->animationNumber = 0;
        }
      }
      break;
    case 2:
      if ( ++NPC->waitTimer > 8 )
      {
        NPC->currentState = 1;
        NPC->animationNumber = 0;
      }
      break;
    case 3:
      NPC->currentState = 4;
      NPC->animationNumber = 2;
      NPC->animationTimer = 0;
      goto case_4;
    case 4:
case_4:
      if ( !--NPC->waitTimer )
        NPC->currentState = 0;
      if ( ++NPC->animationTimer > 2 )
      {
        NPC->animationTimer = 0;
        ++NPC->animationNumber;
      }
      if ( NPC->animationNumber > 4 )
        NPC->animationNumber = 2;
      if ( NPC->collisionFlags & 1 )
      {
        NPC->direction = 2;
        NPC->XVel = 512;
      }
      if ( NPC->collisionFlags & 4 )
      {
        NPC->direction = 0;
        NPC->XVel = -512;
      }
      if ( NPC->direction )
        NPC->XVel = 256;
      else
        NPC->XVel = -256;
      break;
    case 5:
      if ( NPC->collisionFlags & 8 )
        NPC->currentState = 0;
      break;
    default:
      break;
  }
  NPC_Current_State = NPC->currentState;
  if ( NPC_Current_State > 0 && (NPC_Current_State <= 2 || NPC_Current_State == 4) && NPC->isBeingHit )
  {
    NPC->YVel = -512;
    NPC->animationNumber = 5;
    NPC->currentState = 5;
    if ( NPC->XPos >= quote.XPos )
      NPC->XVel = -256;
    else
      NPC->XVel = 256;
  }
  NPC->YVel += 64;
  if ( NPC->YVel > 1535 )
    NPC->YVel = 1535;
  NPC->XPos += NPC->XVel;
  NPC->YPos += NPC->YVel;
  if ( NPC->direction )
    v1 = &Rects_Right[NPC->animationNumber];
  else
    v1 = &Rects_Left[NPC->animationNumber];
  NPC->rect = *v1;
}

//----- (004375E0) --------------------------------------------------------
void __cdecl NPC82(NPC *NPC)
{
  int v1; // ST10_4
  RECT *v2; // edx
  int NPC_Wait_Timer; // [esp+0h] [ebp-128h]
  RECT Rects_Right[9]; // [esp+8h] [ebp-120h]
  RECT Rects_Left[9]; // [esp+98h] [ebp-90h]

  switch ( NPC->currentState )
  {
    case 0:
      NPC->currentState = 1;
      NPC->animationNumber = 2;
      goto case_1;
    case 1:
case_1:
      if ( random(0, 120) == 10 )
      {
        NPC->currentState = 2;
        NPC->waitTimer = 0;
        NPC->animationNumber = 3;
      }
      break;
    case 2:
      if ( ++NPC->waitTimer > 8 )
      {
        NPC->currentState = 1;
        NPC->animationNumber = 2;
      }
      break;
    case 15:
      NPC->currentState = 16;
      NPC->waitTimer = 0;
      NPC->animationNumber = 4;
      goto case_16;
    case 16:
case_16:
      if ( ++NPC->waitTimer == 30 )
      {
        playSoundEffect(SFXBubble, 1);
        createNPC((NPCNames)66, NPC->XPos, NPC->YPos - 0x2000, 0, 0, 0, NPC, 0);
      }
      if ( NPC->waitTimer == 50 )
        NPC->currentState = 14;
      break;
    case 20:
      NPC->currentState = 21;
      NPC->animationNumber = 0;
      NPC->YVel = 0;
      NPC->entityFlags |= 8u;
      goto case_21;
    case 21:
case_21:
      NPC->YVel -= 32;
      if ( NPC->YPos < -4096 )
        NPC->isAlive = 0;
      break;
    case 25:
      NPC->currentState = 26;
      NPC->waitTimer = 0;
      NPC->animationNumber = 5;
      NPC->animationTimer = 0;
      goto case_26;
    case 26:
case_26:
      if ( ++NPC->animationNumber > 7 )
        NPC->animationNumber = 5;
      if ( ++NPC->waitTimer == 30 )
      {
        playSoundEffect(SFXLightning, 1);
        startFlash(0, 0, 2);
        NPC->currentState = 27;
        NPC->animationNumber = 7;
      }
      break;
    case 27:
      if ( ++NPC->waitTimer == 50 )
      {
        NPC->currentState = 0;
        NPC->animationNumber = 0;
      }
      break;
    case 30:
      NPC->currentState = 31;
      NPC->animationNumber = 3;
      NPC->animationTimer = 0;
      goto case_31;
    case 31:
case_31:
      if ( ++NPC->animationTimer > 10 )
      {
        NPC->currentState = 32;
        NPC->animationNumber = 4;
        NPC->animationTimer = 0;
      }
      break;
    case 32:
      if ( ++NPC->animationTimer > 100 )
      {
        NPC->currentState = 1;
        NPC->animationNumber = 2;
      }
      break;
    case 40:
      NPC->currentState = 41;
      NPC->waitTimer = 0;
      goto case_41;
    case 41:
case_41:
      NPC->animationNumber = 4;
      NPC_Wait_Timer = ++NPC->waitTimer;
      if ( NPC_Wait_Timer == 30 || NPC_Wait_Timer == 40 || NPC_Wait_Timer == 50 )
      {
        v1 = random(-512, 0);
        createNPC(NPCProjectileBalrogEnemyBounce, NPC->XPos + 4096, NPC->YPos - 4096, 1536, v1, left, 0, 256);
        playSoundEffect(SFXFireballShoot, 1);
      }
      if ( NPC->waitTimer > 50 )
        NPC->currentState = 0;
      break;
    case 50:
      NPC->animationNumber = 8;
      break;
    default:
      break;
  }
  NPC->XPos += NPC->XVel;
  NPC->YPos += NPC->YVel;
  Rects_Left[0].left = 80;
  Rects_Left[0].top = 0;
  Rects_Left[0].right = 96;
  Rects_Left[0].bottom = 16;
  Rects_Left[1].left = 96;
  Rects_Left[1].top = 0;
  Rects_Left[1].right = 112;
  Rects_Left[1].bottom = 16;
  Rects_Left[2].left = 112;
  Rects_Left[2].top = 0;
  Rects_Left[2].right = 128;
  Rects_Left[2].bottom = 16;
  Rects_Left[3].left = 128;
  Rects_Left[3].top = 0;
  Rects_Left[3].right = 144;
  Rects_Left[3].bottom = 16;
  Rects_Left[4].left = 144;
  Rects_Left[4].top = 0;
  Rects_Left[4].right = 160;
  Rects_Left[4].bottom = 16;
  Rects_Left[5].left = 160;
  Rects_Left[5].top = 0;
  Rects_Left[5].right = 176;
  Rects_Left[5].bottom = 16;
  Rects_Left[6].left = 176;
  Rects_Left[6].top = 0;
  Rects_Left[6].right = 192;
  Rects_Left[6].bottom = 16;
  Rects_Left[7].left = 144;
  Rects_Left[7].top = 0;
  Rects_Left[7].right = 160;
  Rects_Left[7].bottom = 16;
  Rects_Left[8].left = 208;
  Rects_Left[8].top = 64;
  Rects_Left[8].right = 224;
  Rects_Left[8].bottom = 80;
  Rects_Right[0].left = 80;
  Rects_Right[0].top = 16;
  Rects_Right[0].right = 96;
  Rects_Right[0].bottom = 32;
  Rects_Right[1].left = 96;
  Rects_Right[1].top = 16;
  Rects_Right[1].right = 112;
  Rects_Right[1].bottom = 32;
  Rects_Right[2].left = 112;
  Rects_Right[2].top = 16;
  Rects_Right[2].right = 128;
  Rects_Right[2].bottom = 32;
  Rects_Right[3].left = 128;
  Rects_Right[3].top = 16;
  Rects_Right[3].right = 144;
  Rects_Right[3].bottom = 32;
  Rects_Right[4].left = 144;
  Rects_Right[4].top = 16;
  Rects_Right[4].right = 160;
  Rects_Right[4].bottom = 32;
  Rects_Right[5].left = 160;
  Rects_Right[5].top = 16;
  Rects_Right[5].right = 176;
  Rects_Right[5].bottom = 32;
  Rects_Right[6].left = 176;
  Rects_Right[6].top = 16;
  Rects_Right[6].right = 192;
  Rects_Right[6].bottom = 32;
  Rects_Right[7].left = 144;
  Rects_Right[7].top = 16;
  Rects_Right[7].right = 160;
  Rects_Right[7].bottom = 32;
  Rects_Right[8].left = 208;
  Rects_Right[8].top = 80;
  Rects_Right[8].right = 224;
  Rects_Right[8].bottom = 96;
  if ( NPC->currentState == 11 )
  {
    if ( NPC->animationTimer )
    {
      --NPC->animationTimer;
      NPC->animationNumber = 1;
    }
    else
    {
      if ( random(0, 100) == 1 )
        NPC->animationTimer = 30;
      NPC->animationNumber = 0;
    }
  }
  if ( NPC->currentState == 14 )
  {
    if ( NPC->animationTimer )
    {
      --NPC->animationTimer;
      NPC->animationNumber = 3;
    }
    else
    {
      if ( random(0, 100) == 1 )
        NPC->animationTimer = 30;
      NPC->animationNumber = 2;
    }
  }
  if ( NPC->direction )
    v2 = &Rects_Right[NPC->animationNumber];
  else
    v2 = &Rects_Left[NPC->animationNumber];
  NPC->rect = *v2;
}

//----- (00437D90) --------------------------------------------------------
void __cdecl NPC83(NPC *NPC)
{
  RECT *v1; // ecx
  RECT Rects_Right[8]; // [esp+4h] [ebp-100h]
  RECT Rects_Left[8]; // [esp+84h] [ebp-80h]

  Rects_Left[0].left = 0;
  Rects_Left[0].top = 0;
  Rects_Left[0].right = 40;
  Rects_Left[0].bottom = 40;
  Rects_Left[1].left = 40;
  Rects_Left[1].top = 0;
  Rects_Left[1].right = 80;
  Rects_Left[1].bottom = 40;
  Rects_Left[2].left = 80;
  Rects_Left[2].top = 0;
  Rects_Left[2].right = 120;
  Rects_Left[2].bottom = 40;
  Rects_Left[3].left = 0;
  Rects_Left[3].top = 0;
  Rects_Left[3].right = 40;
  Rects_Left[3].bottom = 40;
  Rects_Left[4].left = 120;
  Rects_Left[4].top = 0;
  Rects_Left[4].right = 160;
  Rects_Left[4].bottom = 40;
  Rects_Left[5].left = 0;
  Rects_Left[5].top = 0;
  Rects_Left[5].right = 40;
  Rects_Left[5].bottom = 40;
  Rects_Left[6].left = 160;
  Rects_Left[6].top = 0;
  Rects_Left[6].right = 200;
  Rects_Left[6].bottom = 40;
  Rects_Left[7].left = 200;
  Rects_Left[7].top = 0;
  Rects_Left[7].right = 240;
  Rects_Left[7].bottom = 40;
  Rects_Right[0].left = 0;
  Rects_Right[0].top = 40;
  Rects_Right[0].right = 40;
  Rects_Right[0].bottom = 80;
  Rects_Right[1].left = 40;
  Rects_Right[1].top = 40;
  Rects_Right[1].right = 80;
  Rects_Right[1].bottom = 80;
  Rects_Right[2].left = 80;
  Rects_Right[2].top = 40;
  Rects_Right[2].right = 120;
  Rects_Right[2].bottom = 80;
  Rects_Right[3].left = 0;
  Rects_Right[3].top = 40;
  Rects_Right[3].right = 40;
  Rects_Right[3].bottom = 80;
  Rects_Right[4].left = 120;
  Rects_Right[4].top = 40;
  Rects_Right[4].right = 160;
  Rects_Right[4].bottom = 80;
  Rects_Right[5].left = 0;
  Rects_Right[5].top = 40;
  Rects_Right[5].right = 40;
  Rects_Right[5].bottom = 80;
  Rects_Right[6].left = 160;
  Rects_Right[6].top = 40;
  Rects_Right[6].right = 200;
  Rects_Right[6].bottom = 80;
  Rects_Right[7].left = 200;
  Rects_Right[7].top = 40;
  Rects_Right[7].right = 240;
  Rects_Right[7].bottom = 80;
  switch ( NPC->currentState )
  {
    case 0:
      NPC->XVel = 0;
      NPC->currentState = 1;
      NPC->animationNumber = 0;
      NPC->animationTimer = 0;
      goto case_1;
    case 1:
case_1:
      if ( ++NPC->animationTimer > 5 )
      {
        NPC->animationTimer = 0;
        ++NPC->animationNumber;
      }
      if ( NPC->animationNumber > 1 )
        NPC->animationNumber = 0;
      break;
    case 2:
      NPC->currentState = 3;
      NPC->animationNumber = 2;
      NPC->animationTimer = 0;
      goto case_3;
    case 3:
case_3:
      if ( ++NPC->animationTimer > 3 )
      {
        NPC->animationTimer = 0;
        ++NPC->animationNumber;
      }
      if ( NPC->animationNumber > 5 )
        NPC->animationNumber = 2;
      if ( NPC->direction )
        NPC->XVel = 512;
      else
        NPC->XVel = -512;
      break;
    case 4:
      NPC->XVel = 0;
      NPC->currentState = 5;
      NPC->waitTimer = 0;
      NPC->animationNumber = 6;
      goto case_5;
    case 5:
case_5:
      if ( ++NPC->waitTimer > 10 )
      {
        NPC->waitTimer = 0;
        NPC->currentState = 6;
        NPC->animationNumber = 7;
        playSoundEffect(SFXEnemySmokePoof, 1);
      }
      break;
    case 6:
      if ( ++NPC->waitTimer > 8 )
      {
        NPC->currentState = 0;
        NPC->animationNumber = 0;
      }
      break;
    case 7:
      NPC->currentState = 1;
      break;
    default:
      break;
  }
  NPC->YVel += 64;
  if ( NPC->YVel > 1535 )
    NPC->YVel = 1535;
  NPC->XPos += NPC->XVel;
  NPC->YPos += NPC->YVel;
  if ( NPC->direction )
    v1 = &Rects_Right[NPC->animationNumber];
  else
    v1 = &Rects_Left[NPC->animationNumber];
  NPC->rect = *v1;
}

//----- (00438250) --------------------------------------------------------
void __cdecl NPC84(NPC *NPC)
{
  RECT Rects[4]; // [esp+0h] [ebp-40h]

  if ( NPC->collisionFlags & 0xFF )
  {
    createEffect(NPC->XPos, NPC->YPos, effectRisingDisc, 0);
    NPC->isAlive = 0;
  }
  NPC->YPos += NPC->YVel;
  NPC->XPos += NPC->XVel;
  Rects[0].left = 48;
  Rects[0].top = 48;
  Rects[0].right = 64;
  Rects[0].bottom = 64;
  Rects[1].left = 64;
  Rects[1].top = 48;
  Rects[1].right = 80;
  Rects[1].bottom = 64;
  Rects[2].left = 48;
  Rects[2].top = 64;
  Rects[2].right = 64;
  Rects[2].bottom = 80;
  Rects[3].left = 64;
  Rects[3].top = 64;
  Rects[3].right = 80;
  Rects[3].bottom = 80;
  if ( ++NPC->animationTimer > 2 )
  {
    NPC->animationTimer = 0;
    ++NPC->animationNumber;
  }
  if ( NPC->animationNumber > 3 )
    NPC->animationNumber = 0;
  NPC->rect = Rects[NPC->animationNumber];
  if ( ++NPC->count1 > 300 )
  {
    createEffect(NPC->XPos, NPC->YPos, effectRisingDisc, 0);
    NPC->isAlive = 0;
  }
}

//----- (004383D0) --------------------------------------------------------
void __cdecl NPC85(NPC *NPC)
{
  RECT *v1; // edx
  int NPC_Current_State; // [esp+0h] [ebp-64h]
  RECT Rects_Right[3]; // [esp+4h] [ebp-60h]
  RECT Rects_Left[3]; // [esp+34h] [ebp-30h]

  Rects_Left[0].left = 256;
  Rects_Left[0].top = 96;
  Rects_Left[0].right = 272;
  Rects_Left[0].bottom = 120;
  Rects_Left[1].left = 256;
  Rects_Left[1].top = 96;
  Rects_Left[1].right = 272;
  Rects_Left[1].bottom = 120;
  Rects_Left[2].left = 272;
  Rects_Left[2].top = 96;
  Rects_Left[2].right = 288;
  Rects_Left[2].bottom = 120;
  Rects_Right[0].left = 256;
  Rects_Right[0].top = 96;
  Rects_Right[0].right = 272;
  Rects_Right[0].bottom = 120;
  Rects_Right[1].left = 288;
  Rects_Right[1].top = 96;
  Rects_Right[1].right = 304;
  Rects_Right[1].bottom = 120;
  Rects_Right[2].left = 304;
  Rects_Right[2].top = 96;
  Rects_Right[2].right = 320;
  Rects_Right[2].bottom = 120;
  NPC_Current_State = NPC->currentState;
  if ( NPC_Current_State )
  {
    if ( NPC_Current_State == 1 && ++NPC->animationNumber > 2 )
      NPC->animationNumber = 1;
  }
  else
  {
    NPC->animationNumber = 0;
    if ( NPC->XPos - 4096 < quote.XPos
      && NPC->XPos + 4096 > quote.XPos
      && NPC->YPos - 0x2000 < quote.YPos
      && NPC->YPos + 4096 > quote.YPos )
    {
      playSoundEffect(SFXComputerScreenOn, 1);
      NPC->currentState = 1;
    }
  }
  if ( NPC->direction )
    v1 = &Rects_Right[NPC->animationNumber];
  else
    v1 = &Rects_Left[NPC->animationNumber];
  NPC->rect = *v1;
}

//----- (00438590) --------------------------------------------------------
void __cdecl NPC86(NPC *NPC)
{
  RECT *Cur_Rect; // eax
  int NPC_EXP_Amount; // [esp+0h] [ebp-54h]
  RECT Rects_Much_EXP[2]; // [esp+14h] [ebp-40h]
  RECT Rects_Not_Much_EXP[2]; // [esp+34h] [ebp-20h]

  Rects_Not_Much_EXP[0].left = 0;
  Rects_Not_Much_EXP[0].top = 80;
  Rects_Not_Much_EXP[0].right = 16;
  Rects_Not_Much_EXP[0].bottom = 96;
  Rects_Not_Much_EXP[1].left = 16;
  Rects_Not_Much_EXP[1].top = 80;
  Rects_Not_Much_EXP[1].right = 32;
  Rects_Not_Much_EXP[1].bottom = 96;
  Rects_Much_EXP[0].left = 0;
  Rects_Much_EXP[0].top = 112;
  Rects_Much_EXP[0].right = 16;
  Rects_Much_EXP[0].bottom = 128;
  Rects_Much_EXP[1].left = 16;
  Rects_Much_EXP[1].top = 112;
  Rects_Much_EXP[1].right = 32;
  Rects_Much_EXP[1].bottom = 128;
  if ( !NPC->direction )
  {
    if ( ++NPC->animationTimer > 2 )
    {
      NPC->animationTimer = 0;
      ++NPC->animationNumber;
    }
    if ( NPC->animationNumber > 1 )
      NPC->animationNumber = 0;
  }
  if ( currentBackground.mode == 5 || currentBackground.mode == 6 )
  {
    if ( !NPC->currentState )
    {
      NPC->currentState = 1;
      NPC->YVel = random(-32, 32);
      NPC->XVel = random(127, 256);
    }
    NPC->XVel -= 8;
    if ( NPC->XPos < 40960 )
      NPC->isAlive = 0;
    if ( NPC->XPos < -1536 )
      NPC->XPos = -1536;
    if ( NPC->collisionFlags & 1 )
      NPC->XVel = 256;
    if ( NPC->collisionFlags & 2 )
      NPC->YVel = 64;
    if ( NPC->collisionFlags & 8 )
      NPC->YVel = -64;
    NPC->XPos += NPC->XVel;
    NPC->YPos += NPC->YVel;
  }
  NPC_EXP_Amount = NPC->EXPAmount;
  if ( NPC_EXP_Amount == 1 )
  {
    NPC->rect = Rects_Not_Much_EXP[NPC->animationNumber];
  }
  else if ( NPC_EXP_Amount == 3 )
  {
    NPC->rect = Rects_Much_EXP[NPC->animationNumber];
  }
  if ( !NPC->direction )
    ++NPC->count1;
  if ( NPC->count1 > 550 )
    NPC->isAlive = 0;
  if ( NPC->count1 > 500 && NPC->count1 / 2 % 2 )
    NPC->rect.right = 0;
  if ( NPC->count1 > 547 )
  {
    Cur_Rect = &NPC->rect;
    Cur_Rect->left = 16;
    Cur_Rect->top = 0;
    Cur_Rect->right = 32;
    Cur_Rect->bottom = 16;
  }
}

//----- (00438850) --------------------------------------------------------
void __cdecl NPC87(NPC *NPC)
{
  int NPC_EXP_Amount; // [esp+0h] [ebp-54h]
  RECT Rects_Not_Much_EXP[2]; // [esp+4h] [ebp-50h]
  RECT Rects_Count_Thingy; // [esp+24h] [ebp-30h]
  RECT Rects_Much_EXP[2]; // [esp+34h] [ebp-20h]

  Rects_Not_Much_EXP[0].left = 32;
  Rects_Not_Much_EXP[0].top = 80;
  Rects_Not_Much_EXP[0].right = 48;
  Rects_Not_Much_EXP[0].bottom = 96;
  Rects_Not_Much_EXP[1].left = 48;
  Rects_Not_Much_EXP[1].top = 80;
  Rects_Not_Much_EXP[1].right = 64;
  Rects_Not_Much_EXP[1].bottom = 96;
  Rects_Much_EXP[0].left = 64;
  Rects_Much_EXP[0].top = 80;
  Rects_Much_EXP[0].right = 80;
  Rects_Much_EXP[0].bottom = 96;
  Rects_Much_EXP[1].left = 80;
  Rects_Much_EXP[1].top = 80;
  Rects_Much_EXP[1].right = 96;
  Rects_Much_EXP[1].bottom = 96;
  Rects_Count_Thingy.left = 16;
  Rects_Count_Thingy.top = 0;
  Rects_Count_Thingy.right = 32;
  Rects_Count_Thingy.bottom = 16;
  if ( !NPC->direction )
  {
    if ( ++NPC->animationTimer > 2 )
    {
      NPC->animationTimer = 0;
      ++NPC->animationNumber;
    }
    if ( NPC->animationNumber > 1 )
      NPC->animationNumber = 0;
  }
  if ( currentBackground.mode == 5 || currentBackground.mode == 6 )
  {
    if ( !NPC->currentState )
    {
      NPC->currentState = 1;
      NPC->YVel = random(-32, 32);
      NPC->XVel = random(127, 256);
    }
    NPC->XVel -= 8;
    if ( NPC->XPos < 40960 )
      NPC->isAlive = 0;
    if ( NPC->XPos < -1536 )
      NPC->XPos = -1536;
    if ( NPC->collisionFlags & 1 )
      NPC->XVel = 256;
    if ( NPC->collisionFlags & 2 )
      NPC->YVel = 64;
    if ( NPC->collisionFlags & 8 )
      NPC->YVel = -64;
    NPC->XPos += NPC->XVel;
    NPC->YPos += NPC->YVel;
  }
  NPC_EXP_Amount = NPC->EXPAmount;
  if ( NPC_EXP_Amount == 2 )
  {
    NPC->rect = Rects_Not_Much_EXP[NPC->animationNumber];
  }
  else if ( NPC_EXP_Amount == 6 )
  {
    NPC->rect = Rects_Much_EXP[NPC->animationNumber];
  }
  if ( !NPC->direction )
    ++NPC->count1;
  if ( NPC->count1 > 550 )
    NPC->isAlive = 0;
  if ( NPC->count1 > 500 && NPC->count1 / 2 % 2 )
    NPC->rect.right = 0;
  if ( NPC->count1 > 547 )
    NPC->rect = Rects_Count_Thingy;
}

//----- (00438B10) --------------------------------------------------------
void __cdecl NPC88(NPC *NPC)
{
  int v1; // ST10_4
  int v2; // ST0C_4
  int v3; // ST08_4
  int v4; // eax
  int Y_Vel; // ST24_4
  RECT *v6; // ecx
  RECT Rects_Right[12]; // [esp+8h] [ebp-190h]
  int X_Vel; // [esp+C8h] [ebp-D0h]
  int i; // [esp+CCh] [ebp-CCh]
  RECT Rects_Left[12]; // [esp+D0h] [ebp-C8h]
  unsigned __int8 v11; // [esp+197h] [ebp-1h]

  Rects_Left[0].left = 0;
  Rects_Left[0].top = 0;
  Rects_Left[0].right = 40;
  Rects_Left[0].bottom = 40;
  Rects_Left[1].left = 40;
  Rects_Left[1].top = 0;
  Rects_Left[1].right = 80;
  Rects_Left[1].bottom = 40;
  Rects_Left[2].left = 80;
  Rects_Left[2].top = 0;
  Rects_Left[2].right = 120;
  Rects_Left[2].bottom = 40;
  Rects_Left[3].left = 0;
  Rects_Left[3].top = 0;
  Rects_Left[3].right = 40;
  Rects_Left[3].bottom = 40;
  Rects_Left[4].left = 120;
  Rects_Left[4].top = 0;
  Rects_Left[4].right = 160;
  Rects_Left[4].bottom = 40;
  Rects_Left[5].left = 0;
  Rects_Left[5].top = 0;
  Rects_Left[5].right = 40;
  Rects_Left[5].bottom = 40;
  Rects_Left[6].left = 160;
  Rects_Left[6].top = 0;
  Rects_Left[6].right = 200;
  Rects_Left[6].bottom = 40;
  Rects_Left[7].left = 200;
  Rects_Left[7].top = 0;
  Rects_Left[7].right = 240;
  Rects_Left[7].bottom = 40;
  Rects_Left[8].left = 0;
  Rects_Left[8].top = 80;
  Rects_Left[8].right = 40;
  Rects_Left[8].bottom = 120;
  Rects_Left[9].left = 40;
  Rects_Left[9].top = 80;
  Rects_Left[9].right = 80;
  Rects_Left[9].bottom = 120;
  Rects_Left[10].left = 240;
  Rects_Left[10].top = 0;
  Rects_Left[10].right = 280;
  Rects_Left[10].bottom = 40;
  Rects_Left[11].left = 280;
  Rects_Left[11].top = 0;
  Rects_Left[11].right = 320;
  Rects_Left[11].bottom = 40;
  Rects_Right[0].left = 0;
  Rects_Right[0].top = 40;
  Rects_Right[0].right = 40;
  Rects_Right[0].bottom = 80;
  Rects_Right[1].left = 40;
  Rects_Right[1].top = 40;
  Rects_Right[1].right = 80;
  Rects_Right[1].bottom = 80;
  Rects_Right[2].left = 80;
  Rects_Right[2].top = 40;
  Rects_Right[2].right = 120;
  Rects_Right[2].bottom = 80;
  Rects_Right[3].left = 0;
  Rects_Right[3].top = 40;
  Rects_Right[3].right = 40;
  Rects_Right[3].bottom = 80;
  Rects_Right[4].left = 120;
  Rects_Right[4].top = 40;
  Rects_Right[4].right = 160;
  Rects_Right[4].bottom = 80;
  Rects_Right[5].left = 0;
  Rects_Right[5].top = 40;
  Rects_Right[5].right = 40;
  Rects_Right[5].bottom = 80;
  Rects_Right[6].left = 160;
  Rects_Right[6].top = 40;
  Rects_Right[6].right = 200;
  Rects_Right[6].bottom = 80;
  Rects_Right[7].left = 200;
  Rects_Right[7].top = 40;
  Rects_Right[7].right = 240;
  Rects_Right[7].bottom = 80;
  Rects_Right[8].left = 120;
  Rects_Right[8].top = 80;
  Rects_Right[8].right = 160;
  Rects_Right[8].bottom = 120;
  Rects_Right[9].left = 160;
  Rects_Right[9].top = 80;
  Rects_Right[9].right = 200;
  Rects_Right[9].bottom = 120;
  Rects_Right[10].left = 240;
  Rects_Right[10].top = 40;
  Rects_Right[10].right = 280;
  Rects_Right[10].bottom = 80;
  Rects_Right[11].left = 280;
  Rects_Right[11].top = 40;
  Rects_Right[11].right = 320;
  Rects_Right[11].bottom = 80;
  switch ( NPC->currentState )
  {
    case 0:
      NPC->XVel = 0;
      NPC->currentState = 1;
      NPC->animationNumber = 0;
      NPC->animationTimer = 0;
      goto case_1;
    case 1:
case_1:
      if ( ++NPC->animationTimer > 5 )
      {
        NPC->animationTimer = 0;
        ++NPC->animationNumber;
      }
      if ( NPC->animationNumber > 1 )
        NPC->animationNumber = 0;
      if ( ++NPC->waitTimer > 50 )
        NPC->currentState = 2;
      break;
    case 2:
      NPC->currentState = 3;
      NPC->waitTimer = 0;
      NPC->animationNumber = 2;
      NPC->animationTimer = 0;
      if ( ++NPC->count1 >= 3 && NPC->life <= 150 )
      {
        NPC->count2 = 1;
        if ( quote.XPos >= NPC->XPos )
          NPC->direction = 0;
        else
          NPC->direction = 2;
      }
      else
      {
        NPC->count2 = 0;
        if ( quote.XPos >= NPC->XPos )
          NPC->direction = 2;
        else
          NPC->direction = 0;
      }
      goto case_3;
    case 3:
case_3:
      ++NPC->waitTimer;
      if ( ++NPC->animationTimer > 3 )
      {
        NPC->animationTimer = 0;
        ++NPC->animationNumber;
      }
      if ( NPC->animationNumber > 5 )
        NPC->animationNumber = 2;
      if ( NPC->direction )
        NPC->XVel = 512;
      else
        NPC->XVel = -512;
      if ( NPC->count2 )
      {
        if ( NPC->waitTimer > 16 )
        {
          NPC->currentState = 9;
          NPC->XVel = 0;
          NPC->animationNumber = 10;
        }
      }
      else if ( NPC->waitTimer <= 50 )
      {
        if ( NPC->direction )
        {
          if ( NPC->XPos + 12288 > quote.XPos )
            NPC->currentState = 4;
        }
        else if ( NPC->XPos - 12288 < quote.XPos )
        {
          NPC->currentState = 4;
        }
      }
      else
      {
        NPC->animationNumber = 8;
        NPC->YVel = -1024;
        NPC->currentState = 7;
        NPC->waitTimer = 0;
        NPC->XVel = 3 * NPC->XVel / 2;
        NPC->damage = 2;
      }
      break;
    case 4:
      NPC->XVel = 0;
      NPC->currentState = 5;
      NPC->waitTimer = 0;
      NPC->animationNumber = 6;
      goto case_5;
    case 5:
case_5:
      if ( ++NPC->waitTimer > 12 )
      {
        NPC->waitTimer = 0;
        NPC->currentState = 6;
        NPC->animationNumber = 7;
        playSoundEffect(SFXEnemySmokePoof, 1);
        NPC->damage = 5;
        NPC->hitbox.front = 12288;
        NPC->hitbox.top = 1;
      }
      break;
    case 6:
      if ( ++NPC->waitTimer > 10 )
      {
        NPC->currentState = 0;
        NPC->animationNumber = 0;
        NPC->damage = 0;
        NPC->hitbox.front = 4096;
        NPC->hitbox.top = 0x2000;
      }
      break;
    case 7:
      if ( NPC->collisionFlags & 8 )
      {
        NPC->currentState = 8;
        NPC->animationNumber = 9;
        playSoundEffect(SFXLargeObjectHitGround, 1);
        setQuake(30);
        NPC->damage = 0;
        for ( i = 0; i < 4; ++i )
        {
          v1 = random(-1536, 0);
          v2 = random(-341, 341);
          v3 = NPC->YPos + (random(-12, 12) << 9);
          v4 = random(-12, 12);
          createNPC(NPCSmoke, NPC->XPos + (v4 << 9), v3, v2, v1, 0, 0, 256);
        }
      }
      break;
    case 8:
      NPC->XVel = 0;
      if ( ++NPC->waitTimer > 10 )
      {
        NPC->currentState = 0;
        NPC->animationNumber = 0;
        NPC->damage = 0;
      }
      break;
    case 9:
      NPC->currentState = 10;
      NPC->waitTimer = 0;
      if ( quote.XPos >= NPC->XPos )
        NPC->direction = 2;
      else
        NPC->direction = 0;
      goto case_10;
    case 10:
case_10:
      if ( ++NPC->waitTimer > 100 && NPC->waitTimer % 6 == 1 )
      {
        if ( NPC->direction )
          v11 = -8;
        else
          v11 = -120;
        v11 += random(-16, 16);
        Y_Vel = 3 * getSin(v11);
        X_Vel = 3 * getCos(v11);
        createNPC(NPCProjectileBalrogEnemyBounce, NPC->XPos, NPC->YPos + 2048, X_Vel, Y_Vel, 0, 0, 256);
        playSoundEffect(SFXDestroyBreakableBlock, 1);
      }
      if ( NPC->waitTimer > 50 && NPC->waitTimer / 2 % 2 )
        NPC->animationNumber = 11;
      else
        NPC->animationNumber = 10;
      if ( NPC->waitTimer > 132 )
      {
        NPC->currentState = 0;
        NPC->animationNumber = 0;
        NPC->count1 = 0;
      }
      break;
    default:
      break;
  }
  NPC->YVel += 64;
  if ( NPC->YVel > 1535 )
    NPC->YVel = 1535;
  NPC->XPos += NPC->XVel;
  NPC->YPos += NPC->YVel;
  if ( NPC->direction )
    v6 = &Rects_Right[NPC->animationNumber];
  else
    v6 = &Rects_Left[NPC->animationNumber];
  NPC->rect = *v6;
}

//----- (00439580) --------------------------------------------------------
void __cdecl NPC89(NPC *NPC)
{
  int Child_Y_Vel; // ST10_4
  int Child_X_Vel; // ST0C_4
  int Child_Y_Pos; // ST08_4
  int Child_X_Pos; // eax
  int Child_Y_Vel_; // ST10_4
  int Child_X_Vel_; // ST0C_4
  int Child_Y_Pos_; // ST08_4
  int Child_X_Pos_; // eax
  RECT *NPC_Rect; // eax MAPDST
  int _Child_Y_Vel; // ST10_4
  int _Child_X_Vel; // ST0C_4
  int _Child_Y_Pos; // ST08_4
  int _Child_X_Pos; // eax
  RECT *v15; // edx
  RECT *v16; // ecx
  RECT Rects_Right[4]; // [esp+4h] [ebp-88h]
  int i; // [esp+48h] [ebp-44h]
  RECT Rects_Left[4]; // [esp+4Ch] [ebp-40h]

  Rects_Left[0].left = 80;
  Rects_Left[0].top = 80;
  Rects_Left[0].right = 120;
  Rects_Left[0].bottom = 120;
  Rects_Left[1].left = 240;
  Rects_Left[1].top = 80;
  Rects_Left[1].right = 264;
  Rects_Left[1].bottom = 104;
  Rects_Left[2].left = 264;
  Rects_Left[2].top = 80;
  Rects_Left[2].right = 288;
  Rects_Left[2].bottom = 104;
  Rects_Left[3].left = 288;
  Rects_Left[3].top = 80;
  Rects_Left[3].right = 312;
  Rects_Left[3].bottom = 104;
  Rects_Right[0].left = 200;
  Rects_Right[0].top = 80;
  Rects_Right[0].right = 240;
  Rects_Right[0].bottom = 120;
  Rects_Right[1].left = 240;
  Rects_Right[1].top = 104;
  Rects_Right[1].right = 264;
  Rects_Right[1].bottom = 128;
  Rects_Right[2].left = 264;
  Rects_Right[2].top = 104;
  Rects_Right[2].right = 288;
  Rects_Right[2].bottom = 128;
  Rects_Right[3].left = 288;
  Rects_Right[3].top = 104;
  Rects_Right[3].right = 312;
  Rects_Right[3].bottom = 128;
  switch ( NPC->currentState )
  {
    case 0:
      playSoundEffect(SFXExplosion, 1);
      if ( NPC->XPos <= quote.XPos )
        NPC->direction = 2;
      else
        NPC->direction = 0;
      for ( i = 0; i < 8; ++i )
      {
        Child_Y_Vel = random(-1536, 0);
        Child_X_Vel = random(-341, 341);
        Child_Y_Pos = NPC->YPos + (random(-12, 12) << 9);
        Child_X_Pos = random(-12, 12);
        createNPC(NPCSmoke, NPC->XPos + (Child_X_Pos << 9), Child_Y_Pos, Child_X_Vel, Child_Y_Vel, left, 0, 256);
      }
      NPC->currentState = 1;
      goto case_1;
    case 1:
case_1:
      if ( ++NPC->waitTimer > 100 )
      {
        NPC->waitTimer = 0;
        NPC->currentState = 2;
      }
      if ( !(NPC->waitTimer % 5) )
      {
        Child_Y_Vel_ = random(-1536, 0);
        Child_X_Vel_ = random(-341, 341);
        Child_Y_Pos_ = NPC->YPos + (random(-12, 12) << 9);
        Child_X_Pos_ = random(-12, 12);
        createNPC(NPCSmoke, NPC->XPos + (Child_X_Pos_ << 9), Child_Y_Pos_, Child_X_Vel_, Child_Y_Vel_, 0, 0, 256);
      }
      if ( NPC->direction )
      {
        NPC_Rect = &NPC->rect;
        NPC_Rect->left = Rects_Right[0].left;
        NPC_Rect->top = Rects_Right[0].top;
        NPC_Rect->right = Rects_Right[0].right;
        NPC_Rect->bottom = Rects_Right[0].bottom;
      }
      else
      {
        NPC_Rect = &NPC->rect;
        NPC_Rect->left = Rects_Left[0].left;
        NPC_Rect->top = Rects_Left[0].top;
        NPC_Rect->right = Rects_Left[0].right;
        NPC_Rect->bottom = Rects_Left[0].bottom;
      }
      if ( NPC->waitTimer / 2 % 2 )
        --NPC->rect.left;
      break;
    case 2:
      if ( ++NPC->waitTimer / 2 % 2 && NPC->waitTimer < 100 )
      {
        NPC->animationNumber = 0;
        NPC->view.back = 10240;
        NPC->view.front = 10240;
        NPC->view.top = 10240;
      }
      else
      {
        NPC->animationNumber = 1;
        NPC->view.back = 6144;
        NPC->view.front = 6144;
        NPC->view.top = 4096;
      }
      if ( NPC->waitTimer > 150 )
      {
        NPC->waitTimer = 0;
        NPC->currentState = 3;
        NPC->animationNumber = 1;
      }
      if ( !(NPC->waitTimer % 9) )
      {
        _Child_Y_Vel = random(-1536, 0);
        _Child_X_Vel = random(-341, 341);
        _Child_Y_Pos = NPC->YPos + (random(-12, 12) << 9);
        _Child_X_Pos = random(-12, 12);
        createNPC(NPCSmoke, NPC->XPos + (_Child_X_Pos << 9), _Child_Y_Pos, _Child_X_Vel, _Child_Y_Vel, left, 0, 256);
      }
      if ( NPC->direction )
        v15 = &Rects_Right[NPC->animationNumber];
      else
        v15 = &Rects_Left[NPC->animationNumber];
      NPC->rect = *v15;
      break;
    case 3:
      if ( ++NPC->animationTimer > 50 )
      {
        NPC->animationTimer = 0;
        ++NPC->animationNumber;
      }
      if ( NPC->animationNumber == 3 )
        NPC->currentState = 4;
      if ( NPC->direction )
        v16 = &Rects_Right[NPC->animationNumber];
      else
        v16 = &Rects_Left[NPC->animationNumber];
      NPC->rect = *v16;
      break;
    default:
      break;
  }
  NPC->YVel += 64;
  if ( NPC->YVel > 1535 )
    NPC->YVel = 1535;
  NPC->XPos += NPC->XVel;
  NPC->YPos += NPC->YVel;
}

//----- (00439B00) --------------------------------------------------------
void __cdecl NPC90(NPC *NPC)
{
  RECT *NPC_Rect; // eax

  NPC_Rect = &NPC->rect;
  NPC_Rect->left = 280;
  NPC_Rect->top = 80;
  NPC_Rect->right = 296;
  NPC_Rect->bottom = 104;
}

//----- (00439B50) --------------------------------------------------------
signed int __cdecl NPC91(int a1)
{
  _DWORD *v1; // ecx
  signed int result; // eax

  if ( !*(_DWORD *)(a1 + 116) )
  {
    ++*(_DWORD *)(a1 + 116);
    *(_DWORD *)(a1 + 12) += 0x2000;
  }
  v1 = (_DWORD *)(a1 + 84);
  *v1 = 96;
  v1[1] = 88;
  v1[2] = 128;
  result = 112;
  v1[3] = 112;
  return result;
}

//----- (00439BC0) --------------------------------------------------------
int __cdecl NPC92(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  int v4; // [esp+4h] [ebp-30h]
  int v5; // [esp+8h] [ebp-2Ch]
  int v6; // [esp+Ch] [ebp-28h]
  int v7; // [esp+10h] [ebp-24h]
  int v8; // [esp+14h] [ebp-20h]
  int v9; // [esp+18h] [ebp-1Ch]
  int v10; // [esp+1Ch] [ebp-18h]
  int v11; // [esp+20h] [ebp-14h]
  int v12; // [esp+24h] [ebp-10h]
  int v13; // [esp+28h] [ebp-Ch]
  int v14; // [esp+2Ch] [ebp-8h]
  int v15; // [esp+30h] [ebp-4h]

  v4 = 272;
  v5 = 216;
  v6 = 288;
  v7 = 240;
  v8 = 288;
  v9 = 216;
  v10 = 304;
  v11 = 240;
  v12 = 304;
  v13 = 216;
  v14 = 320;
  v15 = 240;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 8) -= 2048;
      *(_DWORD *)(a1 + 12) += 0x2000;
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( ++*(_DWORD *)(a1 + 100) > 2 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 1 )
        *(_DWORD *)(a1 + 104) = 0;
      if ( random(0, 80) == 1 )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      if ( random(0, 120) == 10 )
      {
        *(_DWORD *)(a1 + 116) = 3;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 2;
      }
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 120) > 40 )
      {
        *(_DWORD *)(a1 + 116) = 3;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 2;
      }
      break;
    case 3:
      if ( ++*(_DWORD *)(a1 + 120) > 80 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    default:
      break;
  }
  v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}

//----- (00439DC0) --------------------------------------------------------
int __cdecl NPC93(int a1)
{
  int v1; // eax
  int *v2; // eax
  int *v3; // ecx
  int result; // eax
  int v5; // [esp+4h] [ebp-E0h]
  int v6; // [esp+8h] [ebp-DCh]
  int v7; // [esp+Ch] [ebp-D8h]
  int v8; // [esp+10h] [ebp-D4h]
  int v9; // [esp+14h] [ebp-D0h]
  int v10; // [esp+18h] [ebp-CCh]
  int v11; // [esp+1Ch] [ebp-C8h]
  int v12; // [esp+20h] [ebp-C4h]
  int v13; // [esp+24h] [ebp-C0h]
  int v14; // [esp+28h] [ebp-BCh]
  int v15; // [esp+2Ch] [ebp-B8h]
  int v16; // [esp+30h] [ebp-B4h]
  int v17; // [esp+34h] [ebp-B0h]
  int v18; // [esp+38h] [ebp-ACh]
  int v19; // [esp+3Ch] [ebp-A8h]
  int v20; // [esp+40h] [ebp-A4h]
  int v21; // [esp+44h] [ebp-A0h]
  int v22; // [esp+48h] [ebp-9Ch]
  int v23; // [esp+4Ch] [ebp-98h]
  int v24; // [esp+50h] [ebp-94h]
  int v25; // [esp+54h] [ebp-90h]
  int v26; // [esp+58h] [ebp-8Ch]
  int v27; // [esp+5Ch] [ebp-88h]
  int v28; // [esp+60h] [ebp-84h]
  int v29; // [esp+64h] [ebp-80h]
  int v30; // [esp+68h] [ebp-7Ch]
  int v31; // [esp+6Ch] [ebp-78h]
  int v32; // [esp+70h] [ebp-74h]
  int v33; // [esp+74h] [ebp-70h]
  int v34; // [esp+78h] [ebp-6Ch]
  int v35; // [esp+7Ch] [ebp-68h]
  int v36; // [esp+80h] [ebp-64h]
  int v37; // [esp+84h] [ebp-60h]
  int v38; // [esp+88h] [ebp-5Ch]
  int v39; // [esp+8Ch] [ebp-58h]
  int v40; // [esp+90h] [ebp-54h]
  int v41; // [esp+94h] [ebp-50h]
  int v42; // [esp+98h] [ebp-4Ch]
  int v43; // [esp+9Ch] [ebp-48h]
  int v44; // [esp+A0h] [ebp-44h]
  int v45; // [esp+A4h] [ebp-40h]
  int v46; // [esp+A8h] [ebp-3Ch]
  int v47; // [esp+ACh] [ebp-38h]
  int v48; // [esp+B0h] [ebp-34h]
  int v49; // [esp+B4h] [ebp-30h]
  int v50; // [esp+B8h] [ebp-2Ch]
  int v51; // [esp+BCh] [ebp-28h]
  int v52; // [esp+C0h] [ebp-24h]
  int v53; // [esp+C4h] [ebp-20h]
  int v54; // [esp+C8h] [ebp-1Ch]
  int v55; // [esp+CCh] [ebp-18h]
  int v56; // [esp+D0h] [ebp-14h]
  int v57; // [esp+D4h] [ebp-10h]
  int v58; // [esp+D8h] [ebp-Ch]
  int v59; // [esp+DCh] [ebp-8h]
  int v60; // [esp+E0h] [ebp-4h]

  v33 = 128;
  v34 = 0;
  v35 = 144;
  v36 = 16;
  v37 = 144;
  v38 = 0;
  v39 = 160;
  v40 = 16;
  v41 = 160;
  v42 = 0;
  v43 = 176;
  v44 = 16;
  v45 = 128;
  v46 = 0;
  v47 = 144;
  v48 = 16;
  v49 = 176;
  v50 = 0;
  v51 = 192;
  v52 = 16;
  v53 = 128;
  v54 = 0;
  v55 = 144;
  v56 = 16;
  v57 = 32;
  v58 = 32;
  v59 = 48;
  v60 = 48;
  v5 = 128;
  v6 = 16;
  v7 = 144;
  v8 = 32;
  v9 = 144;
  v10 = 16;
  v11 = 160;
  v12 = 32;
  v13 = 160;
  v14 = 16;
  v15 = 176;
  v16 = 32;
  v17 = 128;
  v18 = 16;
  v19 = 144;
  v20 = 32;
  v21 = 176;
  v22 = 16;
  v23 = 192;
  v24 = 32;
  v25 = 128;
  v26 = 16;
  v27 = 144;
  v28 = 32;
  v29 = 32;
  v30 = 32;
  v31 = 48;
  v32 = 48;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( random(0, 120) == 10 )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      if ( *(_DWORD *)(a1 + 8) - 0x4000 < quote.XPos
        && *(_DWORD *)(a1 + 8) + 0x4000 > quote.XPos
        && *(_DWORD *)(a1 + 12) - 0x4000 < quote.YPos
        && *(_DWORD *)(a1 + 12) + 0x2000 > quote.YPos )
      {
        if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
          *(_DWORD *)(a1 + 76) = 2;
        else
          *(_DWORD *)(a1 + 76) = 0;
      }
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    case 3:
      *(_DWORD *)(a1 + 116) = 4;
      *(_DWORD *)(a1 + 104) = 2;
      *(_DWORD *)(a1 + 100) = 0;
      goto LABEL_17;
    case 4:
LABEL_17:
      if ( ++*(_DWORD *)(a1 + 100) > 4 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 5 )
        *(_DWORD *)(a1 + 104) = 2;
      if ( *(_DWORD *)(a1 + 76) )
        v1 = *(_DWORD *)(a1 + 8) + 512;
      else
        v1 = *(_DWORD *)(a1 + 8) - 512;
      *(_DWORD *)(a1 + 8) = v1;
      break;
    case 0xA:
      *(_DWORD *)(a1 + 104) = 6;
      if ( ++*(_DWORD *)(a1 + 120) > 200 )
      {
        *(_DWORD *)(a1 + 120) = 0;
        createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectZzZ, 0);
      }
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 76) )
    v2 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  else
    v2 = &v33 + 4 * *(_DWORD *)(a1 + 104);
  v3 = (int *)(a1 + 84);
  *v3 = *v2;
  v3[1] = v2[1];
  v3[2] = v2[2];
  result = v2[3];
  v3[3] = result;
  return result;
}

//----- (0043A220) --------------------------------------------------------
// NPC 94 : Giant Jelly
int *__cdecl NPC94_Giant_Jelly(int a1)
{
  int v1; // ecx
  int *v2; // edx
  int *result; // eax
  int v4; // [esp+4h] [ebp-50h]
  int v5; // [esp+8h] [ebp-4Ch]
  int v6; // [esp+Ch] [ebp-48h]
  int v7; // [esp+10h] [ebp-44h]
  int v8; // [esp+14h] [ebp-40h]
  int v9; // [esp+18h] [ebp-3Ch]
  int v10; // [esp+1Ch] [ebp-38h]
  int v11; // [esp+20h] [ebp-34h]
  int v12; // [esp+24h] [ebp-30h]
  int v13; // [esp+28h] [ebp-2Ch]
  int v14; // [esp+2Ch] [ebp-28h]
  int v15; // [esp+30h] [ebp-24h]
  int v16; // [esp+34h] [ebp-20h]
  int v17; // [esp+38h] [ebp-1Ch]
  int v18; // [esp+3Ch] [ebp-18h]
  int v19; // [esp+40h] [ebp-14h]
  int v20; // [esp+44h] [ebp-10h]
  int v21; // [esp+48h] [ebp-Ch]
  int v22; // [esp+4Ch] [ebp-8h]
  int v23; // [esp+50h] [ebp-4h]

  v4 = 272;
  v5 = 0;
  v6 = 320;
  v7 = 24;
  v8 = 272;
  v9 = 24;
  v10 = 320;
  v11 = 48;
  v12 = 272;
  v13 = 48;
  v14 = 320;
  v15 = 72;
  v16 = 272;
  v17 = 72;
  v18 = 320;
  v19 = 96;
  v20 = 272;
  v21 = 96;
  v22 = 320;
  v23 = 120;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 104) = 4;
      if ( *(_BYTE *)(a1 + 156) )
      {
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    case 0xA:
      *(_WORD *)(a1 + 80) |= 0x20u;
      *(_WORD *)(a1 + 80) &= 0xFFFBu;
      if ( ++*(_DWORD *)(a1 + 120) > 40 )
      {
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 100) = 0;
        *(_DWORD *)(a1 + 116) = 11;
      }
      break;
    case 0xB:
      if ( ++*(_DWORD *)(a1 + 100) > 5 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 2 )
      {
        *(_DWORD *)(a1 + 116) = 12;
        *(_DWORD *)(a1 + 104) = 3;
      }
      break;
    case 0xC:
      *(_DWORD *)(a1 + 20) = -341;
      if ( ++*(_DWORD *)(a1 + 120) > 20 )
      {
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    case 0x14:
      *(_DWORD *)(a1 + 16) /= 2;
      *(_DWORD *)(a1 + 20) += 32;
      if ( !*(_BYTE *)(a1 + 156) )
      {
        *(_DWORD *)(a1 + 120) = 30;
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    default:
      break;
  }
  if ( *(_BYTE *)(a1 + 156) )
  {
    if ( ++*(_DWORD *)(a1 + 112) > 12 )
    {
      *(_DWORD *)(a1 + 116) = 20;
      *(_DWORD *)(a1 + 104) = 4;
      *(_WORD *)(a1 + 80) &= 0xFFDFu;
      *(_WORD *)(a1 + 80) |= 4u;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 112) = 0;
  }
  if ( *(_DWORD *)(a1 + 116) >= 10 )
  {
    if ( *(_DWORD *)(a1 + 4) & 1 )
    {
      *(_DWORD *)(a1 + 108) = 50;
      *(_DWORD *)(a1 + 76) = 2;
    }
    if ( *(_DWORD *)(a1 + 4) & 4 )
    {
      *(_DWORD *)(a1 + 108) = 50;
      *(_DWORD *)(a1 + 76) = 0;
    }
    if ( *(_DWORD *)(a1 + 108) )
    {
      --*(_DWORD *)(a1 + 108);
      if ( *(_DWORD *)(a1 + 76) )
        v1 = *(_DWORD *)(a1 + 16) + 128;
      else
        v1 = *(_DWORD *)(a1 + 16) - 128;
      *(_DWORD *)(a1 + 16) = v1;
    }
    else
    {
      *(_DWORD *)(a1 + 108) = 50;
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
    }
    *(_DWORD *)(a1 + 20) += 16;
    if ( *(_DWORD *)(a1 + 4) & 8 )
      *(_DWORD *)(a1 + 20) = -1024;
  }
  if ( *(_DWORD *)(a1 + 16) > 256 )
    *(_DWORD *)(a1 + 16) = 256;
  if ( *(_DWORD *)(a1 + 16) < -256 )
    *(_DWORD *)(a1 + 16) = -256;
  if ( *(_DWORD *)(a1 + 20) > 768 )
    *(_DWORD *)(a1 + 20) = 768;
  if ( *(_DWORD *)(a1 + 20) < -768 )
    *(_DWORD *)(a1 + 20) = -768;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v2 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v2;
  result[1] = v2[1];
  result[2] = v2[2];
  result[3] = v2[3];
  return result;
}

//----- (0043A680) --------------------------------------------------------
int *__cdecl NPC95(int a1)
{
  int v1; // edx
  int *v2; // edx
  int *result; // eax
  int v4; // [esp+4h] [ebp-80h]
  int v5; // [esp+8h] [ebp-7Ch]
  int v6; // [esp+Ch] [ebp-78h]
  int v7; // [esp+10h] [ebp-74h]
  int v8; // [esp+14h] [ebp-70h]
  int v9; // [esp+18h] [ebp-6Ch]
  int v10; // [esp+1Ch] [ebp-68h]
  int v11; // [esp+20h] [ebp-64h]
  int v12; // [esp+24h] [ebp-60h]
  int v13; // [esp+28h] [ebp-5Ch]
  int v14; // [esp+2Ch] [ebp-58h]
  int v15; // [esp+30h] [ebp-54h]
  int v16; // [esp+34h] [ebp-50h]
  int v17; // [esp+38h] [ebp-4Ch]
  int v18; // [esp+3Ch] [ebp-48h]
  int v19; // [esp+40h] [ebp-44h]
  int v20; // [esp+44h] [ebp-40h]
  int v21; // [esp+48h] [ebp-3Ch]
  int v22; // [esp+4Ch] [ebp-38h]
  int v23; // [esp+50h] [ebp-34h]
  int v24; // [esp+54h] [ebp-30h]
  int v25; // [esp+58h] [ebp-2Ch]
  int v26; // [esp+5Ch] [ebp-28h]
  int v27; // [esp+60h] [ebp-24h]
  int v28; // [esp+64h] [ebp-20h]
  int v29; // [esp+68h] [ebp-1Ch]
  int v30; // [esp+6Ch] [ebp-18h]
  int v31; // [esp+70h] [ebp-14h]
  int v32; // [esp+74h] [ebp-10h]
  int v33; // [esp+78h] [ebp-Ch]
  int v34; // [esp+7Ch] [ebp-8h]
  int v35; // [esp+80h] [ebp-4h]

  v20 = 208;
  v21 = 64;
  v22 = 224;
  v23 = 80;
  v24 = 224;
  v25 = 64;
  v26 = 240;
  v27 = 80;
  v28 = 240;
  v29 = 64;
  v30 = 256;
  v31 = 80;
  v32 = 256;
  v33 = 64;
  v34 = 272;
  v35 = 80;
  v4 = 208;
  v5 = 80;
  v6 = 224;
  v7 = 96;
  v8 = 224;
  v9 = 80;
  v10 = 240;
  v11 = 96;
  v12 = 240;
  v13 = 80;
  v14 = 256;
  v15 = 96;
  v16 = 256;
  v17 = 80;
  v18 = 272;
  v19 = 96;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 120) = random(0, 50);
      *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 8);
      if ( *(_DWORD *)(a1 + 76) )
        *(_DWORD *)(a1 + 16) = -512;
      else
        *(_DWORD *)(a1 + 16) = 512;
      goto LABEL_5;
    case 1:
LABEL_5:
      if ( --*(_DWORD *)(a1 + 120) > 0 )
        break;
      *(_DWORD *)(a1 + 116) = 10;
      goto LABEL_7;
    case 0xA:
LABEL_7:
      if ( ++*(_DWORD *)(a1 + 120) > 10 )
      {
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 100) = 0;
        *(_DWORD *)(a1 + 116) = 11;
      }
      break;
    case 0xB:
      if ( ++*(_DWORD *)(a1 + 100) > 5 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) == 2 )
      {
        if ( *(_DWORD *)(a1 + 76) )
          v1 = *(_DWORD *)(a1 + 16) + 256;
        else
          v1 = *(_DWORD *)(a1 + 16) - 256;
        *(_DWORD *)(a1 + 16) = v1;
        *(_DWORD *)(a1 + 20) -= 512;
      }
      if ( *(_DWORD *)(a1 + 104) > 2 )
      {
        *(_DWORD *)(a1 + 116) = 12;
        *(_DWORD *)(a1 + 104) = 3;
      }
      break;
    case 0xC:
      ++*(_DWORD *)(a1 + 120);
      if ( *(_DWORD *)(a1 + 12) > *(_DWORD *)(a1 + 36) && *(_DWORD *)(a1 + 120) > 10 )
      {
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 8) <= *(_DWORD *)(a1 + 32) )
    *(_DWORD *)(a1 + 76) = 2;
  else
    *(_DWORD *)(a1 + 76) = 0;
  if ( *(_DWORD *)(a1 + 4) & 1 )
  {
    *(_DWORD *)(a1 + 108) = 50;
    *(_DWORD *)(a1 + 76) = 2;
  }
  if ( *(_DWORD *)(a1 + 4) & 4 )
  {
    *(_DWORD *)(a1 + 108) = 50;
    *(_DWORD *)(a1 + 76) = 0;
  }
  *(_DWORD *)(a1 + 20) += 32;
  if ( *(_DWORD *)(a1 + 4) & 8 )
    *(_DWORD *)(a1 + 20) = -1024;
  if ( *(_DWORD *)(a1 + 16) > 256 )
    *(_DWORD *)(a1 + 16) = 256;
  if ( *(_DWORD *)(a1 + 16) < -256 )
    *(_DWORD *)(a1 + 16) = -256;
  if ( *(_DWORD *)(a1 + 20) > 512 )
    *(_DWORD *)(a1 + 20) = 512;
  if ( *(_DWORD *)(a1 + 20) < -512 )
    *(_DWORD *)(a1 + 20) = -512;
  if ( *(_BYTE *)(a1 + 156) )
  {
    *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16) / 2;
    *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20) / 2;
  }
  else
  {
    *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  }
  if ( *(_DWORD *)(a1 + 76) )
    v2 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v2 = &v20 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v2;
  result[1] = v2[1];
  result[2] = v2[2];
  result[3] = v2[3];
  return result;
}

//----- (0043AAF0) --------------------------------------------------------
int __cdecl NPC96(int a1)
{
  int v1; // eax
  int *v2; // ecx
  int *v3; // edx
  int result; // eax
  int v5; // [esp+0h] [ebp-34h]
  int v6; // [esp+4h] [ebp-30h]
  int v7; // [esp+8h] [ebp-2Ch]
  int v8; // [esp+Ch] [ebp-28h]
  int v9; // [esp+10h] [ebp-24h]
  int v10; // [esp+14h] [ebp-20h]
  int v11; // [esp+18h] [ebp-1Ch]
  int v12; // [esp+1Ch] [ebp-18h]
  int v13; // [esp+20h] [ebp-14h]
  int v14; // [esp+24h] [ebp-10h]
  int v15; // [esp+28h] [ebp-Ch]
  int v16; // [esp+2Ch] [ebp-8h]
  int v17; // [esp+30h] [ebp-4h]

  v6 = 272;
  v7 = 120;
  v8 = 288;
  v9 = 136;
  v10 = 288;
  v11 = 120;
  v12 = 304;
  v13 = 136;
  v14 = 304;
  v15 = 120;
  v16 = 320;
  v17 = 136;
  v5 = *(_DWORD *)(a1 + 116);
  switch ( v5 )
  {
    case 0:
      if ( *(_DWORD *)(a1 + 76) == 2 )
        *(_DWORD *)(a1 + 116) = 2;
      else
        *(_DWORD *)(a1 + 104) = 1;
      goto LABEL_8;
    case 1:
LABEL_8:
      *(_DWORD *)(a1 + 104) = 0;
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 100) > 0 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 2 )
        *(_DWORD *)(a1 + 104) = 0;
      if ( quote.XPos > *(_DWORD *)(a1 + 8) - 163840
        && quote.XPos < *(_DWORD *)(a1 + 8) + 163840
        && quote.YPos > *(_DWORD *)(a1 + 12) - 122880
        && quote.YPos < *(_DWORD *)(a1 + 12) + 122880
        && random(0, 5) == 1 )
      {
        v1 = random(-8, 8);
        createNPC(NPCEnemyBasil|0xC0, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12) + (v1 << 9), 0, 0, 0, 0, 256);
      }
      if ( quote.YPos < *(_DWORD *)(a1 + 12) + 4096
        && quote.YPos > *(_DWORD *)(a1 + 12) - 4096
        && quote.XPos < *(_DWORD *)(a1 + 8)
        && quote.XPos > *(_DWORD *)(a1 + 8) - 49152 )
      {
        quote.XVel -= 136;
        quote.flags |= 0x20u;
      }
      break;
  }
  v2 = &v6 + 4 * *(_DWORD *)(a1 + 104);
  v3 = (int *)(a1 + 84);
  *v3 = *v2;
  v3[1] = v2[1];
  result = v2[2];
  v3[2] = result;
  v3[3] = v2[3];
  return result;
}

//----- (0043AD10) --------------------------------------------------------
int *__cdecl NPC97(int a1)
{
  int v1; // ST08_4
  int v2; // eax
  int *v3; // edx
  int *result; // eax
  int v5; // [esp+0h] [ebp-34h]
  int v6; // [esp+4h] [ebp-30h]
  int v7; // [esp+8h] [ebp-2Ch]
  int v8; // [esp+Ch] [ebp-28h]
  int v9; // [esp+10h] [ebp-24h]
  int v10; // [esp+14h] [ebp-20h]
  int v11; // [esp+18h] [ebp-1Ch]
  int v12; // [esp+1Ch] [ebp-18h]
  int v13; // [esp+20h] [ebp-14h]
  int v14; // [esp+24h] [ebp-10h]
  int v15; // [esp+28h] [ebp-Ch]
  int v16; // [esp+2Ch] [ebp-8h]
  int v17; // [esp+30h] [ebp-4h]

  v6 = 272;
  v7 = 136;
  v8 = 288;
  v9 = 152;
  v10 = 288;
  v11 = 136;
  v12 = 304;
  v13 = 152;
  v14 = 304;
  v15 = 136;
  v16 = 320;
  v17 = 152;
  v5 = *(_DWORD *)(a1 + 116);
  switch ( v5 )
  {
    case 0:
      if ( *(_DWORD *)(a1 + 76) == 2 )
        *(_DWORD *)(a1 + 116) = 2;
      else
        *(_DWORD *)(a1 + 104) = 1;
      goto LABEL_8;
    case 1:
LABEL_8:
      *(_DWORD *)(a1 + 104) = 0;
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 100) > 0 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 2 )
        *(_DWORD *)(a1 + 104) = 0;
      if ( quote.XPos > *(_DWORD *)(a1 + 8) - 163840
        && quote.XPos < *(_DWORD *)(a1 + 8) + 163840
        && quote.YPos > *(_DWORD *)(a1 + 12) - 122880
        && quote.YPos < *(_DWORD *)(a1 + 12) + 122880
        && random(0, 5) == 1 )
      {
        v1 = *(_DWORD *)(a1 + 12);
        v2 = random(-8, 8);
        createNPC(NPCEnemyBasil|0xC0, *(_DWORD *)(a1 + 8) + (v2 << 9), v1, 0, 0, up, 0, 256);
      }
      if ( quote.XPos < *(_DWORD *)(a1 + 8) + 4096
        && quote.XPos > *(_DWORD *)(a1 + 8) - 4096
        && quote.YPos < *(_DWORD *)(a1 + 12)
        && quote.YPos > *(_DWORD *)(a1 + 12) - 49152 )
      {
        quote.YVel -= 136;
      }
      break;
  }
  v3 = &v6 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v3;
  result[1] = v3[1];
  result[2] = v3[2];
  result[3] = v3[3];
  return result;
}

//----- (0043AF20) --------------------------------------------------------
int __cdecl NPC98(int a1)
{
  int v1; // eax
  int *v2; // ecx
  int *v3; // edx
  int result; // eax
  int v5; // [esp+0h] [ebp-34h]
  int v6; // [esp+4h] [ebp-30h]
  int v7; // [esp+8h] [ebp-2Ch]
  int v8; // [esp+Ch] [ebp-28h]
  int v9; // [esp+10h] [ebp-24h]
  int v10; // [esp+14h] [ebp-20h]
  int v11; // [esp+18h] [ebp-1Ch]
  int v12; // [esp+1Ch] [ebp-18h]
  int v13; // [esp+20h] [ebp-14h]
  int v14; // [esp+24h] [ebp-10h]
  int v15; // [esp+28h] [ebp-Ch]
  int v16; // [esp+2Ch] [ebp-8h]
  int v17; // [esp+30h] [ebp-4h]

  v6 = 272;
  v7 = 152;
  v8 = 288;
  v9 = 168;
  v10 = 288;
  v11 = 152;
  v12 = 304;
  v13 = 168;
  v14 = 304;
  v15 = 152;
  v16 = 320;
  v17 = 168;
  v5 = *(_DWORD *)(a1 + 116);
  switch ( v5 )
  {
    case 0:
      if ( *(_DWORD *)(a1 + 76) == 2 )
        *(_DWORD *)(a1 + 116) = 2;
      else
        *(_DWORD *)(a1 + 104) = 1;
      goto LABEL_8;
    case 1:
LABEL_8:
      *(_DWORD *)(a1 + 104) = 0;
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 100) > 0 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 2 )
        *(_DWORD *)(a1 + 104) = 0;
      if ( quote.XPos > *(_DWORD *)(a1 + 8) - 163840
        && quote.XPos < *(_DWORD *)(a1 + 8) + 163840
        && quote.YPos > *(_DWORD *)(a1 + 12) - 122880
        && quote.YPos < *(_DWORD *)(a1 + 12) + 122880
        && random(0, 5) == 1 )
      {
        v1 = random(-8, 8);
        createNPC(NPCEnemyBasil|0xC0, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12) + (v1 << 9), 0, 0, right, 0, 256);
      }
      if ( quote.YPos < *(_DWORD *)(a1 + 12) + 4096
        && quote.YPos > *(_DWORD *)(a1 + 12) - 4096
        && quote.XPos < *(_DWORD *)(a1 + 8) + 49152
        && quote.XPos > *(_DWORD *)(a1 + 8) )
      {
        quote.XVel += 136;
        quote.flags |= 0x20u;
      }
      break;
  }
  v2 = &v6 + 4 * *(_DWORD *)(a1 + 104);
  v3 = (int *)(a1 + 84);
  *v3 = *v2;
  v3[1] = v2[1];
  result = v2[2];
  v3[2] = result;
  v3[3] = v2[3];
  return result;
}

//----- (0043B140) --------------------------------------------------------
int *__cdecl NPC99(int a1)
{
  int v1; // ST08_4
  int v2; // eax
  int *v3; // edx
  int *result; // eax
  int v5; // [esp+0h] [ebp-34h]
  int v6; // [esp+4h] [ebp-30h]
  int v7; // [esp+8h] [ebp-2Ch]
  int v8; // [esp+Ch] [ebp-28h]
  int v9; // [esp+10h] [ebp-24h]
  int v10; // [esp+14h] [ebp-20h]
  int v11; // [esp+18h] [ebp-1Ch]
  int v12; // [esp+1Ch] [ebp-18h]
  int v13; // [esp+20h] [ebp-14h]
  int v14; // [esp+24h] [ebp-10h]
  int v15; // [esp+28h] [ebp-Ch]
  int v16; // [esp+2Ch] [ebp-8h]
  int v17; // [esp+30h] [ebp-4h]

  v6 = 272;
  v7 = 168;
  v8 = 288;
  v9 = 184;
  v10 = 288;
  v11 = 168;
  v12 = 304;
  v13 = 184;
  v14 = 304;
  v15 = 168;
  v16 = 320;
  v17 = 184;
  v5 = *(_DWORD *)(a1 + 116);
  switch ( v5 )
  {
    case 0:
      if ( *(_DWORD *)(a1 + 76) == 2 )
        *(_DWORD *)(a1 + 116) = 2;
      else
        *(_DWORD *)(a1 + 104) = 1;
      goto LABEL_8;
    case 1:
LABEL_8:
      *(_DWORD *)(a1 + 104) = 0;
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 100) > 0 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 2 )
        *(_DWORD *)(a1 + 104) = 0;
      if ( quote.XPos > *(_DWORD *)(a1 + 8) - 163840
        && quote.XPos < *(_DWORD *)(a1 + 8) + 163840
        && quote.YPos > *(_DWORD *)(a1 + 12) - 122880
        && quote.YPos < *(_DWORD *)(a1 + 12) + 122880
        && random(0, 5) == 1 )
      {
        v1 = *(_DWORD *)(a1 + 12);
        v2 = random(-8, 8);
        createNPC(NPCEnemyBasil|0xC0, *(_DWORD *)(a1 + 8) + (v2 << 9), v1, 0, 0, down, 0, 256);
      }
      if ( quote.XPos < *(_DWORD *)(a1 + 8) + 4096
        && quote.XPos > *(_DWORD *)(a1 + 8) - 4096
        && quote.YPos < *(_DWORD *)(a1 + 12) + 49152
        && quote.YPos > *(_DWORD *)(a1 + 12) )
      {
        quote.YVel += 136;
      }
      break;
  }
  v3 = &v6 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v3;
  result[1] = v3[1];
  result[2] = v3[2];
  result[3] = v3[3];
  return result;
}

//----- (0043B350) --------------------------------------------------------
signed int __cdecl NPC100(int a1)
{
  _DWORD *v1; // ecx
  signed int result; // eax

  if ( !*(_DWORD *)(a1 + 116) )
  {
    *(_DWORD *)(a1 + 12) += 0x2000;
    *(_DWORD *)(a1 + 116) = 1;
  }
  v1 = (_DWORD *)(a1 + 84);
  *v1 = 272;
  v1[1] = 48;
  v1[2] = 288;
  result = 64;
  v1[3] = 64;
  return result;
}

//----- (0043B410) --------------------------------------------------------
int __cdecl NPC101(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+0h] [ebp-30h]
  int v5; // [esp+4h] [ebp-2Ch]
  int v6; // [esp+8h] [ebp-28h]
  int v7; // [esp+Ch] [ebp-24h]
  int v8; // [esp+10h] [ebp-20h]
  int v9; // [esp+14h] [ebp-1Ch]
  int v10; // [esp+18h] [ebp-18h]
  int v11; // [esp+1Ch] [ebp-14h]
  int v12; // [esp+20h] [ebp-10h]
  int v13; // [esp+24h] [ebp-Ch]
  int v14; // [esp+28h] [ebp-8h]
  int v15; // [esp+2Ch] [ebp-4h]

  v4 = 240;
  v5 = 136;
  v6 = 256;
  v7 = 152;
  v8 = 240;
  v9 = 136;
  v10 = 256;
  v11 = 152;
  v12 = 256;
  v13 = 136;
  v14 = 272;
  v15 = 152;
  if ( ++*(_DWORD *)(a1 + 100) > 3 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 2 )
    *(_DWORD *)(a1 + 104) = 0;
  v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (0043B4E0) --------------------------------------------------------
int *__cdecl NPC102(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+0h] [ebp-40h]
  int v4; // [esp+4h] [ebp-3Ch]
  int v5; // [esp+8h] [ebp-38h]
  int v6; // [esp+Ch] [ebp-34h]
  int v7; // [esp+10h] [ebp-30h]
  int v8; // [esp+14h] [ebp-2Ch]
  int v9; // [esp+18h] [ebp-28h]
  int v10; // [esp+1Ch] [ebp-24h]
  int v11; // [esp+20h] [ebp-20h]
  int v12; // [esp+24h] [ebp-1Ch]
  int v13; // [esp+28h] [ebp-18h]
  int v14; // [esp+2Ch] [ebp-14h]
  int v15; // [esp+30h] [ebp-10h]
  int v16; // [esp+34h] [ebp-Ch]
  int v17; // [esp+38h] [ebp-8h]
  int v18; // [esp+3Ch] [ebp-4h]

  v3 = 208;
  v4 = 120;
  v5 = 224;
  v6 = 136;
  v7 = 224;
  v8 = 120;
  v9 = 240;
  v10 = 136;
  v11 = 240;
  v12 = 120;
  v13 = 256;
  v14 = 136;
  v15 = 256;
  v16 = 120;
  v17 = 272;
  v18 = 136;
  if ( !*(_DWORD *)(a1 + 116) )
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 12) += 4096;
  }
  if ( ++*(_DWORD *)(a1 + 100) > 0 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 3 )
    *(_DWORD *)(a1 + 104) = 0;
  v1 = &v3 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (0043B5F0) --------------------------------------------------------
void __cdecl NPC103(int a1)
{
  int v1; // edx
  int *v2; // eax
  int *v3; // ecx
  int v4; // [esp+0h] [ebp-64h]
  int v5; // [esp+4h] [ebp-60h]
  int v6; // [esp+8h] [ebp-5Ch]
  int v7; // [esp+Ch] [ebp-58h]
  int v8; // [esp+10h] [ebp-54h]
  int v9; // [esp+14h] [ebp-50h]
  int v10; // [esp+18h] [ebp-4Ch]
  int v11; // [esp+1Ch] [ebp-48h]
  int v12; // [esp+20h] [ebp-44h]
  int v13; // [esp+24h] [ebp-40h]
  int v14; // [esp+28h] [ebp-3Ch]
  int v15; // [esp+2Ch] [ebp-38h]
  int v16; // [esp+30h] [ebp-34h]
  int v17; // [esp+34h] [ebp-30h]
  int v18; // [esp+38h] [ebp-2Ch]
  int v19; // [esp+3Ch] [ebp-28h]
  int v20; // [esp+40h] [ebp-24h]
  int v21; // [esp+44h] [ebp-20h]
  int v22; // [esp+48h] [ebp-1Ch]
  int v23; // [esp+4Ch] [ebp-18h]
  int v24; // [esp+50h] [ebp-14h]
  int v25; // [esp+54h] [ebp-10h]
  int v26; // [esp+58h] [ebp-Ch]
  int v27; // [esp+5Ch] [ebp-8h]
  int v28; // [esp+60h] [ebp-4h]

  v17 = 192;
  v18 = 96;
  v19 = 208;
  v20 = 120;
  v21 = 208;
  v22 = 96;
  v23 = 224;
  v24 = 120;
  v25 = 224;
  v26 = 96;
  v27 = 240;
  v28 = 120;
  v5 = 192;
  v6 = 120;
  v7 = 208;
  v8 = 144;
  v9 = 208;
  v10 = 120;
  v11 = 224;
  v12 = 144;
  v13 = 224;
  v14 = 120;
  v15 = 240;
  v16 = 144;
  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 != 1 )
      goto LABEL_12;
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
  }
  if ( *(_DWORD *)(a1 + 76) )
    v1 = *(_DWORD *)(a1 + 16) + 32;
  else
    v1 = *(_DWORD *)(a1 + 16) - 32;
  *(_DWORD *)(a1 + 16) = v1;
  if ( ++*(_DWORD *)(a1 + 100) > 0 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 2 )
    *(_DWORD *)(a1 + 104) = 0;
LABEL_12:
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  if ( *(_DWORD *)(a1 + 76) )
    v2 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  else
    v2 = &v17 + 4 * *(_DWORD *)(a1 + 104);
  v3 = (int *)(a1 + 84);
  *v3 = *v2;
  v3[1] = v2[1];
  v3[2] = v2[2];
  v3[3] = v2[3];
  if ( ++*(_DWORD *)(a1 + 108) > 100 )
    *(_BYTE *)a1 = 0;
  if ( *(_DWORD *)(a1 + 108) % 4 == 1 )
    playSoundEffect(SFXIronHeadShot, 1);
}

//----- (0043B7F0) --------------------------------------------------------
int *__cdecl NPC104(int a1)
{
  int *v1; // edx
  int *result; // eax
  signed int v3; // [esp+4h] [ebp-64h]
  int v4; // [esp+8h] [ebp-60h]
  int v5; // [esp+Ch] [ebp-5Ch]
  int v6; // [esp+10h] [ebp-58h]
  int v7; // [esp+14h] [ebp-54h]
  int v8; // [esp+18h] [ebp-50h]
  int v9; // [esp+1Ch] [ebp-4Ch]
  int v10; // [esp+20h] [ebp-48h]
  int v11; // [esp+24h] [ebp-44h]
  int v12; // [esp+28h] [ebp-40h]
  int v13; // [esp+2Ch] [ebp-3Ch]
  int v14; // [esp+30h] [ebp-38h]
  int v15; // [esp+34h] [ebp-34h]
  int v16; // [esp+38h] [ebp-30h]
  int v17; // [esp+3Ch] [ebp-2Ch]
  int v18; // [esp+40h] [ebp-28h]
  int v19; // [esp+44h] [ebp-24h]
  int v20; // [esp+48h] [ebp-20h]
  int v21; // [esp+4Ch] [ebp-1Ch]
  int v22; // [esp+50h] [ebp-18h]
  int v23; // [esp+54h] [ebp-14h]
  int v24; // [esp+58h] [ebp-10h]
  int v25; // [esp+5Ch] [ebp-Ch]
  int v26; // [esp+60h] [ebp-8h]
  int v27; // [esp+64h] [ebp-4h]

  v16 = 0;
  v17 = 112;
  v18 = 32;
  v19 = 144;
  v20 = 32;
  v21 = 112;
  v22 = 64;
  v23 = 144;
  v24 = 64;
  v25 = 112;
  v26 = 96;
  v27 = 144;
  v4 = 0;
  v5 = 144;
  v6 = 32;
  v7 = 176;
  v8 = 32;
  v9 = 144;
  v10 = 64;
  v11 = 176;
  v12 = 64;
  v13 = 144;
  v14 = 96;
  v15 = 176;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 20) = 0;
      if ( *(_DWORD *)(a1 + 76) != 4 )
      {
        *(_WORD *)(a1 + 80) &= 0xFFF7u;
        goto LABEL_8;
      }
      if ( random(0, 1) )
        *(_DWORD *)(a1 + 76) = 0;
      else
        *(_DWORD *)(a1 + 76) = 2;
      *(_WORD *)(a1 + 80) |= 8u;
      *(_DWORD *)(a1 + 104) = 2;
      *(_DWORD *)(a1 + 116) = 3;
      break;
    case 1:
LABEL_8:
      ++*(_DWORD *)(a1 + 120);
      if ( random(0, 50) == 1 )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 100) = 0;
      }
      break;
    case 2:
      ++*(_DWORD *)(a1 + 120);
      if ( ++*(_DWORD *)(a1 + 100) > 2 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 1 )
        *(_DWORD *)(a1 + 104) = 0;
      if ( *(_DWORD *)(a1 + 120) > 18 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 116) = 1;
      }
      break;
    case 3:
      if ( ++*(_DWORD *)(a1 + 120) > 40 )
        *(_WORD *)(a1 + 80) &= 0xFFF7u;
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 116) = 0;
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      goto LABEL_24;
    case 0xB:
LABEL_24:
      if ( *(_DWORD *)(a1 + 4) & 1 && *(_DWORD *)(a1 + 16) < 0 )
      {
        *(_DWORD *)(a1 + 16) = -*(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 76) = 2;
      }
      if ( *(_DWORD *)(a1 + 4) & 4 && *(_DWORD *)(a1 + 16) > 0 )
      {
        *(_DWORD *)(a1 + 16) = -*(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 76) = 0;
      }
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 116) = 0;
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    default:
      break;
  }
  v3 = 0;
  if ( *(_DWORD *)(a1 + 116) < 10 && *(_DWORD *)(a1 + 116) != 3 && *(_DWORD *)(a1 + 120) > 10 )
  {
    if ( *(_BYTE *)(a1 + 156) )
      v3 = 1;
    if ( *(_DWORD *)(a1 + 8) >= quote.XPos - 81920
      && *(_DWORD *)(a1 + 8) <= quote.XPos + 81920
      && *(_DWORD *)(a1 + 12) >= quote.YPos - 0x8000
      && *(_DWORD *)(a1 + 12) <= quote.YPos + 0x8000
      && random(0, 50) == 2 )
    {
      v3 = 1;
    }
  }
  if ( v3 )
  {
    if ( *(_DWORD *)(a1 + 8) >= quote.XPos )
      *(_DWORD *)(a1 + 76) = 0;
    else
      *(_DWORD *)(a1 + 76) = 2;
    *(_DWORD *)(a1 + 116) = 10;
    *(_DWORD *)(a1 + 104) = 2;
    *(_DWORD *)(a1 + 20) = -1535;
    if ( !(quote.flags & 2) )
      playSoundEffect(SFXCritterHop, 1);
    if ( *(_DWORD *)(a1 + 76) )
      *(_DWORD *)(a1 + 16) = 512;
    else
      *(_DWORD *)(a1 + 16) = -512;
  }
  *(_DWORD *)(a1 + 20) += 128;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v16 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (0043BD00) --------------------------------------------------------
int *__cdecl NPC105(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+0h] [ebp-20h]
  int v4; // [esp+4h] [ebp-1Ch]
  int v5; // [esp+8h] [ebp-18h]
  int v6; // [esp+Ch] [ebp-14h]
  int v7; // [esp+10h] [ebp-10h]
  int v8; // [esp+14h] [ebp-Ch]
  int v9; // [esp+18h] [ebp-8h]
  int v10; // [esp+1Ch] [ebp-4h]

  v3 = 128;
  v4 = 32;
  v5 = 144;
  v6 = 48;
  v7 = 128;
  v8 = 32;
  v9 = 128;
  v10 = 32;
  if ( ++*(_DWORD *)(a1 + 120) > 30 )
    *(_BYTE *)a1 = 0;
  if ( *(_DWORD *)(a1 + 120) < 5 )
    *(_DWORD *)(a1 + 12) -= 512;
  v1 = &v3 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (0043BDB0) --------------------------------------------------------
int __cdecl NPC106(int a1)
{
  int result; // eax

  result = a1;
  if ( !*(_DWORD *)(a1 + 116) )
  {
    createNPC((NPCNames)105, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12) - 4096, 0, 0, 0, 0, 384);
    result = a1;
    *(_DWORD *)(a1 + 116) = 1;
  }
  return result;
}

//----- (0043BE00) --------------------------------------------------------
int __cdecl NPC107(int a1)
{
  int v1; // ST10_4
  int v2; // eax
  int v3; // ST10_4
  int v4; // eax
  int v5; // ST10_4
  int v6; // eax
  int *v7; // ecx
  int *v8; // edx
  int result; // eax
  int v10; // [esp+4h] [ebp-A8h]
  int v11; // [esp+8h] [ebp-A4h]
  int v12; // [esp+Ch] [ebp-A0h]
  int v13; // [esp+10h] [ebp-9Ch]
  int v14; // [esp+14h] [ebp-98h]
  int v15; // [esp+18h] [ebp-94h]
  int v16; // [esp+1Ch] [ebp-90h]
  int v17; // [esp+20h] [ebp-8Ch]
  int v18; // [esp+24h] [ebp-88h]
  int v19; // [esp+28h] [ebp-84h]
  int v20; // [esp+2Ch] [ebp-80h]
  int v21; // [esp+30h] [ebp-7Ch]
  int v22; // [esp+34h] [ebp-78h]
  int v23; // [esp+38h] [ebp-74h]
  int v24; // [esp+3Ch] [ebp-70h]
  int v25; // [esp+40h] [ebp-6Ch]
  int v26; // [esp+44h] [ebp-68h]
  int v27; // [esp+48h] [ebp-64h]
  int v28; // [esp+4Ch] [ebp-60h]
  int v29; // [esp+50h] [ebp-5Ch]
  int v30; // [esp+54h] [ebp-58h]
  int v31; // [esp+58h] [ebp-54h]
  int v32; // [esp+5Ch] [ebp-50h]
  int v33; // [esp+60h] [ebp-4Ch]
  int v34; // [esp+64h] [ebp-48h]
  int v35; // [esp+68h] [ebp-44h]
  int v36; // [esp+6Ch] [ebp-40h]
  int v37; // [esp+70h] [ebp-3Ch]
  int v38; // [esp+74h] [ebp-38h]
  int v39; // [esp+78h] [ebp-34h]
  int v40; // [esp+7Ch] [ebp-30h]
  int v41; // [esp+80h] [ebp-2Ch]
  int v42; // [esp+84h] [ebp-28h]
  int v43; // [esp+88h] [ebp-24h]
  int v44; // [esp+8Ch] [ebp-20h]
  int v45; // [esp+90h] [ebp-1Ch]
  int v46; // [esp+94h] [ebp-18h]
  int v47; // [esp+98h] [ebp-14h]
  int v48; // [esp+9Ch] [ebp-10h]
  int v49; // [esp+A0h] [ebp-Ch]
  int i; // [esp+A8h] [ebp-4h]

  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      if ( *(_DWORD *)(a1 + 76) == 2 )
        *(_DWORD *)(a1 + 104) = 5;
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      for ( i = 0; i < 4; ++i )
      {
        v1 = random(-1536, 0);
        v2 = random(-341, 341);
        createNPC(NPCSmoke, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), v2, v1, 0, 0, 256);
      }
      goto LABEL_8;
    case 0xB:
LABEL_8:
      if ( ++*(_DWORD *)(a1 + 100) > 1 )
      {
        playSoundEffect(SFXComputerScreenOn, 1);
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 1 )
        *(_DWORD *)(a1 + 104) = 0;
      if ( ++*(_DWORD *)(a1 + 120) > 100 )
        *(_DWORD *)(a1 + 116) = 12;
      break;
    case 0xC:
      *(_DWORD *)(a1 + 116) = 13;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 104) = 1;
      goto LABEL_16;
    case 0xD:
LABEL_16:
      if ( ++*(_DWORD *)(a1 + 120) > 50 )
        *(_DWORD *)(a1 + 116) = 14;
      break;
    case 0xE:
      *(_DWORD *)(a1 + 116) = 15;
      *(_DWORD *)(a1 + 120) = 0;
      goto LABEL_20;
    case 0xF:
LABEL_20:
      if ( *(_DWORD *)(a1 + 120) / 2 % 2 )
      {
        *(_DWORD *)(a1 + 8) += 512;
        playSoundEffect(SFXDoorOpen, 1);
      }
      else
      {
        *(_DWORD *)(a1 + 8) -= 512;
      }
      if ( ++*(_DWORD *)(a1 + 120) > 50 )
        *(_DWORD *)(a1 + 116) = 16;
      break;
    case 0x10:
      *(_DWORD *)(a1 + 116) = 17;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 104) = 2;
      playSoundEffect(SFXDestroyBreakableBlock, 1);
      for ( i = 0; i < 8; ++i )
      {
        v3 = random(-1536, 0);
        v4 = random(-341, 341);
        createNPC(NPCSmoke, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), v4, v3, 0, 0, 256);
      }
      goto LABEL_29;
    case 0x11:
LABEL_29:
      if ( ++*(_DWORD *)(a1 + 120) > 150 )
        *(_DWORD *)(a1 + 116) = 18;
      break;
    case 0x12:
      *(_DWORD *)(a1 + 116) = 19;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 104) = 3;
      *(_DWORD *)(a1 + 100) = 0;
      goto LABEL_33;
    case 0x13:
LABEL_33:
      if ( ++*(_DWORD *)(a1 + 100) > 3 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 4 )
      {
        playSoundEffect(SFXDoorOpen, 1);
        *(_DWORD *)(a1 + 104) = 3;
      }
      if ( ++*(_DWORD *)(a1 + 120) > 100 )
      {
        *(_DWORD *)(a1 + 116) = 20;
        playSoundEffect(SFXDestroyBreakableBlock, 1);
        for ( i = 0; i < 4; ++i )
        {
          v5 = random(-1536, 0);
          v6 = random(-341, 341);
          createNPC(NPCSmoke, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), v6, v5, 0, 0, 256);
        }
      }
      break;
    case 0x14:
      *(_DWORD *)(a1 + 104) = 4;
      break;
    case 0x15:
      *(_DWORD *)(a1 + 116) = 22;
      *(_DWORD *)(a1 + 104) = 5;
      playSoundEffect(SFXCritterSmallHurt, 1);
      break;
    case 0x64:
      *(_DWORD *)(a1 + 116) = 101;
      *(_DWORD *)(a1 + 104) = 6;
      *(_DWORD *)(a1 + 100) = 0;
      goto LABEL_45;
    case 0x65:
LABEL_45:
      if ( ++*(_DWORD *)(a1 + 100) > 4 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 9 )
        *(_DWORD *)(a1 + 104) = 6;
      break;
    case 0x6E:
      createDustClouds(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 0x2000, 16);
      *(_BYTE *)a1 = 0;
      break;
    default:
      break;
  }
  v10 = 144;
  v11 = 0;
  v12 = 160;
  v13 = 24;
  v14 = 160;
  v15 = 0;
  v16 = 176;
  v17 = 24;
  v18 = 176;
  v19 = 0;
  v20 = 192;
  v21 = 24;
  v22 = 192;
  v23 = 0;
  v24 = 208;
  v25 = 24;
  v26 = 208;
  v27 = 0;
  v28 = 224;
  v29 = 24;
  v30 = 224;
  v31 = 0;
  v32 = 240;
  v33 = 24;
  v34 = 176;
  v35 = 0;
  v36 = 192;
  v37 = 24;
  v38 = 192;
  v39 = 0;
  v40 = 208;
  v41 = 24;
  v42 = 208;
  v43 = 0;
  v44 = 224;
  v45 = 24;
  v46 = 192;
  v47 = 0;
  v48 = 208;
  v49 = 24;
  v7 = &v10 + 4 * *(_DWORD *)(a1 + 104);
  v8 = (int *)(a1 + 84);
  *v8 = *v7;
  v8[1] = v7[1];
  result = v7[2];
  v8[2] = result;
  v8[3] = v7[3];
  return result;
}

//----- (0043C4B0) --------------------------------------------------------
int __cdecl NPC108(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+0h] [ebp-30h]
  int v5; // [esp+4h] [ebp-2Ch]
  int v6; // [esp+8h] [ebp-28h]
  int v7; // [esp+Ch] [ebp-24h]
  int v8; // [esp+10h] [ebp-20h]
  int v9; // [esp+14h] [ebp-1Ch]
  int v10; // [esp+18h] [ebp-18h]
  int v11; // [esp+1Ch] [ebp-14h]
  int v12; // [esp+20h] [ebp-10h]
  int v13; // [esp+24h] [ebp-Ch]
  int v14; // [esp+28h] [ebp-8h]
  int v15; // [esp+2Ch] [ebp-4h]

  if ( *(_DWORD *)(a1 + 4) & 0xFF )
  {
    createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectRisingDisc, 0);
    *(_BYTE *)a1 = 0;
  }
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  v4 = 96;
  v5 = 48;
  v6 = 112;
  v7 = 64;
  v8 = 112;
  v9 = 48;
  v10 = 128;
  v11 = 64;
  v12 = 128;
  v13 = 48;
  v14 = 144;
  v15 = 64;
  if ( ++*(_DWORD *)(a1 + 100) > 1 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 2 )
    *(_DWORD *)(a1 + 104) = 0;
  v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  v2[3] = v1[3];
  result = a1;
  if ( ++*(_DWORD *)(a1 + 108) > 300 )
  {
    createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectRisingDisc, 0);
    result = a1;
    *(_BYTE *)a1 = 0;
  }
  return result;
}

//----- (0043C610) --------------------------------------------------------
int *__cdecl NPC109(int a1)
{
  int v1; // ST10_4
  int v2; // eax
  int *v3; // edx
  int *result; // eax
  int v5; // [esp+4h] [ebp-44h]
  int v6; // [esp+8h] [ebp-40h]
  int v7; // [esp+Ch] [ebp-3Ch]
  int v8; // [esp+10h] [ebp-38h]
  int v9; // [esp+14h] [ebp-34h]
  int v10; // [esp+18h] [ebp-30h]
  int v11; // [esp+1Ch] [ebp-2Ch]
  int v12; // [esp+20h] [ebp-28h]
  int i; // [esp+24h] [ebp-24h]
  int v14; // [esp+28h] [ebp-20h]
  int v15; // [esp+2Ch] [ebp-1Ch]
  int v16; // [esp+30h] [ebp-18h]
  int v17; // [esp+34h] [ebp-14h]
  int v18; // [esp+38h] [ebp-10h]
  int v19; // [esp+3Ch] [ebp-Ch]
  int v20; // [esp+40h] [ebp-8h]
  int v21; // [esp+44h] [ebp-4h]

  v14 = 240;
  v15 = 0;
  v16 = 256;
  v17 = 24;
  v18 = 256;
  v19 = 0;
  v20 = 272;
  v21 = 24;
  v5 = 240;
  v6 = 24;
  v7 = 256;
  v8 = 48;
  v9 = 256;
  v10 = 24;
  v11 = 272;
  v12 = 48;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      if ( --*(_DWORD *)(a1 + 120) )
        *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      goto LABEL_5;
    case 1:
LABEL_5:
      if ( random(0, 120) == 10 )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      if ( *(_DWORD *)(a1 + 8) - 0x4000 < quote.XPos
        && *(_DWORD *)(a1 + 8) + 0x4000 > quote.XPos
        && *(_DWORD *)(a1 + 12) - 0x4000 < quote.YPos
        && *(_DWORD *)(a1 + 12) + 0x2000 > quote.YPos )
      {
        if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
          *(_DWORD *)(a1 + 76) = 2;
        else
          *(_DWORD *)(a1 + 76) = 0;
      }
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 0;
      playSoundEffect(SFXDestroyBreakableBlock, 1);
      for ( i = 0; i < 8; ++i )
      {
        v1 = random(-1536, 0);
        v2 = random(-341, 341);
        createNPC(NPCSmoke, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), v2, v1, 0, 0, 256);
      }
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 20) += 64;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v3 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  else
    v3 = &v14 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v3;
  result[1] = v3[1];
  result[2] = v3[2];
  result[3] = v3[3];
  return result;
}

//----- (0043C8E0) --------------------------------------------------------
int __cdecl NPC110(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  signed int v4; // [esp+4h] [ebp-64h]
  int v5; // [esp+8h] [ebp-60h]
  int v6; // [esp+Ch] [ebp-5Ch]
  int v7; // [esp+10h] [ebp-58h]
  int v8; // [esp+14h] [ebp-54h]
  int v9; // [esp+18h] [ebp-50h]
  int v10; // [esp+1Ch] [ebp-4Ch]
  int v11; // [esp+20h] [ebp-48h]
  int v12; // [esp+24h] [ebp-44h]
  int v13; // [esp+28h] [ebp-40h]
  int v14; // [esp+2Ch] [ebp-3Ch]
  int v15; // [esp+30h] [ebp-38h]
  int v16; // [esp+34h] [ebp-34h]
  int v17; // [esp+38h] [ebp-30h]
  int v18; // [esp+3Ch] [ebp-2Ch]
  int v19; // [esp+40h] [ebp-28h]
  int v20; // [esp+44h] [ebp-24h]
  int v21; // [esp+48h] [ebp-20h]
  int v22; // [esp+4Ch] [ebp-1Ch]
  int v23; // [esp+50h] [ebp-18h]
  int v24; // [esp+54h] [ebp-14h]
  int v25; // [esp+58h] [ebp-10h]
  int v26; // [esp+5Ch] [ebp-Ch]
  int v27; // [esp+60h] [ebp-8h]
  int v28; // [esp+64h] [ebp-4h]

  v17 = 96;
  v18 = 128;
  v19 = 112;
  v20 = 144;
  v21 = 112;
  v22 = 128;
  v23 = 128;
  v24 = 144;
  v25 = 128;
  v26 = 128;
  v27 = 144;
  v28 = 144;
  v5 = 96;
  v6 = 144;
  v7 = 112;
  v8 = 160;
  v9 = 112;
  v10 = 144;
  v11 = 128;
  v12 = 160;
  v13 = 128;
  v14 = 144;
  v15 = 144;
  v16 = 160;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 20) = 0;
      if ( *(_DWORD *)(a1 + 76) != 4 )
      {
        *(_WORD *)(a1 + 80) &= 0xFFF7u;
        goto LABEL_8;
      }
      if ( random(0, 1) )
        *(_DWORD *)(a1 + 76) = 0;
      else
        *(_DWORD *)(a1 + 76) = 2;
      *(_WORD *)(a1 + 80) |= 8u;
      *(_DWORD *)(a1 + 104) = 2;
      *(_DWORD *)(a1 + 116) = 3;
      break;
    case 1:
LABEL_8:
      ++*(_DWORD *)(a1 + 120);
      if ( random(0, 50) == 1 )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 100) = 0;
      }
      break;
    case 2:
      ++*(_DWORD *)(a1 + 120);
      if ( ++*(_DWORD *)(a1 + 100) > 2 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 1 )
        *(_DWORD *)(a1 + 104) = 0;
      if ( *(_DWORD *)(a1 + 120) > 18 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 116) = 1;
      }
      break;
    case 3:
      if ( ++*(_DWORD *)(a1 + 120) > 40 )
        *(_WORD *)(a1 + 80) &= 0xFFF7u;
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 116) = 0;
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      goto LABEL_24;
    case 0xB:
LABEL_24:
      if ( *(_DWORD *)(a1 + 4) & 1 && *(_DWORD *)(a1 + 16) < 0 )
      {
        *(_DWORD *)(a1 + 16) = -*(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 76) = 2;
      }
      if ( *(_DWORD *)(a1 + 4) & 4 && *(_DWORD *)(a1 + 16) > 0 )
      {
        *(_DWORD *)(a1 + 16) = -*(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 76) = 0;
      }
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 116) = 0;
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    default:
      break;
  }
  v4 = 0;
  if ( *(_DWORD *)(a1 + 116) < 10 && *(_DWORD *)(a1 + 116) != 3 && *(_DWORD *)(a1 + 120) > 10 )
  {
    if ( *(_BYTE *)(a1 + 156) )
      v4 = 1;
    if ( *(_DWORD *)(a1 + 8) >= quote.XPos - 81920
      && *(_DWORD *)(a1 + 8) <= quote.XPos + 81920
      && *(_DWORD *)(a1 + 12) >= quote.YPos - 0x8000
      && *(_DWORD *)(a1 + 12) <= quote.YPos + 0x8000
      && random(0, 50) == 2 )
    {
      v4 = 1;
    }
  }
  if ( v4 )
  {
    if ( *(_DWORD *)(a1 + 8) >= quote.XPos )
      *(_DWORD *)(a1 + 76) = 0;
    else
      *(_DWORD *)(a1 + 76) = 2;
    *(_DWORD *)(a1 + 116) = 10;
    *(_DWORD *)(a1 + 104) = 2;
    *(_DWORD *)(a1 + 20) = -767;
    playSoundEffect(SFXHighPitchCritterHop, 1);
    if ( *(_DWORD *)(a1 + 76) )
      *(_DWORD *)(a1 + 16) = 256;
    else
      *(_DWORD *)(a1 + 16) = -256;
  }
  *(_DWORD *)(a1 + 20) += 128;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v17 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}

//----- (0043CDE0) --------------------------------------------------------
int __cdecl NPC111(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+4h] [ebp-40h]
  int v5; // [esp+8h] [ebp-3Ch]
  int v6; // [esp+Ch] [ebp-38h]
  int v7; // [esp+10h] [ebp-34h]
  int v8; // [esp+14h] [ebp-30h]
  int v9; // [esp+18h] [ebp-2Ch]
  int v10; // [esp+1Ch] [ebp-28h]
  int v11; // [esp+20h] [ebp-24h]
  int v12; // [esp+24h] [ebp-20h]
  int v13; // [esp+28h] [ebp-1Ch]
  int v14; // [esp+2Ch] [ebp-18h]
  int v15; // [esp+30h] [ebp-14h]
  int v16; // [esp+34h] [ebp-10h]
  int v17; // [esp+38h] [ebp-Ch]
  int v18; // [esp+3Ch] [ebp-8h]
  int v19; // [esp+40h] [ebp-4h]

  v12 = 0;
  v13 = 0;
  v14 = 16;
  v15 = 16;
  v16 = 16;
  v17 = 0;
  v18 = 32;
  v19 = 16;
  v4 = 0;
  v5 = 16;
  v6 = 16;
  v7 = 32;
  v8 = 16;
  v9 = 16;
  v10 = 32;
  v11 = 32;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 12) -= 0x2000;
      break;
    case 1:
      if ( ++*(_DWORD *)(a1 + 120) > 20 )
      {
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 104) = 1;
        *(_DWORD *)(a1 + 20) = -767;
      }
      break;
    case 2:
      if ( *(_DWORD *)(a1 + 20) > 0 )
        *(_DWORD *)(a1 + 136) = 0x2000;
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 116) = 3;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    case 3:
      if ( ++*(_DWORD *)(a1 + 120) > 40 )
      {
        *(_DWORD *)(a1 + 116) = 4;
        *(_DWORD *)(a1 + 120) = 64;
        playSoundEffect(SFXTeleport, 1);
      }
      break;
    case 4:
      --*(_DWORD *)(a1 + 120);
      *(_DWORD *)(a1 + 104) = 0;
      if ( !*(_DWORD *)(a1 + 120) )
        *(_BYTE *)a1 = 0;
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 20) += 64;
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v12 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  if ( quote.equippedItems & 0x40 )
  {
    *(_DWORD *)(a1 + 88) += 32;
    result = *(_DWORD *)(a1 + 96) + 32;
    *(_DWORD *)(a1 + 96) = result;
  }
  if ( *(_DWORD *)(a1 + 116) == 4 )
  {
    *(_DWORD *)(a1 + 96) = *(_DWORD *)(a1 + 88) + *(_DWORD *)(a1 + 120) / 4;
    result = *(_DWORD *)(a1 + 120) / 2 % 2;
    if ( result )
    {
      result = a1;
      ++*(_DWORD *)(a1 + 84);
    }
  }
  return result;
}

//----- (0043D0A0) --------------------------------------------------------
int __cdecl NPC112(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  int v4; // [esp+4h] [ebp-40h]
  int v5; // [esp+8h] [ebp-3Ch]
  int v6; // [esp+Ch] [ebp-38h]
  int v7; // [esp+10h] [ebp-34h]
  int v8; // [esp+14h] [ebp-30h]
  int v9; // [esp+18h] [ebp-2Ch]
  int v10; // [esp+1Ch] [ebp-28h]
  int v11; // [esp+20h] [ebp-24h]
  int v12; // [esp+24h] [ebp-20h]
  int v13; // [esp+28h] [ebp-1Ch]
  int v14; // [esp+2Ch] [ebp-18h]
  int v15; // [esp+30h] [ebp-14h]
  int v16; // [esp+34h] [ebp-10h]
  int v17; // [esp+38h] [ebp-Ch]
  int v18; // [esp+3Ch] [ebp-8h]
  int v19; // [esp+40h] [ebp-4h]

  v12 = 0;
  v13 = 0;
  v14 = 16;
  v15 = 16;
  v16 = 16;
  v17 = 0;
  v18 = 32;
  v19 = 16;
  v4 = 0;
  v5 = 16;
  v6 = 16;
  v7 = 32;
  v8 = 16;
  v9 = 16;
  v10 = 32;
  v11 = 32;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      *(_DWORD *)(a1 + 8) += 0x2000;
      *(_DWORD *)(a1 + 12) += 4096;
      playSoundEffect(SFXTeleport, 1);
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( ++*(_DWORD *)(a1 + 120) == 64 )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 120) > 20 )
      {
        *(_DWORD *)(a1 + 116) = 3;
        *(_DWORD *)(a1 + 104) = 1;
        *(_DWORD *)(a1 + 136) = 4096;
      }
      break;
    case 3:
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 116) = 4;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 20) += 64;
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v12 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  v2[3] = v1[3];
  if ( quote.equippedItems & 0x40 )
  {
    *(_DWORD *)(a1 + 88) += 32;
    *(_DWORD *)(a1 + 96) += 32;
  }
  result = a1;
  if ( *(_DWORD *)(a1 + 116) == 1 )
  {
    *(_DWORD *)(a1 + 96) = *(_DWORD *)(a1 + 88) + *(_DWORD *)(a1 + 120) / 4;
    result = *(_DWORD *)(a1 + 120) / 2 % 2;
    if ( result )
    {
      result = a1;
      ++*(_DWORD *)(a1 + 84);
    }
  }
  return result;
}

//----- (0043D320) --------------------------------------------------------
int __cdecl NPC113(int a1)
{
  int v1; // ecx
  int *v2; // eax
  int *v3; // ecx
  int result; // eax
  int v5; // [esp+4h] [ebp-E0h]
  int v6; // [esp+8h] [ebp-DCh]
  int v7; // [esp+Ch] [ebp-D8h]
  int v8; // [esp+10h] [ebp-D4h]
  int v9; // [esp+14h] [ebp-D0h]
  int v10; // [esp+18h] [ebp-CCh]
  int v11; // [esp+1Ch] [ebp-C8h]
  int v12; // [esp+20h] [ebp-C4h]
  int v13; // [esp+24h] [ebp-C0h]
  int v14; // [esp+28h] [ebp-BCh]
  int v15; // [esp+2Ch] [ebp-B8h]
  int v16; // [esp+30h] [ebp-B4h]
  int v17; // [esp+34h] [ebp-B0h]
  int v18; // [esp+38h] [ebp-ACh]
  int v19; // [esp+3Ch] [ebp-A8h]
  int v20; // [esp+40h] [ebp-A4h]
  int v21; // [esp+44h] [ebp-A0h]
  int v22; // [esp+48h] [ebp-9Ch]
  int v23; // [esp+4Ch] [ebp-98h]
  int v24; // [esp+50h] [ebp-94h]
  int v25; // [esp+54h] [ebp-90h]
  int v26; // [esp+58h] [ebp-8Ch]
  int v27; // [esp+5Ch] [ebp-88h]
  int v28; // [esp+60h] [ebp-84h]
  int v29; // [esp+64h] [ebp-80h]
  int v30; // [esp+68h] [ebp-7Ch]
  int v31; // [esp+6Ch] [ebp-78h]
  int v32; // [esp+70h] [ebp-74h]
  int v33; // [esp+74h] [ebp-70h]
  int v34; // [esp+78h] [ebp-6Ch]
  int v35; // [esp+7Ch] [ebp-68h]
  int v36; // [esp+80h] [ebp-64h]
  int v37; // [esp+84h] [ebp-60h]
  int v38; // [esp+88h] [ebp-5Ch]
  int v39; // [esp+8Ch] [ebp-58h]
  int v40; // [esp+90h] [ebp-54h]
  int v41; // [esp+94h] [ebp-50h]
  int v42; // [esp+98h] [ebp-4Ch]
  int v43; // [esp+9Ch] [ebp-48h]
  int v44; // [esp+A0h] [ebp-44h]
  int v45; // [esp+A4h] [ebp-40h]
  int v46; // [esp+A8h] [ebp-3Ch]
  int v47; // [esp+ACh] [ebp-38h]
  int v48; // [esp+B0h] [ebp-34h]
  int v49; // [esp+B4h] [ebp-30h]
  int v50; // [esp+B8h] [ebp-2Ch]
  int v51; // [esp+BCh] [ebp-28h]
  int v52; // [esp+C0h] [ebp-24h]
  int v53; // [esp+C4h] [ebp-20h]
  int v54; // [esp+C8h] [ebp-1Ch]
  int v55; // [esp+CCh] [ebp-18h]
  int v56; // [esp+D0h] [ebp-14h]
  int v57; // [esp+D4h] [ebp-10h]
  int v58; // [esp+D8h] [ebp-Ch]
  int v59; // [esp+DCh] [ebp-8h]
  int v60; // [esp+E0h] [ebp-4h]

  v33 = 224;
  v34 = 0;
  v35 = 240;
  v36 = 16;
  v37 = 240;
  v38 = 0;
  v39 = 256;
  v40 = 16;
  v41 = 256;
  v42 = 0;
  v43 = 272;
  v44 = 16;
  v45 = 224;
  v46 = 0;
  v47 = 240;
  v48 = 16;
  v49 = 272;
  v50 = 0;
  v51 = 288;
  v52 = 16;
  v53 = 224;
  v54 = 0;
  v55 = 240;
  v56 = 16;
  v57 = 288;
  v58 = 0;
  v59 = 304;
  v60 = 16;
  v5 = 224;
  v6 = 16;
  v7 = 240;
  v8 = 32;
  v9 = 240;
  v10 = 16;
  v11 = 256;
  v12 = 32;
  v13 = 256;
  v14 = 16;
  v15 = 272;
  v16 = 32;
  v17 = 224;
  v18 = 16;
  v19 = 240;
  v20 = 32;
  v21 = 272;
  v22 = 16;
  v23 = 288;
  v24 = 32;
  v25 = 224;
  v26 = 16;
  v27 = 240;
  v28 = 32;
  v29 = 288;
  v30 = 16;
  v31 = 304;
  v32 = 32;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( random(0, 120) == 10 )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    case 3:
      *(_DWORD *)(a1 + 116) = 4;
      *(_DWORD *)(a1 + 104) = 2;
      *(_DWORD *)(a1 + 100) = 0;
      goto LABEL_10;
    case 4:
LABEL_10:
      if ( ++*(_DWORD *)(a1 + 100) > 4 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 5 )
        *(_DWORD *)(a1 + 104) = 2;
      if ( *(_DWORD *)(a1 + 76) )
        v1 = *(_DWORD *)(a1 + 8) + 512;
      else
        v1 = *(_DWORD *)(a1 + 8) - 512;
      *(_DWORD *)(a1 + 8) = v1;
      break;
    case 5:
      *(_DWORD *)(a1 + 104) = 6;
      break;
    case 0x1E:
      *(_DWORD *)(a1 + 116) = 31;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      *(_DWORD *)(a1 + 136) = 0x2000;
      *(_DWORD *)(a1 + 8) -= 0x2000;
      *(_DWORD *)(a1 + 12) += 4096;
      playSoundEffect(SFXTeleport, 1);
      goto LABEL_20;
    case 0x1F:
LABEL_20:
      if ( ++*(_DWORD *)(a1 + 120) == 64 )
      {
        *(_DWORD *)(a1 + 116) = 32;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    case 0x20:
      if ( ++*(_DWORD *)(a1 + 120) > 20 )
      {
        *(_DWORD *)(a1 + 116) = 33;
        *(_DWORD *)(a1 + 104) = 1;
        *(_DWORD *)(a1 + 136) = 4096;
      }
      break;
    case 0x21:
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 116) = 34;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 20) += 64;
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v2 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  else
    v2 = &v33 + 4 * *(_DWORD *)(a1 + 104);
  v3 = (int *)(a1 + 84);
  *v3 = *v2;
  v3[1] = v2[1];
  v3[2] = v2[2];
  result = v2[3];
  v3[3] = result;
  if ( *(_DWORD *)(a1 + 116) == 31 )
  {
    *(_DWORD *)(a1 + 96) = *(_DWORD *)(a1 + 88) + *(_DWORD *)(a1 + 120) / 4;
    result = *(_DWORD *)(a1 + 120) / 2 % 2;
    if ( result )
    {
      result = a1;
      ++*(_DWORD *)(a1 + 84);
    }
  }
  return result;
}

//----- (0043D860) --------------------------------------------------------
int *__cdecl NPC114(int a1)
{
  int v1; // ST10_4
  int v2; // eax
  int *v3; // edx
  int *result; // eax
  int v5; // [esp+0h] [ebp-38h]
  signed int i; // [esp+4h] [ebp-34h]
  int v7; // [esp+8h] [ebp-30h]
  int v8; // [esp+Ch] [ebp-2Ch]
  int v9; // [esp+10h] [ebp-28h]
  int v10; // [esp+14h] [ebp-24h]
  int v11; // [esp+18h] [ebp-20h]
  int v12; // [esp+1Ch] [ebp-1Ch]
  int v13; // [esp+20h] [ebp-18h]
  int v14; // [esp+24h] [ebp-14h]
  int v15; // [esp+28h] [ebp-10h]
  int v16; // [esp+2Ch] [ebp-Ch]
  int v17; // [esp+30h] [ebp-8h]
  int v18; // [esp+34h] [ebp-4h]

  v7 = 144;
  v8 = 112;
  v9 = 160;
  v10 = 136;
  v11 = 160;
  v12 = 112;
  v13 = 176;
  v14 = 136;
  v15 = 176;
  v16 = 112;
  v17 = 192;
  v18 = 136;
  v5 = *(_DWORD *)(a1 + 116);
  if ( v5 )
  {
    if ( v5 != 1 )
    {
      if ( v5 == 10 )
      {
        if ( ++*(_DWORD *)(a1 + 100) > 2 )
        {
          *(_DWORD *)(a1 + 100) = 0;
          ++*(_DWORD *)(a1 + 104);
        }
        if ( *(_DWORD *)(a1 + 104) > 2 )
          *(_DWORD *)(a1 + 104) = 2;
        if ( quote.YPos <= *(_DWORD *)(a1 + 12) )
        {
          *(_WORD *)(a1 + 80) |= 0x40u;
          *(_DWORD *)(a1 + 164) = 0;
        }
        else
        {
          *(_WORD *)(a1 + 80) &= 0xFFBFu;
          *(_DWORD *)(a1 + 164) = 127;
        }
        if ( *(_DWORD *)(a1 + 4) & 8 )
        {
          if ( *(_DWORD *)(a1 + 104) > 1 )
          {
            for ( i = 0; i < 4; ++i )
            {
              v1 = random(-1536, 0);
              v2 = random(-341, 341);
              createNPC(NPCSmoke, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), v2, v1, 0, 0, 256);
            }
            playSoundEffect(SFXLargeObjectHitGround, 1);
            setQuake(10);
          }
          *(_DWORD *)(a1 + 116) = 1;
          *(_DWORD *)(a1 + 104) = 0;
          *(_DWORD *)(a1 + 164) = 0;
          *(_WORD *)(a1 + 80) |= 0x40u;
        }
      }
      goto LABEL_23;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 12) -= 2048;
  }
  if ( !(*(_DWORD *)(a1 + 4) & 8) )
  {
    *(_DWORD *)(a1 + 116) = 10;
    *(_DWORD *)(a1 + 100) = 0;
    *(_DWORD *)(a1 + 104) = 1;
  }
LABEL_23:
  *(_DWORD *)(a1 + 20) += 32;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v3 = &v7 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v3;
  result[1] = v3[1];
  result[2] = v3[2];
  result[3] = v3[3];
  return result;
}

//----- (0043DAE0) --------------------------------------------------------
int __cdecl NPC115(int a1)
{
  int v1; // ST10_4
  int v2; // ST0C_4
  int v3; // ST08_4
  int v4; // eax
  int v5; // ecx
  int *v6; // ecx
  int *v7; // edx
  int result; // eax
  int v9; // [esp+4h] [ebp-C8h]
  int v10; // [esp+8h] [ebp-C4h]
  int v11; // [esp+Ch] [ebp-C0h]
  int v12; // [esp+10h] [ebp-BCh]
  int v13; // [esp+14h] [ebp-B8h]
  int v14; // [esp+18h] [ebp-B4h]
  int v15; // [esp+1Ch] [ebp-B0h]
  int v16; // [esp+20h] [ebp-ACh]
  int v17; // [esp+24h] [ebp-A8h]
  int v18; // [esp+28h] [ebp-A4h]
  int v19; // [esp+2Ch] [ebp-A0h]
  int v20; // [esp+30h] [ebp-9Ch]
  int v21; // [esp+34h] [ebp-98h]
  int v22; // [esp+38h] [ebp-94h]
  int v23; // [esp+3Ch] [ebp-90h]
  int v24; // [esp+40h] [ebp-8Ch]
  int v25; // [esp+44h] [ebp-88h]
  int v26; // [esp+48h] [ebp-84h]
  int v27; // [esp+4Ch] [ebp-80h]
  int v28; // [esp+50h] [ebp-7Ch]
  int v29; // [esp+54h] [ebp-78h]
  int v30; // [esp+58h] [ebp-74h]
  int v31; // [esp+5Ch] [ebp-70h]
  int v32; // [esp+60h] [ebp-6Ch]
  int i; // [esp+68h] [ebp-64h]
  int v34; // [esp+6Ch] [ebp-60h]
  int v35; // [esp+70h] [ebp-5Ch]
  int v36; // [esp+74h] [ebp-58h]
  int v37; // [esp+78h] [ebp-54h]
  int v38; // [esp+7Ch] [ebp-50h]
  int v39; // [esp+80h] [ebp-4Ch]
  int v40; // [esp+84h] [ebp-48h]
  int v41; // [esp+88h] [ebp-44h]
  int v42; // [esp+8Ch] [ebp-40h]
  int v43; // [esp+90h] [ebp-3Ch]
  int v44; // [esp+94h] [ebp-38h]
  int v45; // [esp+98h] [ebp-34h]
  int v46; // [esp+9Ch] [ebp-30h]
  int v47; // [esp+A0h] [ebp-2Ch]
  int v48; // [esp+A4h] [ebp-28h]
  int v49; // [esp+A8h] [ebp-24h]
  int v50; // [esp+ACh] [ebp-20h]
  int v51; // [esp+B0h] [ebp-1Ch]
  int v52; // [esp+B4h] [ebp-18h]
  int v53; // [esp+B8h] [ebp-14h]
  int v54; // [esp+BCh] [ebp-10h]
  int v55; // [esp+C0h] [ebp-Ch]
  int v56; // [esp+C4h] [ebp-8h]
  int v57; // [esp+C8h] [ebp-4h]

  v34 = 0;
  v35 = 120;
  v36 = 24;
  v37 = 144;
  v38 = 24;
  v39 = 120;
  v40 = 48;
  v41 = 144;
  v42 = 48;
  v43 = 120;
  v44 = 72;
  v45 = 144;
  v46 = 72;
  v47 = 120;
  v48 = 96;
  v49 = 144;
  v50 = 96;
  v51 = 120;
  v52 = 120;
  v53 = 144;
  v54 = 120;
  v55 = 120;
  v56 = 144;
  v57 = 144;
  v9 = 0;
  v10 = 144;
  v11 = 24;
  v12 = 168;
  v13 = 24;
  v14 = 144;
  v15 = 48;
  v16 = 168;
  v17 = 48;
  v18 = 144;
  v19 = 72;
  v20 = 168;
  v21 = 72;
  v22 = 144;
  v23 = 96;
  v24 = 168;
  v25 = 96;
  v26 = 144;
  v27 = 120;
  v28 = 168;
  v29 = 120;
  v30 = 144;
  v31 = 144;
  v32 = 168;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 108) = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( quote.XPos < *(_DWORD *)(a1 + 8) + 49152
        && quote.XPos > *(_DWORD *)(a1 + 8) - 49152
        && quote.YPos < *(_DWORD *)(a1 + 12) + 0x4000
        && quote.YPos > *(_DWORD *)(a1 + 12) - 49152 )
      {
        *(_DWORD *)(a1 + 116) = 10;
      }
      if ( *(_BYTE *)(a1 + 156) )
        *(_DWORD *)(a1 + 116) = 10;
      break;
    case 0xA:
      if ( quote.XPos >= *(_DWORD *)(a1 + 8) )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      *(_DWORD *)(a1 + 104) = 1;
      if ( ++*(_DWORD *)(a1 + 120) > 20 )
      {
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 116) = 20;
      }
      break;
    case 0x14:
      *(_DWORD *)(a1 + 164) = 0;
      *(_DWORD *)(a1 + 16) = 0;
      if ( ++*(_DWORD *)(a1 + 100) > 2 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 2 )
      {
        if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
          *(_DWORD *)(a1 + 76) = 2;
        else
          *(_DWORD *)(a1 + 76) = 0;
        if ( *(_DWORD *)(a1 + 76) )
          *(_DWORD *)(a1 + 16) = 512;
        else
          *(_DWORD *)(a1 + 16) = -512;
        if ( ++*(_DWORD *)(a1 + 108) <= 2 )
        {
          *(_DWORD *)(a1 + 116) = 21;
          *(_DWORD *)(a1 + 20) = -1024;
          playSoundEffect(SFXCritterHop, 1);
        }
        else
        {
          *(_DWORD *)(a1 + 108) = 0;
          *(_DWORD *)(a1 + 104) = 4;
          *(_DWORD *)(a1 + 116) = 21;
          *(_DWORD *)(a1 + 20) = -1024;
          *(_DWORD *)(a1 + 16) *= 2;
          *(_DWORD *)(a1 + 164) = 5;
          playSoundEffect(SFXSandCroc, 1);
        }
      }
      break;
    case 0x15:
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        playSoundEffect(SFXQuoteHitGround, 1);
        *(_DWORD *)(a1 + 116) = 20;
        *(_DWORD *)(a1 + 104) = 1;
        *(_DWORD *)(a1 + 100) = 0;
        *(_DWORD *)(a1 + 164) = 0;
        if ( quote.XPos > *(_DWORD *)(a1 + 8) + 73728
          || quote.XPos < *(_DWORD *)(a1 + 8) - 73728
          || quote.YPos > *(_DWORD *)(a1 + 12) + 24576
          || quote.YPos < *(_DWORD *)(a1 + 12) - 73728 )
        {
          *(_DWORD *)(a1 + 116) = 0;
        }
      }
      break;
    case 0x1E:
      for ( i = 0; i < 8; ++i )
      {
        v1 = random(-1536, 0);
        v2 = random(-341, 341);
        v3 = *(_DWORD *)(a1 + 12) + (random(-12, 12) << 9);
        v4 = random(-12, 12);
        createNPC(NPCSmoke, *(_DWORD *)(a1 + 8) + (v4 << 9), v3, v2, v1, 0, 0, 256);
      }
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 116) = 0;
      break;
    case 0x32:
      *(_DWORD *)(a1 + 116) = 51;
      *(_DWORD *)(a1 + 104) = 4;
      *(_DWORD *)(a1 + 164) = 0;
      *(_DWORD *)(a1 + 20) = -512;
      *(_WORD *)(a1 + 80) &= 0xFFDEu;
      playSoundEffect(SFXCritterSmallHurt, 1);
      goto LABEL_42;
    case 0x33:
LABEL_42:
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        playSoundEffect(SFXQuoteHitGround, 1);
        *(_DWORD *)(a1 + 116) = 52;
        *(_DWORD *)(a1 + 104) = 5;
        *(_DWORD *)(a1 + 16) = 0;
      }
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 116) <= 50 )
    v5 = *(_DWORD *)(a1 + 20) + 64;
  else
    v5 = *(_DWORD *)(a1 + 20) + 32;
  *(_DWORD *)(a1 + 20) = v5;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v6 = &v9 + 4 * *(_DWORD *)(a1 + 104);
  else
    v6 = &v34 + 4 * *(_DWORD *)(a1 + 104);
  v7 = (int *)(a1 + 84);
  *v7 = *v6;
  v7[1] = v6[1];
  result = v6[2];
  v7[2] = result;
  v7[3] = v6[3];
  return result;
}

//----- (0043E190) --------------------------------------------------------
_DWORD *__cdecl NPC116(int a1)
{
  _DWORD *result; // eax

  result = (_DWORD *)(a1 + 84);
  *result = 272;
  result[1] = 184;
  result[2] = 320;
  result[3] = 200;
  return result;
}

//----- (0043E1E0) --------------------------------------------------------
int __cdecl NPC117(int a1)
{
  int v1; // eax
  int v2; // ecx
  int v3; // edx
  int *v4; // eax
  int *v5; // ecx
  int result; // eax
  int v7; // [esp+4h] [ebp-140h]
  int v8; // [esp+8h] [ebp-13Ch]
  int v9; // [esp+Ch] [ebp-138h]
  int v10; // [esp+10h] [ebp-134h]
  int v11; // [esp+14h] [ebp-130h]
  int v12; // [esp+18h] [ebp-12Ch]
  int v13; // [esp+1Ch] [ebp-128h]
  int v14; // [esp+20h] [ebp-124h]
  int v15; // [esp+24h] [ebp-120h]
  int v16; // [esp+28h] [ebp-11Ch]
  int v17; // [esp+2Ch] [ebp-118h]
  int v18; // [esp+30h] [ebp-114h]
  int v19; // [esp+34h] [ebp-110h]
  int v20; // [esp+38h] [ebp-10Ch]
  int v21; // [esp+3Ch] [ebp-108h]
  int v22; // [esp+40h] [ebp-104h]
  int v23; // [esp+44h] [ebp-100h]
  int v24; // [esp+48h] [ebp-FCh]
  int v25; // [esp+4Ch] [ebp-F8h]
  int v26; // [esp+50h] [ebp-F4h]
  int v27; // [esp+54h] [ebp-F0h]
  int v28; // [esp+58h] [ebp-ECh]
  int v29; // [esp+5Ch] [ebp-E8h]
  int v30; // [esp+60h] [ebp-E4h]
  int v31; // [esp+64h] [ebp-E0h]
  int v32; // [esp+68h] [ebp-DCh]
  int v33; // [esp+6Ch] [ebp-D8h]
  int v34; // [esp+70h] [ebp-D4h]
  int v35; // [esp+74h] [ebp-D0h]
  int v36; // [esp+78h] [ebp-CCh]
  int v37; // [esp+7Ch] [ebp-C8h]
  int v38; // [esp+80h] [ebp-C4h]
  int v39; // [esp+84h] [ebp-C0h]
  int v40; // [esp+88h] [ebp-BCh]
  int v41; // [esp+8Ch] [ebp-B8h]
  int v42; // [esp+90h] [ebp-B4h]
  int v43; // [esp+94h] [ebp-B0h]
  int v44; // [esp+98h] [ebp-ACh]
  int v45; // [esp+9Ch] [ebp-A8h]
  int v46; // [esp+A0h] [ebp-A4h]
  int v47; // [esp+A4h] [ebp-A0h]
  int v48; // [esp+A8h] [ebp-9Ch]
  int v49; // [esp+ACh] [ebp-98h]
  int v50; // [esp+B0h] [ebp-94h]
  int v51; // [esp+B4h] [ebp-90h]
  int v52; // [esp+B8h] [ebp-8Ch]
  int v53; // [esp+BCh] [ebp-88h]
  int v54; // [esp+C0h] [ebp-84h]
  int v55; // [esp+C4h] [ebp-80h]
  int v56; // [esp+C8h] [ebp-7Ch]
  int v57; // [esp+CCh] [ebp-78h]
  int v58; // [esp+D0h] [ebp-74h]
  int v59; // [esp+D4h] [ebp-70h]
  int v60; // [esp+D8h] [ebp-6Ch]
  int v61; // [esp+DCh] [ebp-68h]
  int v62; // [esp+E0h] [ebp-64h]
  int v63; // [esp+E4h] [ebp-60h]
  int v64; // [esp+E8h] [ebp-5Ch]
  int v65; // [esp+ECh] [ebp-58h]
  int v66; // [esp+F0h] [ebp-54h]
  int v67; // [esp+F4h] [ebp-50h]
  int v68; // [esp+F8h] [ebp-4Ch]
  int v69; // [esp+FCh] [ebp-48h]
  int v70; // [esp+100h] [ebp-44h]
  int v71; // [esp+104h] [ebp-40h]
  int v72; // [esp+108h] [ebp-3Ch]
  int v73; // [esp+10Ch] [ebp-38h]
  int v74; // [esp+110h] [ebp-34h]
  int v75; // [esp+114h] [ebp-30h]
  int v76; // [esp+118h] [ebp-2Ch]
  int v77; // [esp+11Ch] [ebp-28h]
  int v78; // [esp+120h] [ebp-24h]
  int v79; // [esp+124h] [ebp-20h]
  int v80; // [esp+128h] [ebp-1Ch]
  int v81; // [esp+12Ch] [ebp-18h]
  int v82; // [esp+130h] [ebp-14h]
  int v83; // [esp+134h] [ebp-10h]
  int v84; // [esp+138h] [ebp-Ch]
  int v85; // [esp+13Ch] [ebp-8h]
  int v86; // [esp+140h] [ebp-4h]

  v47 = 0;
  v48 = 96;
  v49 = 16;
  v50 = 112;
  v51 = 16;
  v52 = 96;
  v53 = 32;
  v54 = 112;
  v55 = 0;
  v56 = 96;
  v57 = 16;
  v58 = 112;
  v59 = 32;
  v60 = 96;
  v61 = 48;
  v62 = 112;
  v63 = 0;
  v64 = 96;
  v65 = 16;
  v66 = 112;
  v67 = 176;
  v68 = 96;
  v69 = 192;
  v70 = 112;
  v71 = 112;
  v72 = 96;
  v73 = 128;
  v74 = 112;
  v75 = 160;
  v76 = 96;
  v77 = 176;
  v78 = 112;
  v79 = 144;
  v80 = 96;
  v81 = 160;
  v82 = 112;
  v83 = 48;
  v84 = 96;
  v85 = 64;
  v86 = 112;
  v7 = 0;
  v8 = 112;
  v9 = 16;
  v10 = 128;
  v11 = 16;
  v12 = 112;
  v13 = 32;
  v14 = 128;
  v15 = 0;
  v16 = 112;
  v17 = 16;
  v18 = 128;
  v19 = 32;
  v20 = 112;
  v21 = 48;
  v22 = 128;
  v23 = 0;
  v24 = 112;
  v25 = 16;
  v26 = 128;
  v27 = 176;
  v28 = 112;
  v29 = 192;
  v30 = 128;
  v31 = 112;
  v32 = 112;
  v33 = 128;
  v34 = 128;
  v35 = 160;
  v36 = 112;
  v37 = 176;
  v38 = 128;
  v39 = 144;
  v40 = 112;
  v41 = 160;
  v42 = 128;
  v43 = 48;
  v44 = 112;
  v45 = 64;
  v46 = 128;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      if ( *(_DWORD *)(a1 + 76) == 4 )
      {
        if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
          *(_DWORD *)(a1 + 76) = 2;
        else
          *(_DWORD *)(a1 + 76) = 0;
      }
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      goto LABEL_7;
    case 1:
LABEL_7:
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 20) += 64;
      break;
    case 3:
      *(_DWORD *)(a1 + 116) = 4;
      *(_DWORD *)(a1 + 104) = 1;
      *(_DWORD *)(a1 + 100) = 0;
      goto LABEL_9;
    case 4:
LABEL_9:
      if ( ++*(_DWORD *)(a1 + 100) > 4 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 4 )
        *(_DWORD *)(a1 + 104) = 1;
      *(_DWORD *)(a1 + 20) += 64;
      if ( *(_DWORD *)(a1 + 76) )
        *(_DWORD *)(a1 + 16) = 512;
      else
        *(_DWORD *)(a1 + 16) = -512;
      break;
    case 5:
      *(_DWORD *)(a1 + 116) = 6;
      *(_DWORD *)(a1 + 104) = 5;
      createDustClouds(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 148), 8);
      break;
    case 6:
      *(_DWORD *)(a1 + 104) = 5;
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 104) = 1;
      *(_DWORD *)(a1 + 100) = 0;
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      goto LABEL_22;
    case 0xB:
LABEL_22:
      if ( ++*(_DWORD *)(a1 + 100) > 4 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 4 )
        *(_DWORD *)(a1 + 104) = 1;
      if ( *(_DWORD *)(a1 + 76) )
        v1 = *(_DWORD *)(a1 + 8) + 512;
      else
        v1 = *(_DWORD *)(a1 + 8) - 512;
      *(_DWORD *)(a1 + 8) = v1;
      if ( quote.XPos < *(_DWORD *)(a1 + 8) + 10240 && quote.XPos > *(_DWORD *)(a1 + 8) - 10240 )
        *(_DWORD *)(a1 + 116) = 0;
      break;
    case 0x14:
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 104) = 6;
      break;
    case 0x15:
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 104) = 9;
      break;
    case 0x1E:
      *(_DWORD *)(a1 + 116) = 31;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 20) = -1024;
      goto LABEL_36;
    case 0x1F:
LABEL_36:
      *(_DWORD *)(a1 + 104) = 7;
      if ( *(_DWORD *)(a1 + 76) )
        *(_DWORD *)(a1 + 16) = -512;
      else
        *(_DWORD *)(a1 + 16) = 512;
      *(_DWORD *)(a1 + 20) += 64;
      v2 = (*(_DWORD *)(a1 + 120))++;
      if ( v2 && *(_DWORD *)(a1 + 4) & 8 )
        *(_DWORD *)(a1 + 116) = 32;
      break;
    case 0x20:
      *(_DWORD *)(a1 + 20) += 64;
      *(_DWORD *)(a1 + 104) = 8;
      *(_DWORD *)(a1 + 16) = 0;
      break;
    case 0x46:
      *(_DWORD *)(a1 + 116) = 71;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 104) = 1;
      *(_DWORD *)(a1 + 100) = 0;
      goto LABEL_45;
    case 0x47:
LABEL_45:
      if ( *(_DWORD *)(a1 + 76) )
        v3 = *(_DWORD *)(a1 + 8) - 256;
      else
        v3 = *(_DWORD *)(a1 + 8) + 256;
      *(_DWORD *)(a1 + 8) = v3;
      if ( ++*(_DWORD *)(a1 + 100) > 8 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 4 )
        *(_DWORD *)(a1 + 104) = 1;
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v4 = &v7 + 4 * *(_DWORD *)(a1 + 104);
  else
    v4 = &v47 + 4 * *(_DWORD *)(a1 + 104);
  v5 = (int *)(a1 + 84);
  *v5 = *v4;
  v5[1] = v4[1];
  v5[2] = v4[2];
  result = v4[3];
  v5[3] = result;
  return result;
}

//----- (0043E9B0) --------------------------------------------------------
int __cdecl NPC118(int a1)
{
  int v1; // eax
  int *v2; // ecx
  int *v3; // edx
  int result; // eax
  signed int v5; // [esp+4h] [ebp-124h]
  int v6; // [esp+8h] [ebp-120h]
  int v7; // [esp+Ch] [ebp-11Ch]
  int v8; // [esp+10h] [ebp-118h]
  int v9; // [esp+14h] [ebp-114h]
  int v10; // [esp+18h] [ebp-110h]
  int v11; // [esp+1Ch] [ebp-10Ch]
  int v12; // [esp+20h] [ebp-108h]
  int v13; // [esp+24h] [ebp-104h]
  int v14; // [esp+28h] [ebp-100h]
  int v15; // [esp+2Ch] [ebp-FCh]
  int v16; // [esp+30h] [ebp-F8h]
  int v17; // [esp+34h] [ebp-F4h]
  int v18; // [esp+38h] [ebp-F0h]
  int v19; // [esp+3Ch] [ebp-ECh]
  int v20; // [esp+40h] [ebp-E8h]
  int v21; // [esp+44h] [ebp-E4h]
  int v22; // [esp+48h] [ebp-E0h]
  int v23; // [esp+4Ch] [ebp-DCh]
  int v24; // [esp+50h] [ebp-D8h]
  int v25; // [esp+54h] [ebp-D4h]
  int v26; // [esp+58h] [ebp-D0h]
  int v27; // [esp+5Ch] [ebp-CCh]
  int v28; // [esp+60h] [ebp-C8h]
  int v29; // [esp+64h] [ebp-C4h]
  int v30; // [esp+68h] [ebp-C0h]
  int v31; // [esp+6Ch] [ebp-BCh]
  int v32; // [esp+70h] [ebp-B8h]
  int v33; // [esp+74h] [ebp-B4h]
  int v34; // [esp+78h] [ebp-B0h]
  int v35; // [esp+7Ch] [ebp-ACh]
  int v36; // [esp+80h] [ebp-A8h]
  int v37; // [esp+84h] [ebp-A4h]
  int v38; // [esp+88h] [ebp-A0h]
  int v39; // [esp+8Ch] [ebp-9Ch]
  int v40; // [esp+90h] [ebp-98h]
  int v41; // [esp+94h] [ebp-94h]
  int v42; // [esp+98h] [ebp-90h]
  int v43; // [esp+9Ch] [ebp-8Ch]
  int v44; // [esp+A0h] [ebp-88h]
  int v45; // [esp+A4h] [ebp-84h]
  int v46; // [esp+A8h] [ebp-80h]
  int v47; // [esp+ACh] [ebp-7Ch]
  int v48; // [esp+B0h] [ebp-78h]
  int v49; // [esp+B4h] [ebp-74h]
  int v50; // [esp+B8h] [ebp-70h]
  int v51; // [esp+BCh] [ebp-6Ch]
  int v52; // [esp+C0h] [ebp-68h]
  int v53; // [esp+C4h] [ebp-64h]
  int v54; // [esp+C8h] [ebp-60h]
  int v55; // [esp+CCh] [ebp-5Ch]
  int v56; // [esp+D0h] [ebp-58h]
  int v57; // [esp+D4h] [ebp-54h]
  int v58; // [esp+D8h] [ebp-50h]
  int v59; // [esp+DCh] [ebp-4Ch]
  int v60; // [esp+E0h] [ebp-48h]
  int v61; // [esp+E4h] [ebp-44h]
  int v62; // [esp+E8h] [ebp-40h]
  int v63; // [esp+ECh] [ebp-3Ch]
  int v64; // [esp+F0h] [ebp-38h]
  int v65; // [esp+F4h] [ebp-34h]
  int v66; // [esp+F8h] [ebp-30h]
  int v67; // [esp+FCh] [ebp-2Ch]
  int v68; // [esp+100h] [ebp-28h]
  int v69; // [esp+104h] [ebp-24h]
  int v70; // [esp+108h] [ebp-20h]
  int v71; // [esp+10Ch] [ebp-1Ch]
  int v72; // [esp+110h] [ebp-18h]
  int v73; // [esp+114h] [ebp-14h]
  int v74; // [esp+118h] [ebp-10h]
  int v75; // [esp+11Ch] [ebp-Ch]
  int v76; // [esp+120h] [ebp-8h]
  int v77; // [esp+124h] [ebp-4h]

  v42 = 0;
  v43 = 32;
  v44 = 32;
  v45 = 56;
  v46 = 32;
  v47 = 32;
  v48 = 64;
  v49 = 56;
  v50 = 64;
  v51 = 32;
  v52 = 96;
  v53 = 56;
  v54 = 96;
  v55 = 32;
  v56 = 128;
  v57 = 56;
  v58 = 0;
  v59 = 32;
  v60 = 32;
  v61 = 56;
  v62 = 128;
  v63 = 32;
  v64 = 160;
  v65 = 56;
  v66 = 0;
  v67 = 32;
  v68 = 32;
  v69 = 56;
  v70 = 0;
  v71 = 32;
  v72 = 32;
  v73 = 56;
  v74 = 160;
  v75 = 32;
  v76 = 192;
  v77 = 56;
  v6 = 0;
  v7 = 56;
  v8 = 32;
  v9 = 80;
  v10 = 32;
  v11 = 56;
  v12 = 64;
  v13 = 80;
  v14 = 64;
  v15 = 56;
  v16 = 96;
  v17 = 80;
  v18 = 96;
  v19 = 56;
  v20 = 128;
  v21 = 80;
  v22 = 0;
  v23 = 56;
  v24 = 32;
  v25 = 80;
  v26 = 128;
  v27 = 56;
  v28 = 160;
  v29 = 80;
  v30 = 0;
  v31 = 56;
  v32 = 32;
  v33 = 80;
  v34 = 0;
  v35 = 56;
  v36 = 32;
  v37 = 80;
  v38 = 160;
  v39 = 56;
  v40 = 192;
  v41 = 80;
  v5 = 0;
  if ( !*(_DWORD *)(a1 + 76) && *(_DWORD *)(a1 + 8) < quote.XPos )
    v5 = 1;
  if ( *(_DWORD *)(a1 + 76) == 2 && *(_DWORD *)(a1 + 8) > quote.XPos )
    v5 = 1;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 120) = random(50, 100);
      *(_DWORD *)(a1 + 104) = 0;
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      *(_WORD *)(a1 + 80) |= 0x20u;
      *(_WORD *)(a1 + 80) &= 0xFFFBu;
      goto LABEL_13;
    case 0xB:
LABEL_13:
      if ( *(_DWORD *)(a1 + 120) )
        --*(_DWORD *)(a1 + 120);
      else
        *(_DWORD *)(a1 + 116) = 13;
      break;
    case 0xD:
      *(_DWORD *)(a1 + 116) = 14;
      *(_DWORD *)(a1 + 104) = 3;
      *(_DWORD *)(a1 + 120) = random(50, 100);
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      goto LABEL_20;
    case 0xE:
LABEL_20:
      if ( ++*(_DWORD *)(a1 + 100) > 2 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 6 )
        *(_DWORD *)(a1 + 104) = 3;
      if ( *(_DWORD *)(a1 + 76) )
        v1 = *(_DWORD *)(a1 + 16) + 64;
      else
        v1 = *(_DWORD *)(a1 + 16) - 64;
      *(_DWORD *)(a1 + 16) = v1;
      if ( *(_DWORD *)(a1 + 120) )
      {
        --*(_DWORD *)(a1 + 120);
      }
      else
      {
        *(_WORD *)(a1 + 80) |= 0x20u;
        *(_DWORD *)(a1 + 116) = 20;
        *(_DWORD *)(a1 + 120) = 0;
        playSoundEffect(SFXBallosBallAndCurlyChargingHerGun, 1);
      }
      break;
    case 0x14:
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      *(_DWORD *)(a1 + 16) = 8 * *(_DWORD *)(a1 + 16) / 9;
      if ( ++*(_DWORD *)(a1 + 104) > 1 )
        *(_DWORD *)(a1 + 104) = 0;
      if ( ++*(_DWORD *)(a1 + 120) > 50 )
      {
        *(_DWORD *)(a1 + 116) = 21;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    case 0x15:
      if ( ++*(_DWORD *)(a1 + 120) % 4 == 1 )
      {
        if ( *(_DWORD *)(a1 + 76) )
        {
          if ( v5 )
          {
            *(_DWORD *)(a1 + 104) = 2;
            createNPC((NPCNames)123, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12) - 4096, 0, 0, up, 0, 256);
          }
          else
          {
            *(_DWORD *)(a1 + 104) = 0;
            createNPC((NPCNames)123, *(_DWORD *)(a1 + 8) + 4096, *(_DWORD *)(a1 + 12) + 2048, 0, 0, right, 0, 256);
            *(_DWORD *)(a1 + 8) -= 512;
          }
        }
        else if ( v5 )
        {
          *(_DWORD *)(a1 + 104) = 2;
          createNPC((NPCNames)123, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12) - 4096, 0, 0, up, 0, 256);
        }
        else
        {
          *(_DWORD *)(a1 + 104) = 0;
          createNPC((NPCNames)123, *(_DWORD *)(a1 + 8) - 4096, *(_DWORD *)(a1 + 12) + 2048, 0, 0, 0, 0, 256);
          *(_DWORD *)(a1 + 8) += 512;
        }
      }
      if ( *(_DWORD *)(a1 + 120) > 30 )
        *(_DWORD *)(a1 + 116) = 10;
      break;
    case 0x1E:
      if ( ++*(_DWORD *)(a1 + 104) > 8 )
        *(_DWORD *)(a1 + 104) = 7;
      if ( ++*(_DWORD *)(a1 + 120) > 30 )
      {
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 116) > 10 && *(_DWORD *)(a1 + 116) < 30 && countBullets(bulletPolarStarLevel3) )
  {
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 116) = 30;
    *(_DWORD *)(a1 + 104) = 7;
    *(_WORD *)(a1 + 80) &= 0xFFDFu;
    *(_WORD *)(a1 + 80) |= 4u;
    *(_DWORD *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 20) += 32;
  if ( *(_DWORD *)(a1 + 16) > 511 )
    *(_DWORD *)(a1 + 16) = 511;
  if ( *(_DWORD *)(a1 + 16) < -511 )
    *(_DWORD *)(a1 + 16) = -511;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  if ( *(_DWORD *)(a1 + 76) )
    v2 = &v6 + 4 * *(_DWORD *)(a1 + 104);
  else
    v2 = &v42 + 4 * *(_DWORD *)(a1 + 104);
  v3 = (int *)(a1 + 84);
  *v3 = *v2;
  v3[1] = v2[1];
  result = v2[2];
  v3[2] = result;
  v3[3] = v2[3];
  return result;
}

//----- (0043F230) --------------------------------------------------------
_DWORD *__cdecl NPC119(int a1)
{
  _DWORD *result; // eax

  result = (_DWORD *)(a1 + 84);
  *result = 248;
  result[1] = 184;
  result[2] = 272;
  result[3] = 200;
  return result;
}

//----- (0043F280) --------------------------------------------------------
signed int __cdecl NPC120(int a1)
{
  _DWORD *v1; // ecx
  signed int result; // eax
  _DWORD *v3; // ecx

  if ( *(_DWORD *)(a1 + 76) )
  {
    v3 = (_DWORD *)(a1 + 84);
    *v3 = 64;
    v3[1] = 16;
    v3[2] = 80;
    result = 32;
    v3[3] = 32;
  }
  else
  {
    v1 = (_DWORD *)(a1 + 84);
    *v1 = 64;
    v1[1] = 0;
    v1[2] = 80;
    result = 16;
    v1[3] = 16;
  }
  return result;
}

//----- (0043F310) --------------------------------------------------------
void __cdecl NPC121(int a1)
{
  int *v1; // edx
  int *v2; // eax
  _DWORD *v3; // eax
  int v4; // [esp+0h] [ebp-34h]
  int v5; // [esp+4h] [ebp-30h]
  int v6; // [esp+8h] [ebp-2Ch]
  int v7; // [esp+Ch] [ebp-28h]
  int v8; // [esp+10h] [ebp-24h]
  int v9; // [esp+14h] [ebp-20h]
  int v10; // [esp+18h] [ebp-1Ch]
  int v11; // [esp+1Ch] [ebp-18h]
  int v12; // [esp+20h] [ebp-14h]
  int v13; // [esp+24h] [ebp-10h]
  int v14; // [esp+28h] [ebp-Ch]
  int v15; // [esp+2Ch] [ebp-8h]
  int v16; // [esp+30h] [ebp-4h]

  v5 = 0;
  v6 = 0;
  v7 = 16;
  v8 = 16;
  v9 = 16;
  v10 = 0;
  v11 = 32;
  v12 = 16;
  v13 = 112;
  v14 = 0;
  v15 = 128;
  v16 = 16;
  if ( !*(_DWORD *)(a1 + 76) )
  {
    v4 = *(_DWORD *)(a1 + 116);
    if ( v4 )
    {
      if ( v4 != 1 )
      {
        if ( v4 == 2 && ++*(_DWORD *)(a1 + 120) > 8 )
        {
          *(_DWORD *)(a1 + 116) = 1;
          *(_DWORD *)(a1 + 104) = 0;
        }
LABEL_12:
        v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
        v2 = (int *)(a1 + 84);
        *v2 = *v1;
        v2[1] = v1[1];
        v2[2] = v1[2];
        v2[3] = v1[3];
        return;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
    }
    if ( random(0, 120) == 10 )
    {
      *(_DWORD *)(a1 + 116) = 2;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 104) = 1;
    }
    goto LABEL_12;
  }
  v3 = (_DWORD *)(a1 + 84);
  *v3 = v13;
  v3[1] = v14;
  v3[2] = v15;
  v3[3] = v16;
  if ( ++*(_DWORD *)(a1 + 120) > 100 )
  {
    *(_DWORD *)(a1 + 120) = 0;
    createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectZzZ, 0);
  }
}

//----- (0043F4A0) --------------------------------------------------------
int *__cdecl NPC122(int a1)
{
  int v1; // eax
  int *v2; // edx
  int *result; // eax
  int v4; // [esp+4h] [ebp-140h]
  int v5; // [esp+8h] [ebp-13Ch]
  int v6; // [esp+Ch] [ebp-138h]
  int v7; // [esp+10h] [ebp-134h]
  int v8; // [esp+14h] [ebp-130h]
  int v9; // [esp+18h] [ebp-12Ch]
  int v10; // [esp+1Ch] [ebp-128h]
  int v11; // [esp+20h] [ebp-124h]
  int v12; // [esp+24h] [ebp-120h]
  int v13; // [esp+28h] [ebp-11Ch]
  int v14; // [esp+2Ch] [ebp-118h]
  int v15; // [esp+30h] [ebp-114h]
  int v16; // [esp+34h] [ebp-110h]
  int v17; // [esp+38h] [ebp-10Ch]
  int v18; // [esp+3Ch] [ebp-108h]
  int v19; // [esp+40h] [ebp-104h]
  int v20; // [esp+44h] [ebp-100h]
  int v21; // [esp+48h] [ebp-FCh]
  int v22; // [esp+4Ch] [ebp-F8h]
  int v23; // [esp+50h] [ebp-F4h]
  int v24; // [esp+54h] [ebp-F0h]
  int v25; // [esp+58h] [ebp-ECh]
  int v26; // [esp+5Ch] [ebp-E8h]
  int v27; // [esp+60h] [ebp-E4h]
  int v28; // [esp+64h] [ebp-E0h]
  int v29; // [esp+68h] [ebp-DCh]
  int v30; // [esp+6Ch] [ebp-D8h]
  int v31; // [esp+70h] [ebp-D4h]
  int v32; // [esp+74h] [ebp-D0h]
  int v33; // [esp+78h] [ebp-CCh]
  int v34; // [esp+7Ch] [ebp-C8h]
  int v35; // [esp+80h] [ebp-C4h]
  int v36; // [esp+84h] [ebp-C0h]
  int v37; // [esp+88h] [ebp-BCh]
  int v38; // [esp+8Ch] [ebp-B8h]
  int v39; // [esp+90h] [ebp-B4h]
  int v40; // [esp+94h] [ebp-B0h]
  int v41; // [esp+98h] [ebp-ACh]
  int v42; // [esp+9Ch] [ebp-A8h]
  int v43; // [esp+A0h] [ebp-A4h]
  int v44; // [esp+A4h] [ebp-A0h]
  int v45; // [esp+A8h] [ebp-9Ch]
  int v46; // [esp+ACh] [ebp-98h]
  int v47; // [esp+B0h] [ebp-94h]
  int v48; // [esp+B4h] [ebp-90h]
  int v49; // [esp+B8h] [ebp-8Ch]
  int v50; // [esp+BCh] [ebp-88h]
  int v51; // [esp+C0h] [ebp-84h]
  int v52; // [esp+C4h] [ebp-80h]
  int v53; // [esp+C8h] [ebp-7Ch]
  int v54; // [esp+CCh] [ebp-78h]
  int v55; // [esp+D0h] [ebp-74h]
  int v56; // [esp+D4h] [ebp-70h]
  int v57; // [esp+D8h] [ebp-6Ch]
  int v58; // [esp+DCh] [ebp-68h]
  int v59; // [esp+E0h] [ebp-64h]
  int v60; // [esp+E4h] [ebp-60h]
  int v61; // [esp+E8h] [ebp-5Ch]
  int v62; // [esp+ECh] [ebp-58h]
  int v63; // [esp+F0h] [ebp-54h]
  int v64; // [esp+F4h] [ebp-50h]
  int v65; // [esp+F8h] [ebp-4Ch]
  int v66; // [esp+FCh] [ebp-48h]
  int v67; // [esp+100h] [ebp-44h]
  int v68; // [esp+104h] [ebp-40h]
  int v69; // [esp+108h] [ebp-3Ch]
  int v70; // [esp+10Ch] [ebp-38h]
  int v71; // [esp+110h] [ebp-34h]
  int v72; // [esp+114h] [ebp-30h]
  int v73; // [esp+118h] [ebp-2Ch]
  int v74; // [esp+11Ch] [ebp-28h]
  int v75; // [esp+120h] [ebp-24h]
  int v76; // [esp+124h] [ebp-20h]
  int v77; // [esp+128h] [ebp-1Ch]
  int v78; // [esp+12Ch] [ebp-18h]
  int v79; // [esp+130h] [ebp-14h]
  int v80; // [esp+134h] [ebp-10h]
  int v81; // [esp+138h] [ebp-Ch]
  int v82; // [esp+13Ch] [ebp-8h]
  int v83; // [esp+140h] [ebp-4h]

  v44 = 0;
  v45 = 0;
  v46 = 16;
  v47 = 16;
  v48 = 16;
  v49 = 0;
  v50 = 32;
  v51 = 16;
  v52 = 32;
  v53 = 0;
  v54 = 48;
  v55 = 16;
  v56 = 0;
  v57 = 0;
  v58 = 16;
  v59 = 16;
  v60 = 48;
  v61 = 0;
  v62 = 64;
  v63 = 16;
  v64 = 0;
  v65 = 0;
  v66 = 16;
  v67 = 16;
  v68 = 80;
  v69 = 0;
  v70 = 96;
  v71 = 16;
  v72 = 96;
  v73 = 0;
  v74 = 112;
  v75 = 16;
  v76 = 112;
  v77 = 0;
  v78 = 128;
  v79 = 16;
  v80 = 128;
  v81 = 0;
  v82 = 144;
  v83 = 16;
  v4 = 0;
  v5 = 16;
  v6 = 16;
  v7 = 32;
  v8 = 16;
  v9 = 16;
  v10 = 32;
  v11 = 32;
  v12 = 32;
  v13 = 16;
  v14 = 48;
  v15 = 32;
  v16 = 0;
  v17 = 16;
  v18 = 16;
  v19 = 32;
  v20 = 48;
  v21 = 16;
  v22 = 64;
  v23 = 32;
  v24 = 0;
  v25 = 16;
  v26 = 16;
  v27 = 32;
  v28 = 80;
  v29 = 16;
  v30 = 96;
  v31 = 32;
  v32 = 96;
  v33 = 16;
  v34 = 112;
  v35 = 32;
  v36 = 112;
  v37 = 16;
  v38 = 128;
  v39 = 32;
  v40 = 128;
  v41 = 16;
  v42 = 144;
  v43 = 32;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( random(0, 120) == 10 )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      if ( *(_DWORD *)(a1 + 8) - 0x4000 < quote.XPos
        && *(_DWORD *)(a1 + 8) + 0x4000 > quote.XPos
        && *(_DWORD *)(a1 + 12) - 0x4000 < quote.YPos
        && *(_DWORD *)(a1 + 12) + 0x2000 > quote.YPos )
      {
        if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
          *(_DWORD *)(a1 + 76) = 2;
        else
          *(_DWORD *)(a1 + 76) = 0;
      }
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    case 0xA:
      *(_DWORD *)(a1 + 64) = 1000;
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 120) = random(0, 50);
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 164) = 0;
      goto LABEL_17;
    case 0xB:
LABEL_17:
      if ( *(_DWORD *)(a1 + 120) )
        --*(_DWORD *)(a1 + 120);
      else
        *(_DWORD *)(a1 + 116) = 13;
      break;
    case 0xD:
      *(_DWORD *)(a1 + 116) = 14;
      *(_DWORD *)(a1 + 120) = random(0, 50);
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      goto LABEL_24;
    case 0xE:
LABEL_24:
      if ( ++*(_DWORD *)(a1 + 100) > 2 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 5 )
        *(_DWORD *)(a1 + 104) = 2;
      if ( *(_DWORD *)(a1 + 76) )
        v1 = *(_DWORD *)(a1 + 16) + 64;
      else
        v1 = *(_DWORD *)(a1 + 16) - 64;
      *(_DWORD *)(a1 + 16) = v1;
      if ( *(_DWORD *)(a1 + 120) )
      {
        --*(_DWORD *)(a1 + 120);
      }
      else
      {
        *(_WORD *)(a1 + 80) |= 0x20u;
        *(_DWORD *)(a1 + 116) = 15;
        *(_DWORD *)(a1 + 104) = 2;
        *(_DWORD *)(a1 + 20) = -512;
        *(_DWORD *)(a1 + 164) = 2;
      }
      break;
    case 0xF:
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_WORD *)(a1 + 80) |= 0x20u;
        *(_DWORD *)(a1 + 16) = 0;
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 164) = 0;
      }
      break;
    case 0x14:
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 16) = 0;
        *(_DWORD *)(a1 + 116) = 21;
        *(_DWORD *)(a1 + 164) = 0;
        if ( *(_DWORD *)(a1 + 104) == 6 )
          *(_DWORD *)(a1 + 104) = 8;
        else
          *(_DWORD *)(a1 + 104) = 9;
        *(_DWORD *)(a1 + 120) = random(300, 400);
      }
      break;
    case 0x15:
      if ( *(_DWORD *)(a1 + 120) )
      {
        --*(_DWORD *)(a1 + 120);
      }
      else
      {
        *(_WORD *)(a1 + 80) |= 0x20u;
        *(_DWORD *)(a1 + 64) = 1000;
        *(_DWORD *)(a1 + 116) = 11;
        *(_DWORD *)(a1 + 120) = random(0, 50);
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 116) > 10 && *(_DWORD *)(a1 + 116) < 20 && *(_DWORD *)(a1 + 64) != 1000 )
  {
    *(_DWORD *)(a1 + 116) = 20;
    *(_DWORD *)(a1 + 20) = -512;
    *(_DWORD *)(a1 + 104) = random(6, 7);
    *(_WORD *)(a1 + 80) &= 0xFFDFu;
  }
  *(_DWORD *)(a1 + 20) += 32;
  if ( *(_DWORD *)(a1 + 16) > 511 )
    *(_DWORD *)(a1 + 16) = 511;
  if ( *(_DWORD *)(a1 + 16) < -511 )
    *(_DWORD *)(a1 + 16) = -511;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  if ( *(_DWORD *)(a1 + 76) )
    v2 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v2 = &v44 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v2;
  result[1] = v2[1];
  result[2] = v2[2];
  result[3] = v2[3];
  return result;
}

//----- (0043FC70) --------------------------------------------------------
int __cdecl NPC123(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  int v4; // [esp+8h] [ebp-4Ch]
  int v5; // [esp+Ch] [ebp-48h]
  int v6; // [esp+10h] [ebp-44h]
  int v7; // [esp+14h] [ebp-40h]
  int v8; // [esp+18h] [ebp-3Ch]
  int v9; // [esp+1Ch] [ebp-38h]
  int v10; // [esp+20h] [ebp-34h]
  int v11; // [esp+24h] [ebp-30h]
  int v12; // [esp+28h] [ebp-2Ch]
  int v13; // [esp+2Ch] [ebp-28h]
  int v14; // [esp+30h] [ebp-24h]
  int v15; // [esp+34h] [ebp-20h]
  int v16; // [esp+38h] [ebp-1Ch]
  int v17; // [esp+3Ch] [ebp-18h]
  int v18; // [esp+40h] [ebp-14h]
  int v19; // [esp+44h] [ebp-10h]
  int v20; // [esp+48h] [ebp-Ch]
  int v21; // [esp+50h] [ebp-4h]

  v5 = 192;
  v6 = 0;
  v7 = 208;
  v8 = 16;
  v9 = 208;
  v10 = 0;
  v11 = 224;
  v12 = 16;
  v13 = 224;
  v14 = 0;
  v15 = 240;
  v16 = 16;
  v17 = 240;
  v18 = 0;
  v19 = 256;
  v20 = 16;
  v21 = 0;
  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 == 1 )
    {
      switch ( *(_DWORD *)(a1 + 76) )
      {
        case 0:
          if ( *(_DWORD *)(a1 + 4) & 1 )
            v21 = 1;
          break;
        case 1:
          if ( *(_DWORD *)(a1 + 4) & 2 )
            v21 = 1;
          break;
        case 2:
          if ( *(_DWORD *)(a1 + 4) & 4 )
            v21 = 1;
          break;
        case 3:
          if ( *(_DWORD *)(a1 + 4) & 8 )
            v21 = 1;
          break;
        default:
          break;
      }
      *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
    }
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectStar, 0);
    playSoundEffect(SFXPolarStarShootLevel12, 1);
    switch ( *(_DWORD *)(a1 + 76) )
    {
      case 0:
        *(_DWORD *)(a1 + 16) = -4096;
        *(_DWORD *)(a1 + 20) = random(-128, 128);
        break;
      case 1:
        *(_DWORD *)(a1 + 20) = -4096;
        *(_DWORD *)(a1 + 16) = random(-128, 128);
        break;
      case 2:
        *(_DWORD *)(a1 + 16) = 4096;
        *(_DWORD *)(a1 + 20) = random(-128, 128);
        break;
      case 3:
        *(_DWORD *)(a1 + 20) = 4096;
        *(_DWORD *)(a1 + 16) = random(-128, 128);
        break;
      default:
        break;
    }
  }
  if ( v21 )
  {
    createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectRisingDisc, right);
    playSoundEffect(SFXShotHitWall, 1);
    *(_BYTE *)a1 = 0;
  }
  v1 = &v5 + 4 * *(_DWORD *)(a1 + 76);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}

//----- (0043FEF0) --------------------------------------------------------
int __cdecl NPC124(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  int v4; // [esp+8h] [ebp-20h]
  int v5; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]
  int v10; // [esp+20h] [ebp-8h]
  int v11; // [esp+24h] [ebp-4h]

  v4 = 160;
  v5 = 0;
  v6 = 192;
  v7 = 32;
  v8 = 192;
  v9 = 0;
  v10 = 224;
  v11 = 32;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 8) += 4096;
      *(_DWORD *)(a1 + 12) += 4096;
      goto LABEL_3;
    case 1:
LABEL_3:
      *(_WORD *)(a1 + 80) &= 0xFFF7u;
      *(_DWORD *)(a1 + 104) = 0;
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 104) = 1;
      *(_DWORD *)(a1 + 120) = 0;
      *(_WORD *)(a1 + 80) |= 8u;
      goto LABEL_5;
    case 0xB:
LABEL_5:
      switch ( *(_DWORD *)(a1 + 76) )
      {
        case 0:
          *(_DWORD *)(a1 + 8) -= 128;
          break;
        case 1:
          *(_DWORD *)(a1 + 12) -= 128;
          break;
        case 2:
          *(_DWORD *)(a1 + 8) += 128;
          break;
        case 3:
          *(_DWORD *)(a1 + 12) += 128;
          break;
        default:
          break;
      }
      if ( !(++*(_DWORD *)(a1 + 120) % 8) )
        playSoundEffect(SFXLargeObjectHitGround, 1);
      setQuake(20);
      break;
    default:
      break;
  }
  v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}

//----- (004400D0) --------------------------------------------------------
_DWORD *__cdecl NPC125(int a1)
{
  _DWORD *result; // eax

  if ( *(_DWORD *)(a1 + 64) < 990 )
  {
    createDustClouds(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 148), 8);
    playSoundEffect(SFXEnemySmokePoof, 1);
    if ( *(_DWORD *)(a1 + 76) )
      createNPC((NPCNames)86, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 0, 0, right, 0, 0);
    else
      createNPC(NPCEnemyBasil|0x50, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 0, 0, right, 0, 0);
    *(_BYTE *)a1 = 0;
  }
  if ( *(_DWORD *)(a1 + 76) )
  {
    result = (_DWORD *)(a1 + 84);
    *result = 16;
    result[1] = 96;
    result[2] = 32;
  }
  else
  {
    result = (_DWORD *)(a1 + 84);
    *result = 0;
    result[1] = 96;
    result[2] = 16;
  }
  result[3] = 112;
  return result;
}

//----- (004401F0) --------------------------------------------------------
int *__cdecl NPC126(int a1)
{
  int v1; // eax
  __int16 v2; // dx
  int *v3; // edx
  int *result; // eax
  int v5; // [esp+4h] [ebp-C0h]
  int v6; // [esp+8h] [ebp-BCh]
  int v7; // [esp+Ch] [ebp-B8h]
  int v8; // [esp+10h] [ebp-B4h]
  int v9; // [esp+14h] [ebp-B0h]
  int v10; // [esp+18h] [ebp-ACh]
  int v11; // [esp+1Ch] [ebp-A8h]
  int v12; // [esp+20h] [ebp-A4h]
  int v13; // [esp+24h] [ebp-A0h]
  int v14; // [esp+28h] [ebp-9Ch]
  int v15; // [esp+2Ch] [ebp-98h]
  int v16; // [esp+30h] [ebp-94h]
  int v17; // [esp+34h] [ebp-90h]
  int v18; // [esp+38h] [ebp-8Ch]
  int v19; // [esp+3Ch] [ebp-88h]
  int v20; // [esp+40h] [ebp-84h]
  int v21; // [esp+44h] [ebp-80h]
  int v22; // [esp+48h] [ebp-7Ch]
  int v23; // [esp+4Ch] [ebp-78h]
  int v24; // [esp+50h] [ebp-74h]
  int v25; // [esp+54h] [ebp-70h]
  int v26; // [esp+58h] [ebp-6Ch]
  int v27; // [esp+5Ch] [ebp-68h]
  int v28; // [esp+60h] [ebp-64h]
  int v29; // [esp+64h] [ebp-60h]
  int v30; // [esp+68h] [ebp-5Ch]
  int v31; // [esp+6Ch] [ebp-58h]
  int v32; // [esp+70h] [ebp-54h]
  int v33; // [esp+74h] [ebp-50h]
  int v34; // [esp+78h] [ebp-4Ch]
  int v35; // [esp+7Ch] [ebp-48h]
  int v36; // [esp+80h] [ebp-44h]
  int v37; // [esp+84h] [ebp-40h]
  int v38; // [esp+88h] [ebp-3Ch]
  int v39; // [esp+8Ch] [ebp-38h]
  int v40; // [esp+90h] [ebp-34h]
  int v41; // [esp+94h] [ebp-30h]
  int v42; // [esp+98h] [ebp-2Ch]
  int v43; // [esp+9Ch] [ebp-28h]
  int v44; // [esp+A0h] [ebp-24h]
  int v45; // [esp+A4h] [ebp-20h]
  int v46; // [esp+A8h] [ebp-1Ch]
  int v47; // [esp+ACh] [ebp-18h]
  int v48; // [esp+B0h] [ebp-14h]
  int v49; // [esp+B4h] [ebp-10h]
  int v50; // [esp+B8h] [ebp-Ch]
  int v51; // [esp+BCh] [ebp-8h]
  int v52; // [esp+C0h] [ebp-4h]

  v29 = 48;
  v30 = 144;
  v31 = 64;
  v32 = 160;
  v33 = 64;
  v34 = 144;
  v35 = 80;
  v36 = 160;
  v37 = 48;
  v38 = 144;
  v39 = 64;
  v40 = 160;
  v41 = 80;
  v42 = 144;
  v43 = 96;
  v44 = 160;
  v45 = 96;
  v46 = 144;
  v47 = 112;
  v48 = 160;
  v49 = 112;
  v50 = 144;
  v51 = 128;
  v52 = 160;
  v5 = 48;
  v6 = 160;
  v7 = 64;
  v8 = 176;
  v9 = 64;
  v10 = 160;
  v11 = 80;
  v12 = 176;
  v13 = 48;
  v14 = 160;
  v15 = 64;
  v16 = 176;
  v17 = 80;
  v18 = 160;
  v19 = 96;
  v20 = 176;
  v21 = 96;
  v22 = 160;
  v23 = 112;
  v24 = 176;
  v25 = 112;
  v26 = 160;
  v27 = 128;
  v28 = 176;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( random(0, 120) == 10 )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      if ( *(_DWORD *)(a1 + 8) - 49152 < quote.XPos
        && *(_DWORD *)(a1 + 8) + 49152 > quote.XPos
        && *(_DWORD *)(a1 + 12) - 0x4000 < quote.YPos
        && *(_DWORD *)(a1 + 12) + 0x2000 > quote.YPos )
      {
        if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
          *(_DWORD *)(a1 + 76) = 2;
        else
          *(_DWORD *)(a1 + 76) = 0;
      }
      if ( *(_DWORD *)(a1 + 8) - 0x4000 < quote.XPos
        && *(_DWORD *)(a1 + 8) + 0x4000 > quote.XPos
        && *(_DWORD *)(a1 + 12) - 0x4000 < quote.YPos
        && *(_DWORD *)(a1 + 12) + 0x2000 > quote.YPos )
      {
        if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
          *(_DWORD *)(a1 + 76) = 0;
        else
          *(_DWORD *)(a1 + 76) = 2;
        *(_DWORD *)(a1 + 116) = 10;
      }
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 104) = 4;
      *(_DWORD *)(a1 + 100) = 0;
      goto LABEL_25;
    case 0xB:
LABEL_25:
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        if ( ++*(_DWORD *)(a1 + 100) > 2 )
        {
          *(_DWORD *)(a1 + 100) = 0;
          ++*(_DWORD *)(a1 + 104);
        }
        if ( *(_DWORD *)(a1 + 104) > 5 )
          *(_DWORD *)(a1 + 104) = 4;
      }
      else
      {
        *(_DWORD *)(a1 + 104) = 5;
        *(_DWORD *)(a1 + 100) = 0;
      }
      if ( *(_DWORD *)(a1 + 16) < 0 && *(_DWORD *)(a1 + 4) & 1 )
      {
        *(_DWORD *)(a1 + 16) /= -2;
        *(_DWORD *)(a1 + 76) = 2;
      }
      if ( *(_DWORD *)(a1 + 16) > 0 && *(_DWORD *)(a1 + 4) & 4 )
      {
        *(_DWORD *)(a1 + 16) /= -2;
        *(_DWORD *)(a1 + 76) = 0;
      }
      if ( *(_DWORD *)(a1 + 76) )
        v1 = *(_DWORD *)(a1 + 16) + 64;
      else
        v1 = *(_DWORD *)(a1 + 16) - 64;
      *(_DWORD *)(a1 + 16) = v1;
      if ( *(_DWORD *)(a1 + 16) > 1535 )
        *(_DWORD *)(a1 + 16) = 1024;
      if ( *(_DWORD *)(a1 + 16) < -1535 )
        *(_DWORD *)(a1 + 16) = -1024;
      break;
    default:
      break;
  }
  if ( keyDown & keyPressed )
    v2 = *(_WORD *)(a1 + 80) | 0x2000;
  else
    v2 = *(_WORD *)(a1 + 80) & 0xDFFF;
  *(_WORD *)(a1 + 80) = v2;
  *(_DWORD *)(a1 + 20) += 64;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v3 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  else
    v3 = &v29 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v3;
  result[1] = v3[1];
  result[2] = v3[2];
  result[3] = v3[3];
  return result;
}
// 49363C: using guessed type int keyDown;
// 49E214: using guessed type int keyPressed;

//----- (00440760) --------------------------------------------------------
int __cdecl NPC127(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  int v4; // [esp+0h] [ebp-60h]
  int v5; // [esp+4h] [ebp-5Ch]
  int v6; // [esp+8h] [ebp-58h]
  int v7; // [esp+Ch] [ebp-54h]
  int v8; // [esp+10h] [ebp-50h]
  int v9; // [esp+14h] [ebp-4Ch]
  int v10; // [esp+18h] [ebp-48h]
  int v11; // [esp+1Ch] [ebp-44h]
  int v12; // [esp+20h] [ebp-40h]
  int v13; // [esp+24h] [ebp-3Ch]
  int v14; // [esp+28h] [ebp-38h]
  int v15; // [esp+2Ch] [ebp-34h]
  int v16; // [esp+30h] [ebp-30h]
  int v17; // [esp+34h] [ebp-2Ch]
  int v18; // [esp+38h] [ebp-28h]
  int v19; // [esp+3Ch] [ebp-24h]
  int v20; // [esp+40h] [ebp-20h]
  int v21; // [esp+44h] [ebp-1Ch]
  int v22; // [esp+48h] [ebp-18h]
  int v23; // [esp+4Ch] [ebp-14h]
  int v24; // [esp+50h] [ebp-10h]
  int v25; // [esp+54h] [ebp-Ch]
  int v26; // [esp+58h] [ebp-8h]
  int v27; // [esp+5Ch] [ebp-4h]

  v4 = 112;
  v5 = 48;
  v6 = 128;
  v7 = 64;
  v8 = 112;
  v9 = 64;
  v10 = 128;
  v11 = 80;
  v12 = 112;
  v13 = 80;
  v14 = 128;
  v15 = 96;
  v16 = 64;
  v17 = 80;
  v18 = 80;
  v19 = 96;
  v20 = 80;
  v21 = 80;
  v22 = 96;
  v23 = 96;
  v24 = 96;
  v25 = 80;
  v26 = 112;
  v27 = 96;
  if ( ++*(_DWORD *)(a1 + 100) > 0 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    if ( ++*(_DWORD *)(a1 + 104) > 2 )
      *(_BYTE *)a1 = 0;
  }
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v16 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}

//----- (004408B0) --------------------------------------------------------
int __cdecl NPC128(int a1)
{
  int result; // eax
  int *v2; // eax
  int *v3; // ecx
  int *v4; // eax
  int *v5; // ecx
  int *v6; // eax
  int *v7; // ecx
  int *v8; // eax
  int *v9; // ecx
  int v10; // [esp+4h] [ebp-140h]
  int v11; // [esp+8h] [ebp-13Ch]
  int v12; // [esp+Ch] [ebp-138h]
  int v13; // [esp+10h] [ebp-134h]
  int v14; // [esp+14h] [ebp-130h]
  int v15; // [esp+18h] [ebp-12Ch]
  int v16; // [esp+1Ch] [ebp-128h]
  int v17; // [esp+20h] [ebp-124h]
  int v18; // [esp+24h] [ebp-120h]
  int v19; // [esp+28h] [ebp-11Ch]
  int v20; // [esp+2Ch] [ebp-118h]
  int v21; // [esp+30h] [ebp-114h]
  int v22; // [esp+34h] [ebp-110h]
  int v23; // [esp+38h] [ebp-10Ch]
  int v24; // [esp+3Ch] [ebp-108h]
  int v25; // [esp+40h] [ebp-104h]
  int v26; // [esp+44h] [ebp-100h]
  int v27; // [esp+48h] [ebp-FCh]
  int v28; // [esp+4Ch] [ebp-F8h]
  int v29; // [esp+50h] [ebp-F4h]
  int v30; // [esp+54h] [ebp-F0h]
  int v31; // [esp+58h] [ebp-ECh]
  int v32; // [esp+5Ch] [ebp-E8h]
  int v33; // [esp+60h] [ebp-E4h]
  int v34; // [esp+64h] [ebp-E0h]
  int v35; // [esp+68h] [ebp-DCh]
  int v36; // [esp+6Ch] [ebp-D8h]
  int v37; // [esp+70h] [ebp-D4h]
  int v38; // [esp+74h] [ebp-D0h]
  int v39; // [esp+78h] [ebp-CCh]
  int v40; // [esp+7Ch] [ebp-C8h]
  int v41; // [esp+80h] [ebp-C4h]
  int v42; // [esp+84h] [ebp-C0h]
  int v43; // [esp+88h] [ebp-BCh]
  int v44; // [esp+8Ch] [ebp-B8h]
  int v45; // [esp+90h] [ebp-B4h]
  int v46; // [esp+94h] [ebp-B0h]
  int v47; // [esp+98h] [ebp-ACh]
  int v48; // [esp+9Ch] [ebp-A8h]
  int v49; // [esp+A0h] [ebp-A4h]
  int v50; // [esp+A4h] [ebp-A0h]
  int v51; // [esp+A8h] [ebp-9Ch]
  int v52; // [esp+ACh] [ebp-98h]
  int v53; // [esp+B0h] [ebp-94h]
  int v54; // [esp+B4h] [ebp-90h]
  int v55; // [esp+B8h] [ebp-8Ch]
  int v56; // [esp+BCh] [ebp-88h]
  int v57; // [esp+C0h] [ebp-84h]
  int v58; // [esp+C4h] [ebp-80h]
  int v59; // [esp+C8h] [ebp-7Ch]
  int v60; // [esp+CCh] [ebp-78h]
  int v61; // [esp+D0h] [ebp-74h]
  int v62; // [esp+D4h] [ebp-70h]
  int v63; // [esp+D8h] [ebp-6Ch]
  int v64; // [esp+DCh] [ebp-68h]
  int v65; // [esp+E0h] [ebp-64h]
  int v66; // [esp+E4h] [ebp-60h]
  int v67; // [esp+E8h] [ebp-5Ch]
  int v68; // [esp+ECh] [ebp-58h]
  int v69; // [esp+F0h] [ebp-54h]
  int v70; // [esp+F4h] [ebp-50h]
  int v71; // [esp+F8h] [ebp-4Ch]
  int v72; // [esp+FCh] [ebp-48h]
  int v73; // [esp+100h] [ebp-44h]
  int v74; // [esp+104h] [ebp-40h]
  int v75; // [esp+108h] [ebp-3Ch]
  int v76; // [esp+10Ch] [ebp-38h]
  int v77; // [esp+110h] [ebp-34h]
  int v78; // [esp+114h] [ebp-30h]
  int v79; // [esp+118h] [ebp-2Ch]
  int v80; // [esp+11Ch] [ebp-28h]
  int v81; // [esp+120h] [ebp-24h]
  int v82; // [esp+124h] [ebp-20h]
  int v83; // [esp+128h] [ebp-1Ch]
  int v84; // [esp+12Ch] [ebp-18h]
  int v85; // [esp+130h] [ebp-14h]
  int v86; // [esp+134h] [ebp-10h]
  int v87; // [esp+138h] [ebp-Ch]
  int v88; // [esp+13Ch] [ebp-8h]
  int v89; // [esp+140h] [ebp-4h]

  v50 = 0;
  v51 = 0;
  v52 = 0;
  v53 = 0;
  v54 = 176;
  v55 = 16;
  v56 = 184;
  v57 = 32;
  v58 = 184;
  v59 = 16;
  v60 = 192;
  v61 = 32;
  v62 = 192;
  v63 = 16;
  v64 = 200;
  v65 = 32;
  v66 = 200;
  v67 = 16;
  v68 = 208;
  v69 = 32;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 232;
  v35 = 16;
  v36 = 240;
  v37 = 32;
  v38 = 224;
  v39 = 16;
  v40 = 232;
  v41 = 32;
  v42 = 216;
  v43 = 16;
  v44 = 224;
  v45 = 32;
  v46 = 208;
  v47 = 16;
  v48 = 216;
  v49 = 32;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 176;
  v75 = 32;
  v76 = 192;
  v77 = 40;
  v78 = 176;
  v79 = 40;
  v80 = 192;
  v81 = 48;
  v82 = 192;
  v83 = 32;
  v84 = 208;
  v85 = 40;
  v86 = 192;
  v87 = 40;
  v88 = 208;
  v89 = 48;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 208;
  v15 = 32;
  v16 = 224;
  v17 = 40;
  v18 = 208;
  v19 = 40;
  v20 = 224;
  v21 = 48;
  v22 = 224;
  v23 = 32;
  v24 = 232;
  v25 = 40;
  v26 = 224;
  v27 = 40;
  v28 = 232;
  v29 = 48;
  if ( !*(_DWORD *)(a1 + 116) )
  {
    *(_DWORD *)(a1 + 116) = 1;
    if ( *(_DWORD *)(a1 + 76) && *(_DWORD *)(a1 + 76) != 2 )
    {
      *(_DWORD *)(a1 + 140) = 4096;
      *(_DWORD *)(a1 + 144) = 2048;
    }
    else
    {
      *(_DWORD *)(a1 + 140) = 2048;
      *(_DWORD *)(a1 + 144) = 4096;
    }
  }
  if ( ++*(_DWORD *)(a1 + 104) > 4 )
    *(_BYTE *)a1 = 0;
  result = *(_DWORD *)(a1 + 76);
  switch ( result )
  {
    case 0:
      v2 = &v50 + 4 * *(_DWORD *)(a1 + 104);
      v3 = (int *)(a1 + 84);
      *v3 = *v2;
      v3[1] = v2[1];
      v3[2] = v2[2];
      result = v2[3];
      v3[3] = result;
      break;
    case 1:
      v4 = &v70 + 4 * *(_DWORD *)(a1 + 104);
      v5 = (int *)(a1 + 84);
      *v5 = *v4;
      v5[1] = v4[1];
      v5[2] = v4[2];
      result = v4[3];
      v5[3] = result;
      break;
    case 2:
      v6 = &v30 + 4 * *(_DWORD *)(a1 + 104);
      v7 = (int *)(a1 + 84);
      *v7 = *v6;
      v7[1] = v6[1];
      v7[2] = v6[2];
      result = v6[3];
      v7[3] = result;
      break;
    case 3:
      v8 = &v10 + 4 * *(_DWORD *)(a1 + 104);
      v9 = (int *)(a1 + 84);
      *v9 = *v8;
      v9[1] = v8[1];
      v9[2] = v8[2];
      result = v8[3];
      v9[3] = result;
      break;
    default:
      return result;
  }
  return result;
}

//----- (00440CF0) --------------------------------------------------------
int *__cdecl NPC129(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+0h] [ebp-120h]
  int v4; // [esp+4h] [ebp-11Ch]
  int v5; // [esp+8h] [ebp-118h]
  int v6; // [esp+Ch] [ebp-114h]
  int v7; // [esp+10h] [ebp-110h]
  int v8; // [esp+14h] [ebp-10Ch]
  int v9; // [esp+18h] [ebp-108h]
  int v10; // [esp+1Ch] [ebp-104h]
  int v11; // [esp+20h] [ebp-100h]
  int v12; // [esp+24h] [ebp-FCh]
  int v13; // [esp+28h] [ebp-F8h]
  int v14; // [esp+2Ch] [ebp-F4h]
  int v15; // [esp+30h] [ebp-F0h]
  int v16; // [esp+34h] [ebp-ECh]
  int v17; // [esp+38h] [ebp-E8h]
  int v18; // [esp+3Ch] [ebp-E4h]
  int v19; // [esp+40h] [ebp-E0h]
  int v20; // [esp+44h] [ebp-DCh]
  int v21; // [esp+48h] [ebp-D8h]
  int v22; // [esp+4Ch] [ebp-D4h]
  int v23; // [esp+50h] [ebp-D0h]
  int v24; // [esp+54h] [ebp-CCh]
  int v25; // [esp+58h] [ebp-C8h]
  int v26; // [esp+5Ch] [ebp-C4h]
  int v27; // [esp+60h] [ebp-C0h]
  int v28; // [esp+64h] [ebp-BCh]
  int v29; // [esp+68h] [ebp-B8h]
  int v30; // [esp+6Ch] [ebp-B4h]
  int v31; // [esp+70h] [ebp-B0h]
  int v32; // [esp+74h] [ebp-ACh]
  int v33; // [esp+78h] [ebp-A8h]
  int v34; // [esp+7Ch] [ebp-A4h]
  int v35; // [esp+80h] [ebp-A0h]
  int v36; // [esp+84h] [ebp-9Ch]
  int v37; // [esp+88h] [ebp-98h]
  int v38; // [esp+8Ch] [ebp-94h]
  int v39; // [esp+90h] [ebp-90h]
  int v40; // [esp+94h] [ebp-8Ch]
  int v41; // [esp+98h] [ebp-88h]
  int v42; // [esp+9Ch] [ebp-84h]
  int v43; // [esp+A0h] [ebp-80h]
  int v44; // [esp+A4h] [ebp-7Ch]
  int v45; // [esp+A8h] [ebp-78h]
  int v46; // [esp+ACh] [ebp-74h]
  int v47; // [esp+B0h] [ebp-70h]
  int v48; // [esp+B4h] [ebp-6Ch]
  int v49; // [esp+B8h] [ebp-68h]
  int v50; // [esp+BCh] [ebp-64h]
  int v51; // [esp+C0h] [ebp-60h]
  int v52; // [esp+C4h] [ebp-5Ch]
  int v53; // [esp+C8h] [ebp-58h]
  int v54; // [esp+CCh] [ebp-54h]
  int v55; // [esp+D0h] [ebp-50h]
  int v56; // [esp+D4h] [ebp-4Ch]
  int v57; // [esp+D8h] [ebp-48h]
  int v58; // [esp+DCh] [ebp-44h]
  int v59; // [esp+E0h] [ebp-40h]
  int v60; // [esp+E4h] [ebp-3Ch]
  int v61; // [esp+E8h] [ebp-38h]
  int v62; // [esp+ECh] [ebp-34h]
  int v63; // [esp+F0h] [ebp-30h]
  int v64; // [esp+F4h] [ebp-2Ch]
  int v65; // [esp+F8h] [ebp-28h]
  int v66; // [esp+FCh] [ebp-24h]
  int v67; // [esp+100h] [ebp-20h]
  int v68; // [esp+104h] [ebp-1Ch]
  int v69; // [esp+108h] [ebp-18h]
  int v70; // [esp+10Ch] [ebp-14h]
  int v71; // [esp+110h] [ebp-10h]
  int v72; // [esp+114h] [ebp-Ch]
  int v73; // [esp+118h] [ebp-8h]
  int v74; // [esp+11Ch] [ebp-4h]

  v3 = 128;
  v4 = 48;
  v5 = 144;
  v6 = 64;
  v7 = 144;
  v8 = 48;
  v9 = 160;
  v10 = 64;
  v11 = 160;
  v12 = 48;
  v13 = 176;
  v14 = 64;
  v15 = 128;
  v16 = 64;
  v17 = 144;
  v18 = 80;
  v19 = 144;
  v20 = 64;
  v21 = 160;
  v22 = 80;
  v23 = 160;
  v24 = 64;
  v25 = 176;
  v26 = 80;
  v27 = 128;
  v28 = 80;
  v29 = 144;
  v30 = 96;
  v31 = 144;
  v32 = 80;
  v33 = 160;
  v34 = 96;
  v35 = 160;
  v36 = 80;
  v37 = 176;
  v38 = 96;
  v39 = 176;
  v40 = 48;
  v41 = 192;
  v42 = 64;
  v43 = 192;
  v44 = 48;
  v45 = 208;
  v46 = 64;
  v47 = 208;
  v48 = 48;
  v49 = 224;
  v50 = 64;
  v51 = 176;
  v52 = 64;
  v53 = 192;
  v54 = 80;
  v55 = 192;
  v56 = 64;
  v57 = 208;
  v58 = 80;
  v59 = 208;
  v60 = 64;
  v61 = 224;
  v62 = 80;
  v63 = 176;
  v64 = 80;
  v65 = 192;
  v66 = 96;
  v67 = 192;
  v68 = 80;
  v69 = 208;
  v70 = 96;
  v71 = 208;
  v72 = 80;
  v73 = 224;
  v74 = 96;
  if ( ++*(_DWORD *)(a1 + 100) > 1 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    if ( ++*(_DWORD *)(a1 + 104) > 2 )
      *(_BYTE *)a1 = 0;
  }
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v1 = &v3 + 4 * (*(_DWORD *)(a1 + 104) + 3 * *(_DWORD *)(a1 + 76));
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (00441000) --------------------------------------------------------
int __cdecl NPC130(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+0h] [ebp-84h]
  int v5; // [esp+4h] [ebp-80h]
  int v6; // [esp+8h] [ebp-7Ch]
  int v7; // [esp+Ch] [ebp-78h]
  int v8; // [esp+10h] [ebp-74h]
  int v9; // [esp+14h] [ebp-70h]
  int v10; // [esp+18h] [ebp-6Ch]
  int v11; // [esp+1Ch] [ebp-68h]
  int v12; // [esp+20h] [ebp-64h]
  int v13; // [esp+24h] [ebp-60h]
  int v14; // [esp+28h] [ebp-5Ch]
  int v15; // [esp+2Ch] [ebp-58h]
  int v16; // [esp+30h] [ebp-54h]
  int v17; // [esp+34h] [ebp-50h]
  int v18; // [esp+38h] [ebp-4Ch]
  int v19; // [esp+3Ch] [ebp-48h]
  int v20; // [esp+40h] [ebp-44h]
  int v21; // [esp+44h] [ebp-40h]
  int v22; // [esp+48h] [ebp-3Ch]
  int v23; // [esp+4Ch] [ebp-38h]
  int v24; // [esp+50h] [ebp-34h]
  int v25; // [esp+54h] [ebp-30h]
  int v26; // [esp+58h] [ebp-2Ch]
  int v27; // [esp+5Ch] [ebp-28h]
  int v28; // [esp+60h] [ebp-24h]
  int v29; // [esp+64h] [ebp-20h]
  int v30; // [esp+68h] [ebp-1Ch]
  int v31; // [esp+6Ch] [ebp-18h]
  int v32; // [esp+70h] [ebp-14h]
  int v33; // [esp+74h] [ebp-10h]
  int v34; // [esp+78h] [ebp-Ch]
  int v35; // [esp+7Ch] [ebp-8h]
  int v36; // [esp+80h] [ebp-4h]

  v21 = 48;
  v22 = 144;
  v23 = 64;
  v24 = 160;
  v25 = 64;
  v26 = 144;
  v27 = 80;
  v28 = 160;
  v29 = 48;
  v30 = 144;
  v31 = 64;
  v32 = 160;
  v33 = 80;
  v34 = 144;
  v35 = 96;
  v36 = 160;
  v5 = 48;
  v6 = 160;
  v7 = 64;
  v8 = 176;
  v9 = 64;
  v10 = 160;
  v11 = 80;
  v12 = 176;
  v13 = 48;
  v14 = 160;
  v15 = 64;
  v16 = 176;
  v17 = 80;
  v18 = 160;
  v19 = 96;
  v20 = 176;
  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      if ( v4 == 2 && ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      goto LABEL_26;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 100) = 0;
    *(_WORD *)(a1 + 80) |= 0x2000u;
  }
  if ( random(0, 120) == 10 )
  {
    *(_DWORD *)(a1 + 116) = 2;
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 104) = 1;
  }
  if ( *(_DWORD *)(a1 + 8) - 0x8000 < quote.XPos
    && *(_DWORD *)(a1 + 8) + 0x8000 > quote.XPos
    && *(_DWORD *)(a1 + 12) - 0x4000 < quote.YPos
    && *(_DWORD *)(a1 + 12) + 0x2000 > quote.YPos )
  {
    if ( ++*(_DWORD *)(a1 + 100) > 3 )
    {
      *(_DWORD *)(a1 + 100) = 0;
      ++*(_DWORD *)(a1 + 104);
    }
    if ( *(_DWORD *)(a1 + 104) > 3 )
      *(_DWORD *)(a1 + 104) = 2;
  }
  if ( *(_DWORD *)(a1 + 8) - 49152 < quote.XPos
    && *(_DWORD *)(a1 + 8) + 49152 > quote.XPos
    && *(_DWORD *)(a1 + 12) - 0x4000 < quote.YPos
    && *(_DWORD *)(a1 + 12) + 0x2000 > quote.YPos )
  {
    if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
      *(_DWORD *)(a1 + 76) = 2;
    else
      *(_DWORD *)(a1 + 76) = 0;
  }
LABEL_26:
  *(_DWORD *)(a1 + 20) += 64;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v21 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (00441360) --------------------------------------------------------
int __cdecl NPC131(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+0h] [ebp-20h]
  int v5; // [esp+4h] [ebp-1Ch]
  int v6; // [esp+8h] [ebp-18h]
  int v7; // [esp+Ch] [ebp-14h]
  int v8; // [esp+10h] [ebp-10h]
  int v9; // [esp+14h] [ebp-Ch]
  int v10; // [esp+18h] [ebp-8h]
  int v11; // [esp+1Ch] [ebp-4h]

  v8 = 144;
  v9 = 144;
  v10 = 160;
  v11 = 160;
  v4 = 144;
  v5 = 160;
  v6 = 160;
  v7 = 176;
  if ( ++*(_DWORD *)(a1 + 120) > 100 )
  {
    *(_DWORD *)(a1 + 120) = 0;
    createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectZzZ, 0);
  }
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v8 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (00441440) --------------------------------------------------------
int *__cdecl NPC132(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+4h] [ebp-A0h]
  int v4; // [esp+8h] [ebp-9Ch]
  int v5; // [esp+Ch] [ebp-98h]
  int v6; // [esp+10h] [ebp-94h]
  int v7; // [esp+14h] [ebp-90h]
  int v8; // [esp+18h] [ebp-8Ch]
  int v9; // [esp+1Ch] [ebp-88h]
  int v10; // [esp+20h] [ebp-84h]
  int v11; // [esp+24h] [ebp-80h]
  int v12; // [esp+28h] [ebp-7Ch]
  int v13; // [esp+2Ch] [ebp-78h]
  int v14; // [esp+30h] [ebp-74h]
  int v15; // [esp+34h] [ebp-70h]
  int v16; // [esp+38h] [ebp-6Ch]
  int v17; // [esp+3Ch] [ebp-68h]
  int v18; // [esp+40h] [ebp-64h]
  int v19; // [esp+44h] [ebp-60h]
  int v20; // [esp+48h] [ebp-5Ch]
  int v21; // [esp+4Ch] [ebp-58h]
  int v22; // [esp+50h] [ebp-54h]
  int v23; // [esp+54h] [ebp-50h]
  int v24; // [esp+58h] [ebp-4Ch]
  int v25; // [esp+5Ch] [ebp-48h]
  int v26; // [esp+60h] [ebp-44h]
  int v27; // [esp+64h] [ebp-40h]
  int v28; // [esp+68h] [ebp-3Ch]
  int v29; // [esp+6Ch] [ebp-38h]
  int v30; // [esp+70h] [ebp-34h]
  int v31; // [esp+74h] [ebp-30h]
  int v32; // [esp+78h] [ebp-2Ch]
  int v33; // [esp+7Ch] [ebp-28h]
  int v34; // [esp+80h] [ebp-24h]
  int v35; // [esp+84h] [ebp-20h]
  int v36; // [esp+88h] [ebp-1Ch]
  int v37; // [esp+8Ch] [ebp-18h]
  int v38; // [esp+90h] [ebp-14h]
  int v39; // [esp+94h] [ebp-10h]
  int v40; // [esp+98h] [ebp-Ch]
  int v41; // [esp+9Ch] [ebp-8h]
  int v42; // [esp+A0h] [ebp-4h]

  v23 = 48;
  v24 = 144;
  v25 = 64;
  v26 = 160;
  v27 = 64;
  v28 = 144;
  v29 = 80;
  v30 = 160;
  v31 = 96;
  v32 = 144;
  v33 = 112;
  v34 = 160;
  v35 = 96;
  v36 = 144;
  v37 = 112;
  v38 = 160;
  v39 = 128;
  v40 = 144;
  v41 = 144;
  v42 = 160;
  v3 = 48;
  v4 = 160;
  v5 = 64;
  v6 = 176;
  v7 = 64;
  v8 = 160;
  v9 = 80;
  v10 = 176;
  v11 = 96;
  v12 = 160;
  v13 = 112;
  v14 = 176;
  v15 = 96;
  v16 = 160;
  v17 = 112;
  v18 = 176;
  v19 = 128;
  v20 = 160;
  v21 = 144;
  v22 = 176;
  if ( *(_DWORD *)(a1 + 116) < 100 )
  {
    if ( quote.XPos >= *(_DWORD *)(a1 + 8) )
      *(_DWORD *)(a1 + 76) = 2;
    else
      *(_DWORD *)(a1 + 76) = 0;
  }
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      goto LABEL_7;
    case 1:
LABEL_7:
      if ( random(0, 120) == 10 )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      if ( *(_DWORD *)(a1 + 8) - 0x8000 >= quote.XPos
        || *(_DWORD *)(a1 + 8) + 0x8000 <= quote.XPos
        || *(_DWORD *)(a1 + 12) - 0x2000 >= quote.YPos
        || *(_DWORD *)(a1 + 12) + 0x2000 <= quote.YPos )
      {
        if ( *(_DWORD *)(a1 + 104) == 4 )
          *(_DWORD *)(a1 + 104) = 2;
      }
      else
      {
        if ( ++*(_DWORD *)(a1 + 100) > 4 )
        {
          *(_DWORD *)(a1 + 100) = 0;
          ++*(_DWORD *)(a1 + 104);
        }
        if ( *(_DWORD *)(a1 + 104) > 4 )
          *(_DWORD *)(a1 + 104) = 2;
        if ( *(_DWORD *)(a1 + 104) == 4 && !*(_DWORD *)(a1 + 100) )
          playSoundEffect(SFXPuppyBark, 1);
      }
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      goto LABEL_28;
    case 0xB:
LABEL_28:
      if ( random(0, 120) == 10 )
      {
        *(_DWORD *)(a1 + 116) = 12;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      break;
    case 0xC:
      if ( ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 11;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    case 0x64:
      *(_DWORD *)(a1 + 116) = 101;
      *(_DWORD *)(a1 + 108) = 0;
      goto LABEL_35;
    case 0x65:
LABEL_35:
      if ( ++*(_DWORD *)(a1 + 100) > 4 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 4 )
      {
        if ( *(_DWORD *)(a1 + 108) >= 3 )
        {
          *(_DWORD *)(a1 + 104) = 0;
          *(_DWORD *)(a1 + 108) = 0;
        }
        else
        {
          *(_DWORD *)(a1 + 104) = 2;
          ++*(_DWORD *)(a1 + 108);
        }
      }
      if ( *(_DWORD *)(a1 + 104) == 4 && !*(_DWORD *)(a1 + 100) )
        playSoundEffect(SFXPuppyBark, 1);
      break;
    case 0x78:
      *(_DWORD *)(a1 + 104) = 0;
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 20) += 64;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v3 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v23 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (004419B0) --------------------------------------------------------
int *__cdecl NPC133(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+0h] [ebp-44h]
  int v4; // [esp+4h] [ebp-40h]
  int v5; // [esp+8h] [ebp-3Ch]
  int v6; // [esp+Ch] [ebp-38h]
  int v7; // [esp+10h] [ebp-34h]
  int v8; // [esp+14h] [ebp-30h]
  int v9; // [esp+18h] [ebp-2Ch]
  int v10; // [esp+1Ch] [ebp-28h]
  int v11; // [esp+20h] [ebp-24h]
  int v12; // [esp+24h] [ebp-20h]
  int v13; // [esp+28h] [ebp-1Ch]
  int v14; // [esp+2Ch] [ebp-18h]
  int v15; // [esp+30h] [ebp-14h]
  int v16; // [esp+34h] [ebp-10h]
  int v17; // [esp+38h] [ebp-Ch]
  int v18; // [esp+3Ch] [ebp-8h]
  int v19; // [esp+40h] [ebp-4h]

  v12 = 176;
  v13 = 32;
  v14 = 192;
  v15 = 48;
  v16 = 192;
  v17 = 32;
  v18 = 208;
  v19 = 48;
  v4 = 176;
  v5 = 48;
  v6 = 192;
  v7 = 64;
  v8 = 192;
  v9 = 48;
  v10 = 208;
  v11 = 64;
  v3 = *(_DWORD *)(a1 + 116);
  if ( v3 )
  {
    if ( v3 != 1 )
    {
      if ( v3 == 2 && ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      goto LABEL_11;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 100) = 0;
  }
  if ( random(0, 120) == 10 )
  {
    *(_DWORD *)(a1 + 116) = 2;
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 104) = 1;
  }
LABEL_11:
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v12 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (00441B20) --------------------------------------------------------
int *__cdecl NPC134(int a1)
{
  int v1; // edx
  int *v2; // edx
  int *result; // eax
  int v4; // [esp+4h] [ebp-60h]
  int v5; // [esp+8h] [ebp-5Ch]
  int v6; // [esp+Ch] [ebp-58h]
  int v7; // [esp+10h] [ebp-54h]
  int v8; // [esp+14h] [ebp-50h]
  int v9; // [esp+18h] [ebp-4Ch]
  int v10; // [esp+1Ch] [ebp-48h]
  int v11; // [esp+20h] [ebp-44h]
  int v12; // [esp+24h] [ebp-40h]
  int v13; // [esp+28h] [ebp-3Ch]
  int v14; // [esp+2Ch] [ebp-38h]
  int v15; // [esp+30h] [ebp-34h]
  int v16; // [esp+34h] [ebp-30h]
  int v17; // [esp+38h] [ebp-2Ch]
  int v18; // [esp+3Ch] [ebp-28h]
  int v19; // [esp+40h] [ebp-24h]
  int v20; // [esp+44h] [ebp-20h]
  int v21; // [esp+48h] [ebp-1Ch]
  int v22; // [esp+4Ch] [ebp-18h]
  int v23; // [esp+50h] [ebp-14h]
  int v24; // [esp+54h] [ebp-10h]
  int v25; // [esp+58h] [ebp-Ch]
  int v26; // [esp+5Ch] [ebp-8h]
  int v27; // [esp+60h] [ebp-4h]

  v16 = 224;
  v17 = 0;
  v18 = 256;
  v19 = 16;
  v20 = 256;
  v21 = 0;
  v22 = 288;
  v23 = 16;
  v24 = 288;
  v25 = 0;
  v26 = 320;
  v27 = 16;
  v4 = 224;
  v5 = 16;
  v6 = 256;
  v7 = 32;
  v8 = 256;
  v9 = 16;
  v10 = 288;
  v11 = 32;
  v12 = 288;
  v13 = 16;
  v14 = 320;
  v15 = 32;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 2;
      *(_WORD *)(a1 + 80) &= 0xFFDFu;
      *(_WORD *)(a1 + 80) |= 4u;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( quote.XPos > *(_DWORD *)(a1 + 8) - 163840
        && quote.XPos < *(_DWORD *)(a1 + 8) + 163840
        && quote.YPos > *(_DWORD *)(a1 + 12) - 81920
        && quote.YPos < *(_DWORD *)(a1 + 12) + 0x8000 )
      {
        *(_DWORD *)(a1 + 116) = 10;
        *(_WORD *)(a1 + 80) |= 0x20u;
        *(_WORD *)(a1 + 80) &= 0xFFFBu;
      }
      break;
    case 0xA:
      if ( ++*(_DWORD *)(a1 + 100) > 4 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 1 )
        *(_DWORD *)(a1 + 104) = 0;
      if ( !*(_DWORD *)(a1 + 76) && *(_DWORD *)(a1 + 4) & 1 )
        *(_DWORD *)(a1 + 76) = 2;
      if ( *(_DWORD *)(a1 + 76) == 2 && *(_DWORD *)(a1 + 4) & 4 )
        *(_DWORD *)(a1 + 76) = 0;
      if ( *(_DWORD *)(a1 + 76) )
        v1 = *(_DWORD *)(a1 + 8) + 256;
      else
        v1 = *(_DWORD *)(a1 + 8) - 256;
      *(_DWORD *)(a1 + 8) = v1;
      if ( countBullets(bulletPolarStarLevel3) )
      {
        *(_DWORD *)(a1 + 116) = 20;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 2;
        *(_WORD *)(a1 + 80) &= 0xFFDFu;
        *(_WORD *)(a1 + 80) |= 4u;
      }
      break;
    case 0x14:
      if ( ++*(_DWORD *)(a1 + 120) > 100 )
      {
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 100) = 0;
        *(_WORD *)(a1 + 80) |= 0x20u;
        *(_WORD *)(a1 + 80) &= 0xFFFBu;
      }
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 20) += 64;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v2 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v2 = &v16 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v2;
  result[1] = v2[1];
  result[2] = v2[2];
  result[3] = v2[3];
  return result;
}

//----- (00441EC0) --------------------------------------------------------
int __cdecl NPC135(int a1)
{
  int v1; // ecx
  int v2; // eax
  int Y_Vel; // ST24_4
  int *v4; // eax
  int *v5; // ecx
  int result; // eax
  int v7; // [esp+8h] [ebp-48h]
  int v8; // [esp+Ch] [ebp-44h]
  int v9; // [esp+10h] [ebp-40h]
  int v10; // [esp+14h] [ebp-3Ch]
  int v11; // [esp+18h] [ebp-38h]
  int v12; // [esp+1Ch] [ebp-34h]
  int v13; // [esp+20h] [ebp-30h]
  int v14; // [esp+24h] [ebp-2Ch]
  int X_Vel; // [esp+28h] [ebp-28h]
  int v16; // [esp+2Ch] [ebp-24h]
  int v17; // [esp+30h] [ebp-20h]
  int v18; // [esp+34h] [ebp-1Ch]
  int v19; // [esp+38h] [ebp-18h]
  int v20; // [esp+3Ch] [ebp-14h]
  int v21; // [esp+40h] [ebp-10h]
  int v22; // [esp+44h] [ebp-Ch]
  int v23; // [esp+48h] [ebp-8h]
  unsigned __int8 v24; // [esp+4Fh] [ebp-1h]

  v16 = 256;
  v17 = 32;
  v18 = 288;
  v19 = 64;
  v20 = 288;
  v21 = 32;
  v22 = 320;
  v23 = 64;
  v7 = 256;
  v8 = 64;
  v9 = 288;
  v10 = 96;
  v11 = 288;
  v12 = 64;
  v13 = 320;
  v14 = 96;
  if ( quote.XPos < *(_DWORD *)(a1 + 8) - 180224
    || quote.XPos > *(_DWORD *)(a1 + 8) + 180224
    || quote.YPos < *(_DWORD *)(a1 + 12) - 81920
    || quote.YPos > *(_DWORD *)(a1 + 12) + 0x8000 )
  {
    *(_DWORD *)(a1 + 116) = 0;
  }
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 16) = 0;
      goto LABEL_8;
    case 1:
LABEL_8:
      if ( quote.XPos > *(_DWORD *)(a1 + 8) - 163840
        && quote.XPos < *(_DWORD *)(a1 + 8) + 163840
        && quote.YPos > *(_DWORD *)(a1 + 12) - 81920
        && quote.YPos < *(_DWORD *)(a1 + 12) + 0x8000 )
      {
        *(_DWORD *)(a1 + 116) = 10;
      }
      if ( *(_DWORD *)(a1 + 4) & 8 )
        *(_DWORD *)(a1 + 104) = 0;
      break;
    case 0xA:
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 104) = 0;
      goto LABEL_17;
    case 0xB:
LABEL_17:
      if ( ++*(_DWORD *)(a1 + 120) >= 5 && *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 116) = 20;
        *(_DWORD *)(a1 + 104) = 1;
        *(_DWORD *)(a1 + 108) = 0;
        *(_DWORD *)(a1 + 20) = -512 * random(1, 3);
        if ( *(_BYTE *)(a1 + 156) )
        {
          if ( *(_DWORD *)(a1 + 8) >= quote.XPos )
            v1 = *(_DWORD *)(a1 + 16) + 256;
          else
            v1 = *(_DWORD *)(a1 + 16) - 256;
          *(_DWORD *)(a1 + 16) = v1;
        }
        else
        {
          if ( *(_DWORD *)(a1 + 8) >= quote.XPos )
            v2 = *(_DWORD *)(a1 + 16) - 256;
          else
            v2 = *(_DWORD *)(a1 + 16) + 256;
          *(_DWORD *)(a1 + 16) = v2;
        }
      }
      break;
    case 0x14:
      if ( *(_DWORD *)(a1 + 20) > 0 && !*(_DWORD *)(a1 + 108) )
      {
        ++*(_DWORD *)(a1 + 108);
        v24 = getArcTan(*(_DWORD *)(a1 + 8) - quote.XPos, *(_DWORD *)(a1 + 12) + 2048 - quote.YPos);
        Y_Vel = 2 * getSin(v24);
        X_Vel = 2 * getCos(v24);
        createNPC((NPCNames)50, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), X_Vel, Y_Vel, 0, 0, 384);
        playSoundEffect(SFXEnemyShootProjectile, 1);
      }
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 116) >= 10 )
  {
    if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
      *(_DWORD *)(a1 + 76) = 2;
    else
      *(_DWORD *)(a1 + 76) = 0;
  }
  *(_DWORD *)(a1 + 20) += 51;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  if ( *(_DWORD *)(a1 + 16) > 1535 )
    *(_DWORD *)(a1 + 16) = 1535;
  if ( *(_DWORD *)(a1 + 16) < -1535 )
    *(_DWORD *)(a1 + 16) = -1535;
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  if ( *(_DWORD *)(a1 + 76) )
    v4 = &v7 + 4 * *(_DWORD *)(a1 + 104);
  else
    v4 = &v16 + 4 * *(_DWORD *)(a1 + 104);
  v5 = (int *)(a1 + 84);
  *v5 = *v4;
  v5[1] = v4[1];
  v5[2] = v4[2];
  result = v4[3];
  v5[3] = result;
  return result;
}

//----- (00442340) --------------------------------------------------------
int *__cdecl NPC136(int a1)
{
  int *v1; // edx
  int *result; // eax
  int *v3; // ecx
  int *v4; // edx
  int v5; // [esp+0h] [ebp-44h]
  int v6; // [esp+4h] [ebp-40h]
  int v7; // [esp+8h] [ebp-3Ch]
  int v8; // [esp+Ch] [ebp-38h]
  int v9; // [esp+10h] [ebp-34h]
  int v10; // [esp+14h] [ebp-30h]
  int v11; // [esp+18h] [ebp-2Ch]
  int v12; // [esp+1Ch] [ebp-28h]
  int v13; // [esp+20h] [ebp-24h]
  int v14; // [esp+24h] [ebp-20h]
  int v15; // [esp+28h] [ebp-1Ch]
  int v16; // [esp+2Ch] [ebp-18h]
  int v17; // [esp+30h] [ebp-14h]
  int v18; // [esp+34h] [ebp-10h]
  int v19; // [esp+38h] [ebp-Ch]
  int v20; // [esp+3Ch] [ebp-8h]
  int v21; // [esp+40h] [ebp-4h]

  v14 = 48;
  v15 = 144;
  v16 = 64;
  v17 = 160;
  v18 = 64;
  v19 = 144;
  v20 = 80;
  v21 = 160;
  v6 = 48;
  v7 = 160;
  v8 = 64;
  v9 = 176;
  v10 = 64;
  v11 = 160;
  v12 = 80;
  v13 = 176;
  v5 = *(_DWORD *)(a1 + 116);
  if ( v5 )
  {
    if ( v5 != 1 )
    {
      if ( v5 == 2 && ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      goto LABEL_11;
    }
  }
  else
  {
    *(_WORD *)(a1 + 80) &= 0xDFFFu;
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 100) = 0;
  }
  if ( random(0, 120) == 10 )
  {
    *(_DWORD *)(a1 + 116) = 2;
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 104) = 1;
  }
LABEL_11:
  if ( quote.direction )
    *(_DWORD *)(a1 + 76) = 2;
  else
    *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 12) = quote.YPos - 5120;
  if ( *(_DWORD *)(a1 + 76) )
  {
    *(_DWORD *)(a1 + 8) = quote.XPos - 2048;
    v3 = &v6 + 4 * *(_DWORD *)(a1 + 104);
    v4 = (int *)(a1 + 84);
    *v4 = *v3;
    v4[1] = v3[1];
    result = (int *)v3[2];
    v4[2] = (int)result;
    v4[3] = v3[3];
  }
  else
  {
    *(_DWORD *)(a1 + 8) = quote.XPos + 2048;
    v1 = &v14 + 4 * *(_DWORD *)(a1 + 104);
    result = (int *)(a1 + 84);
    *result = *v1;
    result[1] = v1[1];
    result[2] = v1[2];
    result[3] = v1[3];
  }
  if ( quote.animationNumber % 2 )
  {
    result = (int *)a1;
    ++*(_DWORD *)(a1 + 88);
  }
  return result;
}

//----- (00442540) --------------------------------------------------------
_DWORD *__cdecl NPC137(int a1)
{
  _DWORD *result; // eax

  result = (_DWORD *)(a1 + 84);
  *result = 96;
  result[1] = 136;
  result[2] = 128;
  result[3] = 188;
  return result;
}

//----- (00442590) --------------------------------------------------------
int __cdecl NPC138(int a1)
{
  int result; // eax
  _DWORD *v2; // ecx
  int v3; // edx
  _DWORD *v4; // ecx
  _DWORD *v5; // ecx
  _DWORD *v6; // eax
  int v7; // [esp+0h] [ebp-24h]

  result = a1;
  v7 = *(_DWORD *)(a1 + 116);
  if ( v7 )
  {
    if ( v7 == 10 )
    {
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 104) = 1;
      *(_DWORD *)(a1 + 120) = 0;
      *(_WORD *)(a1 + 80) |= 8u;
    }
    else if ( v7 != 11 )
    {
      return result;
    }
    if ( !(++*(_DWORD *)(a1 + 120) % 8) )
      playSoundEffect(SFXLargeObjectHitGround, 1);
    if ( *(_DWORD *)(a1 + 76) )
    {
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 32) + (*(_DWORD *)(a1 + 120) / 8 << 9);
      v6 = (_DWORD *)(a1 + 84);
      *v6 = 112;
      v6[1] = 112;
      v6[2] = 128;
      v6[3] = 136;
      result = a1;
      *(_DWORD *)(a1 + 92) -= *(_DWORD *)(a1 + 120) / 8;
    }
    else
    {
      v5 = (_DWORD *)(a1 + 84);
      *v5 = 96;
      v5[1] = 112;
      v5[2] = 112;
      v5[3] = 136;
      result = *(_DWORD *)(a1 + 84) + *(_DWORD *)(a1 + 120) / 8;
      *(_DWORD *)(a1 + 84) = result;
    }
    if ( *(_DWORD *)(a1 + 120) == 104 )
      *(_BYTE *)a1 = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    if ( *(_DWORD *)(a1 + 76) )
    {
      v4 = (_DWORD *)(a1 + 84);
      *v4 = 112;
      v4[1] = 112;
      v4[2] = 128;
      v4[3] = 136;
      v3 = *(_DWORD *)(a1 + 8) - 4096;
    }
    else
    {
      v2 = (_DWORD *)(a1 + 84);
      *v2 = 96;
      v2[1] = 112;
      v2[2] = 112;
      v2[3] = 136;
      v3 = *(_DWORD *)(a1 + 8) + 4096;
    }
    *(_DWORD *)(a1 + 8) = v3;
    result = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 32) = result;
  }
  return result;
}

//----- (00442790) --------------------------------------------------------
int __cdecl NPC139(int a1)
{
  int v1; // edx
  int *v2; // eax
  int *v3; // ecx
  int result; // eax
  int v5; // [esp+4h] [ebp-60h]
  int v6; // [esp+8h] [ebp-5Ch]
  int v7; // [esp+Ch] [ebp-58h]
  int v8; // [esp+10h] [ebp-54h]
  int v9; // [esp+14h] [ebp-50h]
  int v10; // [esp+18h] [ebp-4Ch]
  int v11; // [esp+1Ch] [ebp-48h]
  int v12; // [esp+20h] [ebp-44h]
  int v13; // [esp+24h] [ebp-40h]
  int v14; // [esp+28h] [ebp-3Ch]
  int v15; // [esp+2Ch] [ebp-38h]
  int v16; // [esp+30h] [ebp-34h]
  int v17; // [esp+34h] [ebp-30h]
  int v18; // [esp+38h] [ebp-2Ch]
  int v19; // [esp+3Ch] [ebp-28h]
  int v20; // [esp+40h] [ebp-24h]
  int v21; // [esp+44h] [ebp-20h]
  int v22; // [esp+48h] [ebp-1Ch]
  int v23; // [esp+4Ch] [ebp-18h]
  int v24; // [esp+50h] [ebp-14h]
  int v25; // [esp+54h] [ebp-10h]
  int v26; // [esp+58h] [ebp-Ch]
  int v27; // [esp+5Ch] [ebp-8h]
  int v28; // [esp+60h] [ebp-4h]

  v17 = 0;
  v18 = 128;
  v19 = 24;
  v20 = 160;
  v21 = 24;
  v22 = 128;
  v23 = 48;
  v24 = 160;
  v25 = 48;
  v26 = 128;
  v27 = 72;
  v28 = 160;
  v5 = 0;
  v6 = 160;
  v7 = 24;
  v8 = 192;
  v9 = 24;
  v10 = 160;
  v11 = 48;
  v12 = 192;
  v13 = 48;
  v14 = 160;
  v15 = 72;
  v16 = 192;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 20) = 0;
      *(_DWORD *)(a1 + 12) -= 4096;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( *(_DWORD *)(a1 + 4) & 8 )
        *(_DWORD *)(a1 + 104) = 0;
      else
        *(_DWORD *)(a1 + 104) = 2;
      *(_DWORD *)(a1 + 20) += 64;
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 104) = 1;
      *(_DWORD *)(a1 + 100) = 0;
      *(_DWORD *)(a1 + 108) = 0;
      goto LABEL_8;
    case 0xB:
LABEL_8:
      if ( ++*(_DWORD *)(a1 + 100) > 6 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 1 )
      {
        *(_DWORD *)(a1 + 104) = 0;
        ++*(_DWORD *)(a1 + 108);
      }
      if ( *(_DWORD *)(a1 + 108) > 8 )
      {
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 116) = 1;
      }
      break;
    case 0x14:
      *(_DWORD *)(a1 + 116) = 21;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 104) = 2;
      *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 12) - 0x4000;
      goto LABEL_16;
    case 0x15:
LABEL_16:
      if ( *(_DWORD *)(a1 + 12) >= *(_DWORD *)(a1 + 36) )
        v1 = *(_DWORD *)(a1 + 20) - 32;
      else
        v1 = *(_DWORD *)(a1 + 20) + 32;
      *(_DWORD *)(a1 + 20) = v1;
      if ( *(_DWORD *)(a1 + 20) > 512 )
        *(_DWORD *)(a1 + 20) = 512;
      if ( *(_DWORD *)(a1 + 20) < -512 )
        *(_DWORD *)(a1 + 20) = -512;
      break;
    case 0x1E:
      *(_DWORD *)(a1 + 116) = 31;
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 20) = 0;
      *(_DWORD *)(a1 + 120) = 2 * (*(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 88));
      playSoundEffect(SFXTeleport, 1);
      goto LABEL_25;
    case 0x1F:
LABEL_25:
      --*(_DWORD *)(a1 + 120);
      *(_DWORD *)(a1 + 104) = 0;
      if ( !*(_DWORD *)(a1 + 120) )
        *(_BYTE *)a1 = 0;
      break;
    case 0x28:
      *(_DWORD *)(a1 + 116) = 41;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 20) = 0;
      playSoundEffect(SFXTeleport, 1);
      goto LABEL_29;
    case 0x29:
LABEL_29:
      *(_DWORD *)(a1 + 104) = 2;
      if ( ++*(_DWORD *)(a1 + 120) >= 64 )
        *(_DWORD *)(a1 + 116) = 20;
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v2 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  else
    v2 = &v17 + 4 * *(_DWORD *)(a1 + 104);
  v3 = (int *)(a1 + 84);
  *v3 = *v2;
  v3[1] = v2[1];
  v3[2] = v2[2];
  result = v2[3];
  v3[3] = result;
  if ( *(_DWORD *)(a1 + 116) == 31 || *(_DWORD *)(a1 + 116) == 41 )
  {
    *(_DWORD *)(a1 + 96) = *(_DWORD *)(a1 + 88) + *(_DWORD *)(a1 + 120) / 2;
    result = *(_DWORD *)(a1 + 120) / 2 % 2;
    if ( result )
    {
      result = a1;
      ++*(_DWORD *)(a1 + 84);
    }
  }
  return result;
}

//----- (00442BF0) --------------------------------------------------------
void __cdecl NPC140(NPC *npc)
{
  int v1; // ST10_4
  int v2; // ST0C_4
  int v3; // ST08_4
  int v4; // eax
  int v5; // ST10_4
  int v6; // ST0C_4
  int v7; // ST08_4
  int v8; // eax
  int v9; // ST10_4
  int v10; // ST0C_4
  int v11; // ST08_4
  int v12; // eax
  int *v13; // edx
  RECT *v14; // eax
  int v15; // [esp+4h] [ebp-1C8h]
  int v16; // [esp+8h] [ebp-1C4h]
  int v17; // [esp+Ch] [ebp-1C0h]
  int v18; // [esp+10h] [ebp-1BCh]
  int v19; // [esp+14h] [ebp-1B8h]
  int v20; // [esp+18h] [ebp-1B4h]
  int v21; // [esp+1Ch] [ebp-1B0h]
  int v22; // [esp+20h] [ebp-1ACh]
  int v23; // [esp+24h] [ebp-1A8h]
  int v24; // [esp+28h] [ebp-1A4h]
  int v25; // [esp+2Ch] [ebp-1A0h]
  int v26; // [esp+30h] [ebp-19Ch]
  int v27; // [esp+34h] [ebp-198h]
  int v28; // [esp+38h] [ebp-194h]
  int v29; // [esp+3Ch] [ebp-190h]
  int v30; // [esp+40h] [ebp-18Ch]
  int v31; // [esp+44h] [ebp-188h]
  int v32; // [esp+48h] [ebp-184h]
  int v33; // [esp+4Ch] [ebp-180h]
  int v34; // [esp+50h] [ebp-17Ch]
  int v35; // [esp+54h] [ebp-178h]
  int v36; // [esp+58h] [ebp-174h]
  int v37; // [esp+5Ch] [ebp-170h]
  int v38; // [esp+60h] [ebp-16Ch]
  int v39; // [esp+64h] [ebp-168h]
  int v40; // [esp+68h] [ebp-164h]
  int v41; // [esp+6Ch] [ebp-160h]
  int v42; // [esp+70h] [ebp-15Ch]
  int v43; // [esp+74h] [ebp-158h]
  int v44; // [esp+78h] [ebp-154h]
  int v45; // [esp+7Ch] [ebp-150h]
  int v46; // [esp+80h] [ebp-14Ch]
  int v47; // [esp+84h] [ebp-148h]
  int v48; // [esp+88h] [ebp-144h]
  int v49; // [esp+8Ch] [ebp-140h]
  int v50; // [esp+90h] [ebp-13Ch]
  int v51; // [esp+94h] [ebp-138h]
  int v52; // [esp+98h] [ebp-134h]
  int v53; // [esp+9Ch] [ebp-130h]
  int v54; // [esp+A0h] [ebp-12Ch]
  int v55; // [esp+A4h] [ebp-128h]
  int v56; // [esp+A8h] [ebp-124h]
  int v57; // [esp+ACh] [ebp-120h]
  int v58; // [esp+B0h] [ebp-11Ch]
  int v59; // [esp+B4h] [ebp-118h]
  int v60; // [esp+B8h] [ebp-114h]
  int v61; // [esp+BCh] [ebp-110h]
  int v62; // [esp+C0h] [ebp-10Ch]
  int v63; // [esp+C4h] [ebp-108h]
  int v64; // [esp+C8h] [ebp-104h]
  int v65; // [esp+CCh] [ebp-100h]
  int v66; // [esp+D0h] [ebp-FCh]
  int v67; // [esp+D4h] [ebp-F8h]
  int v68; // [esp+D8h] [ebp-F4h]
  int v69; // [esp+DCh] [ebp-F0h]
  int v70; // [esp+E0h] [ebp-ECh]
  int i; // [esp+E8h] [ebp-E4h]
  int v72; // [esp+ECh] [ebp-E0h]
  int v73; // [esp+F0h] [ebp-DCh]
  int v74; // [esp+F4h] [ebp-D8h]
  int v75; // [esp+F8h] [ebp-D4h]
  int v76; // [esp+FCh] [ebp-D0h]
  int v77; // [esp+100h] [ebp-CCh]
  int v78; // [esp+104h] [ebp-C8h]
  int v79; // [esp+108h] [ebp-C4h]
  int v80; // [esp+10Ch] [ebp-C0h]
  int v81; // [esp+110h] [ebp-BCh]
  int v82; // [esp+114h] [ebp-B8h]
  int v83; // [esp+118h] [ebp-B4h]
  int v84; // [esp+11Ch] [ebp-B0h]
  int v85; // [esp+120h] [ebp-ACh]
  int v86; // [esp+124h] [ebp-A8h]
  int v87; // [esp+128h] [ebp-A4h]
  int v88; // [esp+12Ch] [ebp-A0h]
  int v89; // [esp+130h] [ebp-9Ch]
  int v90; // [esp+134h] [ebp-98h]
  int v91; // [esp+138h] [ebp-94h]
  int v92; // [esp+13Ch] [ebp-90h]
  int v93; // [esp+140h] [ebp-8Ch]
  int v94; // [esp+144h] [ebp-88h]
  int v95; // [esp+148h] [ebp-84h]
  int v96; // [esp+14Ch] [ebp-80h]
  int v97; // [esp+150h] [ebp-7Ch]
  int v98; // [esp+154h] [ebp-78h]
  int v99; // [esp+158h] [ebp-74h]
  int v100; // [esp+15Ch] [ebp-70h]
  int v101; // [esp+160h] [ebp-6Ch]
  int v102; // [esp+164h] [ebp-68h]
  int v103; // [esp+168h] [ebp-64h]
  int v104; // [esp+16Ch] [ebp-60h]
  int v105; // [esp+170h] [ebp-5Ch]
  int v106; // [esp+174h] [ebp-58h]
  int v107; // [esp+178h] [ebp-54h]
  int v108; // [esp+17Ch] [ebp-50h]
  int v109; // [esp+180h] [ebp-4Ch]
  int v110; // [esp+184h] [ebp-48h]
  int v111; // [esp+188h] [ebp-44h]
  int v112; // [esp+18Ch] [ebp-40h]
  int v113; // [esp+190h] [ebp-3Ch]
  int v114; // [esp+194h] [ebp-38h]
  int v115; // [esp+198h] [ebp-34h]
  int v116; // [esp+19Ch] [ebp-30h]
  int v117; // [esp+1A0h] [ebp-2Ch]
  int v118; // [esp+1A4h] [ebp-28h]
  int v119; // [esp+1A8h] [ebp-24h]
  int v120; // [esp+1ACh] [ebp-20h]
  int v121; // [esp+1B0h] [ebp-1Ch]
  int v122; // [esp+1B4h] [ebp-18h]
  int v123; // [esp+1B8h] [ebp-14h]
  int v124; // [esp+1BCh] [ebp-10h]
  int v125; // [esp+1C0h] [ebp-Ch]
  int v126; // [esp+1C4h] [ebp-8h]
  int v127; // [esp+1C8h] [ebp-4h]

  v72 = 0;
  v73 = 0;
  v74 = 32;
  v75 = 32;
  v76 = 32;
  v77 = 0;
  v78 = 64;
  v79 = 32;
  v80 = 64;
  v81 = 0;
  v82 = 96;
  v83 = 32;
  v84 = 96;
  v85 = 0;
  v86 = 128;
  v87 = 32;
  v88 = 128;
  v89 = 0;
  v90 = 160;
  v91 = 32;
  v92 = 160;
  v93 = 0;
  v94 = 192;
  v95 = 32;
  v96 = 192;
  v97 = 0;
  v98 = 224;
  v99 = 32;
  v100 = 224;
  v101 = 0;
  v102 = 256;
  v103 = 32;
  v104 = 0;
  v105 = 64;
  v106 = 32;
  v107 = 96;
  v108 = 32;
  v109 = 64;
  v110 = 64;
  v111 = 96;
  v112 = 64;
  v113 = 64;
  v114 = 96;
  v115 = 96;
  v116 = 96;
  v117 = 64;
  v118 = 128;
  v119 = 96;
  v120 = 128;
  v121 = 64;
  v122 = 160;
  v123 = 96;
  v124 = 0;
  v125 = 0;
  v126 = 0;
  v127 = 0;
  v15 = 0;
  v16 = 32;
  v17 = 32;
  v18 = 64;
  v19 = 32;
  v20 = 32;
  v21 = 64;
  v22 = 64;
  v23 = 64;
  v24 = 32;
  v25 = 96;
  v26 = 64;
  v27 = 96;
  v28 = 32;
  v29 = 128;
  v30 = 64;
  v31 = 128;
  v32 = 32;
  v33 = 160;
  v34 = 64;
  v35 = 160;
  v36 = 32;
  v37 = 192;
  v38 = 64;
  v39 = 192;
  v40 = 32;
  v41 = 224;
  v42 = 64;
  v43 = 224;
  v44 = 32;
  v45 = 256;
  v46 = 64;
  v47 = 0;
  v48 = 96;
  v49 = 32;
  v50 = 128;
  v51 = 32;
  v52 = 96;
  v53 = 64;
  v54 = 128;
  v55 = 64;
  v56 = 96;
  v57 = 96;
  v58 = 128;
  v59 = 96;
  v60 = 96;
  v61 = 128;
  v62 = 128;
  v63 = 128;
  v64 = 96;
  v65 = 160;
  v66 = 128;
  v67 = 0;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  switch ( npc->currentState )
  {
    case 0:
      npc->currentState = 1;
      npc->animationNumber = 9;
      npc->waitTimer = 0;
      npc->entityFlags &= 0xDFFFu;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( ++npc->waitTimer > 50 )
      {
        npc->currentState = 2;
        npc->waitTimer = 0;
        npc->animationNumber = 8;
      }
      break;
    case 2:
      if ( ++npc->animationNumber > 10 )
        npc->animationNumber = 9;
      if ( ++npc->waitTimer > 50 )
      {
        npc->currentState = 3;
        npc->waitTimer = 0;
        npc->animationNumber = 0;
      }
      break;
    case 3:
      if ( ++npc->waitTimer > 50 )
      {
        npc->currentState = 10;
        npc->entityFlags |= 0x20u;
      }
      break;
    case 0xA:
      npc->entityFlags = npc->entityFlags;
      npc->currentState = 11;
      npc->animationNumber = 0;
      npc->animationTimer = 0;
      npc->waitTimer = random(20, 130);
      npc->XVel = 0;
      goto LABEL_15;
    case 0xB:
LABEL_15:
      if ( npc->XPos <= quote.XPos )
        npc->direction = 2;
      else
        npc->direction = 0;
      if ( ++npc->animationTimer > 4 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 1 )
        npc->animationNumber = 0;
      if ( countBullets(bulletPolarStarLevel3) || countBullets(bulletSnakeLevel3) > 3 )
        npc->currentState = 20;
      if ( npc->waitTimer )
      {
        --npc->waitTimer;
      }
      else if ( random(0, 99) % 2 )
      {
        npc->currentState = 20;
      }
      else
      {
        npc->currentState = 50;
      }
      break;
    case 0x14:
      npc->currentState = 21;
      npc->animationNumber = 2;
      npc->waitTimer = 0;
      goto LABEL_32;
    case 0x15:
LABEL_32:
      if ( ++npc->waitTimer > 10 )
      {
        npc->currentState = 22;
        npc->waitTimer = 0;
        npc->animationNumber = 3;
        npc->YVel = -1535;
        if ( npc->direction )
          npc->XVel = 512;
        else
          npc->XVel = -512;
      }
      break;
    case 0x16:
      if ( ++npc->waitTimer > 10 )
      {
        npc->currentState = 23;
        npc->waitTimer = 0;
        npc->animationNumber = 6;
        createNPC(NPCForcefield|0x80, 0, 0, 0, 0, 0, npc, 0);
      }
      break;
    case 0x17:
      if ( ++npc->waitTimer > 30 )
      {
        npc->currentState = 24;
        npc->waitTimer = 0;
        npc->animationNumber = 7;
      }
      if ( npc->XPos <= quote.XPos )
        npc->direction = 2;
      else
        npc->direction = 0;
      break;
    case 0x18:
      if ( ++npc->waitTimer > 3 )
      {
        npc->currentState = 25;
        npc->animationNumber = 3;
      }
      break;
    case 0x19:
      if ( npc->collisionFlags & 8 )
      {
        npc->currentState = 26;
        npc->waitTimer = 0;
        npc->animationNumber = 2;
        playSoundEffect(SFXLargeObjectHitGround, 1);
        setQuake(20);
      }
      break;
    case 0x1A:
      npc->XVel = 8 * npc->XVel / 9;
      if ( ++npc->waitTimer > 20 )
      {
        npc->currentState = 10;
        npc->animationNumber = 0;
      }
      break;
    case 0x32:
      npc->currentState = 51;
      npc->waitTimer = 0;
      npc->animationNumber = 4;
      createNPC(NPCForcefield|0x80, 0, 0, 0, 0, 0, npc, 0);
      goto LABEL_56;
    case 0x33:
LABEL_56:
      if ( ++npc->waitTimer > 30 )
      {
        npc->currentState = 52;
        npc->waitTimer = 0;
        npc->animationNumber = 5;
      }
      if ( npc->XPos <= quote.XPos )
        npc->direction = 2;
      else
        npc->direction = 0;
      break;
    case 0x34:
      if ( ++npc->waitTimer > 3 )
      {
        npc->currentState = 10;
        npc->animationNumber = 0;
      }
      break;
    case 0x64:
      npc->animationNumber = 3;
      npc->currentState = 101;
      npc->entityFlags &= 0xFFDFu;
      npc->damage = 0;
      for ( i = 0; i < 8; ++i )
      {
        v1 = random(-1536, 0);
        v2 = random(-341, 341);
        v3 = npc->YPos + (random(-12, 12) << 9);
        v4 = random(-12, 12);
        createNPC(NPCSmoke, npc->XPos + (v4 << 9), v3, v2, v1, 0, 0, 256);
      }
      break;
    case 0x65:
      if ( npc->collisionFlags & 8 )
      {
        npc->currentState = 102;
        npc->waitTimer = 0;
        npc->animationNumber = 2;
        playSoundEffect(SFXLargeObjectHitGround, 1);
        setQuake(20);
      }
      break;
    case 0x66:
      npc->XVel = 8 * npc->XVel / 9;
      if ( ++npc->waitTimer > 50 )
      {
        npc->currentState = 103;
        npc->waitTimer = 0;
        npc->animationNumber = 10;
      }
      break;
    case 0x67:
      if ( ++npc->waitTimer > 50 )
      {
        npc->animationNumber = 9;
        npc->currentState = 104;
        npc->waitTimer = 0;
      }
      break;
    case 0x68:
      if ( ++npc->animationNumber > 10 )
        npc->animationNumber = 9;
      if ( ++npc->waitTimer > 100 )
      {
        npc->waitTimer = 0;
        npc->animationNumber = 9;
        npc->currentState = 105;
      }
      break;
    case 0x69:
      if ( ++npc->waitTimer > 50 )
      {
        npc->animationTimer = 0;
        npc->currentState = 106;
        npc->animationNumber = 11;
      }
      break;
    case 0x6A:
      if ( ++npc->animationTimer > 50 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 12 )
        npc->animationNumber = 12;
      break;
    case 0x8C:
      npc->currentState = 141;
      npc->waitTimer = 0;
      npc->animationNumber = 12;
      playSoundEffect(SFXTeleport, 1);
      goto LABEL_92;
    case 0x8D:
LABEL_92:
      if ( ++npc->animationNumber > 13 )
        npc->animationNumber = 12;
      if ( ++npc->waitTimer > 100 )
      {
        for ( i = 0; i < 4; ++i )
        {
          v5 = random(-1536, 0);
          v6 = random(-341, 341);
          v7 = npc->YPos + (random(-12, 12) << 9);
          v8 = random(-12, 12);
          createNPC(NPCSmoke, npc->XPos + (v8 << 9), v7, v6, v5, 0, 0, 256);
        }
        npc->isAlive = 0;
      }
      break;
    default:
      break;
  }
  if ( npc->currentState > 100 && npc->currentState < 105 && !(npc->waitTimer % 9) )
  {
    v9 = random(-1536, 0);
    v10 = random(-341, 341);
    v11 = npc->YPos + (random(-12, 12) << 9);
    v12 = random(-12, 12);
    createNPC(NPCSmoke, npc->XPos + (v12 << 9), v11, v10, v9, 0, 0, 256);
  }
  npc->YVel += 32;
  if ( npc->YVel > 1535 )
    npc->YVel = 1535;
  if ( npc->YVel < -1535 )
    npc->YVel = -1535;
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  if ( npc->direction )
    v13 = &v15 + 4 * npc->animationNumber;
  else
    v13 = &v72 + 4 * npc->animationNumber;
  v14 = &npc->rect;
  v14->left = *v13;
  v14->top = v13[1];
  v14->right = v13[2];
  v14->bottom = v13[3];
}

//----- (00443AC0) --------------------------------------------------------
int __cdecl NPC141(int a1)
{
  int v1; // ST10_4
  int v2; // eax
  int v3; // ST10_4
  int v4; // eax
  int *v5; // ecx
  int *v6; // edx
  int result; // eax
  signed int i; // [esp+4h] [ebp-28h]
  signed int ia; // [esp+4h] [ebp-28h]
  int v10; // [esp+8h] [ebp-24h]
  int v11; // [esp+Ch] [ebp-20h]
  int v12; // [esp+10h] [ebp-1Ch]
  int v13; // [esp+14h] [ebp-18h]
  int v14; // [esp+18h] [ebp-14h]
  int v15; // [esp+1Ch] [ebp-10h]
  int v16; // [esp+20h] [ebp-Ch]
  int v17; // [esp+24h] [ebp-8h]
  unsigned __int8 v18; // [esp+2Bh] [ebp-1h]

  v10 = 288;
  v11 = 32;
  v12 = 304;
  v13 = 48;
  v14 = 304;
  v15 = 32;
  v16 = 320;
  v17 = 48;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 120) = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 76) )
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) - 5120;
      else
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) + 5120;
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12) - 4096;
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 116) == 24 || *(_DWORD *)(*(_DWORD *)(a1 + 168) + 116) == 52 )
      {
        *(_DWORD *)(a1 + 116) = 10;
        if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 76) )
          *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) + 0x2000;
        else
          *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) - 0x2000;
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12);
        v18 = getArcTan(*(_DWORD *)(a1 + 8) - quote.XPos, *(_DWORD *)(a1 + 12) - quote.YPos);
        *(_DWORD *)(a1 + 20) = 4 * getSin(v18);
        *(_DWORD *)(a1 + 16) = 4 * getCos(v18);
        playSoundEffect(SFXEnemyShootProjectile, 1);
      }
      break;
    case 0xA:
      if ( *(_DWORD *)(a1 + 4) & 0xF )
      {
        *(_DWORD *)(a1 + 116) = 20;
        *(_DWORD *)(a1 + 120) = 0;
        createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectRisingDisc, 0);
        playSoundEffect(SFXDestroyBreakableBlock, 1);
        for ( i = 0; i < 4; ++i )
        {
          v1 = random(-512, 512);
          v2 = random(-512, 512);
          createNPC(NPCSmoke, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), v2, v1, 0, 0, 256);
        }
      }
      else
      {
        *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
      }
      break;
    case 0x14:
      *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
      if ( ++*(_DWORD *)(a1 + 120) > 4 )
      {
        for ( ia = 0; ia < 4; ++ia )
        {
          v3 = random(-512, 512);
          v4 = random(-512, 512);
          createNPC(NPCSmoke, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), v4, v3, 0, 0, 256);
        }
        *(_DWORD *)(a1 + 40) = 142;
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 116) = 20;
        *(_DWORD *)(a1 + 16) = 0;
        *(_WORD *)(a1 + 80) &= 0xFFFBu;
        *(_WORD *)(a1 + 80) |= 0x20u;
        *(_DWORD *)(a1 + 164) = 1;
      }
      break;
    default:
      break;
  }
  if ( ++*(_DWORD *)(a1 + 104) > 1 )
    *(_DWORD *)(a1 + 104) = 0;
  v5 = &v10 + 4 * *(_DWORD *)(a1 + 104);
  v6 = (int *)(a1 + 84);
  *v6 = *v5;
  v6[1] = v5[1];
  result = v5[2];
  v6[2] = result;
  v6[3] = v5[3];
  return result;
}

//----- (00443EC0) --------------------------------------------------------
int *__cdecl NPC142(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+4h] [ebp-50h]
  int v4; // [esp+8h] [ebp-4Ch]
  int v5; // [esp+Ch] [ebp-48h]
  int v6; // [esp+10h] [ebp-44h]
  int v7; // [esp+14h] [ebp-40h]
  int v8; // [esp+18h] [ebp-3Ch]
  int v9; // [esp+1Ch] [ebp-38h]
  int v10; // [esp+20h] [ebp-34h]
  int v11; // [esp+24h] [ebp-30h]
  int v12; // [esp+28h] [ebp-2Ch]
  int v13; // [esp+2Ch] [ebp-28h]
  int v14; // [esp+30h] [ebp-24h]
  int v15; // [esp+34h] [ebp-20h]
  int v16; // [esp+38h] [ebp-1Ch]
  int v17; // [esp+3Ch] [ebp-18h]
  int v18; // [esp+40h] [ebp-14h]
  int v19; // [esp+44h] [ebp-10h]
  int v20; // [esp+48h] [ebp-Ch]
  int v21; // [esp+4Ch] [ebp-8h]
  int v22; // [esp+50h] [ebp-4h]

  v3 = 0;
  v4 = 128;
  v5 = 16;
  v6 = 144;
  v7 = 16;
  v8 = 128;
  v9 = 32;
  v10 = 144;
  v11 = 32;
  v12 = 128;
  v13 = 48;
  v14 = 144;
  v15 = 48;
  v16 = 128;
  v17 = 64;
  v18 = 144;
  v19 = 64;
  v20 = 128;
  v21 = 80;
  v22 = 144;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 120) = 0;
      goto LABEL_3;
    case 0xB:
LABEL_3:
      if ( ++*(_DWORD *)(a1 + 120) > 30 )
      {
        *(_DWORD *)(a1 + 116) = 12;
        *(_DWORD *)(a1 + 104) = 1;
        *(_DWORD *)(a1 + 100) = 0;
      }
      break;
    case 0xC:
      if ( ++*(_DWORD *)(a1 + 100) > 8 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) == 3 )
      {
        *(_DWORD *)(a1 + 116) = 20;
        *(_DWORD *)(a1 + 20) = -512;
        if ( quote.XPos >= *(_DWORD *)(a1 + 8) )
          *(_DWORD *)(a1 + 16) = 512;
        else
          *(_DWORD *)(a1 + 16) = -512;
      }
      break;
    case 0x14:
      if ( *(_DWORD *)(a1 + 20) <= -128 )
        *(_DWORD *)(a1 + 104) = 3;
      else
        *(_DWORD *)(a1 + 104) = 4;
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 104) = 2;
        *(_DWORD *)(a1 + 116) = 21;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 16) = 0;
        playSoundEffect(SFXQuoteHitGround, 1);
      }
      break;
    case 0x15:
      if ( ++*(_DWORD *)(a1 + 120) > 10 )
      {
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 20) += 64;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  if ( *(_DWORD *)(a1 + 20) < -1535 )
    *(_DWORD *)(a1 + 20) = -1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v1 = &v3 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (00444190) --------------------------------------------------------
int __cdecl NPC143(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+0h] [ebp-20h]
  int v5; // [esp+4h] [ebp-1Ch]
  int v6; // [esp+8h] [ebp-18h]
  int v7; // [esp+Ch] [ebp-14h]
  int v8; // [esp+10h] [ebp-10h]
  int v9; // [esp+14h] [ebp-Ch]
  int v10; // [esp+18h] [ebp-8h]
  int v11; // [esp+1Ch] [ebp-4h]

  v8 = 208;
  v9 = 32;
  v10 = 224;
  v11 = 48;
  v4 = 208;
  v5 = 48;
  v6 = 224;
  v7 = 64;
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v8 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (00444230) --------------------------------------------------------
int __cdecl NPC144(int a1)
{
  int *v1; // edx
  int *v2; // eax
  int result; // eax
  int v4; // [esp+4h] [ebp-A0h]
  int v5; // [esp+8h] [ebp-9Ch]
  int v6; // [esp+Ch] [ebp-98h]
  int v7; // [esp+10h] [ebp-94h]
  int v8; // [esp+14h] [ebp-90h]
  int v9; // [esp+18h] [ebp-8Ch]
  int v10; // [esp+1Ch] [ebp-88h]
  int v11; // [esp+20h] [ebp-84h]
  int v12; // [esp+24h] [ebp-80h]
  int v13; // [esp+28h] [ebp-7Ch]
  int v14; // [esp+2Ch] [ebp-78h]
  int v15; // [esp+30h] [ebp-74h]
  int v16; // [esp+34h] [ebp-70h]
  int v17; // [esp+38h] [ebp-6Ch]
  int v18; // [esp+3Ch] [ebp-68h]
  int v19; // [esp+40h] [ebp-64h]
  int v20; // [esp+44h] [ebp-60h]
  int v21; // [esp+48h] [ebp-5Ch]
  int v22; // [esp+4Ch] [ebp-58h]
  int v23; // [esp+50h] [ebp-54h]
  int v24; // [esp+54h] [ebp-50h]
  int v25; // [esp+58h] [ebp-4Ch]
  int v26; // [esp+5Ch] [ebp-48h]
  int v27; // [esp+60h] [ebp-44h]
  int v28; // [esp+64h] [ebp-40h]
  int v29; // [esp+68h] [ebp-3Ch]
  int v30; // [esp+6Ch] [ebp-38h]
  int v31; // [esp+70h] [ebp-34h]
  int v32; // [esp+74h] [ebp-30h]
  int v33; // [esp+78h] [ebp-2Ch]
  int v34; // [esp+7Ch] [ebp-28h]
  int v35; // [esp+80h] [ebp-24h]
  int v36; // [esp+84h] [ebp-20h]
  int v37; // [esp+88h] [ebp-1Ch]
  int v38; // [esp+8Ch] [ebp-18h]
  int v39; // [esp+90h] [ebp-14h]
  int v40; // [esp+94h] [ebp-10h]
  int v41; // [esp+98h] [ebp-Ch]
  int v42; // [esp+9Ch] [ebp-8h]
  int v43; // [esp+A0h] [ebp-4h]

  v24 = 0;
  v25 = 64;
  v26 = 16;
  v27 = 80;
  v28 = 16;
  v29 = 64;
  v30 = 32;
  v31 = 80;
  v32 = 32;
  v33 = 64;
  v34 = 48;
  v35 = 80;
  v36 = 16;
  v37 = 64;
  v38 = 32;
  v39 = 80;
  v40 = 128;
  v41 = 64;
  v42 = 144;
  v43 = 80;
  v4 = 0;
  v5 = 80;
  v6 = 16;
  v7 = 96;
  v8 = 16;
  v9 = 80;
  v10 = 32;
  v11 = 96;
  v12 = 32;
  v13 = 80;
  v14 = 48;
  v15 = 96;
  v16 = 16;
  v17 = 80;
  v18 = 32;
  v19 = 96;
  v20 = 128;
  v21 = 80;
  v22 = 144;
  v23 = 96;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 8);
      playSoundEffect(SFXTeleport, 1);
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( ++*(_DWORD *)(a1 + 120) == 64 )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 100) > 2 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 3 )
        *(_DWORD *)(a1 + 104) = 2;
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 116) = 4;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 4;
        playSoundEffect(SFXQuoteHitGround, 1);
      }
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      goto LABEL_14;
    case 0xB:
LABEL_14:
      if ( random(0, 120) == 10 )
      {
        *(_DWORD *)(a1 + 116) = 12;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      break;
    case 0xC:
      if ( ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 11;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 116) > 1 )
  {
    *(_DWORD *)(a1 + 20) += 32;
    if ( *(_DWORD *)(a1 + 20) > 1535 )
      *(_DWORD *)(a1 + 20) = 1535;
    *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  }
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v24 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  v2[3] = v1[3];
  result = a1;
  if ( *(_DWORD *)(a1 + 116) == 1 )
  {
    *(_DWORD *)(a1 + 96) = *(_DWORD *)(a1 + 88) + *(_DWORD *)(a1 + 120) / 4;
    if ( *(_DWORD *)(a1 + 120) / 2 % 2 )
    {
      result = a1;
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 32);
    }
    else
    {
      result = a1;
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 32) + 512;
    }
  }
  return result;
}

//----- (00444620) --------------------------------------------------------
LONG __cdecl NPC145(NPC *npc)
{
  int *v1; // ecx
  RECT *v2; // edx
  LONG result; // eax
  int v4; // [esp+4h] [ebp-20h]
  int v5; // [esp+8h] [ebp-1Ch]
  int v6; // [esp+Ch] [ebp-18h]
  int v7; // [esp+10h] [ebp-14h]
  int v8; // [esp+14h] [ebp-10h]
  int v9; // [esp+18h] [ebp-Ch]
  int v10; // [esp+1Ch] [ebp-8h]
  int v11; // [esp+20h] [ebp-4h]

  v8 = 96;
  v9 = 32;
  v10 = 112;
  v11 = 48;
  v4 = 112;
  v5 = 32;
  v6 = 128;
  v7 = 48;
  if ( !npc->currentState )
  {
    if ( npc->parentNPC->count2 )
    {
      if ( npc->parentNPC->direction )
        npc->direction = 0;
      else
        npc->direction = 2;
    }
    else if ( npc->parentNPC->direction )
    {
      npc->direction = 2;
    }
    else
    {
      npc->direction = 0;
    }
    if ( npc->direction )
      npc->XPos = npc->parentNPC->XPos + 5120;
    else
      npc->XPos = npc->parentNPC->XPos - 5120;
    npc->YPos = npc->parentNPC->YPos;
  }
  if ( npc->direction )
    v1 = &v4 + 4 * npc->animationNumber;
  else
    v1 = &v8 + 4 * npc->animationNumber;
  v2 = &npc->rect;
  v2->left = *v1;
  v2->top = v1[1];
  result = v1[2];
  v2->right = result;
  v2->bottom = v1[3];
  return result;
}

//----- (00444780) --------------------------------------------------------
int __cdecl NPC146(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+0h] [ebp-54h]
  int v5; // [esp+4h] [ebp-50h]
  int v6; // [esp+8h] [ebp-4Ch]
  int v7; // [esp+Ch] [ebp-48h]
  int v8; // [esp+10h] [ebp-44h]
  int v9; // [esp+14h] [ebp-40h]
  int v10; // [esp+18h] [ebp-3Ch]
  int v11; // [esp+1Ch] [ebp-38h]
  int v12; // [esp+20h] [ebp-34h]
  int v13; // [esp+24h] [ebp-30h]
  int v14; // [esp+28h] [ebp-2Ch]
  int v15; // [esp+2Ch] [ebp-28h]
  int v16; // [esp+30h] [ebp-24h]
  int v17; // [esp+34h] [ebp-20h]
  int v18; // [esp+38h] [ebp-1Ch]
  int v19; // [esp+3Ch] [ebp-18h]
  int v20; // [esp+40h] [ebp-14h]
  int v21; // [esp+44h] [ebp-10h]
  int v22; // [esp+48h] [ebp-Ch]
  int v23; // [esp+4Ch] [ebp-8h]
  int v24; // [esp+50h] [ebp-4h]

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 256;
  v10 = 0;
  v11 = 272;
  v12 = 240;
  v13 = 272;
  v14 = 0;
  v15 = 288;
  v16 = 240;
  v17 = 288;
  v18 = 0;
  v19 = 304;
  v20 = 240;
  v21 = 304;
  v22 = 0;
  v23 = 320;
  v24 = 240;
  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      if ( v4 == 2 )
      {
        if ( ++*(_DWORD *)(a1 + 100) > 2 )
        {
          *(_DWORD *)(a1 + 100) = 0;
          ++*(_DWORD *)(a1 + 104);
        }
        if ( *(_DWORD *)(a1 + 104) == 2 )
          *(_DWORD *)(a1 + 164) = 10;
        if ( *(_DWORD *)(a1 + 104) > 4 )
        {
          createDustClouds(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 4096, 8);
          *(_BYTE *)a1 = 0;
        }
      }
      goto LABEL_16;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    if ( *(_DWORD *)(a1 + 76) == 2 )
      startFlash(0, 0, 2);
  }
  if ( ++*(_DWORD *)(a1 + 120) > 10 )
  {
    *(_DWORD *)(a1 + 116) = 2;
    playSoundEffect(SFXLightning, 1);
  }
LABEL_16:
  v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (00444930) --------------------------------------------------------
// Checks for starblock tile & if bullet can break it
int __cdecl NPC147(int a1)
{
  int Sin; // ST24_4
  int v2; // ecx
  int *v3; // ecx
  int *v4; // edx
  int result; // eax
  int v6; // [esp+8h] [ebp-D0h]
  int v7; // [esp+Ch] [ebp-CCh]
  int v8; // [esp+10h] [ebp-C8h]
  int v9; // [esp+14h] [ebp-C4h]
  int v10; // [esp+18h] [ebp-C0h]
  int v11; // [esp+1Ch] [ebp-BCh]
  int v12; // [esp+20h] [ebp-B8h]
  int v13; // [esp+24h] [ebp-B4h]
  int v14; // [esp+28h] [ebp-B0h]
  int v15; // [esp+2Ch] [ebp-ACh]
  int v16; // [esp+30h] [ebp-A8h]
  int v17; // [esp+34h] [ebp-A4h]
  int v18; // [esp+38h] [ebp-A0h]
  int v19; // [esp+3Ch] [ebp-9Ch]
  int v20; // [esp+40h] [ebp-98h]
  int v21; // [esp+44h] [ebp-94h]
  int v22; // [esp+48h] [ebp-90h]
  int v23; // [esp+4Ch] [ebp-8Ch]
  int v24; // [esp+50h] [ebp-88h]
  int v25; // [esp+54h] [ebp-84h]
  int v26; // [esp+58h] [ebp-80h]
  int v27; // [esp+5Ch] [ebp-7Ch]
  int v28; // [esp+60h] [ebp-78h]
  int v29; // [esp+64h] [ebp-74h]
  int X_Vel; // [esp+6Ch] [ebp-6Ch]
  int v31; // [esp+70h] [ebp-68h]
  int v32; // [esp+74h] [ebp-64h]
  int v33; // [esp+78h] [ebp-60h]
  int v34; // [esp+7Ch] [ebp-5Ch]
  int v35; // [esp+80h] [ebp-58h]
  int v36; // [esp+84h] [ebp-54h]
  int v37; // [esp+88h] [ebp-50h]
  int v38; // [esp+8Ch] [ebp-4Ch]
  int v39; // [esp+90h] [ebp-48h]
  int v40; // [esp+94h] [ebp-44h]
  int v41; // [esp+98h] [ebp-40h]
  int v42; // [esp+9Ch] [ebp-3Ch]
  int v43; // [esp+A0h] [ebp-38h]
  int v44; // [esp+A4h] [ebp-34h]
  int v45; // [esp+A8h] [ebp-30h]
  int v46; // [esp+ACh] [ebp-2Ch]
  int v47; // [esp+B0h] [ebp-28h]
  int v48; // [esp+B4h] [ebp-24h]
  int v49; // [esp+B8h] [ebp-20h]
  int v50; // [esp+BCh] [ebp-1Ch]
  int v51; // [esp+C0h] [ebp-18h]
  int v52; // [esp+C4h] [ebp-14h]
  int v53; // [esp+C8h] [ebp-10h]
  int v54; // [esp+CCh] [ebp-Ch]
  unsigned __int8 Angle; // [esp+D7h] [ebp-1h]

  v31 = 0;
  v32 = 96;
  v33 = 16;
  v34 = 112;
  v35 = 16;
  v36 = 96;
  v37 = 32;
  v38 = 112;
  v39 = 32;
  v40 = 96;
  v41 = 48;
  v42 = 112;
  v43 = 48;
  v44 = 96;
  v45 = 64;
  v46 = 112;
  v47 = 64;
  v48 = 96;
  v49 = 80;
  v50 = 112;
  v51 = 80;
  v52 = 96;
  v53 = 96;
  v54 = 112;
  v6 = 0;
  v7 = 112;
  v8 = 16;
  v9 = 128;
  v10 = 16;
  v11 = 112;
  v12 = 32;
  v13 = 128;
  v14 = 32;
  v15 = 112;
  v16 = 48;
  v17 = 128;
  v18 = 48;
  v19 = 112;
  v20 = 64;
  v21 = 128;
  v22 = 64;
  v23 = 112;
  v24 = 80;
  v25 = 128;
  v26 = 80;
  v27 = 112;
  v28 = 96;
  v29 = 128;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 12) += 1536;
      *(_DWORD *)(a1 + 116) = 1;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( *(_DWORD *)(a1 + 120) < 8
        || *(_DWORD *)(a1 + 8) - 49152 >= quote.XPos
        || *(_DWORD *)(a1 + 8) + 49152 <= quote.XPos
        || *(_DWORD *)(a1 + 12) - 49152 >= quote.YPos
        || *(_DWORD *)(a1 + 12) + 0x4000 <= quote.YPos )
      {
        if ( *(_DWORD *)(a1 + 120) < 8 )
          ++*(_DWORD *)(a1 + 120);
        *(_DWORD *)(a1 + 104) = 0;
      }
      else
      {
        if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
          *(_DWORD *)(a1 + 76) = 2;
        else
          *(_DWORD *)(a1 + 76) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      if ( *(_BYTE *)(a1 + 156) )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 120) = 0;
      }
      if ( *(_DWORD *)(a1 + 120) >= 8
        && *(_DWORD *)(a1 + 8) - 24576 < quote.XPos
        && *(_DWORD *)(a1 + 8) + 24576 > quote.XPos
        && *(_DWORD *)(a1 + 12) - 49152 < quote.YPos
        && *(_DWORD *)(a1 + 12) + 0x4000 > quote.YPos )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 3;
        *(_DWORD *)(a1 + 104) = 2;
        *(_DWORD *)(a1 + 20) = -1535;
        playSoundEffect(SFXCritterHop, 1);
        if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
          *(_DWORD *)(a1 + 76) = 2;
        else
          *(_DWORD *)(a1 + 76) = 0;
      }
      break;
    case 3:
      if ( *(_DWORD *)(a1 + 20) > 256 )
      {
        *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 12);
        *(_DWORD *)(a1 + 116) = 4;
        *(_DWORD *)(a1 + 104) = 3;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    case 4:
      if ( *(_DWORD *)(a1 + 8) >= quote.XPos )
        *(_DWORD *)(a1 + 76) = 0;
      else
        *(_DWORD *)(a1 + 76) = 2;
      ++*(_DWORD *)(a1 + 120);
      if ( *(_DWORD *)(a1 + 4) & 7 || *(_DWORD *)(a1 + 120) > 60 )
      {
        *(_DWORD *)(a1 + 164) = 3;
        *(_DWORD *)(a1 + 116) = 5;
        *(_DWORD *)(a1 + 104) = 2;
      }
      else
      {
        if ( *(_DWORD *)(a1 + 120) % 4 == 1 )
          playSoundEffect(SFXCritterFly, 1);
        if ( *(_DWORD *)(a1 + 4) & 8 )
          *(_DWORD *)(a1 + 20) = -512;
        if ( *(_DWORD *)(a1 + 120) % 30 == 6 )
        {
          Angle = getArcTan(*(_DWORD *)(a1 + 8) - quote.XPos, *(_DWORD *)(a1 + 12) - quote.YPos);
          Angle += random(-6, 6);
          Sin = 3 * getSin(Angle);
          X_Vel = 3 * getCos(Angle);
          createNPC((NPCNames)148, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), X_Vel, Sin, 0, 0, 256);
          playSoundEffect(SFXEnemyShootProjectile, 1);
        }
        if ( ++*(_DWORD *)(a1 + 100) > 0 )
        {
          *(_DWORD *)(a1 + 100) = 0;
          ++*(_DWORD *)(a1 + 104);
        }
        if ( *(_DWORD *)(a1 + 104) > 5 )
          *(_DWORD *)(a1 + 104) = 3;
      }
      break;
    case 5:
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 164) = 2;
        *(_DWORD *)(a1 + 16) = 0;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 116) = 1;
        playSoundEffect(SFXQuoteHitGround, 1);
      }
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 116) == 4 )
  {
    if ( *(_DWORD *)(a1 + 12) <= *(_DWORD *)(a1 + 36) )
      v2 = *(_DWORD *)(a1 + 20) + 16;
    else
      v2 = *(_DWORD *)(a1 + 20) - 16;
    *(_DWORD *)(a1 + 20) = v2;
    if ( *(_DWORD *)(a1 + 20) > 512 )
      *(_DWORD *)(a1 + 20) = 512;
    if ( *(_DWORD *)(a1 + 20) < -512 )
      *(_DWORD *)(a1 + 20) = -512;
    if ( *(_DWORD *)(a1 + 16) > 512 )
      *(_DWORD *)(a1 + 16) = 512;
    if ( *(_DWORD *)(a1 + 16) < -512 )
      *(_DWORD *)(a1 + 16) = -512;
  }
  else
  {
    *(_DWORD *)(a1 + 20) += 32;
    if ( *(_DWORD *)(a1 + 20) > 1535 )
      *(_DWORD *)(a1 + 20) = 1535;
  }
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v3 = &v6 + 4 * *(_DWORD *)(a1 + 104);
  else
    v3 = &v31 + 4 * *(_DWORD *)(a1 + 104);
  v4 = (int *)(a1 + 84);
  *v4 = *v3;
  v4[1] = v3[1];
  result = v3[2];
  v4[2] = result;
  v4[3] = v3[3];
  return result;
}

//----- (00445050) --------------------------------------------------------
void __cdecl NPC148(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int v3; // [esp+0h] [ebp-20h]
  int v4; // [esp+4h] [ebp-1Ch]
  int v5; // [esp+8h] [ebp-18h]
  int v6; // [esp+Ch] [ebp-14h]
  int v7; // [esp+10h] [ebp-10h]
  int v8; // [esp+14h] [ebp-Ch]
  int v9; // [esp+18h] [ebp-8h]
  int v10; // [esp+1Ch] [ebp-4h]

  if ( *(_DWORD *)(a1 + 4) & 0xFF )
  {
    createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectRisingDisc, 0);
    *(_BYTE *)a1 = 0;
  }
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  v3 = 96;
  v4 = 96;
  v5 = 104;
  v6 = 104;
  v7 = 104;
  v8 = 96;
  v9 = 112;
  v10 = 104;
  if ( ++*(_DWORD *)(a1 + 104) > 1 )
    *(_DWORD *)(a1 + 104) = 0;
  v1 = &v3 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  v2[3] = v1[3];
  if ( ++*(_DWORD *)(a1 + 108) > 300 )
  {
    createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectRisingDisc, 0);
    *(_BYTE *)a1 = 0;
  }
}

//----- (00445170) --------------------------------------------------------
signed int __cdecl NPC149(int a1)
{
  int v1; // ST10_4
  int v2; // ST0C_4
  int v3; // eax
  int v4; // ST10_4
  int v5; // ST0C_4
  int v6; // eax
  _DWORD *v7; // ecx
  signed int result; // eax
  signed int i; // [esp+4h] [ebp-14h]
  signed int ia; // [esp+4h] [ebp-14h]

  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 8) += 4096;
      *(_DWORD *)(a1 + 12) += 4096;
      if ( *(_DWORD *)(a1 + 76) )
        *(_DWORD *)(a1 + 116) = 20;
      else
        *(_DWORD *)(a1 + 116) = 10;
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 20) = 0;
      *(_WORD *)(a1 + 80) |= 0x40u;
      break;
    case 0xA:
      *(_WORD *)(a1 + 80) &= 0xFF7Fu;
      *(_DWORD *)(a1 + 164) = 0;
      if ( quote.XPos < *(_DWORD *)(a1 + 8) + 12800
        && quote.XPos > *(_DWORD *)(a1 + 8) - 204800
        && quote.YPos < *(_DWORD *)(a1 + 12) + 12800
        && quote.YPos > *(_DWORD *)(a1 + 12) - 12800 )
      {
        *(_DWORD *)(a1 + 116) = 11;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    case 0xB:
      if ( ++*(_DWORD *)(a1 + 120) % 10 == 6 )
        playSoundEffect(SFXBlockMove, 1);
      if ( *(_DWORD *)(a1 + 4) & 1 )
      {
        *(_DWORD *)(a1 + 16) = 0;
        *(_DWORD *)(a1 + 76) = 2;
        *(_DWORD *)(a1 + 116) = 20;
        setQuake(10);
        playSoundEffect(SFXLargeObjectHitGround, 1);
        for ( i = 0; i < 4; ++i )
        {
          v1 = random(-1536, 0);
          v2 = random(-341, 341);
          v3 = random(-12, 12);
          createNPC(NPCSmoke, *(_DWORD *)(a1 + 8) - 0x2000, *(_DWORD *)(a1 + 12) + (v3 << 9), v2, v1, 0, 0, 256);
        }
      }
      else
      {
        if ( quote.collisionFlags & 1 )
        {
          *(_WORD *)(a1 + 80) |= 0x80u;
          *(_DWORD *)(a1 + 164) = 100;
        }
        else
        {
          *(_WORD *)(a1 + 80) &= 0xFF7Fu;
          *(_DWORD *)(a1 + 164) = 0;
        }
        *(_DWORD *)(a1 + 16) -= 32;
      }
      break;
    case 0x14:
      *(_WORD *)(a1 + 80) &= 0xFF7Fu;
      *(_DWORD *)(a1 + 164) = 0;
      if ( quote.XPos > *(_DWORD *)(a1 + 8) - 12800
        && quote.XPos < *(_DWORD *)(a1 + 8) + 204800
        && quote.YPos < *(_DWORD *)(a1 + 12) + 12800
        && quote.YPos > *(_DWORD *)(a1 + 12) - 12800 )
      {
        *(_DWORD *)(a1 + 116) = 21;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    case 0x15:
      if ( ++*(_DWORD *)(a1 + 120) % 10 == 6 )
        playSoundEffect(SFXBlockMove, 1);
      if ( *(_DWORD *)(a1 + 4) & 4 )
      {
        *(_DWORD *)(a1 + 16) = 0;
        *(_DWORD *)(a1 + 76) = 0;
        *(_DWORD *)(a1 + 116) = 10;
        setQuake(10);
        playSoundEffect(SFXLargeObjectHitGround, 1);
        for ( ia = 0; ia < 4; ++ia )
        {
          v4 = random(-1536, 0);
          v5 = random(-341, 341);
          v6 = random(-12, 12);
          createNPC(NPCSmoke, *(_DWORD *)(a1 + 8) + 0x2000, *(_DWORD *)(a1 + 12) + (v6 << 9), v5, v4, 0, 0, 256);
        }
      }
      else
      {
        if ( quote.collisionFlags & 4 )
        {
          *(_WORD *)(a1 + 80) |= 0x80u;
          *(_DWORD *)(a1 + 164) = 100;
        }
        else
        {
          *(_WORD *)(a1 + 80) &= 0xFF7Fu;
          *(_DWORD *)(a1 + 164) = 0;
        }
        *(_DWORD *)(a1 + 16) += 32;
      }
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 16) > 512 )
    *(_DWORD *)(a1 + 16) = 512;
  if ( *(_DWORD *)(a1 + 16) < -512 )
    *(_DWORD *)(a1 + 16) = -512;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  v7 = (_DWORD *)(a1 + 84);
  *v7 = 16;
  v7[1] = 0;
  v7[2] = 48;
  result = 32;
  v7[3] = 32;
  return result;
}

//----- (00445660) --------------------------------------------------------
// Solid tile -> Two stage filter for blocks that bullets are s'posta collide with
void __cdecl NPC150(NPC *npc)
{
  int v1; // ST10_4
  int v2; // eax
  int v3; // edx
  int v4; // eax
  int *v5; // eax
  RECT *v6; // ecx
  int v7; // [esp+4h] [ebp-128h]
  int v8; // [esp+8h] [ebp-124h]
  int v9; // [esp+Ch] [ebp-120h]
  int v10; // [esp+10h] [ebp-11Ch]
  int v11; // [esp+14h] [ebp-118h]
  int v12; // [esp+18h] [ebp-114h]
  int v13; // [esp+1Ch] [ebp-110h]
  int v14; // [esp+20h] [ebp-10Ch]
  int v15; // [esp+24h] [ebp-108h]
  int v16; // [esp+28h] [ebp-104h]
  int v17; // [esp+2Ch] [ebp-100h]
  int v18; // [esp+30h] [ebp-FCh]
  int v19; // [esp+34h] [ebp-F8h]
  int v20; // [esp+38h] [ebp-F4h]
  int v21; // [esp+3Ch] [ebp-F0h]
  int v22; // [esp+40h] [ebp-ECh]
  int v23; // [esp+44h] [ebp-E8h]
  int v24; // [esp+48h] [ebp-E4h]
  int v25; // [esp+4Ch] [ebp-E0h]
  int v26; // [esp+50h] [ebp-DCh]
  int v27; // [esp+54h] [ebp-D8h]
  int v28; // [esp+58h] [ebp-D4h]
  int v29; // [esp+5Ch] [ebp-D0h]
  int v30; // [esp+60h] [ebp-CCh]
  int v31; // [esp+64h] [ebp-C8h]
  int v32; // [esp+68h] [ebp-C4h]
  int v33; // [esp+6Ch] [ebp-C0h]
  int v34; // [esp+70h] [ebp-BCh]
  int v35; // [esp+74h] [ebp-B8h]
  int v36; // [esp+78h] [ebp-B4h]
  int v37; // [esp+7Ch] [ebp-B0h]
  int v38; // [esp+80h] [ebp-ACh]
  int v39; // [esp+84h] [ebp-A8h]
  int v40; // [esp+88h] [ebp-A4h]
  int v41; // [esp+8Ch] [ebp-A0h]
  int v42; // [esp+90h] [ebp-9Ch]
  int i; // [esp+98h] [ebp-94h]
  int v44; // [esp+9Ch] [ebp-90h]
  int v45; // [esp+A0h] [ebp-8Ch]
  int v46; // [esp+A4h] [ebp-88h]
  int v47; // [esp+A8h] [ebp-84h]
  int v48; // [esp+ACh] [ebp-80h]
  int v49; // [esp+B0h] [ebp-7Ch]
  int v50; // [esp+B4h] [ebp-78h]
  int v51; // [esp+B8h] [ebp-74h]
  int v52; // [esp+BCh] [ebp-70h]
  int v53; // [esp+C0h] [ebp-6Ch]
  int v54; // [esp+C4h] [ebp-68h]
  int v55; // [esp+C8h] [ebp-64h]
  int v56; // [esp+CCh] [ebp-60h]
  int v57; // [esp+D0h] [ebp-5Ch]
  int v58; // [esp+D4h] [ebp-58h]
  int v59; // [esp+D8h] [ebp-54h]
  int v60; // [esp+DCh] [ebp-50h]
  int v61; // [esp+E0h] [ebp-4Ch]
  int v62; // [esp+E4h] [ebp-48h]
  int v63; // [esp+E8h] [ebp-44h]
  int v64; // [esp+ECh] [ebp-40h]
  int v65; // [esp+F0h] [ebp-3Ch]
  int v66; // [esp+F4h] [ebp-38h]
  int v67; // [esp+F8h] [ebp-34h]
  int v68; // [esp+FCh] [ebp-30h]
  int v69; // [esp+100h] [ebp-2Ch]
  int v70; // [esp+104h] [ebp-28h]
  int v71; // [esp+108h] [ebp-24h]
  int v72; // [esp+10Ch] [ebp-20h]
  int v73; // [esp+110h] [ebp-1Ch]
  int v74; // [esp+114h] [ebp-18h]
  int v75; // [esp+118h] [ebp-14h]
  int v76; // [esp+11Ch] [ebp-10h]
  int v77; // [esp+120h] [ebp-Ch]
  int v78; // [esp+124h] [ebp-8h]
  int v79; // [esp+128h] [ebp-4h]

  v44 = 0;
  v45 = 0;
  v46 = 16;
  v47 = 16;
  v48 = 48;
  v49 = 0;
  v50 = 64;
  v51 = 16;
  v52 = 144;
  v53 = 0;
  v54 = 160;
  v55 = 16;
  v56 = 16;
  v57 = 0;
  v58 = 32;
  v59 = 16;
  v60 = 0;
  v61 = 0;
  v62 = 16;
  v63 = 16;
  v64 = 32;
  v65 = 0;
  v66 = 48;
  v67 = 16;
  v68 = 0;
  v69 = 0;
  v70 = 16;
  v71 = 16;
  v72 = 160;
  v73 = 0;
  v74 = 176;
  v75 = 16;
  v76 = 112;
  v77 = 0;
  v78 = 128;
  v79 = 16;
  v7 = 0;
  v8 = 16;
  v9 = 16;
  v10 = 32;
  v11 = 48;
  v12 = 16;
  v13 = 64;
  v14 = 32;
  v15 = 144;
  v16 = 16;
  v17 = 160;
  v18 = 32;
  v19 = 16;
  v20 = 16;
  v21 = 32;
  v22 = 32;
  v23 = 0;
  v24 = 16;
  v25 = 16;
  v26 = 32;
  v27 = 32;
  v28 = 16;
  v29 = 48;
  v30 = 32;
  v31 = 0;
  v32 = 16;
  v33 = 16;
  v34 = 32;
  v35 = 160;
  v36 = 16;
  v37 = 176;
  v38 = 32;
  v39 = 112;
  v40 = 16;
  v41 = 128;
  v42 = 32;
  switch ( npc->currentState )
  {
    case 0:
      npc->currentState = 1;
      npc->animationNumber = 0;
      if ( npc->direction > 10 )
      {
        npc->XPos = quote.XPos;
        npc->YPos = quote.YPos;
        npc->direction -= 10;
      }
      break;
    case 2:
      npc->animationNumber = 1;
      break;
    case 10:
      npc->currentState = 11;
      for ( i = 0; i < 4; ++i )
      {
        v1 = random(-1536, 0);
        v2 = random(-341, 341);
        createNPC(NPCSmoke, npc->XPos, npc->YPos, v2, v1, 0, 0, 256);
      }
      playSoundEffect(SFXQuoteSmashIntoGround, 1);
      goto LABEL_10;
    case 11:
LABEL_10:
      npc->animationNumber = 2;
      break;
    case 20:
      npc->currentState = 21;
      npc->waitTimer = 64;
      playSoundEffect(SFXTeleport, 1);
      goto LABEL_12;
    case 21:
LABEL_12:
      if ( !--npc->waitTimer )
        npc->isAlive = 0;
      break;
    case 50:
      npc->currentState = 51;
      npc->animationNumber = 3;
      npc->animationTimer = 0;
      goto LABEL_16;
    case 51:
LABEL_16:
      if ( ++npc->animationTimer > 4 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 6 )
        npc->animationNumber = 3;
      if ( npc->direction )
        v3 = npc->XPos + 512;
      else
        v3 = npc->XPos - 512;
      npc->XPos = v3;
      break;
    case 60:
      npc->currentState = 61;
      npc->animationNumber = 7;
      npc->curlyTargetX = npc->XPos;
      npc->curlyTargetY = npc->YPos;
      goto LABEL_25;
    case 61:
LABEL_25:
      npc->curlyTargetY += 256;
      npc->XPos = npc->curlyTargetX + (random(-1, 1) << 9);
      npc->YPos = npc->curlyTargetY + (random(-1, 1) << 9);
      break;
    case 70:
      npc->currentState = 71;
      npc->waitTimer = 0;
      npc->animationNumber = 3;
      npc->animationTimer = 0;
      goto LABEL_27;
    case 71:
LABEL_27:
      if ( npc->direction )
        v4 = npc->XPos - 256;
      else
        v4 = npc->XPos + 256;
      npc->XPos = v4;
      if ( ++npc->animationTimer > 8 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 6 )
        npc->animationNumber = 3;
      break;
    case 80:
      npc->animationNumber = 8;
      break;
    case 99:
    case 100:
      npc->currentState = 101;
      npc->animationNumber = 3;
      npc->animationTimer = 0;
      goto LABEL_37;
    case 101:
LABEL_37:
      npc->YVel += 64;
      if ( npc->YVel > 1535 )
        npc->YVel = 1535;
      if ( npc->collisionFlags & 8 )
      {
        npc->YVel = 0;
        npc->currentState = 102;
      }
      npc->YPos += npc->YVel;
      break;
    case 102:
      if ( ++npc->animationTimer > 8 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 6 )
        npc->animationNumber = 3;
      break;
    default:
      break;
  }
  if ( npc->direction )
    v5 = &v7 + 4 * npc->animationNumber;
  else
    v5 = &v44 + 4 * npc->animationNumber;
  v6 = &npc->rect;
  v6->left = *v5;
  v6->top = v5[1];
  v6->right = v5[2];
  v6->bottom = v5[3];
  if ( npc->currentState == 21 )
  {
    npc->rect.bottom = npc->rect.top + npc->waitTimer / 4;
    if ( npc->waitTimer / 2 % 2 )
      ++npc->rect.left;
  }
  if ( quote.equippedItems & 0x40 )
  {
    npc->rect.top += 32;
    npc->rect.bottom += 32;
  }
}

//----- (00445E30) --------------------------------------------------------
int *__cdecl NPC151(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+0h] [ebp-44h]
  int v4; // [esp+4h] [ebp-40h]
  int v5; // [esp+8h] [ebp-3Ch]
  int v6; // [esp+Ch] [ebp-38h]
  int v7; // [esp+10h] [ebp-34h]
  int v8; // [esp+14h] [ebp-30h]
  int v9; // [esp+18h] [ebp-2Ch]
  int v10; // [esp+1Ch] [ebp-28h]
  int v11; // [esp+20h] [ebp-24h]
  int v12; // [esp+24h] [ebp-20h]
  int v13; // [esp+28h] [ebp-1Ch]
  int v14; // [esp+2Ch] [ebp-18h]
  int v15; // [esp+30h] [ebp-14h]
  int v16; // [esp+34h] [ebp-10h]
  int v17; // [esp+38h] [ebp-Ch]
  int v18; // [esp+3Ch] [ebp-8h]
  int v19; // [esp+40h] [ebp-4h]

  v12 = 192;
  v13 = 0;
  v14 = 208;
  v15 = 16;
  v16 = 208;
  v17 = 0;
  v18 = 224;
  v19 = 16;
  v4 = 192;
  v5 = 16;
  v6 = 208;
  v7 = 32;
  v8 = 208;
  v9 = 16;
  v10 = 224;
  v11 = 32;
  v3 = *(_DWORD *)(a1 + 116);
  if ( v3 )
  {
    if ( v3 != 1 )
    {
      if ( v3 == 2 && ++*(_DWORD *)(a1 + 120) > 16 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      goto LABEL_11;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 100) = 0;
  }
  if ( !random(0, 100) )
  {
    *(_DWORD *)(a1 + 116) = 2;
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 104) = 1;
  }
LABEL_11:
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v12 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (00445FA0) --------------------------------------------------------
// Backgrounds?
int __cdecl NPC152(int a1)
{
  _DWORD *v1; // ecx
  int result; // eax

  if ( !*(_DWORD *)(a1 + 116) )
  {
    if ( *(_DWORD *)(a1 + 76) == 2 )
      *(_DWORD *)(a1 + 12) += 0x2000;
    *(_DWORD *)(a1 + 116) = 1;
  }
  v1 = (_DWORD *)(a1 + 84);
  *v1 = 0;
  v1[1] = 0;
  v1[2] = 0;
  result = 0;
  v1[3] = 0;
  return result;
}

//----- (00446020) --------------------------------------------------------
int __cdecl NPC153(int a1)
{
  int result; // eax
  _DWORD *v2; // eax
  _DWORD *v3; // ecx
  _DWORD *v4; // edx
  _DWORD *v5; // eax

  result = quote.XPos + 163840;
  if ( *(_DWORD *)(a1 + 8) <= quote.XPos + 163840 )
  {
    result = a1;
    if ( *(_DWORD *)(a1 + 8) >= quote.XPos - 163840 && *(_DWORD *)(a1 + 12) <= quote.YPos + 122880 )
    {
      result = quote.YPos - 122880;
      if ( *(_DWORD *)(a1 + 12) >= quote.YPos - 122880 )
      {
        switch ( *(_DWORD *)(a1 + 116) )
        {
          case 0:
            *(_DWORD *)(a1 + 116) = 1;
            *(_DWORD *)(a1 + 16) = 0;
            *(_DWORD *)(a1 + 104) = 0;
            *(_DWORD *)(a1 + 12) += 1536;
            goto LABEL_8;
          case 1:
LABEL_8:
            if ( random(0, 100) == 1 )
            {
              *(_DWORD *)(a1 + 116) = 2;
              *(_DWORD *)(a1 + 104) = 1;
              *(_DWORD *)(a1 + 120) = 0;
            }
            if ( random(0, 100) == 1 )
            {
              if ( *(_DWORD *)(a1 + 76) )
                *(_DWORD *)(a1 + 76) = 0;
              else
                *(_DWORD *)(a1 + 76) = 2;
            }
            if ( random(0, 100) == 1 )
              *(_DWORD *)(a1 + 116) = 10;
            break;
          case 2:
            if ( ++*(_DWORD *)(a1 + 120) > 20 )
            {
              *(_DWORD *)(a1 + 116) = 1;
              *(_DWORD *)(a1 + 104) = 0;
            }
            break;
          case 0xA:
            *(_DWORD *)(a1 + 116) = 11;
            *(_DWORD *)(a1 + 120) = random(25, 100);
            *(_DWORD *)(a1 + 104) = 2;
            *(_DWORD *)(a1 + 100) = 0;
            goto LABEL_21;
          case 0xB:
LABEL_21:
            if ( ++*(_DWORD *)(a1 + 100) > 3 )
            {
              *(_DWORD *)(a1 + 100) = 0;
              ++*(_DWORD *)(a1 + 104);
            }
            if ( *(_DWORD *)(a1 + 104) > 5 )
              *(_DWORD *)(a1 + 104) = 2;
            if ( *(_DWORD *)(a1 + 76) )
              *(_DWORD *)(a1 + 16) = 512;
            else
              *(_DWORD *)(a1 + 16) = -512;
            if ( *(_DWORD *)(a1 + 120) )
            {
              --*(_DWORD *)(a1 + 120);
            }
            else
            {
              *(_DWORD *)(a1 + 116) = 1;
              *(_DWORD *)(a1 + 104) = 0;
              *(_DWORD *)(a1 + 16) = 0;
            }
            if ( *(_DWORD *)(a1 + 76) || !(*(_DWORD *)(a1 + 4) & 1) )
            {
              if ( *(_DWORD *)(a1 + 76) == 2 )
              {
                if ( *(_DWORD *)(a1 + 4) & 4 )
                {
                  *(_DWORD *)(a1 + 104) = 2;
                  *(_DWORD *)(a1 + 20) = -1535;
                  *(_DWORD *)(a1 + 116) = 20;
                  if ( !(quote.flags & 2) )
                    playSoundEffect(SFXCritterHop, 1);
                }
              }
            }
            else
            {
              *(_DWORD *)(a1 + 104) = 2;
              *(_DWORD *)(a1 + 20) = -1535;
              *(_DWORD *)(a1 + 116) = 20;
              if ( !(quote.flags & 2) )
                playSoundEffect(SFXCritterHop, 1);
            }
            break;
          case 0x14:
            if ( *(_DWORD *)(a1 + 76) || !(*(_DWORD *)(a1 + 4) & 1) )
            {
              if ( *(_DWORD *)(a1 + 76) == 2 && *(_DWORD *)(a1 + 4) & 4 )
                ++*(_DWORD *)(a1 + 108);
              else
                *(_DWORD *)(a1 + 108) = 0;
            }
            else
            {
              ++*(_DWORD *)(a1 + 108);
            }
            if ( *(_DWORD *)(a1 + 108) > 10 )
            {
              if ( *(_DWORD *)(a1 + 76) )
                *(_DWORD *)(a1 + 76) = 0;
              else
                *(_DWORD *)(a1 + 76) = 2;
            }
            if ( *(_DWORD *)(a1 + 76) )
              *(_DWORD *)(a1 + 16) = 256;
            else
              *(_DWORD *)(a1 + 16) = -256;
            if ( *(_DWORD *)(a1 + 4) & 8 )
            {
              *(_DWORD *)(a1 + 116) = 21;
              *(_DWORD *)(a1 + 104) = 20;
              *(_DWORD *)(a1 + 120) = 0;
              *(_DWORD *)(a1 + 16) = 0;
              if ( !(quote.flags & 2) )
                playSoundEffect(SFXQuoteHitGround, 1);
            }
            break;
          case 0x15:
            if ( ++*(_DWORD *)(a1 + 120) > 10 )
            {
              *(_DWORD *)(a1 + 116) = 1;
              *(_DWORD *)(a1 + 104) = 0;
            }
            break;
          default:
            break;
        }
        *(_DWORD *)(a1 + 20) += 64;
        if ( *(_DWORD *)(a1 + 20) > 1535 )
          *(_DWORD *)(a1 + 20) = 1535;
        *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
        if ( *(_DWORD *)(a1 + 76) )
        {
          v4 = (_DWORD *)((char *)&unk_4983F0 + 16 * *(_DWORD *)(a1 + 104));
          v5 = (_DWORD *)(a1 + 84);
          *v5 = *v4;
          v5[1] = v4[1];
          v5[2] = v4[2];
          v5[3] = v4[3];
        }
        else
        {
          v2 = (_DWORD *)((char *)&unk_4982A0 + 16 * *(_DWORD *)(a1 + 104));
          v3 = (_DWORD *)(a1 + 84);
          *v3 = *v2;
          v3[1] = v2[1];
          v3[2] = v2[2];
          v3[3] = v2[3];
        }
        result = a1;
        if ( *(_DWORD *)(a1 + 64) <= 985 )
        {
          *(_DWORD *)(a1 + 40) = 154;
          *(_DWORD *)(a1 + 116) = 0;
        }
      }
    }
  }
  return result;
}

//----- (00446500) --------------------------------------------------------
_DWORD *__cdecl NPC154(int NPC_Vars_Pointer)
{
  _DWORD *v1; // edx
  _DWORD *result; // eax
  _DWORD *v3; // ecx
  _DWORD *v4; // edx
  int v5; // [esp+0h] [ebp-4h]

  v5 = *(_DWORD *)(NPC_Vars_Pointer + 116);
  if ( v5 )
  {
    if ( v5 == 1 )
    {
      if ( *(_DWORD *)(NPC_Vars_Pointer + 4) & 8 )
      {
        *(_DWORD *)(NPC_Vars_Pointer + 104) = 10;
        *(_DWORD *)(NPC_Vars_Pointer + 100) = 0;
        *(_DWORD *)(NPC_Vars_Pointer + 116) = 2;
        *(_DWORD *)(NPC_Vars_Pointer + 120) = 0;
      }
    }
    else if ( v5 == 2 )
    {
      *(_DWORD *)(NPC_Vars_Pointer + 16) = 8 * *(_DWORD *)(NPC_Vars_Pointer + 16) / 9;
      if ( ++*(_DWORD *)(NPC_Vars_Pointer + 100) > 3 )
      {
        *(_DWORD *)(NPC_Vars_Pointer + 100) = 0;
        ++*(_DWORD *)(NPC_Vars_Pointer + 104);
      }
      if ( *(_DWORD *)(NPC_Vars_Pointer + 104) > 11 )
        *(_DWORD *)(NPC_Vars_Pointer + 104) = 10;
      if ( ++*(_DWORD *)(NPC_Vars_Pointer + 120) > 50 )
        *(_BYTE *)NPC_Vars_Pointer |= 8u;
    }
  }
  else
  {
    *(_WORD *)(NPC_Vars_Pointer + 80) &= 0xFFDFu;
    *(_WORD *)(NPC_Vars_Pointer + 80) &= 0xFFF7u;
    *(_DWORD *)(NPC_Vars_Pointer + 164) = 0;
    *(_DWORD *)(NPC_Vars_Pointer + 116) = 1;
    *(_DWORD *)(NPC_Vars_Pointer + 104) = 9;
    *(_DWORD *)(NPC_Vars_Pointer + 20) = -512;
    if ( *(_DWORD *)(NPC_Vars_Pointer + 76) )
      *(_DWORD *)(NPC_Vars_Pointer + 16) = -256;
    else
      *(_DWORD *)(NPC_Vars_Pointer + 16) = 256;
    playSoundEffect(SFXGaudiDie, 1);
  }
  *(_DWORD *)(NPC_Vars_Pointer + 20) += 32;
  if ( *(_DWORD *)(NPC_Vars_Pointer + 20) > 1535 )
    *(_DWORD *)(NPC_Vars_Pointer + 20) = 1535;
  *(_DWORD *)(NPC_Vars_Pointer + 8) += *(_DWORD *)(NPC_Vars_Pointer + 16);
  *(_DWORD *)(NPC_Vars_Pointer + 12) += *(_DWORD *)(NPC_Vars_Pointer + 20);
  if ( *(_DWORD *)(NPC_Vars_Pointer + 76) )
  {
    v3 = (_DWORD *)((char *)&unk_4983F0 + 16 * *(_DWORD *)(NPC_Vars_Pointer + 104));
    v4 = (_DWORD *)(NPC_Vars_Pointer + 84);
    *v4 = *v3;
    v4[1] = v3[1];
    result = (_DWORD *)v3[2];
    v4[2] = result;
    v4[3] = v3[3];
  }
  else
  {
    v1 = (_DWORD *)((char *)&unk_4982A0 + 16 * *(_DWORD *)(NPC_Vars_Pointer + 104));
    result = (_DWORD *)(NPC_Vars_Pointer + 84);
    *result = *v1;
    result[1] = v1[1];
    result[2] = v1[2];
    result[3] = v1[3];
  }
  return result;
}

//----- (00446710) --------------------------------------------------------
// Remove Ammo From Weapon
_DWORD *__cdecl NPC155(int a1)
{
  _DWORD *result; // eax
  unsigned __int8 v2; // ST2F_1
  unsigned __int8 v3; // ST2F_1
  unsigned __int8 v4; // ST2F_1
  unsigned __int8 v5; // ST2F_1
  int Y_Vel; // ST24_4
  int X_Vel; // ST28_4
  _DWORD *v8; // edx
  _DWORD *v9; // ecx
  _DWORD *v10; // edx
  int v11; // [esp+0h] [ebp-10h]

  result = (_DWORD *)(quote.XPos + 163840);
  if ( *(_DWORD *)(a1 + 8) > quote.XPos + 163840 )
    return result;
  result = (_DWORD *)a1;
  if ( *(_DWORD *)(a1 + 8) < quote.XPos - 163840 )
    return result;
  if ( *(_DWORD *)(a1 + 12) > quote.YPos + 122880 )
    return result;
  result = (_DWORD *)(quote.YPos - 122880);
  if ( *(_DWORD *)(a1 + 12) < quote.YPos - 122880 )
    return result;
  v11 = *(_DWORD *)(a1 + 116);
  switch ( v11 )
  {
    case 0:
      v2 = random(0, 255);
      *(_DWORD *)(a1 + 16) = getCos(v2);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 8) + 8 * getCos(v2 + 64);
      v3 = random(0, 255);
      *(_DWORD *)(a1 + 20) = getSin(v3);
      *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 12) + 8 * getSin(v3 + 64);
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 108) = 120;
      *(_DWORD *)(a1 + 120) = random(70, 150);
      *(_DWORD *)(a1 + 104) = 14;
      goto LABEL_11;
    case 1:
LABEL_11:
      if ( ++*(_DWORD *)(a1 + 104) > 15 )
        *(_DWORD *)(a1 + 104) = 14;
      if ( *(_DWORD *)(a1 + 120) )
      {
        --*(_DWORD *)(a1 + 120);
      }
      else
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 104) = 18;
      }
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 104) > 19 )
        *(_DWORD *)(a1 + 104) = 18;
      if ( ++*(_DWORD *)(a1 + 120) > 30 )
      {
        v4 = getArcTan(*(_DWORD *)(a1 + 8) - quote.XPos, *(_DWORD *)(a1 + 12) - quote.YPos);
        v5 = random(-6, 6) + v4;
        Y_Vel = 3 * getSin(v5);
        X_Vel = 3 * getCos(v5);
        createNPC((NPCNames)156, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), X_Vel, Y_Vel, 0, 0, 256);
        if ( !(quote.flags & 2) )
          playSoundEffect(SFXEnemyShootProjectile, 1);
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 120) = random(70, 150);
        *(_DWORD *)(a1 + 104) = 14;
        *(_DWORD *)(a1 + 100) = 0;
      }
      break;
  }
  if ( quote.XPos >= *(_DWORD *)(a1 + 8) )
    *(_DWORD *)(a1 + 76) = 2;
  else
    *(_DWORD *)(a1 + 76) = 0;
  if ( *(_DWORD *)(a1 + 32) < *(_DWORD *)(a1 + 8) )
    *(_DWORD *)(a1 + 16) -= 16;
  if ( *(_DWORD *)(a1 + 32) > *(_DWORD *)(a1 + 8) )
    *(_DWORD *)(a1 + 16) += 16;
  if ( *(_DWORD *)(a1 + 36) < *(_DWORD *)(a1 + 12) )
    *(_DWORD *)(a1 + 20) -= 16;
  if ( *(_DWORD *)(a1 + 36) > *(_DWORD *)(a1 + 12) )
    *(_DWORD *)(a1 + 20) += 16;
  if ( *(_DWORD *)(a1 + 16) > 512 )
    *(_DWORD *)(a1 + 16) = 512;
  if ( *(_DWORD *)(a1 + 16) < -512 )
    *(_DWORD *)(a1 + 16) = -512;
  if ( *(_DWORD *)(a1 + 20) > 512 )
    *(_DWORD *)(a1 + 20) = 512;
  if ( *(_DWORD *)(a1 + 20) < -512 )
    *(_DWORD *)(a1 + 20) = -512;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
  {
    v9 = (_DWORD *)((char *)&unk_4983F0 + 16 * *(_DWORD *)(a1 + 104));
    v10 = (_DWORD *)(a1 + 84);
    *v10 = *v9;
    v10[1] = v9[1];
    result = (_DWORD *)v9[2];
    v10[2] = result;
    v10[3] = v9[3];
  }
  else
  {
    v8 = (_DWORD *)((char *)&unk_4982A0 + 16 * *(_DWORD *)(a1 + 104));
    result = (_DWORD *)(a1 + 84);
    *result = *v8;
    result[1] = v8[1];
    result[2] = v8[2];
    result[3] = v8[3];
  }
  if ( *(_DWORD *)(a1 + 64) <= 985 )
  {
    result = (_DWORD *)a1;
    *(_DWORD *)(a1 + 40) = 154;
    *(_DWORD *)(a1 + 116) = 0;
  }
  return result;
}

//----- (00446B60) --------------------------------------------------------
void __cdecl NPC156(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int v3; // [esp+0h] [ebp-30h]
  int v4; // [esp+4h] [ebp-2Ch]
  int v5; // [esp+8h] [ebp-28h]
  int v6; // [esp+Ch] [ebp-24h]
  int v7; // [esp+10h] [ebp-20h]
  int v8; // [esp+14h] [ebp-1Ch]
  int v9; // [esp+18h] [ebp-18h]
  int v10; // [esp+1Ch] [ebp-14h]
  int v11; // [esp+20h] [ebp-10h]
  int v12; // [esp+24h] [ebp-Ch]
  int v13; // [esp+28h] [ebp-8h]
  int v14; // [esp+2Ch] [ebp-4h]

  if ( *(_DWORD *)(a1 + 4) & 0xFF )
  {
    createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectRisingDisc, 0);
    *(_BYTE *)a1 = 0;
  }
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  v3 = 96;
  v4 = 112;
  v5 = 112;
  v6 = 128;
  v7 = 112;
  v8 = 112;
  v9 = 128;
  v10 = 128;
  v11 = 128;
  v12 = 112;
  v13 = 144;
  v14 = 128;
  if ( ++*(_DWORD *)(a1 + 104) > 2 )
    *(_DWORD *)(a1 + 104) = 0;
  v1 = &v3 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  v2[3] = v1[3];
  if ( ++*(_DWORD *)(a1 + 108) > 300 )
  {
    createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectRisingDisc, 0);
    *(_BYTE *)a1 = 0;
  }
}

//----- (00446CA0) --------------------------------------------------------
signed int __cdecl NPC157(int a1)
{
  int v1; // ST10_4
  int v2; // ST0C_4
  int v3; // ST08_4
  int v4; // eax
  int v5; // ST10_4
  int v6; // ST0C_4
  int v7; // ST08_4
  int v8; // eax
  _DWORD *v9; // ecx
  signed int result; // eax
  signed int i; // [esp+4h] [ebp-14h]
  signed int ia; // [esp+4h] [ebp-14h]

  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 8) += 4096;
      *(_DWORD *)(a1 + 12) += 4096;
      if ( *(_DWORD *)(a1 + 76) )
        *(_DWORD *)(a1 + 116) = 20;
      else
        *(_DWORD *)(a1 + 116) = 10;
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 20) = 0;
      *(_WORD *)(a1 + 80) |= 0x40u;
      break;
    case 0xA:
      *(_WORD *)(a1 + 80) &= 0xFF7Fu;
      *(_DWORD *)(a1 + 164) = 0;
      if ( quote.YPos < *(_DWORD *)(a1 + 12) + 12800
        && quote.YPos > *(_DWORD *)(a1 + 12) - 204800
        && quote.XPos < *(_DWORD *)(a1 + 8) + 12800
        && quote.XPos > *(_DWORD *)(a1 + 8) - 12800 )
      {
        *(_DWORD *)(a1 + 116) = 11;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    case 0xB:
      if ( ++*(_DWORD *)(a1 + 120) % 10 == 6 )
        playSoundEffect(SFXBlockMove, 1);
      if ( *(_DWORD *)(a1 + 4) & 2 )
      {
        *(_DWORD *)(a1 + 20) = 0;
        *(_DWORD *)(a1 + 76) = 2;
        *(_DWORD *)(a1 + 116) = 20;
        setQuake(10);
        playSoundEffect(SFXLargeObjectHitGround, 1);
        for ( i = 0; i < 4; ++i )
        {
          v1 = random(-1536, 0);
          v2 = random(-341, 341);
          v3 = *(_DWORD *)(a1 + 12) - 0x2000;
          v4 = random(-12, 12);
          createNPC(NPCSmoke, *(_DWORD *)(a1 + 8) + (v4 << 9), v3, v2, v1, 0, 0, 256);
        }
      }
      else
      {
        if ( quote.collisionFlags & 2 )
        {
          *(_WORD *)(a1 + 80) |= 0x80u;
          *(_DWORD *)(a1 + 164) = 100;
        }
        else
        {
          *(_WORD *)(a1 + 80) &= 0xFF7Fu;
          *(_DWORD *)(a1 + 164) = 0;
        }
        *(_DWORD *)(a1 + 20) -= 32;
      }
      break;
    case 0x14:
      *(_WORD *)(a1 + 80) &= 0xFF7Fu;
      *(_DWORD *)(a1 + 164) = 0;
      if ( quote.YPos > *(_DWORD *)(a1 + 12) - 12800
        && quote.YPos < *(_DWORD *)(a1 + 12) + 204800
        && quote.XPos < *(_DWORD *)(a1 + 8) + 12800
        && quote.XPos > *(_DWORD *)(a1 + 8) - 12800 )
      {
        *(_DWORD *)(a1 + 116) = 21;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    case 0x15:
      if ( ++*(_DWORD *)(a1 + 120) % 10 == 6 )
        playSoundEffect(SFXBlockMove, 1);
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 20) = 0;
        *(_DWORD *)(a1 + 76) = 0;
        *(_DWORD *)(a1 + 116) = 10;
        setQuake(10);
        playSoundEffect(SFXLargeObjectHitGround, 1);
        for ( ia = 0; ia < 4; ++ia )
        {
          v5 = random(-1536, 0);
          v6 = random(-341, 341);
          v7 = *(_DWORD *)(a1 + 12) + 0x2000;
          v8 = random(-12, 12);
          createNPC(NPCSmoke, *(_DWORD *)(a1 + 8) + (v8 << 9), v7, v6, v5, 0, 0, 256);
        }
      }
      else
      {
        if ( quote.collisionFlags & 8 )
        {
          *(_WORD *)(a1 + 80) |= 0x80u;
          *(_DWORD *)(a1 + 164) = 100;
        }
        else
        {
          *(_WORD *)(a1 + 80) &= 0xFF7Fu;
          *(_DWORD *)(a1 + 164) = 0;
        }
        *(_DWORD *)(a1 + 20) += 32;
      }
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 20) > 512 )
    *(_DWORD *)(a1 + 20) = 512;
  if ( *(_DWORD *)(a1 + 20) < -512 )
    *(_DWORD *)(a1 + 20) = -512;
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v9 = (_DWORD *)(a1 + 84);
  *v9 = 16;
  v9[1] = 0;
  v9[2] = 48;
  result = 32;
  v9[3] = 32;
  return result;
}

//----- (00447180) --------------------------------------------------------
int __cdecl NPC158(int a1)
{
  int v1; // edx
  int v2; // ecx
  int *v3; // eax
  int *v4; // ecx
  int result; // eax
  int v6; // [esp+4h] [ebp-88h]
  int v7; // [esp+8h] [ebp-84h]
  int v8; // [esp+Ch] [ebp-80h]
  int v9; // [esp+10h] [ebp-7Ch]
  int v10; // [esp+14h] [ebp-78h]
  int v11; // [esp+18h] [ebp-74h]
  int v12; // [esp+1Ch] [ebp-70h]
  int v13; // [esp+20h] [ebp-6Ch]
  int v14; // [esp+24h] [ebp-68h]
  int v15; // [esp+28h] [ebp-64h]
  int v16; // [esp+2Ch] [ebp-60h]
  int v17; // [esp+30h] [ebp-5Ch]
  int v18; // [esp+34h] [ebp-58h]
  int v19; // [esp+38h] [ebp-54h]
  int v20; // [esp+3Ch] [ebp-50h]
  int v21; // [esp+40h] [ebp-4Ch]
  int v22; // [esp+44h] [ebp-48h]
  int v23; // [esp+48h] [ebp-44h]
  int v24; // [esp+4Ch] [ebp-40h]
  int v25; // [esp+50h] [ebp-3Ch]
  int v26; // [esp+54h] [ebp-38h]
  int v27; // [esp+58h] [ebp-34h]
  int v28; // [esp+5Ch] [ebp-30h]
  int v29; // [esp+60h] [ebp-2Ch]
  int v30; // [esp+64h] [ebp-28h]
  int v31; // [esp+68h] [ebp-24h]
  int v32; // [esp+6Ch] [ebp-20h]
  int v33; // [esp+70h] [ebp-1Ch]
  int v34; // [esp+74h] [ebp-18h]
  int v35; // [esp+78h] [ebp-14h]
  int v36; // [esp+7Ch] [ebp-10h]
  int v37; // [esp+80h] [ebp-Ch]
  int v38; // [esp+84h] [ebp-8h]
  int v39; // [esp+88h] [ebp-4h]

  v8 = 0;
  v9 = 224;
  v10 = 16;
  v11 = 240;
  v12 = 16;
  v13 = 224;
  v14 = 32;
  v15 = 240;
  v16 = 32;
  v17 = 224;
  v18 = 48;
  v19 = 240;
  v20 = 48;
  v21 = 224;
  v22 = 64;
  v23 = 240;
  v24 = 64;
  v25 = 224;
  v26 = 80;
  v27 = 240;
  v28 = 80;
  v29 = 224;
  v30 = 96;
  v31 = 240;
  v32 = 96;
  v33 = 224;
  v34 = 112;
  v35 = 240;
  v36 = 112;
  v37 = 224;
  v38 = 128;
  v39 = 240;
  v6 = *(_DWORD *)(a1 + 116);
  if ( v6 )
  {
    if ( v6 != 1 )
      goto LABEL_22;
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    switch ( *(_DWORD *)(a1 + 76) )
    {
      case 0:
        *(_DWORD *)(a1 + 108) = 160;
        break;
      case 1:
        *(_DWORD *)(a1 + 108) = 224;
        break;
      case 2:
        *(_DWORD *)(a1 + 108) = 32;
        break;
      case 3:
        *(_DWORD *)(a1 + 108) = 96;
        break;
      default:
        break;
    }
  }
  *(_DWORD *)(a1 + 16) = 2 * getCos(*(_BYTE *)(a1 + 108));
  *(_DWORD *)(a1 + 20) = 2 * getSin(*(_BYTE *)(a1 + 108));
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  v7 = getArcTan(*(_DWORD *)(a1 + 8) - quote.XPos, *(_DWORD *)(a1 + 12) - quote.YPos);
  if ( v7 >= *(_DWORD *)(a1 + 108) )
  {
    if ( v7 - *(_DWORD *)(a1 + 108) >= 128 )
      v2 = *(_DWORD *)(a1 + 108) - 1;
    else
      v2 = *(_DWORD *)(a1 + 108) + 1;
    *(_DWORD *)(a1 + 108) = v2;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 108) - v7 >= 128 )
      v1 = *(_DWORD *)(a1 + 108) + 1;
    else
      v1 = *(_DWORD *)(a1 + 108) - 1;
    *(_DWORD *)(a1 + 108) = v1;
  }
  if ( *(_DWORD *)(a1 + 108) > 255 )
    *(_DWORD *)(a1 + 108) -= 256;
  if ( *(_DWORD *)(a1 + 108) < 0 )
    *(_DWORD *)(a1 + 108) += 256;
LABEL_22:
  if ( ++*(_DWORD *)(a1 + 100) > 2 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectDrownedQuote, (Directions)4);
  }
  *(_DWORD *)(a1 + 104) = (*(_DWORD *)(a1 + 108) + 16) / 32;
  if ( *(_DWORD *)(a1 + 104) > 7 )
    *(_DWORD *)(a1 + 104) = 7;
  v3 = &v8 + 4 * *(_DWORD *)(a1 + 104);
  v4 = (int *)(a1 + 84);
  *v4 = *v3;
  v4[1] = v3[1];
  v4[2] = v3[2];
  result = v3[3];
  v4[3] = result;
  return result;
}

//----- (004474C0) --------------------------------------------------------
void __cdecl NPC159(int a1)
{
  int v1; // ST10_4
  int v2; // ST0C_4
  int v3; // ST08_4
  int v4; // eax
  int v5; // edx
  _DWORD *v6; // edx
  int v7; // ST10_4
  int v8; // ST0C_4
  int v9; // ST08_4
  int v10; // eax
  int v11; // [esp+0h] [ebp-18h]
  signed int i; // [esp+4h] [ebp-14h]

  v11 = *(_DWORD *)(a1 + 116);
  if ( v11 )
  {
    if ( v11 != 1 )
    {
      if ( v11 == 2 )
      {
        ++*(_DWORD *)(a1 + 120);
        *(_DWORD *)(a1 + 20) += 64;
        if ( *(_DWORD *)(a1 + 12) > 327680 )
          *(_BYTE *)a1 = 0;
      }
      goto LABEL_16;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    for ( i = 0; i < 8; ++i )
    {
      v1 = random(-341, 341);
      v2 = random(-341, 341);
      v3 = *(_DWORD *)(a1 + 12) + (random(-16, 16) << 9);
      v4 = random(-16, 16);
      createNPC(NPCSmoke, *(_DWORD *)(a1 + 8) + (v4 << 9), v3, v2, v1, 0, 0, 256);
    }
  }
  if ( ++*(_DWORD *)(a1 + 120) > 50 )
  {
    *(_DWORD *)(a1 + 116) = 2;
    *(_DWORD *)(a1 + 16) = -256;
  }
  if ( *(_DWORD *)(a1 + 120) / 2 % 2 )
    v5 = *(_DWORD *)(a1 + 8) + 512;
  else
    v5 = *(_DWORD *)(a1 + 8) - 512;
  *(_DWORD *)(a1 + 8) = v5;
LABEL_16:
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  v6 = (_DWORD *)(a1 + 84);
  *v6 = 144;
  v6[1] = 128;
  v6[2] = 192;
  v6[3] = 200;
  if ( *(_DWORD *)(a1 + 120) % 8 == 1 )
  {
    v7 = random(-341, 341);
    v8 = random(-341, 341);
    v9 = *(_DWORD *)(a1 + 12) + (random(-16, 16) << 9);
    v10 = random(-16, 16);
    createNPC(NPCSmoke, *(_DWORD *)(a1 + 8) + (v10 << 9), v9, v8, v7, 0, 0, 256);
  }
}

//----- (00447700) --------------------------------------------------------
int *__cdecl NPC160(int a1)
{
  int v1; // ST10_4
  int v2; // ST0C_4
  int v3; // ST08_4
  int v4; // eax
  int v5; // ST10_4
  int v6; // ST0C_4
  int v7; // ST08_4
  int v8; // eax
  int *v9; // edx
  int *result; // eax
  int v11; // [esp+8h] [ebp-88h]
  int v12; // [esp+Ch] [ebp-84h]
  int v13; // [esp+10h] [ebp-80h]
  int v14; // [esp+14h] [ebp-7Ch]
  int v15; // [esp+18h] [ebp-78h]
  int v16; // [esp+1Ch] [ebp-74h]
  int v17; // [esp+20h] [ebp-70h]
  int v18; // [esp+24h] [ebp-6Ch]
  int v19; // [esp+28h] [ebp-68h]
  int v20; // [esp+2Ch] [ebp-64h]
  int v21; // [esp+30h] [ebp-60h]
  int v22; // [esp+34h] [ebp-5Ch]
  int v23; // [esp+38h] [ebp-58h]
  int v24; // [esp+3Ch] [ebp-54h]
  int v25; // [esp+40h] [ebp-50h]
  int v26; // [esp+44h] [ebp-4Ch]
  int v27; // [esp+48h] [ebp-48h]
  int v28; // [esp+4Ch] [ebp-44h]
  int v29; // [esp+50h] [ebp-40h]
  int v30; // [esp+54h] [ebp-3Ch]
  int v31; // [esp+58h] [ebp-38h]
  int v32; // [esp+5Ch] [ebp-34h]
  int v33; // [esp+60h] [ebp-30h]
  int v34; // [esp+64h] [ebp-2Ch]
  int v35; // [esp+68h] [ebp-28h]
  int v36; // [esp+6Ch] [ebp-24h]
  int v37; // [esp+70h] [ebp-20h]
  int v38; // [esp+74h] [ebp-1Ch]
  int v39; // [esp+78h] [ebp-18h]
  int v40; // [esp+7Ch] [ebp-14h]
  int v41; // [esp+80h] [ebp-10h]
  int v42; // [esp+84h] [ebp-Ch]
  int i; // [esp+8Ch] [ebp-4h]

  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_WORD *)(a1 + 80) &= 0xFFFEu;
      *(_DWORD *)(a1 + 116) = 1;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( *(_DWORD *)(a1 + 8) >= quote.XPos )
        *(_DWORD *)(a1 + 76) = 0;
      else
        *(_DWORD *)(a1 + 76) = 2;
      *(_DWORD *)(a1 + 20) = 2560;
      if ( *(_DWORD *)(a1 + 12) >= 0x10000 )
      {
        *(_WORD *)(a1 + 80) &= 0xFFF7u;
        *(_DWORD *)(a1 + 116) = 2;
      }
      else
      {
        ++*(_DWORD *)(a1 + 108);
      }
      break;
    case 2:
      *(_DWORD *)(a1 + 20) = 2560;
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        killNPC(161, 1);
        for ( i = 0; i < 4; ++i )
        {
          v1 = random(-1536, 0);
          v2 = random(-341, 341);
          v3 = *(_DWORD *)(a1 + 12) + (random(-12, 12) << 9);
          v4 = random(-12, 12);
          createNPC(NPCSmoke, *(_DWORD *)(a1 + 8) + (v4 << 9), v3, v2, v1, 0, 0, 256);
        }
        *(_DWORD *)(a1 + 116) = 3;
        *(_DWORD *)(a1 + 120) = 0;
        setQuake(30);
        playSoundEffect(SFXLargeObjectHitGround, 1);
        playSoundEffect(SFXExplosion, 1);
      }
      if ( *(_DWORD *)(a1 + 12) < quote.YPos && quote.collisionFlags & 8 )
        *(_DWORD *)(a1 + 164) = 20;
      else
        *(_DWORD *)(a1 + 164) = 0;
      break;
    case 3:
      *(_DWORD *)(a1 + 164) = 20;
      *(_DWORD *)(a1 + 164) = 0;
      if ( ++*(_DWORD *)(a1 + 120) > 24 )
      {
        *(_DWORD *)(a1 + 116) = 4;
        *(_DWORD *)(a1 + 108) = 0;
        *(_DWORD *)(a1 + 112) = 0;
      }
      break;
    case 4:
      superYPos = *(_DWORD *)(a1 + 8);
      curlyShootY = *(_DWORD *)(a1 + 12);
      if ( *(unsigned __int8 *)(a1 + 156) % 2 == 1 )
      {
        v5 = random(-1536, 1536);
        v6 = random(-1536, 1536);
        v7 = *(_DWORD *)(a1 + 12) + (random(-12, 12) << 9);
        v8 = random(-12, 12);
        createNPC((NPCNames)161, *(_DWORD *)(a1 + 8) + (v8 << 9), v7, v6, v5, 0, 0, 256);
        if ( ++*(_DWORD *)(a1 + 108) > 30 )
        {
          *(_DWORD *)(a1 + 108) = 0;
          *(_DWORD *)(a1 + 116) = 5;
          *(_DWORD *)(a1 + 20) = -3072;
          *(_WORD *)(a1 + 80) |= 8u;
        }
      }
      break;
    case 5:
      superYPos = *(_DWORD *)(a1 + 8);
      curlyShootY = *(_DWORD *)(a1 + 12);
      if ( ++*(_DWORD *)(a1 + 108) > 60 )
      {
        *(_DWORD *)(a1 + 108) = 0;
        *(_DWORD *)(a1 + 116) = 6;
      }
      break;
    case 6:
      superYPos = quote.XPos;
      curlyShootY = 3276800;
      if ( ++*(_DWORD *)(a1 + 108) > 110 )
      {
        *(_DWORD *)(a1 + 108) = 10;
        *(_DWORD *)(a1 + 8) = quote.XPos;
        *(_DWORD *)(a1 + 12) = 0;
        *(_DWORD *)(a1 + 20) = 1535;
        *(_DWORD *)(a1 + 116) = 1;
      }
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
    case 1:
      *(_DWORD *)(a1 + 104) = 3;
      break;
    case 2:
      *(_DWORD *)(a1 + 104) = 3;
      break;
    case 3:
      *(_DWORD *)(a1 + 104) = 2;
      break;
    case 4:
      *(_DWORD *)(a1 + 104) = 0;
      break;
    case 5:
      *(_DWORD *)(a1 + 104) = 3;
      break;
    case 6:
      *(_DWORD *)(a1 + 104) = 3;
      break;
    default:
      break;
  }
  v27 = 0;
  v28 = 0;
  v29 = 40;
  v30 = 24;
  v31 = 40;
  v32 = 0;
  v33 = 80;
  v34 = 24;
  v35 = 80;
  v36 = 0;
  v37 = 120;
  v38 = 24;
  v39 = 120;
  v40 = 0;
  v41 = 160;
  v42 = 24;
  v11 = 0;
  v12 = 24;
  v13 = 40;
  v14 = 48;
  v15 = 40;
  v16 = 24;
  v17 = 80;
  v18 = 48;
  v19 = 80;
  v20 = 24;
  v21 = 120;
  v22 = 48;
  v23 = 120;
  v24 = 24;
  v25 = 160;
  v26 = 48;
  if ( *(_DWORD *)(a1 + 76) )
    v9 = &v11 + 4 * *(_DWORD *)(a1 + 104);
  else
    v9 = &v27 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v9;
  result[1] = v9[1];
  result[2] = v9[2];
  result[3] = v9[3];
  return result;
}
// 4BBA28: using guessed type int curlyShootY;
// 4BBA30: using guessed type int superYPos;

//----- (00447CB0) --------------------------------------------------------
int *__cdecl NPC161(int a1)
{
  int v1; // ecx
  int v2; // eax
  int *v3; // edx
  int *result; // eax
  int v5; // [esp+0h] [ebp-30h]
  int v6; // [esp+4h] [ebp-2Ch]
  int v7; // [esp+8h] [ebp-28h]
  int v8; // [esp+Ch] [ebp-24h]
  int v9; // [esp+10h] [ebp-20h]
  int v10; // [esp+14h] [ebp-1Ch]
  int v11; // [esp+18h] [ebp-18h]
  int v12; // [esp+1Ch] [ebp-14h]
  int v13; // [esp+20h] [ebp-10h]
  int v14; // [esp+24h] [ebp-Ch]
  int v15; // [esp+28h] [ebp-8h]
  int v16; // [esp+2Ch] [ebp-4h]

  *(_DWORD *)(a1 + 68) = 0;
  if ( *(_DWORD *)(a1 + 8) >= superYPos )
    v1 = *(_DWORD *)(a1 + 16) - 64;
  else
    v1 = *(_DWORD *)(a1 + 16) + 64;
  *(_DWORD *)(a1 + 16) = v1;
  if ( *(_DWORD *)(a1 + 12) >= curlyShootY )
    v2 = *(_DWORD *)(a1 + 20) - 64;
  else
    v2 = *(_DWORD *)(a1 + 20) + 64;
  *(_DWORD *)(a1 + 20) = v2;
  if ( *(_DWORD *)(a1 + 16) < -4605 )
    *(_DWORD *)(a1 + 16) = -4605;
  if ( *(_DWORD *)(a1 + 16) > 4605 )
    *(_DWORD *)(a1 + 16) = 4605;
  if ( *(_DWORD *)(a1 + 20) < -4605 )
    *(_DWORD *)(a1 + 20) = -4605;
  if ( *(_DWORD *)(a1 + 20) > 4605 )
    *(_DWORD *)(a1 + 20) = 4605;
  if ( *(_DWORD *)(a1 + 64) < 100 )
  {
    *(_WORD *)(a1 + 80) &= 0xFFDFu;
    *(_WORD *)(a1 + 80) &= 0xFFFBu;
    *(_DWORD *)(a1 + 164) = 0;
    *(_DWORD *)(a1 + 104) = 2;
  }
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 104) < 2 )
    *(_DWORD *)(a1 + 104) = random(0, 10) != 2;
  v5 = 0;
  v6 = 48;
  v7 = 16;
  v8 = 64;
  v9 = 16;
  v10 = 48;
  v11 = 32;
  v12 = 64;
  v13 = 32;
  v14 = 48;
  v15 = 48;
  v16 = 64;
  v3 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v3;
  result[1] = v3[1];
  result[2] = v3[2];
  result[3] = v3[3];
  return result;
}
// 4BBA28: using guessed type int curlyShootY;
// 4BBA30: using guessed type int superYPos;

//----- (00447E90) --------------------------------------------------------
int __cdecl NPC162(int a1)
{
  int v1; // ST10_4
  int v2; // ST0C_4
  int v3; // ST08_4
  int v4; // eax
  _DWORD *v5; // edx
  _DWORD *v6; // edx
  int v7; // ST08_4
  int v8; // eax
  _DWORD *v9; // edx
  _DWORD *v10; // edx
  _DWORD *v11; // ecx
  int v12; // ST0C_4
  int v13; // ST08_4
  int v14; // eax
  int result; // eax
  signed int i; // [esp+34h] [ebp-4h]

  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      killNPC(161, 1);
      playSoundEffect(SFXExplosion, 1);
      for ( i = 0; i < 10; ++i )
      {
        v1 = random(-1536, 1536);
        v2 = random(-1536, 1536);
        v3 = *(_DWORD *)(a1 + 12) + (random(-12, 12) << 9);
        v4 = random(-12, 12);
        createNPC(NPCSmoke, *(_DWORD *)(a1 + 8) + (v4 << 9), v3, v2, v1, 0, 0, 256);
      }
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      if ( *(_DWORD *)(a1 + 76) )
      {
        v6 = (_DWORD *)(a1 + 84);
        *v6 = 40;
        v6[1] = 24;
        v6[2] = 80;
        v6[3] = 48;
      }
      else
      {
        v5 = (_DWORD *)(a1 + 84);
        *v5 = 40;
        v5[1] = 0;
        v5[2] = 80;
        v5[3] = 24;
      }
      *(_DWORD *)(a1 + 108) = 0;
      *(_DWORD *)(a1 + 116) = 1;
      goto LABEL_12;
    case 1:
LABEL_12:
      if ( !(++*(_DWORD *)(a1 + 108) % 4) )
      {
        v7 = *(_DWORD *)(a1 + 12) + (random(-12, 12) << 9);
        v8 = random(-12, 12);
        createNPC((NPCNames)161, *(_DWORD *)(a1 + 8) + (v8 << 9), v7, 0, 0, 0, 0, 256);
      }
      if ( *(_DWORD *)(a1 + 108) > 160 )
      {
        *(_DWORD *)(a1 + 108) = 0;
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 12);
      }
      break;
    case 2:
      setQuake(2);
      if ( ++*(_DWORD *)(a1 + 108) > 240 )
      {
        v11 = (_DWORD *)(a1 + 84);
        *v11 = 0;
        v11[1] = 0;
        v11[2] = 0;
        v11[3] = 0;
        *(_DWORD *)(a1 + 108) = 0;
        *(_DWORD *)(a1 + 116) = 3;
      }
      else
      {
        if ( *(_DWORD *)(a1 + 76) )
        {
          v10 = (_DWORD *)(a1 + 84);
          *v10 = 40;
          v10[1] = 24;
          v10[2] = 80;
          v10[3] = 48;
        }
        else
        {
          v9 = (_DWORD *)(a1 + 84);
          *v9 = 40;
          v9[1] = 0;
          v9[2] = 80;
          v9[3] = 24;
        }
        *(_DWORD *)(a1 + 88) += *(_DWORD *)(a1 + 108) / 8;
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 36) + (*(_DWORD *)(a1 + 108) / 8 << 9);
        *(_DWORD *)(a1 + 84) -= *(_DWORD *)(a1 + 108) / 2 % 2;
      }
      if ( *(_DWORD *)(a1 + 108) % 3 == 2 )
      {
        v12 = random(-512, 512);
        v13 = *(_DWORD *)(a1 + 12) - 6144;
        v14 = random(-12, 12);
        createNPC((NPCNames)161, *(_DWORD *)(a1 + 8) + (v14 << 9), v13, v12, 256, 0, 0, 256);
      }
      if ( *(_DWORD *)(a1 + 108) % 4 == 2 )
        playSoundEffect(SFXBubble, 1);
      break;
    case 3:
      if ( ++*(_DWORD *)(a1 + 108) >= 60 )
      {
        killNPC(161, 1);
        *(_BYTE *)a1 = 0;
      }
      break;
    default:
      break;
  }
  result = a1;
  superYPos = *(_DWORD *)(a1 + 8);
  curlyShootY = -512000;
  return result;
}
// 4BBA28: using guessed type int curlyShootY;
// 4BBA30: using guessed type int superYPos;

//----- (004482A0) --------------------------------------------------------
int *__cdecl NPC163(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+0h] [ebp-44h]
  int v4; // [esp+4h] [ebp-40h]
  int v5; // [esp+8h] [ebp-3Ch]
  int v6; // [esp+Ch] [ebp-38h]
  int v7; // [esp+10h] [ebp-34h]
  int v8; // [esp+14h] [ebp-30h]
  int v9; // [esp+18h] [ebp-2Ch]
  int v10; // [esp+1Ch] [ebp-28h]
  int v11; // [esp+20h] [ebp-24h]
  int v12; // [esp+24h] [ebp-20h]
  int v13; // [esp+28h] [ebp-1Ch]
  int v14; // [esp+2Ch] [ebp-18h]
  int v15; // [esp+30h] [ebp-14h]
  int v16; // [esp+34h] [ebp-10h]
  int v17; // [esp+38h] [ebp-Ch]
  int v18; // [esp+3Ch] [ebp-8h]
  int v19; // [esp+40h] [ebp-4h]

  v12 = 192;
  v13 = 0;
  v14 = 208;
  v15 = 16;
  v16 = 208;
  v17 = 0;
  v18 = 224;
  v19 = 16;
  v4 = 192;
  v5 = 16;
  v6 = 208;
  v7 = 32;
  v8 = 208;
  v9 = 16;
  v10 = 224;
  v11 = 32;
  v3 = *(_DWORD *)(a1 + 116);
  if ( v3 )
  {
    if ( v3 != 1 )
    {
      if ( v3 == 2 && ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      goto LABEL_11;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 100) = 0;
  }
  if ( random(0, 120) == 10 )
  {
    *(_DWORD *)(a1 + 116) = 2;
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 104) = 1;
  }
LABEL_11:
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v12 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (00448410) --------------------------------------------------------
int *__cdecl NPC164(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+0h] [ebp-44h]
  int v4; // [esp+4h] [ebp-40h]
  int v5; // [esp+8h] [ebp-3Ch]
  int v6; // [esp+Ch] [ebp-38h]
  int v7; // [esp+10h] [ebp-34h]
  int v8; // [esp+14h] [ebp-30h]
  int v9; // [esp+18h] [ebp-2Ch]
  int v10; // [esp+1Ch] [ebp-28h]
  int v11; // [esp+20h] [ebp-24h]
  int v12; // [esp+24h] [ebp-20h]
  int v13; // [esp+28h] [ebp-1Ch]
  int v14; // [esp+2Ch] [ebp-18h]
  int v15; // [esp+30h] [ebp-14h]
  int v16; // [esp+34h] [ebp-10h]
  int v17; // [esp+38h] [ebp-Ch]
  int v18; // [esp+3Ch] [ebp-8h]
  int v19; // [esp+40h] [ebp-4h]

  v12 = 224;
  v13 = 0;
  v14 = 240;
  v15 = 16;
  v16 = 240;
  v17 = 0;
  v18 = 256;
  v19 = 16;
  v4 = 224;
  v5 = 16;
  v6 = 240;
  v7 = 32;
  v8 = 240;
  v9 = 16;
  v10 = 256;
  v11 = 32;
  v3 = *(_DWORD *)(a1 + 116);
  if ( v3 )
  {
    if ( v3 != 1 )
    {
      if ( v3 == 2 && ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      goto LABEL_11;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 100) = 0;
  }
  if ( random(0, 120) == 10 )
  {
    *(_DWORD *)(a1 + 116) = 2;
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 104) = 1;
  }
LABEL_11:
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v12 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (00448580) --------------------------------------------------------
int __cdecl NPC165(int a1)
{
  int result; // eax
  int *v2; // edx
  int v3; // [esp+0h] [ebp-34h]
  int v4; // [esp+4h] [ebp-30h]
  int v5; // [esp+8h] [ebp-2Ch]
  int v6; // [esp+Ch] [ebp-28h]
  int v7; // [esp+10h] [ebp-24h]
  int v8; // [esp+14h] [ebp-20h]
  int v9; // [esp+18h] [ebp-1Ch]
  int v10; // [esp+1Ch] [ebp-18h]
  int v11; // [esp+20h] [ebp-14h]
  int v12; // [esp+24h] [ebp-10h]
  int v13; // [esp+28h] [ebp-Ch]
  int v14; // [esp+2Ch] [ebp-8h]
  int v15; // [esp+30h] [ebp-4h]

  v4 = 192;
  v5 = 96;
  v6 = 208;
  v7 = 112;
  v8 = 208;
  v9 = 96;
  v10 = 224;
  v11 = 112;
  v12 = 144;
  v13 = 96;
  v14 = 160;
  v15 = 112;
  v3 = *(_DWORD *)(a1 + 116);
  if ( v3 )
  {
    if ( v3 != 1 )
      goto LABEL_12;
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 12) += 5120;
  }
  *(_DWORD *)(a1 + 104) = *(_DWORD *)(a1 + 76) == 2
                       && quote.XPos > *(_DWORD *)(a1 + 8) - 0x4000
                       && quote.XPos < *(_DWORD *)(a1 + 8) + 0x4000
                       && quote.YPos > *(_DWORD *)(a1 + 12) - 0x2000
                       && quote.YPos < *(_DWORD *)(a1 + 12) + 0x2000;
LABEL_12:
  if ( *(_DWORD *)(a1 + 76) )
  {
    v2 = &v4 + 4 * *(_DWORD *)(a1 + 104);
    result = a1 + 84;
    *(_DWORD *)result = *v2;
    *(_DWORD *)(result + 4) = v2[1];
    *(_DWORD *)(result + 8) = v2[2];
    *(_DWORD *)(result + 12) = v2[3];
  }
  else
  {
    result = a1 + 84;
    *(_DWORD *)result = v12;
    *(_DWORD *)(result + 4) = v13;
    *(_DWORD *)(result + 8) = v14;
    *(_DWORD *)(result + 12) = v15;
  }
  return result;
}

//----- (004486E0) --------------------------------------------------------
int __cdecl NPC166(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  int v4; // [esp+0h] [ebp-24h]
  int v5; // [esp+4h] [ebp-20h]
  int v6; // [esp+8h] [ebp-1Ch]
  int v7; // [esp+Ch] [ebp-18h]
  int v8; // [esp+10h] [ebp-14h]
  int v9; // [esp+14h] [ebp-10h]
  int v10; // [esp+18h] [ebp-Ch]
  int v11; // [esp+1Ch] [ebp-8h]
  int v12; // [esp+20h] [ebp-4h]

  v5 = 144;
  v6 = 104;
  v7 = 184;
  v8 = 128;
  v9 = 184;
  v10 = 104;
  v11 = 224;
  v12 = 128;
  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      if ( v4 == 2 && ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      goto LABEL_11;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 100) = 0;
  }
  if ( random(0, 120) == 10 )
  {
    *(_DWORD *)(a1 + 116) = 2;
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 104) = 1;
  }
LABEL_11:
  v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}

//----- (004487F0) --------------------------------------------------------
int *__cdecl NPC167(int a1)
{
  int v1; // ST10_4
  int v2; // ST0C_4
  int v3; // ST08_4
  int v4; // eax
  int *v5; // edx
  int *result; // eax
  signed int i; // [esp+4h] [ebp-34h]
  int v8; // [esp+8h] [ebp-30h]
  int v9; // [esp+Ch] [ebp-2Ch]
  int v10; // [esp+10h] [ebp-28h]
  int v11; // [esp+14h] [ebp-24h]
  int v12; // [esp+18h] [ebp-20h]
  int v13; // [esp+1Ch] [ebp-1Ch]
  int v14; // [esp+20h] [ebp-18h]
  int v15; // [esp+24h] [ebp-14h]
  int v16; // [esp+28h] [ebp-10h]
  int v17; // [esp+2Ch] [ebp-Ch]
  int v18; // [esp+30h] [ebp-8h]
  int v19; // [esp+34h] [ebp-4h]

  v8 = 304;
  v9 = 0;
  v10 = 320;
  v11 = 16;
  v12 = 304;
  v13 = 16;
  v14 = 320;
  v15 = 32;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 1;
      break;
    case 0xA:
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 20) += 64;
      if ( *(_DWORD *)(a1 + 20) > 1535 )
        *(_DWORD *)(a1 + 20) = 1535;
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
      break;
    case 0x14:
      *(_DWORD *)(a1 + 116) = 21;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 104) = 0;
      playSoundEffect(SFXTeleport, 1);
      goto LABEL_7;
    case 0x15:
LABEL_7:
      if ( ++*(_DWORD *)(a1 + 104) > 2 )
        *(_DWORD *)(a1 + 104) = 1;
      if ( ++*(_DWORD *)(a1 + 120) > 100 )
      {
        for ( i = 0; i < 4; ++i )
        {
          v1 = random(-1536, 0);
          v2 = random(-341, 341);
          v3 = *(_DWORD *)(a1 + 12) + (random(-12, 12) << 9);
          v4 = random(-12, 12);
          createNPC(NPCSmoke, *(_DWORD *)(a1 + 8) + (v4 << 9), v3, v2, v1, 0, 0, 256);
        }
        *(_BYTE *)a1 = 0;
      }
      break;
    default:
      break;
  }
  v5 = &v8 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v5;
  result[1] = v5[1];
  result[2] = v5[2];
  result[3] = v5[3];
  return result;
}

//----- (00448A10) --------------------------------------------------------
signed int __cdecl NPC168(int a1)
{
  _DWORD *v1; // ecx
  signed int result; // eax

  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 8);
      goto LABEL_4;
    case 0xB:
LABEL_4:
      ++*(_DWORD *)(a1 + 120);
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 32);
      if ( *(_DWORD *)(a1 + 120) / 3 % 2 )
        *(_DWORD *)(a1 + 8) += 512;
      break;
    case 0x14:
      *(_DWORD *)(a1 + 116) = 21;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 20) = -1024;
      *(_DWORD *)(a1 + 16) = 256;
      playSoundEffect(SFXSillyExplosion, 1);
      goto LABEL_8;
    case 0x15:
LABEL_8:
      *(_DWORD *)(a1 + 20) += 16;
      *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
      if ( *(_DWORD *)(a1 + 120) && *(_DWORD *)(a1 + 4) & 8 )
      {
        playSoundEffect(SFXlargeExplosion, 1);
        setQuake(40);
        *(_DWORD *)(a1 + 116) = 0;
      }
      if ( !*(_DWORD *)(a1 + 120) )
        ++*(_DWORD *)(a1 + 120);
      break;
    default:
      break;
  }
  v1 = (_DWORD *)(a1 + 84);
  *v1 = 264;
  v1[1] = 56;
  v1[2] = 320;
  result = 96;
  v1[3] = 96;
  return result;
}

//----- (00448BE0) --------------------------------------------------------
int __cdecl NPC169(int a1)
{
  int v1; // ecx
  int *v2; // eax
  int *v3; // ecx
  int result; // eax
  int v5; // [esp+4h] [ebp-120h]
  int v6; // [esp+8h] [ebp-11Ch]
  int v7; // [esp+Ch] [ebp-118h]
  int v8; // [esp+10h] [ebp-114h]
  int v9; // [esp+14h] [ebp-110h]
  int v10; // [esp+18h] [ebp-10Ch]
  int v11; // [esp+1Ch] [ebp-108h]
  int v12; // [esp+20h] [ebp-104h]
  int v13; // [esp+24h] [ebp-100h]
  int v14; // [esp+28h] [ebp-FCh]
  int v15; // [esp+2Ch] [ebp-F8h]
  int v16; // [esp+30h] [ebp-F4h]
  int v17; // [esp+34h] [ebp-F0h]
  int v18; // [esp+38h] [ebp-ECh]
  int v19; // [esp+3Ch] [ebp-E8h]
  int v20; // [esp+40h] [ebp-E4h]
  int v21; // [esp+44h] [ebp-E0h]
  int v22; // [esp+48h] [ebp-DCh]
  int v23; // [esp+4Ch] [ebp-D8h]
  int v24; // [esp+50h] [ebp-D4h]
  int v25; // [esp+54h] [ebp-D0h]
  int v26; // [esp+58h] [ebp-CCh]
  int v27; // [esp+5Ch] [ebp-C8h]
  int v28; // [esp+60h] [ebp-C4h]
  int v29; // [esp+64h] [ebp-C0h]
  int v30; // [esp+68h] [ebp-BCh]
  int v31; // [esp+6Ch] [ebp-B8h]
  int v32; // [esp+70h] [ebp-B4h]
  int v33; // [esp+74h] [ebp-B0h]
  int v34; // [esp+78h] [ebp-ACh]
  int v35; // [esp+7Ch] [ebp-A8h]
  int v36; // [esp+80h] [ebp-A4h]
  int v37; // [esp+84h] [ebp-A0h]
  int v38; // [esp+88h] [ebp-9Ch]
  int v39; // [esp+8Ch] [ebp-98h]
  int v40; // [esp+90h] [ebp-94h]
  int v41; // [esp+94h] [ebp-90h]
  int v42; // [esp+98h] [ebp-8Ch]
  int v43; // [esp+9Ch] [ebp-88h]
  int v44; // [esp+A0h] [ebp-84h]
  int v45; // [esp+A4h] [ebp-80h]
  int v46; // [esp+A8h] [ebp-7Ch]
  int v47; // [esp+ACh] [ebp-78h]
  int v48; // [esp+B0h] [ebp-74h]
  int v49; // [esp+B4h] [ebp-70h]
  int v50; // [esp+B8h] [ebp-6Ch]
  int v51; // [esp+BCh] [ebp-68h]
  int v52; // [esp+C0h] [ebp-64h]
  int v53; // [esp+C4h] [ebp-60h]
  int v54; // [esp+C8h] [ebp-5Ch]
  int v55; // [esp+CCh] [ebp-58h]
  int v56; // [esp+D0h] [ebp-54h]
  int v57; // [esp+D4h] [ebp-50h]
  int v58; // [esp+D8h] [ebp-4Ch]
  int v59; // [esp+DCh] [ebp-48h]
  int v60; // [esp+E0h] [ebp-44h]
  int v61; // [esp+E4h] [ebp-40h]
  int v62; // [esp+E8h] [ebp-3Ch]
  int v63; // [esp+ECh] [ebp-38h]
  int v64; // [esp+F0h] [ebp-34h]
  int v65; // [esp+F4h] [ebp-30h]
  int v66; // [esp+F8h] [ebp-2Ch]
  int v67; // [esp+FCh] [ebp-28h]
  int v68; // [esp+100h] [ebp-24h]
  int v69; // [esp+104h] [ebp-20h]
  int v70; // [esp+108h] [ebp-1Ch]
  int v71; // [esp+10Ch] [ebp-18h]
  int v72; // [esp+110h] [ebp-14h]
  int v73; // [esp+114h] [ebp-10h]
  int v74; // [esp+118h] [ebp-Ch]
  int v75; // [esp+11Ch] [ebp-8h]
  int v76; // [esp+120h] [ebp-4h]

  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 120) = 30;
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      goto LABEL_5;
    case 1:
LABEL_5:
      if ( !--*(_DWORD *)(a1 + 120) )
      {
        *(_DWORD *)(a1 + 116) = 2;
        ++*(_DWORD *)(a1 + 108);
      }
      break;
    case 2:
      *(_DWORD *)(a1 + 116) = 3;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 104) = 1;
      *(_DWORD *)(a1 + 100) = 0;
      goto LABEL_8;
    case 3:
LABEL_8:
      if ( ++*(_DWORD *)(a1 + 100) > 3 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        if ( ++*(_DWORD *)(a1 + 104) == 2 || *(_DWORD *)(a1 + 104) == 4 )
          playSoundEffect(SFXQuoteHitGround, 1);
      }
      if ( *(_DWORD *)(a1 + 104) > 4 )
        *(_DWORD *)(a1 + 104) = 1;
      if ( *(_DWORD *)(a1 + 76) )
        v1 = *(_DWORD *)(a1 + 16) + 32;
      else
        v1 = *(_DWORD *)(a1 + 16) - 32;
      *(_DWORD *)(a1 + 16) = v1;
      if ( *(_DWORD *)(a1 + 120) < 8
        || *(_DWORD *)(a1 + 8) - 6144 >= quote.XPos
        || *(_DWORD *)(a1 + 8) + 6144 <= quote.XPos
        || *(_DWORD *)(a1 + 12) - 6144 >= quote.YPos
        || *(_DWORD *)(a1 + 12) + 4096 <= quote.YPos )
      {
        if ( ++*(_DWORD *)(a1 + 120) <= 75 )
        {
          if ( *(_DWORD *)(a1 + 4) & 5 )
          {
            if ( *(_DWORD *)(a1 + 112) >= 5 )
            {
              *(_DWORD *)(a1 + 116) = 4;
              *(_DWORD *)(a1 + 120) = 0;
              *(_DWORD *)(a1 + 104) = 7;
              *(_DWORD *)(a1 + 20) = -1535;
            }
            else
            {
              ++*(_DWORD *)(a1 + 112);
            }
          }
          else
          {
            *(_DWORD *)(a1 + 112) = 0;
          }
          if ( !(*(_DWORD *)(a1 + 108) % 2) && *(_DWORD *)(a1 + 120) > 25 )
          {
            *(_DWORD *)(a1 + 116) = 4;
            *(_DWORD *)(a1 + 120) = 0;
            *(_DWORD *)(a1 + 104) = 7;
            *(_DWORD *)(a1 + 20) = -1535;
          }
        }
        else
        {
          *(_DWORD *)(a1 + 116) = 9;
          *(_DWORD *)(a1 + 104) = 0;
        }
      }
      else
      {
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 104) = 5;
        quote.flags |= 2u;
        damagePlayer(5);
      }
      break;
    case 4:
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      if ( ++*(_DWORD *)(a1 + 120) < 30 && *(_DWORD *)(a1 + 120) % 6 == 1 )
      {
        playSoundEffect(SFXEnemyShootProjectile, 1);
        createNPC((NPCNames)170, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 0, 0, *(Directions *)(a1 + 76), 0, 256);
      }
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 116) = 9;
        *(_DWORD *)(a1 + 104) = 8;
        setQuake(30);
        playSoundEffect(SFXLargeObjectHitGround, 1);
      }
      if ( *(_DWORD *)(a1 + 120) >= 8
        && *(_DWORD *)(a1 + 8) - 6144 < quote.XPos
        && *(_DWORD *)(a1 + 8) + 6144 > quote.XPos
        && *(_DWORD *)(a1 + 12) - 6144 < quote.YPos
        && *(_DWORD *)(a1 + 12) + 4096 > quote.YPos )
      {
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 104) = 5;
        quote.flags |= 2u;
        damagePlayer(10);
      }
      break;
    case 9:
      *(_DWORD *)(a1 + 16) = 4 * *(_DWORD *)(a1 + 16) / 5;
      if ( !*(_DWORD *)(a1 + 16) )
        *(_DWORD *)(a1 + 116) = 0;
      break;
    case 0xA:
      quote.XPos = *(_DWORD *)(a1 + 8);
      quote.YPos = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 16) = 4 * *(_DWORD *)(a1 + 16) / 5;
      if ( !*(_DWORD *)(a1 + 16) )
      {
        *(_DWORD *)(a1 + 116) = 11;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 5;
        *(_DWORD *)(a1 + 100) = 0;
      }
      break;
    case 0xB:
      quote.XPos = *(_DWORD *)(a1 + 8);
      quote.YPos = *(_DWORD *)(a1 + 12);
      if ( ++*(_DWORD *)(a1 + 100) > 2 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 6 )
        *(_DWORD *)(a1 + 104) = 5;
      if ( ++*(_DWORD *)(a1 + 120) > 100 )
        *(_DWORD *)(a1 + 116) = 20;
      break;
    case 0x14:
      playSoundEffect(SFXSillyExplosion, 1);
      quote.flags &= 0xFDu;
      if ( *(_DWORD *)(a1 + 76) )
      {
        quote.XPos -= 2048;
        quote.YPos -= 4096;
        quote.XVel = -1535;
        quote.YVel = -512;
        quote.direction = 0;
        *(_DWORD *)(a1 + 76) = 0;
      }
      else
      {
        quote.XPos += 2048;
        quote.YPos -= 4096;
        quote.XVel = 1535;
        quote.YVel = -512;
        quote.direction = 2;
        *(_DWORD *)(a1 + 76) = 2;
      }
      *(_DWORD *)(a1 + 116) = 21;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 104) = 7;
      goto LABEL_65;
    case 0x15:
LABEL_65:
      if ( ++*(_DWORD *)(a1 + 120) >= 50 )
        *(_DWORD *)(a1 + 116) = 0;
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 20) += 32;
  if ( *(_DWORD *)(a1 + 16) < -768 )
    *(_DWORD *)(a1 + 16) = -768;
  if ( *(_DWORD *)(a1 + 16) > 768 )
    *(_DWORD *)(a1 + 16) = 768;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v41 = 0;
  v42 = 0;
  v43 = 40;
  v44 = 24;
  v45 = 0;
  v46 = 48;
  v47 = 40;
  v48 = 72;
  v49 = 0;
  v50 = 0;
  v51 = 40;
  v52 = 24;
  v53 = 40;
  v54 = 48;
  v55 = 80;
  v56 = 72;
  v57 = 0;
  v58 = 0;
  v59 = 40;
  v60 = 24;
  v61 = 80;
  v62 = 48;
  v63 = 120;
  v64 = 72;
  v65 = 120;
  v66 = 48;
  v67 = 160;
  v68 = 72;
  v69 = 120;
  v70 = 0;
  v71 = 160;
  v72 = 24;
  v73 = 80;
  v74 = 0;
  v75 = 120;
  v76 = 24;
  v5 = 0;
  v6 = 24;
  v7 = 40;
  v8 = 48;
  v9 = 0;
  v10 = 72;
  v11 = 40;
  v12 = 96;
  v13 = 0;
  v14 = 24;
  v15 = 40;
  v16 = 48;
  v17 = 40;
  v18 = 72;
  v19 = 80;
  v20 = 96;
  v21 = 0;
  v22 = 24;
  v23 = 40;
  v24 = 48;
  v25 = 80;
  v26 = 72;
  v27 = 120;
  v28 = 96;
  v29 = 120;
  v30 = 72;
  v31 = 160;
  v32 = 96;
  v33 = 120;
  v34 = 24;
  v35 = 160;
  v36 = 48;
  v37 = 80;
  v38 = 24;
  v39 = 120;
  v40 = 48;
  if ( *(_DWORD *)(a1 + 76) )
    v2 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  else
    v2 = &v41 + 4 * *(_DWORD *)(a1 + 104);
  v3 = (int *)(a1 + 84);
  *v3 = *v2;
  v3[1] = v2[1];
  v3[2] = v2[2];
  result = v2[3];
  v3[3] = result;
  return result;
}

//----- (004495A0) --------------------------------------------------------
void __cdecl NPC170(void *Frame_1_A_4)
{
  int v1; // eax
  int v2; // ecx
  int *v3; // eax
  int *v4; // ecx
  int v5; // [esp+0h] [ebp-48h]
  int v6; // [esp+4h] [ebp-44h]
  int v7; // [esp+8h] [ebp-40h]
  int v8; // [esp+Ch] [ebp-3Ch]
  int v9; // [esp+10h] [ebp-38h]
  int v10; // [esp+14h] [ebp-34h]
  int v11; // [esp+18h] [ebp-30h]
  int v12; // [esp+1Ch] [ebp-2Ch]
  int v13; // [esp+20h] [ebp-28h]
  int v14; // [esp+24h] [ebp-24h]
  int v15; // [esp+28h] [ebp-20h]
  int v16; // [esp+2Ch] [ebp-1Ch]
  int v17; // [esp+30h] [ebp-18h]
  int v18; // [esp+34h] [ebp-14h]
  int v19; // [esp+38h] [ebp-10h]
  int v20; // [esp+3Ch] [ebp-Ch]
  int v21; // [esp+40h] [ebp-8h]
  int v22; // [esp+44h] [ebp-4h]

  v15 = 112;
  v16 = 96;
  v17 = 128;
  v18 = 104;
  v19 = 128;
  v20 = 96;
  v21 = 144;
  v22 = 104;
  v6 = 112;
  v7 = 104;
  v8 = 128;
  v9 = 112;
  v10 = 128;
  v11 = 104;
  v12 = 144;
  v13 = 112;
  v14 = 0;
  if ( !*((_DWORD *)Frame_1_A_4 + 19) && *((_DWORD *)Frame_1_A_4 + 1) & 1 )
    v14 = 1;
  if ( *((_DWORD *)Frame_1_A_4 + 19) == 2 && *((_DWORD *)Frame_1_A_4 + 1) & 4 )
    v14 = 1;
  if ( v14 )
  {
    playSoundEffect(SFXMissileImpact, 1);
    createDustClouds(*((_DWORD *)Frame_1_A_4 + 2), *((_DWORD *)Frame_1_A_4 + 3), 0, 3);
    Vanish_NPC((NPC *)Frame_1_A_4);
    return;
  }
  v5 = *((_DWORD *)Frame_1_A_4 + 29);
  if ( !v5 )
  {
    *((_DWORD *)Frame_1_A_4 + 29) = 1;
    if ( *((_DWORD *)Frame_1_A_4 + 19) )
      v1 = random(-2, -1);
    else
      v1 = random(1, 2);
    *((_DWORD *)Frame_1_A_4 + 4) = v1 << 9;
    *((_DWORD *)Frame_1_A_4 + 5) = random(-2, 0) << 9;
    goto LABEL_16;
  }
  if ( v5 == 1 )
  {
LABEL_16:
    ++*((_DWORD *)Frame_1_A_4 + 27);
    if ( *((_DWORD *)Frame_1_A_4 + 19) )
    {
      *((_DWORD *)Frame_1_A_4 + 4) += 32;
      if ( *((_DWORD *)Frame_1_A_4 + 27) % 3 == 1 )
        createEffect(*((_DWORD *)Frame_1_A_4 + 2) - 4096, *((_DWORD *)Frame_1_A_4 + 3), effectDrownedQuote, 0);
    }
    else
    {
      *((_DWORD *)Frame_1_A_4 + 4) -= 32;
      if ( *((_DWORD *)Frame_1_A_4 + 27) % 3 == 1 )
        createEffect(*((_DWORD *)Frame_1_A_4 + 2) + 4096, *((_DWORD *)Frame_1_A_4 + 3), effectDrownedQuote, right);
    }
    if ( *((_DWORD *)Frame_1_A_4 + 27) >= 50 )
    {
      *((_DWORD *)Frame_1_A_4 + 5) = 0;
    }
    else
    {
      if ( *((_DWORD *)Frame_1_A_4 + 3) >= quote.YPos )
        v2 = *((_DWORD *)Frame_1_A_4 + 5) - 32;
      else
        v2 = *((_DWORD *)Frame_1_A_4 + 5) + 32;
      *((_DWORD *)Frame_1_A_4 + 5) = v2;
    }
    if ( ++*((_DWORD *)Frame_1_A_4 + 26) > 1 )
      *((_DWORD *)Frame_1_A_4 + 26) = 0;
  }
  if ( *((_DWORD *)Frame_1_A_4 + 4) < -1024 )
    *((_DWORD *)Frame_1_A_4 + 4) = -1536;
  if ( *((_DWORD *)Frame_1_A_4 + 4) > 1024 )
    *((_DWORD *)Frame_1_A_4 + 4) = 1536;
  *((_DWORD *)Frame_1_A_4 + 2) += *((_DWORD *)Frame_1_A_4 + 4);
  *((_DWORD *)Frame_1_A_4 + 3) += *((_DWORD *)Frame_1_A_4 + 5);
  if ( *((_DWORD *)Frame_1_A_4 + 19) )
    v3 = &v6 + 4 * *((_DWORD *)Frame_1_A_4 + 26);
  else
    v3 = &v15 + 4 * *((_DWORD *)Frame_1_A_4 + 26);
  v4 = (int *)((char *)Frame_1_A_4 + 84);
  *v4 = *v3;
  v4[1] = v3[1];
  v4[2] = v3[2];
  v4[3] = v3[3];
}

//----- (004498C0) --------------------------------------------------------
int __cdecl NPC171(int a1)
{
  int v1; // ecx
  int *v2; // ecx
  int *v3; // edx
  int result; // eax
  int v5; // [esp+0h] [ebp-44h]
  int v6; // [esp+4h] [ebp-40h]
  int v7; // [esp+8h] [ebp-3Ch]
  int v8; // [esp+Ch] [ebp-38h]
  int v9; // [esp+10h] [ebp-34h]
  int v10; // [esp+14h] [ebp-30h]
  int v11; // [esp+18h] [ebp-2Ch]
  int v12; // [esp+1Ch] [ebp-28h]
  int v13; // [esp+20h] [ebp-24h]
  int v14; // [esp+24h] [ebp-20h]
  int v15; // [esp+28h] [ebp-1Ch]
  int v16; // [esp+2Ch] [ebp-18h]
  int v17; // [esp+30h] [ebp-14h]
  int v18; // [esp+34h] [ebp-10h]
  int v19; // [esp+38h] [ebp-Ch]
  int v20; // [esp+3Ch] [ebp-8h]
  int v21; // [esp+40h] [ebp-4h]

  v14 = 120;
  v15 = 48;
  v16 = 152;
  v17 = 80;
  v18 = 152;
  v19 = 48;
  v20 = 184;
  v21 = 80;
  v6 = 184;
  v7 = 48;
  v8 = 216;
  v9 = 80;
  v10 = 216;
  v11 = 48;
  v12 = 248;
  v13 = 80;
  if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
    *(_DWORD *)(a1 + 76) = 2;
  else
    *(_DWORD *)(a1 + 76) = 0;
  v5 = *(_DWORD *)(a1 + 116);
  if ( v5 )
  {
    if ( v5 != 1 )
    {
      if ( v5 != 10 )
        goto LABEL_37;
      goto LABEL_12;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 120) = random(0, 50);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 12);
  }
  if ( *(_DWORD *)(a1 + 120) )
  {
    --*(_DWORD *)(a1 + 120);
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 10;
    *(_DWORD *)(a1 + 20) = 512;
  }
LABEL_12:
  if ( ++*(_DWORD *)(a1 + 100) > 0 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 1 )
    *(_DWORD *)(a1 + 104) = 0;
  if ( *(_DWORD *)(a1 + 12) >= *(_DWORD *)(a1 + 36) )
    v1 = *(_DWORD *)(a1 + 20) - 16;
  else
    v1 = *(_DWORD *)(a1 + 20) + 16;
  *(_DWORD *)(a1 + 20) = v1;
  if ( *(_DWORD *)(a1 + 20) > 512 )
    *(_DWORD *)(a1 + 20) = 512;
  if ( *(_DWORD *)(a1 + 20) < -512 )
    *(_DWORD *)(a1 + 20) = -512;
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
  {
    if ( quote.YPos < *(_DWORD *)(a1 + 12) + 40960
      && quote.YPos > *(_DWORD *)(a1 + 12) - 40960
      && quote.XPos < *(_DWORD *)(a1 + 8) + 81920
      && quote.XPos > *(_DWORD *)(a1 + 8) )
    {
      ++*(_DWORD *)(a1 + 108);
    }
  }
  else if ( quote.YPos < *(_DWORD *)(a1 + 12) + 40960
         && quote.YPos > *(_DWORD *)(a1 + 12) - 40960
         && quote.XPos < *(_DWORD *)(a1 + 8)
         && quote.XPos > *(_DWORD *)(a1 + 8) - 81920 )
  {
    ++*(_DWORD *)(a1 + 108);
  }
  if ( *(_DWORD *)(a1 + 108) > 20 )
  {
    createNPC((NPCNames)172, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 0, 0, *(Directions *)(a1 + 76), 0, 256);
    *(_DWORD *)(a1 + 108) = -100;
    superXPos = random(80, 100);
    curlyShootWait = *(_DWORD *)(a1 + 8);
    curlyShootX = *(_DWORD *)(a1 + 12);
  }
LABEL_37:
  if ( *(_DWORD *)(a1 + 76) )
    v2 = &v6 + 4 * *(_DWORD *)(a1 + 104);
  else
    v2 = &v14 + 4 * *(_DWORD *)(a1 + 104);
  v3 = (int *)(a1 + 84);
  *v3 = *v2;
  v3[1] = v2[1];
  result = v2[2];
  v3[2] = result;
  v3[3] = v2[3];
  return result;
}
// 4BBA20: using guessed type int curlyShootWait;
// 4BBA24: using guessed type int curlyShootX;
// 4BBA2C: using guessed type int superXPos;

//----- (00449C10) --------------------------------------------------------
void __cdecl NPC172(void *npc)
{
  int v1; // eax
  int *v2; // ecx
  int *v3; // edx
  int v4; // [esp+0h] [ebp-34h]
  int v5; // [esp+4h] [ebp-30h]
  int v6; // [esp+8h] [ebp-2Ch]
  int v7; // [esp+Ch] [ebp-28h]
  int v8; // [esp+10h] [ebp-24h]
  int v9; // [esp+14h] [ebp-20h]
  int v10; // [esp+18h] [ebp-1Ch]
  int v11; // [esp+1Ch] [ebp-18h]
  int v12; // [esp+20h] [ebp-14h]
  int v13; // [esp+24h] [ebp-10h]
  int v14; // [esp+28h] [ebp-Ch]
  int v15; // [esp+2Ch] [ebp-8h]
  int v16; // [esp+30h] [ebp-4h]

  v5 = 248;
  v6 = 48;
  v7 = 264;
  v8 = 80;
  v9 = 264;
  v10 = 48;
  v11 = 280;
  v12 = 80;
  v13 = 280;
  v14 = 48;
  v15 = 296;
  v16 = 80;
  v4 = *((_DWORD *)npc + 29);
  if ( v4 )
  {
    if ( v4 != 1 )
      goto LABEL_15;
  }
  else
  {
    *((_DWORD *)npc + 29) = 1;
  }
  if ( ++*((_DWORD *)npc + 25) > 1 )
  {
    *((_DWORD *)npc + 25) = 0;
    ++*((_DWORD *)npc + 26);
  }
  if ( *((_DWORD *)npc + 26) > 2 )
    *((_DWORD *)npc + 26) = 0;
  if ( *((_DWORD *)npc + 19) )
    v1 = *((_DWORD *)npc + 2) + 512;
  else
    v1 = *((_DWORD *)npc + 2) - 512;
  *((_DWORD *)npc + 2) = v1;
  if ( *((_DWORD *)npc + 1) & 1 || *((_DWORD *)npc + 1) & 4 )
  {
    createEffect(*((_DWORD *)npc + 2), *((_DWORD *)npc + 3), effectRisingDisc, 0);
    Vanish_NPC((NPC *)npc);
    return;
  }
LABEL_15:
  v2 = &v5 + 4 * *((_DWORD *)npc + 26);
  v3 = (int *)((char *)npc + 84);
  *v3 = *v2;
  v3[1] = v2[1];
  v3[2] = v2[2];
  v3[3] = v2[3];
}

//----- (00449D70) --------------------------------------------------------
void __cdecl NPC173(int a1)
{
  int Y_Vel; // ST24_4
  int *v2; // ecx
  int *v3; // edx
  int v4; // [esp+8h] [ebp-90h]
  int v5; // [esp+Ch] [ebp-8Ch]
  int v6; // [esp+10h] [ebp-88h]
  int v7; // [esp+14h] [ebp-84h]
  int v8; // [esp+18h] [ebp-80h]
  int v9; // [esp+1Ch] [ebp-7Ch]
  int v10; // [esp+20h] [ebp-78h]
  int v11; // [esp+24h] [ebp-74h]
  int v12; // [esp+28h] [ebp-70h]
  int v13; // [esp+2Ch] [ebp-6Ch]
  int v14; // [esp+30h] [ebp-68h]
  int v15; // [esp+34h] [ebp-64h]
  int v16; // [esp+38h] [ebp-60h]
  int v17; // [esp+3Ch] [ebp-5Ch]
  int v18; // [esp+40h] [ebp-58h]
  int v19; // [esp+44h] [ebp-54h]
  int X_Vel; // [esp+4Ch] [ebp-4Ch]
  int v21; // [esp+50h] [ebp-48h]
  int v22; // [esp+54h] [ebp-44h]
  int v23; // [esp+58h] [ebp-40h]
  int v24; // [esp+5Ch] [ebp-3Ch]
  int v25; // [esp+60h] [ebp-38h]
  int v26; // [esp+64h] [ebp-34h]
  int v27; // [esp+68h] [ebp-30h]
  int v28; // [esp+6Ch] [ebp-2Ch]
  int v29; // [esp+70h] [ebp-28h]
  int v30; // [esp+74h] [ebp-24h]
  int v31; // [esp+78h] [ebp-20h]
  int v32; // [esp+7Ch] [ebp-1Ch]
  int v33; // [esp+80h] [ebp-18h]
  int v34; // [esp+84h] [ebp-14h]
  int v35; // [esp+88h] [ebp-10h]
  int v36; // [esp+8Ch] [ebp-Ch]
  unsigned __int8 v37; // [esp+97h] [ebp-1h]

  v21 = 0;
  v22 = 128;
  v23 = 24;
  v24 = 152;
  v25 = 24;
  v26 = 128;
  v27 = 48;
  v28 = 152;
  v29 = 48;
  v30 = 128;
  v31 = 72;
  v32 = 152;
  v33 = 72;
  v34 = 128;
  v35 = 96;
  v36 = 152;
  v4 = 0;
  v5 = 152;
  v6 = 24;
  v7 = 176;
  v8 = 24;
  v9 = 152;
  v10 = 48;
  v11 = 176;
  v12 = 48;
  v13 = 152;
  v14 = 72;
  v15 = 176;
  v16 = 72;
  v17 = 152;
  v18 = 96;
  v19 = 176;
  if ( *(_DWORD *)(a1 + 8) <= quote.XPos + 163840
    && *(_DWORD *)(a1 + 8) >= quote.XPos - 163840
    && *(_DWORD *)(a1 + 12) <= quote.YPos + 122880
    && *(_DWORD *)(a1 + 12) >= quote.YPos - 122880 )
  {
    switch ( *(_DWORD *)(a1 + 116) )
    {
      case 0:
        *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 116) = 1;
        goto LABEL_8;
      case 1:
LABEL_8:
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 16) = 0;
        if ( *(_DWORD *)(a1 + 120) >= 5 )
        {
          if ( *(_DWORD *)(a1 + 8) - 98304 < quote.XPos
            && *(_DWORD *)(a1 + 8) + 98304 > quote.XPos
            && *(_DWORD *)(a1 + 12) - 81920 < quote.YPos
            && *(_DWORD *)(a1 + 12) + 81920 > quote.YPos )
          {
            *(_DWORD *)(a1 + 116) = 10;
            *(_DWORD *)(a1 + 120) = 0;
            *(_DWORD *)(a1 + 104) = 1;
          }
        }
        else
        {
          ++*(_DWORD *)(a1 + 120);
        }
        break;
      case 0xA:
        if ( ++*(_DWORD *)(a1 + 120) > 3 )
        {
          if ( ++*(_DWORD *)(a1 + 108) == 3 )
          {
            playSoundEffect(SFXCritterHop, 1);
            *(_DWORD *)(a1 + 108) = 0;
            *(_DWORD *)(a1 + 116) = 25;
            *(_DWORD *)(a1 + 120) = 0;
            *(_DWORD *)(a1 + 104) = 2;
            *(_DWORD *)(a1 + 20) = -1536;
            if ( *(_DWORD *)(a1 + 8) >= *(_DWORD *)(a1 + 32) )
              *(_DWORD *)(a1 + 16) = -128;
            else
              *(_DWORD *)(a1 + 16) = 128;
          }
          else
          {
            playSoundEffect(SFXCritterHop, 1);
            *(_DWORD *)(a1 + 116) = 20;
            *(_DWORD *)(a1 + 104) = 2;
            *(_DWORD *)(a1 + 20) = -512;
            if ( *(_DWORD *)(a1 + 8) >= *(_DWORD *)(a1 + 32) )
              *(_DWORD *)(a1 + 16) = -512;
            else
              *(_DWORD *)(a1 + 16) = 512;
          }
        }
        break;
      case 0x14:
        ++*(_DWORD *)(a1 + 120);
        if ( *(_DWORD *)(a1 + 4) & 8 )
        {
          playSoundEffect(SFXQuoteHitGround, 1);
          *(_DWORD *)(a1 + 104) = 1;
          *(_DWORD *)(a1 + 116) = 30;
          *(_DWORD *)(a1 + 120) = 0;
        }
        break;
      case 0x19:
        if ( ++*(_DWORD *)(a1 + 120) == 30 || *(_DWORD *)(a1 + 120) == 40 )
        {
          v37 = getArcTan(*(_DWORD *)(a1 + 8) - quote.XPos, *(_DWORD *)(a1 + 12) - quote.YPos);
          v37 += random(-6, 6);
          Y_Vel = 3 * getSin(v37);
          X_Vel = 3 * getCos(v37);
          createNPC(NPCSantasKey|0xA0, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), X_Vel, Y_Vel, 0, 0, 256);
          playSoundEffect(SFXEnemyShootProjectile, 1);
          *(_DWORD *)(a1 + 104) = 3;
          superXPos = random(80, 100);
          curlyShootWait = *(_DWORD *)(a1 + 8);
          curlyShootX = *(_DWORD *)(a1 + 12);
        }
        if ( *(_DWORD *)(a1 + 120) == 35 || *(_DWORD *)(a1 + 120) == 45 )
          *(_DWORD *)(a1 + 104) = 2;
        if ( *(_DWORD *)(a1 + 4) & 8 )
        {
          playSoundEffect(SFXQuoteHitGround, 1);
          *(_DWORD *)(a1 + 104) = 1;
          *(_DWORD *)(a1 + 116) = 30;
          *(_DWORD *)(a1 + 120) = 0;
        }
        break;
      case 0x1E:
        *(_DWORD *)(a1 + 16) = 7 * *(_DWORD *)(a1 + 16) / 8;
        if ( ++*(_DWORD *)(a1 + 120) > 3 )
        {
          *(_DWORD *)(a1 + 104) = 0;
          *(_DWORD *)(a1 + 116) = 1;
          *(_DWORD *)(a1 + 120) = 0;
        }
        break;
      default:
        break;
    }
    *(_DWORD *)(a1 + 20) += 51;
    if ( quote.XPos >= *(_DWORD *)(a1 + 8) )
      *(_DWORD *)(a1 + 76) = 2;
    else
      *(_DWORD *)(a1 + 76) = 0;
    if ( *(_DWORD *)(a1 + 20) > 1535 )
      *(_DWORD *)(a1 + 20) = 1535;
    if ( *(_DWORD *)(a1 + 20) < -1535 )
      *(_DWORD *)(a1 + 20) = 1535;
    *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
    if ( *(_DWORD *)(a1 + 76) )
      v2 = &v4 + 4 * *(_DWORD *)(a1 + 104);
    else
      v2 = &v21 + 4 * *(_DWORD *)(a1 + 104);
    v3 = (int *)(a1 + 84);
    *v3 = *v2;
    v3[1] = v2[1];
    v3[2] = v2[2];
    v3[3] = v2[3];
    if ( *(_DWORD *)(a1 + 64) <= 985 )
    {
      createDustClouds(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 0, 2);
      *(_DWORD *)(a1 + 40) = 154;
      *(_DWORD *)(a1 + 116) = 0;
    }
  }
}
// 4BBA20: using guessed type int curlyShootWait;
// 4BBA24: using guessed type int curlyShootX;
// 4BBA2C: using guessed type int superXPos;

//----- (0044A3C0) --------------------------------------------------------
int __cdecl NPC174(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  int v4; // [esp+0h] [ebp-38h]
  int v5; // [esp+4h] [ebp-34h]
  int v6; // [esp+8h] [ebp-30h]
  int v7; // [esp+Ch] [ebp-2Ch]
  int v8; // [esp+10h] [ebp-28h]
  int v9; // [esp+14h] [ebp-24h]
  int v10; // [esp+18h] [ebp-20h]
  int v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+20h] [ebp-18h]
  int v13; // [esp+24h] [ebp-14h]
  int v14; // [esp+28h] [ebp-10h]
  int v15; // [esp+2Ch] [ebp-Ch]
  int v16; // [esp+30h] [ebp-8h]
  int v17; // [esp+34h] [ebp-4h]

  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      if ( v4 == 2 )
      {
        *(_DWORD *)(a1 + 20) += 64;
        *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
        if ( *(_DWORD *)(a1 + 4) & 8 )
        {
          if ( ++*(_DWORD *)(a1 + 108) > 1 )
          {
            createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectRisingDisc, 0);
            *(_BYTE *)a1 = 0;
          }
        }
      }
      goto LABEL_21;
    }
  }
  else if ( *(_DWORD *)(a1 + 76) == 2 )
  {
    *(_DWORD *)(a1 + 116) = 2;
  }
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v17 = 0;
  if ( *(_DWORD *)(a1 + 4) & 1 )
  {
    v17 = 1;
    *(_DWORD *)(a1 + 16) = 512;
  }
  if ( *(_DWORD *)(a1 + 4) & 4 )
  {
    v17 = 1;
    *(_DWORD *)(a1 + 16) = -512;
  }
  if ( *(_DWORD *)(a1 + 4) & 2 )
  {
    v17 = 1;
    *(_DWORD *)(a1 + 20) = 512;
  }
  if ( *(_DWORD *)(a1 + 4) & 8 )
  {
    v17 = 1;
    *(_DWORD *)(a1 + 20) = -512;
  }
  if ( v17 )
  {
    *(_DWORD *)(a1 + 116) = 2;
    ++*(_DWORD *)(a1 + 108);
    playSoundEffect(SFXShotHitInvulnerableEntity, 1);
  }
LABEL_21:
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  if ( *(_DWORD *)(a1 + 20) < -1535 )
    *(_DWORD *)(a1 + 20) = -1535;
  v5 = 120;
  v6 = 80;
  v7 = 136;
  v8 = 96;
  v9 = 136;
  v10 = 80;
  v11 = 152;
  v12 = 96;
  v13 = 152;
  v14 = 80;
  v15 = 168;
  v16 = 96;
  if ( ++*(_DWORD *)(a1 + 104) > 2 )
    *(_DWORD *)(a1 + 104) = 0;
  v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}

//----- (0044A610) --------------------------------------------------------
int __cdecl NPC175(void *Is_NPC_Alive)
{
  int v1; // eax
  int *v2; // ecx
  int *v3; // edx
  int result; // eax
  int v5; // [esp+4h] [ebp-40h]
  int v6; // [esp+8h] [ebp-3Ch]
  int v7; // [esp+Ch] [ebp-38h]
  int v8; // [esp+10h] [ebp-34h]
  int v9; // [esp+14h] [ebp-30h]
  int v10; // [esp+18h] [ebp-2Ch]
  int v11; // [esp+1Ch] [ebp-28h]
  int v12; // [esp+20h] [ebp-24h]
  int v13; // [esp+24h] [ebp-20h]
  int v14; // [esp+28h] [ebp-1Ch]
  int v15; // [esp+2Ch] [ebp-18h]
  int v16; // [esp+30h] [ebp-14h]
  int v17; // [esp+34h] [ebp-10h]
  int v18; // [esp+38h] [ebp-Ch]
  int v19; // [esp+3Ch] [ebp-8h]
  int v20; // [esp+40h] [ebp-4h]

  v13 = 168;
  v14 = 80;
  v15 = 192;
  v16 = 104;
  v17 = 192;
  v18 = 80;
  v19 = 216;
  v20 = 104;
  v5 = 216;
  v6 = 80;
  v7 = 240;
  v8 = 104;
  v9 = 240;
  v10 = 80;
  v11 = 264;
  v12 = 104;
  if ( *((_DWORD *)Is_NPC_Alive + 29) < 3 && *((_DWORD *)Is_NPC_Alive + 16) < 90 )
  {
    NPC_Death_Maybe(Is_NPC_Alive, 0);
    *((_DWORD *)Is_NPC_Alive + 29) = 10;
    *((_DWORD *)Is_NPC_Alive + 26) = 1;
    *((_WORD *)Is_NPC_Alive + 40) &= 0xFFDFu;
    *((_DWORD *)Is_NPC_Alive + 41) = 0;
  }
  if ( !*((_DWORD *)Is_NPC_Alive + 29) )
  {
    *((_DWORD *)Is_NPC_Alive + 26) = 0;
    *((_DWORD *)Is_NPC_Alive + 29) = 1;
  }
  if ( *((_DWORD *)Is_NPC_Alive + 19) )
    v1 = *((_DWORD *)Is_NPC_Alive + 5) - 32;
  else
    v1 = *((_DWORD *)Is_NPC_Alive + 5) + 32;
  *((_DWORD *)Is_NPC_Alive + 5) = v1;
  if ( *((_DWORD *)Is_NPC_Alive + 5) < -1535 )
    *((_DWORD *)Is_NPC_Alive + 5) = -1535;
  if ( *((_DWORD *)Is_NPC_Alive + 5) > 1535 )
    *((_DWORD *)Is_NPC_Alive + 5) = 1535;
  *((_DWORD *)Is_NPC_Alive + 3) += *((_DWORD *)Is_NPC_Alive + 5);
  if ( *((_DWORD *)Is_NPC_Alive + 19) )
    v2 = &v5 + 4 * *((_DWORD *)Is_NPC_Alive + 26);
  else
    v2 = &v13 + 4 * *((_DWORD *)Is_NPC_Alive + 26);
  v3 = (int *)((char *)Is_NPC_Alive + 84);
  *v3 = *v2;
  v3[1] = v2[1];
  result = v2[2];
  v3[2] = result;
  v3[3] = v2[3];
  return result;
}

//----- (0044A7D0) --------------------------------------------------------
int __cdecl NPC176(void *Is_NPC_Alive)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  int v4; // [esp+0h] [ebp-64h]
  int v5; // [esp+4h] [ebp-60h]
  int v6; // [esp+8h] [ebp-5Ch]
  int v7; // [esp+Ch] [ebp-58h]
  int v8; // [esp+10h] [ebp-54h]
  int v9; // [esp+14h] [ebp-50h]
  int v10; // [esp+18h] [ebp-4Ch]
  int v11; // [esp+1Ch] [ebp-48h]
  int v12; // [esp+20h] [ebp-44h]
  int v13; // [esp+24h] [ebp-40h]
  int v14; // [esp+28h] [ebp-3Ch]
  int v15; // [esp+2Ch] [ebp-38h]
  int v16; // [esp+30h] [ebp-34h]
  int v17; // [esp+34h] [ebp-30h]
  int v18; // [esp+38h] [ebp-2Ch]
  int v19; // [esp+3Ch] [ebp-28h]
  int v20; // [esp+40h] [ebp-24h]
  int v21; // [esp+44h] [ebp-20h]
  int v22; // [esp+48h] [ebp-1Ch]
  int v23; // [esp+4Ch] [ebp-18h]
  int v24; // [esp+50h] [ebp-14h]
  int v25; // [esp+54h] [ebp-10h]
  int v26; // [esp+58h] [ebp-Ch]
  int v27; // [esp+5Ch] [ebp-8h]
  int v28; // [esp+60h] [ebp-4h]

  v17 = 96;
  v18 = 128;
  v19 = 128;
  v20 = 144;
  v21 = 128;
  v22 = 128;
  v23 = 160;
  v24 = 144;
  v25 = 160;
  v26 = 128;
  v27 = 192;
  v28 = 144;
  v5 = 96;
  v6 = 144;
  v7 = 128;
  v8 = 160;
  v9 = 128;
  v10 = 144;
  v11 = 160;
  v12 = 160;
  v13 = 160;
  v14 = 144;
  v15 = 192;
  v16 = 160;
  if ( *((_DWORD *)Is_NPC_Alive + 29) < 3 && *((_DWORD *)Is_NPC_Alive + 16) < 940 )
  {
    NPC_Death_Maybe(Is_NPC_Alive, 0);
    *((_DWORD *)Is_NPC_Alive + 29) = 10;
    *((_DWORD *)Is_NPC_Alive + 26) = 2;
    *((_WORD *)Is_NPC_Alive + 40) &= 0xFFDFu;
    *((_DWORD *)Is_NPC_Alive + 41) = 0;
  }
  v4 = *((_DWORD *)Is_NPC_Alive + 29);
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      if ( v4 == 2 )
      {
        if ( ++*((_DWORD *)Is_NPC_Alive + 25) > 3 )
        {
          *((_DWORD *)Is_NPC_Alive + 25) = 0;
          ++*((_DWORD *)Is_NPC_Alive + 26);
        }
        if ( *((_DWORD *)Is_NPC_Alive + 26) > 1 )
          *((_DWORD *)Is_NPC_Alive + 26) = 0;
        if ( ++*((_DWORD *)Is_NPC_Alive + 30) > 10 )
        {
          if ( ++*((_DWORD *)Is_NPC_Alive + 28) <= 2 )
          {
            *((_DWORD *)Is_NPC_Alive + 27) = -10;
          }
          else
          {
            *((_DWORD *)Is_NPC_Alive + 28) = 0;
            *((_DWORD *)Is_NPC_Alive + 27) = -90;
          }
          if ( *((_DWORD *)Is_NPC_Alive + 19) )
            createNPC(
              (NPCNames)177,
              *((_DWORD *)Is_NPC_Alive + 2),
              *((_DWORD *)Is_NPC_Alive + 3) + 4096,
              0,
              0,
              right,
              0,
              256);
          else
            createNPC(
              (NPCNames)177,
              *((_DWORD *)Is_NPC_Alive + 2),
              *((_DWORD *)Is_NPC_Alive + 3) - 4096,
              0,
              0,
              0,
              0,
              256);
          playSoundEffect(SFXEnemyShootProjectile, 1);
          *((_DWORD *)Is_NPC_Alive + 29) = 0;
          *((_DWORD *)Is_NPC_Alive + 26) = 0;
          superXPos = random(80, 100);
          curlyShootWait = *((_DWORD *)Is_NPC_Alive + 2);
          curlyShootX = *((_DWORD *)Is_NPC_Alive + 3);
        }
      }
      goto LABEL_36;
    }
  }
  else
  {
    *((_DWORD *)Is_NPC_Alive + 29) = 1;
    *((_DWORD *)Is_NPC_Alive + 26) = 0;
    *((_DWORD *)Is_NPC_Alive + 25) = 0;
  }
  if ( *((_DWORD *)Is_NPC_Alive + 19) )
  {
    if ( *((_DWORD *)Is_NPC_Alive + 2) < quote.XPos + 81920
      && *((_DWORD *)Is_NPC_Alive + 2) > quote.XPos - 81920
      && *((_DWORD *)Is_NPC_Alive + 3) < quote.YPos + 0x2000
      && *((_DWORD *)Is_NPC_Alive + 3) > quote.YPos - 81920 )
    {
      ++*((_DWORD *)Is_NPC_Alive + 27);
    }
  }
  else if ( *((_DWORD *)Is_NPC_Alive + 2) < quote.XPos + 81920
         && *((_DWORD *)Is_NPC_Alive + 2) > quote.XPos - 81920
         && *((_DWORD *)Is_NPC_Alive + 3) < quote.YPos + 81920
         && *((_DWORD *)Is_NPC_Alive + 3) > quote.YPos - 0x2000 )
  {
    ++*((_DWORD *)Is_NPC_Alive + 27);
  }
  if ( *((_DWORD *)Is_NPC_Alive + 27) > 10 )
  {
    *((_DWORD *)Is_NPC_Alive + 29) = 2;
    *((_DWORD *)Is_NPC_Alive + 30) = 0;
  }
LABEL_36:
  if ( *((_DWORD *)Is_NPC_Alive + 19) )
    v1 = &v5 + 4 * *((_DWORD *)Is_NPC_Alive + 26);
  else
    v1 = &v17 + 4 * *((_DWORD *)Is_NPC_Alive + 26);
  v2 = (int *)((char *)Is_NPC_Alive + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}
// 4BBA20: using guessed type int curlyShootWait;
// 4BBA24: using guessed type int curlyShootX;
// 4BBA2C: using guessed type int superXPos;

//----- (0044ABB0) --------------------------------------------------------
void __cdecl NPC177(int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // ecx
  int *v4; // ecx
  int *v5; // edx
  int v6; // [esp+0h] [ebp-24h]
  int v7; // [esp+4h] [ebp-20h]
  int v8; // [esp+8h] [ebp-1Ch]
  int v9; // [esp+Ch] [ebp-18h]
  int v10; // [esp+10h] [ebp-14h]
  int v11; // [esp+14h] [ebp-10h]
  int v12; // [esp+18h] [ebp-Ch]
  int v13; // [esp+1Ch] [ebp-8h]
  int v14; // [esp+20h] [ebp-4h]

  v7 = 192;
  v8 = 128;
  v9 = 208;
  v10 = 144;
  v11 = 208;
  v12 = 128;
  v13 = 224;
  v14 = 144;
  if ( *(_DWORD *)(a1 + 4) & 0xFF )
  {
    createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectStar, 0);
    *(_BYTE *)a1 = 0;
    return;
  }
  v6 = *(_DWORD *)(a1 + 116);
  switch ( v6 )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      if ( *(_DWORD *)(a1 + 76) )
        *(_DWORD *)(a1 + 20) = 1536;
      else
        *(_DWORD *)(a1 + 20) = -1536;
LABEL_10:
      if ( *(_DWORD *)(a1 + 12) < quote.YPos + 0x2000 && *(_DWORD *)(a1 + 12) > quote.YPos - 0x2000 )
      {
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 12);
        if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
          *(_DWORD *)(a1 + 76) = 2;
        else
          *(_DWORD *)(a1 + 76) = 0;
        *(_DWORD *)(a1 + 16) = (random(0, 1) << 10) - 512;
        *(_DWORD *)(a1 + 20) = (random(0, 1) << 10) - 512;
      }
      break;
    case 1:
      goto LABEL_10;
    case 10:
      if ( *(_DWORD *)(a1 + 8) >= *(_DWORD *)(a1 + 32) )
        v1 = *(_DWORD *)(a1 + 16) - 32;
      else
        v1 = *(_DWORD *)(a1 + 16) + 32;
      *(_DWORD *)(a1 + 16) = v1;
      if ( *(_DWORD *)(a1 + 12) >= *(_DWORD *)(a1 + 36) )
        v2 = *(_DWORD *)(a1 + 20) - 32;
      else
        v2 = *(_DWORD *)(a1 + 20) + 32;
      *(_DWORD *)(a1 + 20) = v2;
      if ( ++*(_DWORD *)(a1 + 120) > 300 )
      {
        createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectStar, 0);
        *(_BYTE *)a1 = 0;
        return;
      }
      if ( *(_DWORD *)(a1 + 76) )
        v3 = *(_DWORD *)(a1 + 32) + 512;
      else
        v3 = *(_DWORD *)(a1 + 32) - 512;
      *(_DWORD *)(a1 + 32) = v3;
      break;
  }
  if ( *(_DWORD *)(a1 + 16) > 1024 )
    *(_DWORD *)(a1 + 16) = 1024;
  if ( *(_DWORD *)(a1 + 16) < -1024 )
    *(_DWORD *)(a1 + 16) = -1024;
  if ( *(_DWORD *)(a1 + 20) > 1024 )
    *(_DWORD *)(a1 + 20) = 1024;
  if ( *(_DWORD *)(a1 + 20) < -1024 )
    *(_DWORD *)(a1 + 20) = -1024;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( ++*(_DWORD *)(a1 + 100) > 6 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 1 )
    *(_DWORD *)(a1 + 104) = 0;
  v4 = &v7 + 4 * *(_DWORD *)(a1 + 104);
  v5 = (int *)(a1 + 84);
  *v5 = *v4;
  v5[1] = v4[1];
  v5[2] = v4[2];
  v5[3] = v4[3];
}

//----- (0044AEE0) --------------------------------------------------------
void __cdecl NPC178(void *a1)
{
  int *v1; // edx
  int *v2; // eax
  int v3; // [esp+0h] [ebp-30h]
  int v4; // [esp+4h] [ebp-2Ch]
  int v5; // [esp+8h] [ebp-28h]
  int v6; // [esp+Ch] [ebp-24h]
  int v7; // [esp+10h] [ebp-20h]
  int v8; // [esp+14h] [ebp-1Ch]
  int v9; // [esp+18h] [ebp-18h]
  int v10; // [esp+1Ch] [ebp-14h]
  int v11; // [esp+20h] [ebp-10h]
  int v12; // [esp+24h] [ebp-Ch]
  int v13; // [esp+28h] [ebp-8h]
  int v14; // [esp+2Ch] [ebp-4h]

  if ( *((_DWORD *)a1 + 1) & 0xFF )
  {
    createEffect(*((_DWORD *)a1 + 2), *((_DWORD *)a1 + 3), effectRisingDisc, 0);
    *(_BYTE *)a1 = 0;
  }
  if ( *((_DWORD *)a1 + 1) & 0x100 )
  {
    *((_DWORD *)a1 + 3) += *((_DWORD *)a1 + 5) / 2;
    *((_DWORD *)a1 + 2) += *((_DWORD *)a1 + 4) / 2;
  }
  else
  {
    *((_DWORD *)a1 + 3) += *((_DWORD *)a1 + 5);
    *((_DWORD *)a1 + 2) += *((_DWORD *)a1 + 4);
  }
  v3 = 0;
  v4 = 224;
  v5 = 16;
  v6 = 240;
  v7 = 16;
  v8 = 224;
  v9 = 32;
  v10 = 240;
  v11 = 32;
  v12 = 224;
  v13 = 48;
  v14 = 240;
  if ( ++*((_DWORD *)a1 + 25) > 1 )
  {
    *((_DWORD *)a1 + 25) = 0;
    ++*((_DWORD *)a1 + 26);
  }
  if ( *((_DWORD *)a1 + 26) > 2 )
    *((_DWORD *)a1 + 26) = 0;
  v1 = &v3 + 4 * *((_DWORD *)a1 + 26);
  v2 = (int *)((char *)a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  v2[3] = v1[3];
  if ( ++*((_DWORD *)a1 + 27) > 150 )
  {
    Vanish_NPC((NPC *)a1);
    createEffect(*((_DWORD *)a1 + 2), *((_DWORD *)a1 + 3), effectRisingDisc, 0);
  }
}

//----- (0044B080) --------------------------------------------------------
void __cdecl NPC179(void *a1)
{
  int *v1; // eax
  int *v2; // ecx
  int v3; // [esp+0h] [ebp-30h]
  int v4; // [esp+4h] [ebp-2Ch]
  int v5; // [esp+8h] [ebp-28h]
  int v6; // [esp+Ch] [ebp-24h]
  int v7; // [esp+10h] [ebp-20h]
  int v8; // [esp+14h] [ebp-1Ch]
  int v9; // [esp+18h] [ebp-18h]
  int v10; // [esp+1Ch] [ebp-14h]
  int v11; // [esp+20h] [ebp-10h]
  int v12; // [esp+24h] [ebp-Ch]
  int v13; // [esp+28h] [ebp-8h]
  int v14; // [esp+2Ch] [ebp-4h]

  if ( *((_DWORD *)a1 + 1) & 0xFF )
  {
    *(_BYTE *)a1 = 0;
    createEffect(*((_DWORD *)a1 + 2), *((_DWORD *)a1 + 3), effectRisingDisc, 0);
  }
  *((_DWORD *)a1 + 4) -= 32;
  *((_DWORD *)a1 + 5) = 0;
  if ( *((_DWORD *)a1 + 4) < -1024 )
    *((_DWORD *)a1 + 4) = -1024;
  *((_DWORD *)a1 + 3) += *((_DWORD *)a1 + 5);
  *((_DWORD *)a1 + 2) += *((_DWORD *)a1 + 4);
  v3 = 48;
  v4 = 224;
  v5 = 72;
  v6 = 240;
  v7 = 72;
  v8 = 224;
  v9 = 96;
  v10 = 240;
  v11 = 96;
  v12 = 224;
  v13 = 120;
  v14 = 240;
  if ( ++*((_DWORD *)a1 + 25) > 1 )
  {
    *((_DWORD *)a1 + 25) = 0;
    ++*((_DWORD *)a1 + 26);
  }
  if ( *((_DWORD *)a1 + 26) > 2 )
    *((_DWORD *)a1 + 26) = 0;
  v1 = &v3 + 4 * *((_DWORD *)a1 + 26);
  v2 = (int *)((char *)a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  v2[3] = v1[3];
  if ( ++*((_DWORD *)a1 + 27) > 300 )
  {
    Vanish_NPC((NPC *)a1);
    createEffect(*((_DWORD *)a1 + 2), *((_DWORD *)a1 + 3), effectRisingDisc, 0);
  }
}

//----- (0044B210) --------------------------------------------------------
RECT *__cdecl NPC180(NPC *a1)
{
  int *v1; // edx
  RECT *result; // eax
  int v3; // [esp+4h] [ebp-170h]
  int v4; // [esp+8h] [ebp-16Ch]
  int v5; // [esp+Ch] [ebp-168h]
  int v6; // [esp+10h] [ebp-164h]
  int v7; // [esp+14h] [ebp-160h]
  int v8; // [esp+18h] [ebp-15Ch]
  int v9; // [esp+1Ch] [ebp-158h]
  int v10; // [esp+20h] [ebp-154h]
  int v11; // [esp+24h] [ebp-150h]
  int v12; // [esp+28h] [ebp-14Ch]
  int v13; // [esp+2Ch] [ebp-148h]
  int v14; // [esp+30h] [ebp-144h]
  int v15; // [esp+34h] [ebp-140h]
  int v16; // [esp+38h] [ebp-13Ch]
  int v17; // [esp+3Ch] [ebp-138h]
  int v18; // [esp+40h] [ebp-134h]
  int v19; // [esp+44h] [ebp-130h]
  int v20; // [esp+48h] [ebp-12Ch]
  int v21; // [esp+4Ch] [ebp-128h]
  int v22; // [esp+50h] [ebp-124h]
  int v23; // [esp+54h] [ebp-120h]
  int v24; // [esp+58h] [ebp-11Ch]
  int v25; // [esp+5Ch] [ebp-118h]
  int v26; // [esp+60h] [ebp-114h]
  int v27; // [esp+64h] [ebp-110h]
  int v28; // [esp+68h] [ebp-10Ch]
  int v29; // [esp+6Ch] [ebp-108h]
  int v30; // [esp+70h] [ebp-104h]
  int v31; // [esp+74h] [ebp-100h]
  int v32; // [esp+78h] [ebp-FCh]
  int v33; // [esp+7Ch] [ebp-F8h]
  int v34; // [esp+80h] [ebp-F4h]
  int v35; // [esp+84h] [ebp-F0h]
  int v36; // [esp+88h] [ebp-ECh]
  int v37; // [esp+8Ch] [ebp-E8h]
  int v38; // [esp+90h] [ebp-E4h]
  int v39; // [esp+94h] [ebp-E0h]
  int v40; // [esp+98h] [ebp-DCh]
  int v41; // [esp+9Ch] [ebp-D8h]
  int v42; // [esp+A0h] [ebp-D4h]
  int v43; // [esp+A4h] [ebp-D0h]
  int v44; // [esp+A8h] [ebp-CCh]
  int v45; // [esp+ACh] [ebp-C8h]
  int v46; // [esp+B0h] [ebp-C4h]
  int v47; // [esp+B4h] [ebp-C0h]
  int v48; // [esp+B8h] [ebp-BCh]
  int v49; // [esp+C0h] [ebp-B4h]
  int v50; // [esp+C4h] [ebp-B0h]
  int v51; // [esp+C8h] [ebp-ACh]
  int v52; // [esp+CCh] [ebp-A8h]
  int v53; // [esp+D0h] [ebp-A4h]
  int v54; // [esp+D4h] [ebp-A0h]
  int v55; // [esp+D8h] [ebp-9Ch]
  int v56; // [esp+DCh] [ebp-98h]
  int v57; // [esp+E0h] [ebp-94h]
  int v58; // [esp+E4h] [ebp-90h]
  int v59; // [esp+E8h] [ebp-8Ch]
  int v60; // [esp+ECh] [ebp-88h]
  int v61; // [esp+F0h] [ebp-84h]
  int v62; // [esp+F4h] [ebp-80h]
  int v63; // [esp+F8h] [ebp-7Ch]
  int v64; // [esp+FCh] [ebp-78h]
  int v65; // [esp+100h] [ebp-74h]
  int v66; // [esp+104h] [ebp-70h]
  int v67; // [esp+108h] [ebp-6Ch]
  int v68; // [esp+10Ch] [ebp-68h]
  int v69; // [esp+110h] [ebp-64h]
  int v70; // [esp+114h] [ebp-60h]
  int v71; // [esp+118h] [ebp-5Ch]
  int v72; // [esp+11Ch] [ebp-58h]
  int v73; // [esp+120h] [ebp-54h]
  int v74; // [esp+124h] [ebp-50h]
  int v75; // [esp+128h] [ebp-4Ch]
  int v76; // [esp+12Ch] [ebp-48h]
  int v77; // [esp+130h] [ebp-44h]
  int v78; // [esp+134h] [ebp-40h]
  int v79; // [esp+138h] [ebp-3Ch]
  int v80; // [esp+13Ch] [ebp-38h]
  int v81; // [esp+140h] [ebp-34h]
  int v82; // [esp+144h] [ebp-30h]
  int v83; // [esp+148h] [ebp-2Ch]
  int v84; // [esp+14Ch] [ebp-28h]
  int v85; // [esp+150h] [ebp-24h]
  int v86; // [esp+154h] [ebp-20h]
  int v87; // [esp+158h] [ebp-1Ch]
  int v88; // [esp+15Ch] [ebp-18h]
  int v89; // [esp+160h] [ebp-14h]
  int v90; // [esp+164h] [ebp-10h]
  int v91; // [esp+168h] [ebp-Ch]
  int v92; // [esp+16Ch] [ebp-8h]
  int v93; // [esp+170h] [ebp-4h]

  v50 = 0;
  v51 = 96;
  v52 = 16;
  v53 = 112;
  v54 = 16;
  v55 = 96;
  v56 = 32;
  v57 = 112;
  v58 = 0;
  v59 = 96;
  v60 = 16;
  v61 = 112;
  v62 = 32;
  v63 = 96;
  v64 = 48;
  v65 = 112;
  v66 = 0;
  v67 = 96;
  v68 = 16;
  v69 = 112;
  v70 = 48;
  v71 = 96;
  v72 = 64;
  v73 = 112;
  v74 = 64;
  v75 = 96;
  v76 = 80;
  v77 = 112;
  v78 = 48;
  v79 = 96;
  v80 = 64;
  v81 = 112;
  v82 = 80;
  v83 = 96;
  v84 = 96;
  v85 = 112;
  v86 = 48;
  v87 = 96;
  v88 = 64;
  v89 = 112;
  v90 = 144;
  v91 = 96;
  v92 = 160;
  v93 = 112;
  v5 = 0;
  v6 = 112;
  v7 = 16;
  v8 = 128;
  v9 = 16;
  v10 = 112;
  v11 = 32;
  v12 = 128;
  v13 = 0;
  v14 = 112;
  v15 = 16;
  v16 = 128;
  v17 = 32;
  v18 = 112;
  v19 = 48;
  v20 = 128;
  v21 = 0;
  v22 = 112;
  v23 = 16;
  v24 = 128;
  v25 = 48;
  v26 = 112;
  v27 = 64;
  v28 = 128;
  v29 = 64;
  v30 = 112;
  v31 = 80;
  v32 = 128;
  v33 = 48;
  v34 = 112;
  v35 = 64;
  v36 = 128;
  v37 = 80;
  v38 = 112;
  v39 = 96;
  v40 = 128;
  v41 = 48;
  v42 = 112;
  v43 = 64;
  v44 = 128;
  v45 = 144;
  v46 = 112;
  v47 = 160;
  v48 = 128;
  if ( a1->YPos >= quote.YPos - 81920 )
  {
    if ( superXPos )
    {
      a1->curlyTargetX = curlyShootWait;
      a1->curlyTargetY = curlyShootX;
    }
    else
    {
      a1->curlyTargetX = quote.XPos;
      a1->curlyTargetY = quote.YPos;
    }
  }
  else
  {
    if ( a1->YPos >= 0x20000 )
      a1->curlyTargetX = 0;
    else
      a1->curlyTargetX = 2621440;
    a1->curlyTargetY = a1->YPos;
  }
  if ( a1->XVel < 0 && a1->collisionFlags & 1 )
    a1->XVel = 0;
  if ( a1->XVel > 0 && a1->collisionFlags & 4 )
    a1->XVel = 0;
  v3 = a1->currentState;
  if ( v3 > 200 )
  {
    switch ( v3 )
    {
      case 210:
        a1->XVel -= 32;
        a1->direction = 0;
        if ( a1->collisionFlags & 8 )
          a1->currentState = 100;
        break;
      case 300:
        a1->XVel += 32;
        a1->direction = 2;
        if ( a1->collisionFlags & 4 )
          ++a1->count1;
        else
          a1->count1 = 0;
        break;
      case 310:
        a1->XVel += 32;
        a1->direction = 2;
        if ( a1->collisionFlags & 8 )
          a1->currentState = 100;
        break;
    }
  }
  else if ( v3 == 200 )
  {
    a1->XVel -= 32;
    a1->direction = 0;
    if ( a1->collisionFlags & 1 )
      ++a1->count1;
    else
      a1->count1 = 0;
  }
  else
  {
    switch ( v3 )
    {
      case 20:
        a1->XPos = quote.XPos;
        a1->YPos = quote.YPos;
        a1->currentState = 100;
        a1->animationNumber = 0;
        createNPC((NPCNames)183, 0, 0, 0, 0, 0, a1, 256);
        if ( getNPCFlag(563) )
          createNPC((NPCNames)182, 0, 0, 0, 0, 0, a1, 256);
        else
          createNPC((NPCNames)181, 0, 0, 0, 0, 0, a1, 256);
        break;
      case 40:
        a1->currentState = 41;
        a1->waitTimer = 0;
        a1->animationNumber = 10;
        goto LABEL_27;
      case 41:
LABEL_27:
        if ( ++a1->waitTimer == 750 )
        {
          a1->entityFlags &= 0xDFFFu;
          a1->animationNumber = 0;
        }
        if ( a1->waitTimer > 1000 )
        {
          a1->currentState = 100;
          a1->animationNumber = 0;
          createNPC((NPCNames)183, 0, 0, 0, 0, 0, a1, 256);
          if ( getNPCFlag(563) )
            createNPC((NPCNames)182, 0, 0, 0, 0, 0, a1, 256);
          else
            createNPC((NPCNames)181, 0, 0, 0, 0, 0, a1, 256);
        }
        break;
      case 100:
        a1->animationNumber = 0;
        a1->XVel = 7 * a1->XVel / 8;
        a1->count1 = 0;
        if ( a1->XPos <= a1->curlyTargetX + 0x2000 )
        {
          if ( a1->XPos < a1->curlyTargetX - 0x2000 )
          {
            a1->currentState = 300;
            a1->animationNumber = 1;
            a1->direction = 2;
            a1->waitTimer = random(20, 60);
          }
        }
        else
        {
          a1->currentState = 200;
          a1->animationNumber = 1;
          a1->direction = 0;
          a1->waitTimer = random(20, 60);
        }
        break;
      default:
        break;
    }
  }
  if ( superXPos )
    --superXPos;
  if ( superXPos == 70 )
    a1->count2 = 10;
  if ( superXPos == 60 && a1->collisionFlags & 8 && random(0, 2) )
  {
    a1->count1 = 0;
    a1->YVel = -1536;
    a1->animationNumber = 1;
    playSoundEffect(SFXQuoteJump, 1);
    if ( a1->XPos <= a1->curlyTargetX )
      a1->currentState = 310;
    else
      a1->currentState = 210;
  }
  v49 = a1->XPos - a1->curlyTargetX;
  v4 = a1->YPos - a1->curlyTargetY;
  if ( v49 < 0 )
    v49 = -v49;
  if ( a1->currentState == 100 )
  {
    if ( v49 + 1024 >= v4 )
      a1->animationNumber = 0;
    else
      a1->animationNumber = 5;
  }
  if ( a1->currentState == 210 || a1->currentState == 310 )
  {
    if ( v49 + 1024 >= v4 )
      a1->animationNumber = 1;
    else
      a1->animationNumber = 6;
  }
  if ( a1->currentState == 200 || a1->currentState == 300 )
  {
    ++a1->animationTimer;
    if ( v49 + 1024 >= v4 )
      a1->animationNumber = a1->animationTimer / 4 % 4 + 1;
    else
      a1->animationNumber = a1->animationTimer / 4 % 4 + 6;
    if ( a1->waitTimer )
    {
      --a1->waitTimer;
      if ( a1->collisionFlags && a1->count1 > 10 )
      {
        a1->count1 = 0;
        a1->YVel = -1536;
        a1->currentState += 10;
        a1->animationNumber = 1;
        playSoundEffect(SFXQuoteJump, 1);
      }
    }
    else
    {
      a1->currentState = 100;
      a1->animationNumber = 0;
    }
  }
  if ( a1->currentState >= 100 && a1->currentState < 500 )
  {
    if ( a1->XPos >= quote.XPos - 40960 && a1->XPos <= quote.XPos + 40960 )
    {
      a1->YVel += 51;
    }
    else if ( a1->collisionFlags )
    {
      a1->YVel += 16;
    }
    else
    {
      a1->YVel += 51;
    }
  }
  if ( a1->XVel > 768 )
    a1->XVel = 768;
  if ( a1->XVel < -768 )
    a1->XVel = -768;
  if ( a1->YVel > 1535 )
    a1->YVel = 1535;
  a1->XPos += a1->XVel;
  a1->YPos += a1->YVel;
  if ( a1->currentState >= 100 && !(a1->collisionFlags & 8) && a1->animationNumber != 1000 )
  {
    if ( v49 + 1024 >= v4 )
      a1->animationNumber = 1;
    else
      a1->animationNumber = 6;
  }
  if ( a1->direction )
    v1 = &v5 + 4 * a1->animationNumber;
  else
    v1 = &v50 + 4 * a1->animationNumber;
  result = &a1->rect;
  result->left = *v1;
  result->top = v1[1];
  result->right = v1[2];
  result->bottom = v1[3];
  return result;
}
// 4BBA20: using guessed type int curlyShootWait;
// 4BBA24: using guessed type int curlyShootX;
// 4BBA2C: using guessed type int superXPos;

//----- (0044BE10) --------------------------------------------------------
int __cdecl NPC181(int a1)
{
  int result; // eax
  int *v2; // eax
  int *v3; // ecx
  int v4; // [esp+0h] [ebp-44h]
  int v5; // [esp+4h] [ebp-40h]
  int v6; // [esp+8h] [ebp-3Ch]
  int v7; // [esp+Ch] [ebp-38h]
  int v8; // [esp+10h] [ebp-34h]
  int v9; // [esp+14h] [ebp-30h]
  int v10; // [esp+18h] [ebp-2Ch]
  int v11; // [esp+1Ch] [ebp-28h]
  int v12; // [esp+20h] [ebp-24h]
  int v13; // [esp+24h] [ebp-20h]
  int v14; // [esp+28h] [ebp-1Ch]
  int v15; // [esp+2Ch] [ebp-18h]
  int v16; // [esp+30h] [ebp-14h]
  int v17; // [esp+34h] [ebp-10h]
  int v18; // [esp+38h] [ebp-Ch]
  int v19; // [esp+3Ch] [ebp-8h]
  int v20; // [esp+40h] [ebp-4h]

  v13 = 216;
  v14 = 152;
  v15 = 232;
  v16 = 168;
  v17 = 232;
  v18 = 152;
  v19 = 248;
  v20 = 168;
  v5 = 216;
  v6 = 168;
  v7 = 232;
  v8 = 184;
  v9 = 232;
  v10 = 168;
  v11 = 248;
  v12 = 184;
  result = a1;
  if ( *(_DWORD *)(a1 + 168) )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 104) >= 5 )
    {
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 76) )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8);
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12) - 5120;
      *(_DWORD *)(a1 + 104) = 1;
    }
    else
    {
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 76) )
      {
        *(_DWORD *)(a1 + 76) = 2;
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) + 4096;
      }
      else
      {
        *(_DWORD *)(a1 + 76) = 0;
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) - 4096;
      }
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12);
      *(_DWORD *)(a1 + 104) = 0;
    }
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 104) == 1
      || *(_DWORD *)(*(_DWORD *)(a1 + 168) + 104) == 3
      || *(_DWORD *)(*(_DWORD *)(a1 + 168) + 104) == 6
      || *(_DWORD *)(*(_DWORD *)(a1 + 168) + 104) == 8 )
    {
      *(_DWORD *)(a1 + 12) -= 512;
    }
    v4 = *(_DWORD *)(a1 + 116);
    if ( v4 )
    {
      if ( v4 == 10 )
      {
        if ( ++*(_DWORD *)(a1 + 120) % 6 == 1 )
        {
          if ( *(_DWORD *)(a1 + 104) )
          {
            if ( *(_DWORD *)(a1 + 76) )
            {
              createBullet(bulletMachineGunLevel3, *(_DWORD *)(a1 + 8) + 1024, *(_DWORD *)(a1 + 12) - 2048, up);
              createEffect(*(_DWORD *)(a1 + 8) + 1024, *(_DWORD *)(a1 + 12) - 2048, effectStar, 0);
            }
            else
            {
              createBullet(bulletMachineGunLevel3, *(_DWORD *)(a1 + 8) - 1024, *(_DWORD *)(a1 + 12) - 2048, up);
              createEffect(*(_DWORD *)(a1 + 8) - 1024, *(_DWORD *)(a1 + 12) - 2048, effectStar, 0);
            }
          }
          else if ( *(_DWORD *)(a1 + 76) )
          {
            createBullet(bulletMachineGunLevel3, *(_DWORD *)(a1 + 8) + 2048, *(_DWORD *)(a1 + 12) + 1536, right);
            createEffect(*(_DWORD *)(a1 + 8) + 2048, *(_DWORD *)(a1 + 12) + 1536, effectStar, 0);
          }
          else
          {
            createBullet(bulletMachineGunLevel3, *(_DWORD *)(a1 + 8) - 2048, *(_DWORD *)(a1 + 12) + 1536, 0);
            createEffect(*(_DWORD *)(a1 + 8) - 2048, *(_DWORD *)(a1 + 12) + 1536, effectStar, 0);
          }
        }
        if ( *(_DWORD *)(a1 + 120) == 60 )
          *(_DWORD *)(a1 + 116) = 0;
      }
    }
    else if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 112) == 10 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 168) + 112) = 0;
      *(_DWORD *)(a1 + 116) = 10;
      *(_DWORD *)(a1 + 120) = 0;
    }
    if ( *(_DWORD *)(a1 + 76) )
      v2 = &v5 + 4 * *(_DWORD *)(a1 + 104);
    else
      v2 = &v13 + 4 * *(_DWORD *)(a1 + 104);
    v3 = (int *)(a1 + 84);
    *v3 = *v2;
    v3[1] = v2[1];
    v3[2] = v2[2];
    result = v2[3];
    v3[3] = result;
  }
  return result;
}

//----- (0044C220) --------------------------------------------------------
int __cdecl NPC182(int a1)
{
  int result; // eax
  int *v2; // eax
  int *v3; // ecx
  int v4; // [esp+0h] [ebp-44h]
  int v5; // [esp+4h] [ebp-40h]
  int v6; // [esp+8h] [ebp-3Ch]
  int v7; // [esp+Ch] [ebp-38h]
  int v8; // [esp+10h] [ebp-34h]
  int v9; // [esp+14h] [ebp-30h]
  int v10; // [esp+18h] [ebp-2Ch]
  int v11; // [esp+1Ch] [ebp-28h]
  int v12; // [esp+20h] [ebp-24h]
  int v13; // [esp+24h] [ebp-20h]
  int v14; // [esp+28h] [ebp-1Ch]
  int v15; // [esp+2Ch] [ebp-18h]
  int v16; // [esp+30h] [ebp-14h]
  int v17; // [esp+34h] [ebp-10h]
  int v18; // [esp+38h] [ebp-Ch]
  int v19; // [esp+3Ch] [ebp-8h]
  int v20; // [esp+40h] [ebp-4h]

  v13 = 184;
  v14 = 152;
  v15 = 200;
  v16 = 168;
  v17 = 200;
  v18 = 152;
  v19 = 216;
  v20 = 168;
  v5 = 184;
  v6 = 168;
  v7 = 200;
  v8 = 184;
  v9 = 200;
  v10 = 168;
  v11 = 216;
  v12 = 184;
  result = a1;
  if ( *(_DWORD *)(a1 + 168) )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 104) >= 5 )
    {
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 76) )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8);
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12) - 5120;
      *(_DWORD *)(a1 + 104) = 1;
    }
    else
    {
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 76) )
      {
        *(_DWORD *)(a1 + 76) = 2;
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) + 4096;
      }
      else
      {
        *(_DWORD *)(a1 + 76) = 0;
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) - 4096;
      }
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12);
      *(_DWORD *)(a1 + 104) = 0;
    }
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 104) == 1
      || *(_DWORD *)(*(_DWORD *)(a1 + 168) + 104) == 3
      || *(_DWORD *)(*(_DWORD *)(a1 + 168) + 104) == 6
      || *(_DWORD *)(*(_DWORD *)(a1 + 168) + 104) == 8 )
    {
      *(_DWORD *)(a1 + 12) -= 512;
    }
    v4 = *(_DWORD *)(a1 + 116);
    if ( v4 )
    {
      if ( v4 == 10 )
      {
        if ( ++*(_DWORD *)(a1 + 120) % 12 == 1 )
        {
          if ( *(_DWORD *)(a1 + 104) )
          {
            if ( *(_DWORD *)(a1 + 76) )
            {
              createBullet(bulletPolarStarLevel3, *(_DWORD *)(a1 + 8) + 1024, *(_DWORD *)(a1 + 12) - 2048, up);
              createEffect(*(_DWORD *)(a1 + 8) + 1024, *(_DWORD *)(a1 + 12) - 2048, effectStar, 0);
            }
            else
            {
              createBullet(bulletPolarStarLevel3, *(_DWORD *)(a1 + 8) - 1024, *(_DWORD *)(a1 + 12) - 2048, up);
              createEffect(*(_DWORD *)(a1 + 8) - 1024, *(_DWORD *)(a1 + 12) - 2048, effectStar, 0);
            }
          }
          else if ( *(_DWORD *)(a1 + 76) )
          {
            createBullet(bulletPolarStarLevel3, *(_DWORD *)(a1 + 8) + 2048, *(_DWORD *)(a1 + 12) + 1536, right);
            createEffect(*(_DWORD *)(a1 + 8) + 2048, *(_DWORD *)(a1 + 12) + 1536, effectStar, 0);
          }
          else
          {
            createBullet(bulletPolarStarLevel3, *(_DWORD *)(a1 + 8) - 2048, *(_DWORD *)(a1 + 12) + 1536, 0);
            createEffect(*(_DWORD *)(a1 + 8) - 2048, *(_DWORD *)(a1 + 12) + 1536, effectStar, 0);
          }
        }
        if ( *(_DWORD *)(a1 + 120) == 60 )
          *(_DWORD *)(a1 + 116) = 0;
      }
    }
    else if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 112) == 10 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 168) + 112) = 0;
      *(_DWORD *)(a1 + 116) = 10;
      *(_DWORD *)(a1 + 120) = 0;
    }
    if ( *(_DWORD *)(a1 + 76) )
      v2 = &v5 + 4 * *(_DWORD *)(a1 + 104);
    else
      v2 = &v13 + 4 * *(_DWORD *)(a1 + 104);
    v3 = (int *)(a1 + 84);
    *v3 = *v2;
    v3[1] = v2[1];
    v3[2] = v2[2];
    result = v2[3];
    v3[3] = result;
  }
  return result;
}

//----- (0044C630) --------------------------------------------------------
int __cdecl NPC183(int a1)
{
  int result; // eax
  int *v2; // eax
  int *v3; // ecx
  int v4; // [esp+4h] [ebp-20h]
  int v5; // [esp+8h] [ebp-1Ch]
  int v6; // [esp+Ch] [ebp-18h]
  int v7; // [esp+10h] [ebp-14h]
  int v8; // [esp+14h] [ebp-10h]
  int v9; // [esp+18h] [ebp-Ch]
  int v10; // [esp+1Ch] [ebp-8h]
  int v11; // [esp+20h] [ebp-4h]

  v4 = 56;
  v5 = 96;
  v6 = 80;
  v7 = 120;
  v8 = 80;
  v9 = 96;
  v10 = 104;
  v11 = 120;
  result = a1;
  if ( *(_DWORD *)(a1 + 168) )
  {
    if ( !*(_DWORD *)(a1 + 116) )
    {
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8);
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12);
      *(_DWORD *)(a1 + 116) = 1;
    }
    *(_DWORD *)(a1 + 8) += (*(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) - *(_DWORD *)(a1 + 8)) / 2;
    *(_DWORD *)(a1 + 12) += (*(_DWORD *)(*(_DWORD *)(a1 + 168) + 12) - *(_DWORD *)(a1 + 12)) / 2;
    if ( ++*(_DWORD *)(a1 + 100) > 1 )
    {
      *(_DWORD *)(a1 + 100) = 0;
      ++*(_DWORD *)(a1 + 104);
    }
    if ( *(_DWORD *)(a1 + 104) > 1 )
      *(_DWORD *)(a1 + 104) = 0;
    result = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 4) & 0x100;
    if ( result )
    {
      v2 = &v4 + 4 * *(_DWORD *)(a1 + 104);
      v3 = (int *)(a1 + 84);
      *v3 = *v2;
      v3[1] = v2[1];
      v3[2] = v2[2];
      result = v2[3];
      v3[3] = result;
    }
    else
    {
      *(_DWORD *)(a1 + 92) = 0;
    }
  }
  return result;
}

//----- (0044C7A0) --------------------------------------------------------
int __cdecl NPC184(int a1)
{
  int v1; // ST10_4
  int v2; // ST0C_4
  int v3; // ST08_4
  int v4; // eax
  int *v5; // eax
  int *v6; // ecx
  int result; // eax
  signed int i; // [esp+8h] [ebp-44h]
  int v9; // [esp+Ch] [ebp-40h]
  int v10; // [esp+10h] [ebp-3Ch]
  int v11; // [esp+14h] [ebp-38h]
  int v12; // [esp+18h] [ebp-34h]
  int v13; // [esp+1Ch] [ebp-30h]
  int v14; // [esp+20h] [ebp-2Ch]
  int v15; // [esp+24h] [ebp-28h]
  int v16; // [esp+28h] [ebp-24h]
  int v17; // [esp+2Ch] [ebp-20h]
  int v18; // [esp+30h] [ebp-1Ch]
  int v19; // [esp+34h] [ebp-18h]
  int v20; // [esp+38h] [ebp-14h]
  int v21; // [esp+3Ch] [ebp-10h]
  int v22; // [esp+40h] [ebp-Ch]
  int v23; // [esp+44h] [ebp-8h]
  int v24; // [esp+48h] [ebp-4h]

  v9 = 0;
  v10 = 64;
  v11 = 32;
  v12 = 96;
  v13 = 32;
  v14 = 64;
  v15 = 64;
  v16 = 96;
  v17 = 64;
  v18 = 64;
  v19 = 96;
  v20 = 96;
  v21 = 32;
  v22 = 64;
  v23 = 64;
  v24 = 96;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 8) += 4096;
      *(_DWORD *)(a1 + 12) += 4096;
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 104) = 1;
      *(_DWORD *)(a1 + 120) = 0;
      *(_WORD *)(a1 + 80) |= 8u;
      goto LABEL_4;
    case 0xB:
LABEL_4:
      switch ( *(_DWORD *)(a1 + 76) )
      {
        case 0:
          *(_DWORD *)(a1 + 8) -= 128;
          break;
        case 1:
          *(_DWORD *)(a1 + 12) -= 128;
          break;
        case 2:
          *(_DWORD *)(a1 + 8) += 128;
          break;
        case 3:
          *(_DWORD *)(a1 + 12) += 128;
          break;
        default:
          break;
      }
      if ( !(++*(_DWORD *)(a1 + 120) % 8) )
        playSoundEffect(SFXLargeObjectHitGround, 1);
      setQuake(20);
      break;
    case 0x14:
      for ( i = 0; i < 4; ++i )
      {
        v1 = random(-1536, 0);
        v2 = random(-341, 341);
        v3 = *(_DWORD *)(a1 + 12) + 0x2000;
        v4 = random(-12, 12);
        createNPC(NPCSmoke, *(_DWORD *)(a1 + 8) + (v4 << 9), v3, v2, v1, 0, 0, 256);
      }
      *(_DWORD *)(a1 + 116) = 1;
      break;
    default:
      break;
  }
  if ( ++*(_DWORD *)(a1 + 100) > 10 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 3 )
    *(_DWORD *)(a1 + 104) = 0;
  v5 = &v9 + 4 * *(_DWORD *)(a1 + 104);
  v6 = (int *)(a1 + 84);
  *v6 = *v5;
  v6[1] = v5[1];
  v6[2] = v5[2];
  result = v5[3];
  v6[3] = result;
  return result;
}

//----- (0044CA60) --------------------------------------------------------
_DWORD *__cdecl NPC185(int a1)
{
  _DWORD *result; // eax

  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 12) += 4096;
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 104) = 1;
      *(_DWORD *)(a1 + 120) = 0;
      *(_WORD *)(a1 + 80) |= 8u;
      goto LABEL_4;
    case 0xB:
LABEL_4:
      switch ( *(_DWORD *)(a1 + 76) )
      {
        case 0:
          *(_DWORD *)(a1 + 8) -= 128;
          break;
        case 1:
          *(_DWORD *)(a1 + 12) -= 128;
          break;
        case 2:
          *(_DWORD *)(a1 + 8) += 128;
          break;
        case 3:
          *(_DWORD *)(a1 + 12) += 128;
          break;
        default:
          break;
      }
      ++*(_DWORD *)(a1 + 120);
      break;
    case 0x14:
      *(_DWORD *)(a1 + 12) -= 12288;
      *(_DWORD *)(a1 + 116) = 1;
      break;
    default:
      break;
  }
  result = (_DWORD *)(a1 + 84);
  *result = 96;
  result[1] = 64;
  result[2] = 112;
  result[3] = 96;
  return result;
}

//----- (0044CBE0) --------------------------------------------------------
int __cdecl NPC186(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+4h] [ebp-44h]
  int v5; // [esp+8h] [ebp-40h]
  int v6; // [esp+Ch] [ebp-3Ch]
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  int v9; // [esp+18h] [ebp-30h]
  int v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  int v13; // [esp+28h] [ebp-20h]
  int v14; // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+30h] [ebp-18h]
  int v16; // [esp+34h] [ebp-14h]
  int v17; // [esp+38h] [ebp-10h]
  int v18; // [esp+3Ch] [ebp-Ch]
  int v19; // [esp+40h] [ebp-8h]
  int v20; // [esp+44h] [ebp-4h]

  v5 = 48;
  v6 = 48;
  v7 = 64;
  v8 = 64;
  v9 = 64;
  v10 = 48;
  v11 = 80;
  v12 = 64;
  v13 = 80;
  v14 = 48;
  v15 = 96;
  v16 = 64;
  v17 = 64;
  v18 = 48;
  v19 = 80;
  v20 = 64;
  v4 = *(_DWORD *)(a1 + 116);
  switch ( v4 )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      goto LABEL_13;
    case 10:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 104) = 1;
      *(_DWORD *)(a1 + 120) = 0;
      *(_WORD *)(a1 + 80) |= 8u;
      break;
    case 11:
      break;
    default:
      goto LABEL_13;
  }
  switch ( *(_DWORD *)(a1 + 76) )
  {
    case 0:
      *(_DWORD *)(a1 + 8) -= 128;
      break;
    case 1:
      *(_DWORD *)(a1 + 12) -= 128;
      break;
    case 2:
      *(_DWORD *)(a1 + 8) += 128;
      break;
    case 3:
      *(_DWORD *)(a1 + 12) += 128;
      break;
    default:
      break;
  }
  ++*(_DWORD *)(a1 + 120);
LABEL_13:
  if ( ++*(_DWORD *)(a1 + 100) > 10 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 3 )
    *(_DWORD *)(a1 + 104) = 0;
  v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (0044CDB0) --------------------------------------------------------
RECT *__cdecl NPC187(NPC *a1)
{
  int *v1; // edx
  RECT *result; // eax
  int v3; // [esp+0h] [ebp-48h]
  int v4; // [esp+4h] [ebp-44h]
  int v5; // [esp+8h] [ebp-40h]
  int v6; // [esp+Ch] [ebp-3Ch]
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  int v9; // [esp+18h] [ebp-30h]
  int v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  int v13; // [esp+28h] [ebp-20h]
  int v14; // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+30h] [ebp-18h]
  int v16; // [esp+34h] [ebp-14h]
  int v17; // [esp+38h] [ebp-10h]
  int v18; // [esp+3Ch] [ebp-Ch]
  int v19; // [esp+40h] [ebp-8h]
  int i; // [esp+44h] [ebp-4h]

  v3 = a1->currentState;
  if ( v3 )
  {
    if ( v3 != 1 )
    {
      if ( v3 == 2 )
      {
        a1->count1 += 4;
        if ( quote.XPos >= a1->XPos )
          a1->direction = 2;
        else
          a1->direction = 0;
        if ( a1->curlyTargetY < a1->YPos )
          a1->YVel -= 16;
        if ( a1->curlyTargetY > a1->YPos )
          a1->YVel += 16;
        if ( a1->YVel > 853 )
          a1->YVel = 853;
        if ( a1->YVel < -853 )
          a1->YVel = -853;
      }
      goto LABEL_21;
    }
  }
  else
  {
    a1->currentState = 1;
    a1->curlyTargetX = a1->XPos;
    a1->curlyTargetY = a1->YPos;
    a1->count1 = 120;
    a1->waitTimer = random(0, 50);
    for ( i = 0; i < 5; ++i )
      createNPC((NPCNames)188, 0, 0, 0, 0, (Directions)(51 * i), a1, 256);
  }
  if ( ++a1->waitTimer >= 50 )
  {
    a1->waitTimer = 0;
    a1->currentState = 2;
    a1->YVel = 768;
  }
LABEL_21:
  a1->XPos += a1->XVel;
  a1->YPos += a1->YVel;
  v12 = 224;
  v13 = 104;
  v14 = 256;
  v15 = 136;
  v16 = 256;
  v17 = 104;
  v18 = 288;
  v19 = 136;
  v4 = 224;
  v5 = 136;
  v6 = 256;
  v7 = 168;
  v8 = 256;
  v9 = 136;
  v10 = 288;
  v11 = 168;
  if ( ++a1->animationTimer > 2 )
  {
    a1->animationTimer = 0;
    ++a1->animationNumber;
  }
  if ( a1->animationNumber > 1 )
    a1->animationNumber = 0;
  if ( a1->direction )
    v1 = &v4 + 4 * a1->animationNumber;
  else
    v1 = &v12 + 4 * a1->animationNumber;
  result = &a1->rect;
  result->left = *v1;
  result->top = v1[1];
  result->right = v1[2];
  result->bottom = v1[3];
  return result;
}

//----- (0044D070) --------------------------------------------------------
int *__cdecl NPC188(int a1)
{
  int v1; // esi
  int v2; // esi
  int v3; // ecx
  int v4; // eax
  int *v5; // edx
  int *result; // eax
  int v7; // [esp+0h] [ebp-48h]
  int v8; // [esp+4h] [ebp-44h]
  int v9; // [esp+8h] [ebp-40h]
  int v10; // [esp+Ch] [ebp-3Ch]
  int v11; // [esp+10h] [ebp-38h]
  int v12; // [esp+14h] [ebp-34h]
  int v13; // [esp+18h] [ebp-30h]
  int v14; // [esp+1Ch] [ebp-2Ch]
  int v15; // [esp+20h] [ebp-28h]
  int v16; // [esp+24h] [ebp-24h]
  int v17; // [esp+28h] [ebp-20h]
  int v18; // [esp+2Ch] [ebp-1Ch]
  int v19; // [esp+30h] [ebp-18h]
  int v20; // [esp+34h] [ebp-14h]
  int v21; // [esp+38h] [ebp-10h]
  int v22; // [esp+3Ch] [ebp-Ch]
  int v23; // [esp+40h] [ebp-8h]
  unsigned __int8 v24; // [esp+47h] [ebp-1h]

  v7 = *(_DWORD *)(a1 + 116);
  switch ( v7 )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 108) = *(_DWORD *)(a1 + 76);
      goto LABEL_6;
    case 1:
LABEL_6:
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 40) == 187 && **(_BYTE **)(a1 + 168) & 0x80 )
      {
        v24 = *(_BYTE *)(a1 + 108) + *(_BYTE *)(*(_DWORD *)(a1 + 168) + 108);
        v1 = *(_DWORD *)(a1 + 168);
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(v1 + 8) + 20 * getSin(v24);
        v2 = *(_DWORD *)(a1 + 168);
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(v2 + 12) + 32 * getCos(v24);
      }
      else
      {
        *(_DWORD *)(a1 + 16) = random(-512, 512);
        *(_DWORD *)(a1 + 20) = random(-512, 512);
        *(_DWORD *)(a1 + 116) = 10;
      }
      break;
    case 10:
      if ( quote.XPos >= *(_DWORD *)(a1 + 8) )
        v3 = *(_DWORD *)(a1 + 16) + 32;
      else
        v3 = *(_DWORD *)(a1 + 16) - 32;
      *(_DWORD *)(a1 + 16) = v3;
      if ( quote.YPos >= *(_DWORD *)(a1 + 12) )
        v4 = *(_DWORD *)(a1 + 20) + 32;
      else
        v4 = *(_DWORD *)(a1 + 20) - 32;
      *(_DWORD *)(a1 + 20) = v4;
      if ( *(_DWORD *)(a1 + 16) > 2048 )
        *(_DWORD *)(a1 + 16) = 2048;
      if ( *(_DWORD *)(a1 + 16) < -2048 )
        *(_DWORD *)(a1 + 16) = -2048;
      if ( *(_DWORD *)(a1 + 20) > 512 )
        *(_DWORD *)(a1 + 20) = 512;
      if ( *(_DWORD *)(a1 + 20) < -512 )
        *(_DWORD *)(a1 + 20) = -512;
      *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
      break;
  }
  if ( quote.XPos >= *(_DWORD *)(a1 + 8) )
    *(_DWORD *)(a1 + 76) = 2;
  else
    *(_DWORD *)(a1 + 76) = 0;
  if ( ++*(_DWORD *)(a1 + 100) > 2 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 1 )
    *(_DWORD *)(a1 + 104) = 0;
  v16 = 288;
  v17 = 104;
  v18 = 304;
  v19 = 120;
  v20 = 304;
  v21 = 104;
  v22 = 320;
  v23 = 120;
  v8 = 288;
  v9 = 120;
  v10 = 304;
  v11 = 136;
  v12 = 304;
  v13 = 120;
  v14 = 320;
  v15 = 136;
  if ( *(_DWORD *)(a1 + 76) )
    v5 = &v8 + 4 * *(_DWORD *)(a1 + 104);
  else
    v5 = &v16 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v5;
  result[1] = v5[1];
  result[2] = v5[2];
  result[3] = v5[3];
  return result;
}

//----- (0044D3A0) --------------------------------------------------------
int __cdecl NPC189(int a1)
{
  int v1; // ecx
  int v2; // eax
  int *v3; // ecx
  int *v4; // edx
  int result; // eax
  int v6; // [esp+0h] [ebp-34h]
  int v7; // [esp+4h] [ebp-30h]
  int v8; // [esp+8h] [ebp-2Ch]
  int v9; // [esp+Ch] [ebp-28h]
  int v10; // [esp+10h] [ebp-24h]
  int v11; // [esp+14h] [ebp-20h]
  int v12; // [esp+18h] [ebp-1Ch]
  int v13; // [esp+1Ch] [ebp-18h]
  int v14; // [esp+20h] [ebp-14h]
  int v15; // [esp+24h] [ebp-10h]
  int v16; // [esp+28h] [ebp-Ch]
  int v17; // [esp+2Ch] [ebp-8h]
  int v18; // [esp+30h] [ebp-4h]

  v6 = *(_DWORD *)(a1 + 116);
  if ( v6 )
  {
    if ( v6 != 1 )
    {
      if ( v6 == 10 )
      {
        if ( quote.XPos >= *(_DWORD *)(a1 + 8) )
          v1 = *(_DWORD *)(a1 + 16) + 8;
        else
          v1 = *(_DWORD *)(a1 + 16) - 8;
        *(_DWORD *)(a1 + 16) = v1;
        if ( quote.YPos >= *(_DWORD *)(a1 + 12) )
          v2 = *(_DWORD *)(a1 + 20) + 8;
        else
          v2 = *(_DWORD *)(a1 + 20) - 8;
        *(_DWORD *)(a1 + 20) = v2;
        if ( *(_DWORD *)(a1 + 16) > 1024 )
          *(_DWORD *)(a1 + 16) = 1024;
        if ( *(_DWORD *)(a1 + 16) < -1024 )
          *(_DWORD *)(a1 + 16) = -1024;
        if ( *(_DWORD *)(a1 + 20) > 1024 )
          *(_DWORD *)(a1 + 20) = 1024;
        if ( *(_DWORD *)(a1 + 20) < -1024 )
          *(_DWORD *)(a1 + 20) = -1024;
        *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
      }
      goto LABEL_24;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 16) = -64;
  }
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( ++*(_DWORD *)(a1 + 120) > 256 )
    *(_DWORD *)(a1 + 116) = 10;
LABEL_24:
  if ( quote.XPos >= *(_DWORD *)(a1 + 8) )
    *(_DWORD *)(a1 + 76) = 2;
  else
    *(_DWORD *)(a1 + 76) = 0;
  if ( ++*(_DWORD *)(a1 + 100) > 2 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 2 )
    *(_DWORD *)(a1 + 104) = 0;
  v7 = 224;
  v8 = 184;
  v9 = 232;
  v10 = 200;
  v11 = 232;
  v12 = 184;
  v13 = 240;
  v14 = 200;
  v15 = 240;
  v16 = 184;
  v17 = 248;
  v18 = 200;
  v3 = &v7 + 4 * *(_DWORD *)(a1 + 104);
  v4 = (int *)(a1 + 84);
  *v4 = *v3;
  v4[1] = v3[1];
  result = v3[2];
  v4[2] = result;
  v4[3] = v3[3];
  return result;
}

//----- (0044D5E0) --------------------------------------------------------
int *__cdecl NPC190(int a1)
{
  int v1; // ST10_4
  int v2; // ST0C_4
  int v3; // eax
  int *v4; // edx
  int *result; // eax
  int v6; // [esp+0h] [ebp-28h]
  signed int i; // [esp+4h] [ebp-24h]
  int v8; // [esp+8h] [ebp-20h]
  int v9; // [esp+Ch] [ebp-1Ch]
  int v10; // [esp+10h] [ebp-18h]
  int v11; // [esp+14h] [ebp-14h]
  int v12; // [esp+18h] [ebp-10h]
  int v13; // [esp+1Ch] [ebp-Ch]
  int v14; // [esp+20h] [ebp-8h]
  int v15; // [esp+24h] [ebp-4h]

  v8 = 192;
  v9 = 32;
  v10 = 208;
  v11 = 48;
  v12 = 208;
  v13 = 32;
  v14 = 224;
  v15 = 48;
  v6 = *(_DWORD *)(a1 + 116);
  if ( v6 )
  {
    if ( v6 == 10 )
    {
      playSoundEffect(SFXExplosion, 1);
      for ( i = 0; i < 8; ++i )
      {
        v1 = random(-3, 3) << 9;
        v2 = random(-8, -2) << 9;
        v3 = random(-8, 8);
        createNPC(NPCSmoke, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12) + (v3 << 9), v2, v1, 0, 0, 256);
      }
      *(_BYTE *)a1 = 0;
    }
    else if ( v6 == 20 )
    {
      if ( ++*(_DWORD *)(a1 + 100) > 10 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 1 )
        *(_DWORD *)(a1 + 104) = 0;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 104) = 0;
  }
  v4 = &v8 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v4;
  result[1] = v4[1];
  result[2] = v4[2];
  result[3] = v4[3];
  return result;
}

//----- (0044D740) --------------------------------------------------------
int __cdecl NPC191(int a1, int a2, int a3, int a4)
{
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  int v7; // ecx
  int result; // eax

  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 10;
      *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 20) = 512;
      goto LABEL_3;
    case 0xA:
LABEL_3:
      if ( *(_DWORD *)(a1 + 12) >= *(_DWORD *)(a1 + 36) )
        v4 = *(_DWORD *)(a1 + 20) - 4;
      else
        v4 = *(_DWORD *)(a1 + 20) + 4;
      *(_DWORD *)(a1 + 20) = v4;
      if ( *(_DWORD *)(a1 + 20) < -256 )
        *(_DWORD *)(a1 + 20) = -256;
      if ( *(_DWORD *)(a1 + 20) > 256 )
        *(_DWORD *)(a1 + 20) = 256;
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
      break;
    case 0x14:
      *(_DWORD *)(a1 + 116) = 21;
      *(_DWORD *)(a1 + 120) = 0;
      goto LABEL_12;
    case 0x15:
LABEL_12:
      if ( *(_DWORD *)(a1 + 12) >= *(_DWORD *)(a1 + 36) )
        v5 = *(_DWORD *)(a1 + 20) - 4;
      else
        v5 = *(_DWORD *)(a1 + 20) + 4;
      *(_DWORD *)(a1 + 20) = v5;
      if ( *(_DWORD *)(a1 + 20) < -512 )
        *(_DWORD *)(a1 + 20) = -512;
      if ( *(_DWORD *)(a1 + 20) > 512 )
        *(_DWORD *)(a1 + 20) = 512;
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
      if ( ++*(_DWORD *)(a1 + 120) > 1000 )
        *(_DWORD *)(a1 + 116) = 22;
      break;
    case 0x16:
      if ( *(_DWORD *)(a1 + 12) >= 0 )
        v6 = *(_DWORD *)(a1 + 20) - 4;
      else
        v6 = *(_DWORD *)(a1 + 20) + 4;
      *(_DWORD *)(a1 + 20) = v6;
      if ( *(_DWORD *)(a1 + 20) < -512 )
        *(_DWORD *)(a1 + 20) = -512;
      if ( *(_DWORD *)(a1 + 20) > 512 )
        *(_DWORD *)(a1 + 20) = 512;
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
      if ( *(_DWORD *)(a1 + 12) < 0x8000 || curlyShootY )
      {
        *(_DWORD *)(a1 + 116) = 21;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    case 0x1E:
      if ( *(_DWORD *)(a1 + 12) >= 0 )
        v7 = *(_DWORD *)(a1 + 20) - 4;
      else
        v7 = *(_DWORD *)(a1 + 20) + 4;
      *(_DWORD *)(a1 + 20) = v7;
      if ( *(_DWORD *)(a1 + 20) < -512 )
        *(_DWORD *)(a1 + 20) = -512;
      if ( *(_DWORD *)(a1 + 20) > 256 )
        *(_DWORD *)(a1 + 20) = 256;
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
      break;
    default:
      break;
  }
  result = *(_DWORD *)(a1 + 12);
  globalWaterDepth = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 92) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  return result;
}
// 499C90: using guessed type int globalWaterDepth;
// 4BBA28: using guessed type int curlyShootY;

//----- (0044DA00) --------------------------------------------------------
int __cdecl NPC192(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+4h] [ebp-40h]
  int v5; // [esp+8h] [ebp-3Ch]
  int v6; // [esp+Ch] [ebp-38h]
  int v7; // [esp+10h] [ebp-34h]
  int v8; // [esp+14h] [ebp-30h]
  int v9; // [esp+18h] [ebp-2Ch]
  int v10; // [esp+1Ch] [ebp-28h]
  int v11; // [esp+20h] [ebp-24h]
  int v12; // [esp+24h] [ebp-20h]
  int v13; // [esp+28h] [ebp-1Ch]
  int v14; // [esp+2Ch] [ebp-18h]
  int v15; // [esp+30h] [ebp-14h]
  int v16; // [esp+34h] [ebp-10h]
  int v17; // [esp+38h] [ebp-Ch]
  int v18; // [esp+3Ch] [ebp-8h]
  int v19; // [esp+40h] [ebp-4h]

  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 148) = 0x2000;
      *(_DWORD *)(a1 + 140) = 0x2000;
      *(_DWORD *)(a1 + 144) = 4096;
      *(_DWORD *)(a1 + 152) = 4096;
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 104) = 1;
      *(_DWORD *)(a1 + 144) = 0x2000;
      *(_DWORD *)(a1 + 152) = 0x2000;
      *(_DWORD *)(a1 + 12) -= 2560;
      break;
    case 0x14:
      *(_DWORD *)(a1 + 116) = 21;
      *(_DWORD *)(a1 + 120) = 1;
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 12);
      goto LABEL_5;
    case 0x15:
LABEL_5:
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 32) + (random(-1, 1) << 9);
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 36) + (random(-1, 1) << 9);
      if ( ++*(_DWORD *)(a1 + 120) > 30 )
        *(_DWORD *)(a1 + 116) = 30;
      break;
    case 0x1E:
      *(_DWORD *)(a1 + 116) = 31;
      *(_DWORD *)(a1 + 120) = 1;
      *(_DWORD *)(a1 + 16) = -2048;
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 32);
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 36);
      playSoundEffect(SFXMissileImpact, 1);
      goto LABEL_9;
    case 0x1F:
LABEL_9:
      *(_DWORD *)(a1 + 16) += 32;
      *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
      ++*(_DWORD *)(a1 + 120);
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 36) + (random(-1, 1) << 9);
      if ( *(_DWORD *)(a1 + 120) > 10 )
        *(_DWORD *)(a1 + 76) = 2;
      if ( *(_DWORD *)(a1 + 120) > 200 )
        *(_DWORD *)(a1 + 116) = 40;
      break;
    case 0x28:
      *(_DWORD *)(a1 + 116) = 41;
      *(_DWORD *)(a1 + 120) = 2;
      *(_DWORD *)(a1 + 76) = 0;
      *(_DWORD *)(a1 + 12) -= 24576;
      *(_DWORD *)(a1 + 16) = -4096;
      goto LABEL_15;
    case 0x29:
LABEL_15:
      *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
      *(_DWORD *)(a1 + 120) += 2;
      if ( *(_DWORD *)(a1 + 120) > 1200 )
        *(_BYTE *)a1 = 0;
      break;
    default:
      break;
  }
  if ( !(*(_DWORD *)(a1 + 120) % 4) && *(_DWORD *)(a1 + 116) >= 20 )
  {
    playSoundEffect(SFXFireballBounce, 1);
    if ( *(_DWORD *)(a1 + 76) )
      createEffect(*(_DWORD *)(a1 + 8) - 5120, *(_DWORD *)(a1 + 12) + 5120, effectDrownedQuote, 0);
    else
      createEffect(*(_DWORD *)(a1 + 8) + 5120, *(_DWORD *)(a1 + 12) + 5120, effectDrownedQuote, right);
  }
  v12 = 224;
  v13 = 64;
  v14 = 256;
  v15 = 80;
  v16 = 256;
  v17 = 64;
  v18 = 288;
  v19 = 96;
  v4 = 224;
  v5 = 80;
  v6 = 256;
  v7 = 96;
  v8 = 288;
  v9 = 64;
  v10 = 320;
  v11 = 96;
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v12 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (0044DE20) --------------------------------------------------------
_DWORD *__cdecl NPC193(int a1)
{
  _DWORD *result; // eax

  if ( !*(_DWORD *)(a1 + 116) )
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 8) += 12288;
  }
  result = (_DWORD *)(a1 + 84);
  *result = 256;
  result[1] = 96;
  result[2] = 320;
  result[3] = 112;
  return result;
}

//----- (0044DEA0) --------------------------------------------------------
signed int __cdecl NPC194(int a1)
{
  _DWORD *v1; // edx
  signed int result; // eax

  if ( !*(_DWORD *)(a1 + 116) )
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 12) += 2048;
  }
  v1 = (_DWORD *)(a1 + 84);
  *v1 = 192;
  v1[1] = 120;
  result = 224;
  v1[2] = 224;
  v1[3] = 128;
  return result;
}

//----- (0044DF10) --------------------------------------------------------
_DWORD *__cdecl NPC195(int a1)
{
  _DWORD *result; // eax

  result = (_DWORD *)(a1 + 84);
  *result = 112;
  result[1] = 64;
  result[2] = 128;
  result[3] = 80;
  return result;
}

//----- (0044DF60) --------------------------------------------------------
signed int __cdecl NPC196(int a1)
{
  _DWORD *v1; // edx
  signed int result; // eax
  _DWORD *v3; // edx

  *(_DWORD *)(a1 + 8) -= 3072;
  if ( *(_DWORD *)(a1 + 8) <= 155648 )
    *(_DWORD *)(a1 + 8) += 180224;
  if ( *(_DWORD *)(a1 + 76) )
  {
    v3 = (_DWORD *)(a1 + 84);
    *v3 = 112;
    v3[1] = 80;
    result = 144;
    v3[2] = 144;
    v3[3] = 96;
  }
  else
  {
    v1 = (_DWORD *)(a1 + 84);
    *v1 = 112;
    v1[1] = 64;
    result = 144;
    v1[2] = 144;
    v1[3] = 80;
  }
  return result;
}

//----- (0044E020) --------------------------------------------------------
int __cdecl NPC197(void *Is_NPC_Alive)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  int v4; // [esp+0h] [ebp-44h]
  int v5; // [esp+4h] [ebp-40h]
  int v6; // [esp+8h] [ebp-3Ch]
  int v7; // [esp+Ch] [ebp-38h]
  int v8; // [esp+10h] [ebp-34h]
  int v9; // [esp+14h] [ebp-30h]
  int v10; // [esp+18h] [ebp-2Ch]
  int v11; // [esp+1Ch] [ebp-28h]
  int v12; // [esp+20h] [ebp-24h]
  int v13; // [esp+24h] [ebp-20h]
  int v14; // [esp+28h] [ebp-1Ch]
  int v15; // [esp+2Ch] [ebp-18h]
  int v16; // [esp+30h] [ebp-14h]
  int v17; // [esp+34h] [ebp-10h]
  int v18; // [esp+38h] [ebp-Ch]
  int v19; // [esp+3Ch] [ebp-8h]
  int v20; // [esp+40h] [ebp-4h]

  v5 = 0;
  v6 = 0;
  v7 = 16;
  v8 = 16;
  v9 = 16;
  v10 = 0;
  v11 = 32;
  v12 = 16;
  v13 = 32;
  v14 = 0;
  v15 = 48;
  v16 = 16;
  v17 = 48;
  v18 = 0;
  v19 = 64;
  v20 = 16;
  v4 = *((_DWORD *)Is_NPC_Alive + 29);
  if ( v4 )
  {
    if ( v4 != 10 )
    {
      if ( v4 == 20 )
      {
        *((_DWORD *)Is_NPC_Alive + 41) = 3;
        if ( ++*((_DWORD *)Is_NPC_Alive + 25) > 0 )
        {
          *((_DWORD *)Is_NPC_Alive + 25) = 0;
          ++*((_DWORD *)Is_NPC_Alive + 26);
        }
        if ( *((_DWORD *)Is_NPC_Alive + 26) > 3 )
          *((_DWORD *)Is_NPC_Alive + 26) = 2;
        if ( *((_DWORD *)Is_NPC_Alive + 2) < 24576 )
        {
          *((_DWORD *)Is_NPC_Alive + 15) = 0;
          NPC_Death_Maybe(Is_NPC_Alive, 1);
        }
      }
      goto LABEL_19;
    }
  }
  else
  {
    *((_DWORD *)Is_NPC_Alive + 29) = 10;
    *((_DWORD *)Is_NPC_Alive + 25) = 0;
    *((_DWORD *)Is_NPC_Alive + 5) = random(-512, 512);
    *((_DWORD *)Is_NPC_Alive + 4) = 2048;
  }
  if ( ++*((_DWORD *)Is_NPC_Alive + 25) > 2 )
  {
    *((_DWORD *)Is_NPC_Alive + 25) = 0;
    ++*((_DWORD *)Is_NPC_Alive + 26);
  }
  if ( *((_DWORD *)Is_NPC_Alive + 26) > 1 )
    *((_DWORD *)Is_NPC_Alive + 26) = 0;
  if ( *((_DWORD *)Is_NPC_Alive + 4) < 0 )
  {
    *((_DWORD *)Is_NPC_Alive + 41) = 3;
    *((_DWORD *)Is_NPC_Alive + 29) = 20;
  }
LABEL_19:
  if ( *((_DWORD *)Is_NPC_Alive + 1) & 2 )
    *((_DWORD *)Is_NPC_Alive + 5) = 512;
  if ( *((_DWORD *)Is_NPC_Alive + 1) & 8 )
    *((_DWORD *)Is_NPC_Alive + 5) = -512;
  *((_DWORD *)Is_NPC_Alive + 4) -= 12;
  *((_DWORD *)Is_NPC_Alive + 2) += *((_DWORD *)Is_NPC_Alive + 4);
  *((_DWORD *)Is_NPC_Alive + 3) += *((_DWORD *)Is_NPC_Alive + 5);
  v1 = &v5 + 4 * *((_DWORD *)Is_NPC_Alive + 26);
  v2 = (int *)((char *)Is_NPC_Alive + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}

//----- (0044E260) --------------------------------------------------------
void __cdecl NPC198(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int v3; // [esp+0h] [ebp-34h]
  int v4; // [esp+4h] [ebp-30h]
  int v5; // [esp+8h] [ebp-2Ch]
  int v6; // [esp+Ch] [ebp-28h]
  int v7; // [esp+10h] [ebp-24h]
  int v8; // [esp+14h] [ebp-20h]
  int v9; // [esp+18h] [ebp-1Ch]
  int v10; // [esp+1Ch] [ebp-18h]
  int v11; // [esp+20h] [ebp-14h]
  int v12; // [esp+24h] [ebp-10h]
  int v13; // [esp+28h] [ebp-Ch]
  int v14; // [esp+2Ch] [ebp-8h]
  int v15; // [esp+30h] [ebp-4h]

  v4 = 208;
  v5 = 48;
  v6 = 224;
  v7 = 72;
  v8 = 224;
  v9 = 48;
  v10 = 240;
  v11 = 72;
  v12 = 240;
  v13 = 48;
  v14 = 256;
  v15 = 72;
  v3 = *(_DWORD *)(a1 + 116);
  if ( v3 )
  {
    if ( v3 == 1 )
      *(_DWORD *)(a1 + 16) += 32;
  }
  else if ( ++*(_DWORD *)(a1 + 120) > 20 )
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 108) = 0;
  }
  if ( ++*(_DWORD *)(a1 + 100) > 0 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 2 )
    *(_DWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  v2[3] = v1[3];
  if ( ++*(_DWORD *)(a1 + 108) > 100 )
    *(_BYTE *)a1 = 0;
  if ( *(_DWORD *)(a1 + 108) % 4 == 1 )
    playSoundEffect(SFXIronHeadShot, 1);
}

//----- (0044E400) --------------------------------------------------------
int *__cdecl NPC199(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+8h] [ebp-50h]
  int v4; // [esp+Ch] [ebp-4Ch]
  int v5; // [esp+10h] [ebp-48h]
  int v6; // [esp+14h] [ebp-44h]
  int v7; // [esp+18h] [ebp-40h]
  int v8; // [esp+1Ch] [ebp-3Ch]
  int v9; // [esp+20h] [ebp-38h]
  int v10; // [esp+24h] [ebp-34h]
  int v11; // [esp+28h] [ebp-30h]
  int v12; // [esp+2Ch] [ebp-2Ch]
  int v13; // [esp+30h] [ebp-28h]
  int v14; // [esp+34h] [ebp-24h]
  int v15; // [esp+38h] [ebp-20h]
  int v16; // [esp+3Ch] [ebp-1Ch]
  int v17; // [esp+40h] [ebp-18h]
  int v18; // [esp+44h] [ebp-14h]
  int v19; // [esp+48h] [ebp-10h]
  int v20; // [esp+4Ch] [ebp-Ch]
  int v21; // [esp+50h] [ebp-8h]
  int v22; // [esp+54h] [ebp-4h]

  v3 = 72;
  v4 = 16;
  v5 = 74;
  v6 = 18;
  v7 = 74;
  v8 = 16;
  v9 = 76;
  v10 = 18;
  v11 = 76;
  v12 = 16;
  v13 = 78;
  v14 = 18;
  v15 = 78;
  v16 = 16;
  v17 = 80;
  v18 = 18;
  v19 = 80;
  v20 = 16;
  v21 = 82;
  v22 = 18;
  if ( !*(_DWORD *)(a1 + 116) )
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 104) = random(0, 2);
    switch ( *(_DWORD *)(a1 + 76) )
    {
      case 0:
        *(_DWORD *)(a1 + 16) = -1;
        break;
      case 1:
        *(_DWORD *)(a1 + 20) = -1;
        break;
      case 2:
        *(_DWORD *)(a1 + 16) = 1;
        break;
      case 3:
        *(_DWORD *)(a1 + 20) = 1;
        break;
      default:
        break;
    }
    *(_DWORD *)(a1 + 16) *= (random(4, 8) << 9) / 2;
    *(_DWORD *)(a1 + 20) *= (random(4, 8) << 9) / 2;
  }
  if ( ++*(_DWORD *)(a1 + 100) > 6 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 4 )
    *(_BYTE *)a1 = 0;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v1 = &v3 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (0044E5F0) --------------------------------------------------------
int __cdecl NPC200(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  int Y_Vel; // [esp+4h] [ebp-D4h]
  int v5; // [esp+8h] [ebp-D0h]
  int v6; // [esp+Ch] [ebp-CCh]
  int v7; // [esp+10h] [ebp-C8h]
  int v8; // [esp+14h] [ebp-C4h]
  int v9; // [esp+18h] [ebp-C0h]
  int v10; // [esp+1Ch] [ebp-BCh]
  int v11; // [esp+20h] [ebp-B8h]
  int v12; // [esp+24h] [ebp-B4h]
  int v13; // [esp+28h] [ebp-B0h]
  int v14; // [esp+2Ch] [ebp-ACh]
  int v15; // [esp+30h] [ebp-A8h]
  int v16; // [esp+34h] [ebp-A4h]
  int v17; // [esp+38h] [ebp-A0h]
  int v18; // [esp+3Ch] [ebp-9Ch]
  int v19; // [esp+40h] [ebp-98h]
  int v20; // [esp+44h] [ebp-94h]
  int v21; // [esp+48h] [ebp-90h]
  int v22; // [esp+4Ch] [ebp-8Ch]
  int v23; // [esp+50h] [ebp-88h]
  int v24; // [esp+54h] [ebp-84h]
  int v25; // [esp+58h] [ebp-80h]
  int v26; // [esp+5Ch] [ebp-7Ch]
  int v27; // [esp+60h] [ebp-78h]
  int v28; // [esp+64h] [ebp-74h]
  int X_Vel; // [esp+6Ch] [ebp-6Ch]
  int v30; // [esp+70h] [ebp-68h]
  int v31; // [esp+74h] [ebp-64h]
  int v32; // [esp+78h] [ebp-60h]
  int v33; // [esp+7Ch] [ebp-5Ch]
  int v34; // [esp+80h] [ebp-58h]
  int v35; // [esp+84h] [ebp-54h]
  int v36; // [esp+88h] [ebp-50h]
  int v37; // [esp+8Ch] [ebp-4Ch]
  int v38; // [esp+90h] [ebp-48h]
  int v39; // [esp+94h] [ebp-44h]
  int v40; // [esp+98h] [ebp-40h]
  int v41; // [esp+9Ch] [ebp-3Ch]
  int v42; // [esp+A0h] [ebp-38h]
  int v43; // [esp+A4h] [ebp-34h]
  int v44; // [esp+A8h] [ebp-30h]
  int v45; // [esp+ACh] [ebp-2Ch]
  int v46; // [esp+B0h] [ebp-28h]
  int v47; // [esp+B4h] [ebp-24h]
  int v48; // [esp+B8h] [ebp-20h]
  int v49; // [esp+BCh] [ebp-1Ch]
  int v50; // [esp+C0h] [ebp-18h]
  int v51; // [esp+C4h] [ebp-14h]
  int v52; // [esp+C8h] [ebp-10h]
  int v53; // [esp+CCh] [ebp-Ch]
  unsigned __int8 v54; // [esp+D7h] [ebp-1h]

  v30 = 0;
  v31 = 0;
  v32 = 40;
  v33 = 40;
  v34 = 40;
  v35 = 0;
  v36 = 80;
  v37 = 40;
  v38 = 80;
  v39 = 0;
  v40 = 120;
  v41 = 40;
  v42 = 120;
  v43 = 0;
  v44 = 160;
  v45 = 40;
  v46 = 160;
  v47 = 0;
  v48 = 200;
  v49 = 40;
  v50 = 200;
  v51 = 0;
  v52 = 240;
  v53 = 40;
  v5 = 0;
  v6 = 40;
  v7 = 40;
  v8 = 80;
  v9 = 40;
  v10 = 40;
  v11 = 80;
  v12 = 80;
  v13 = 80;
  v14 = 40;
  v15 = 120;
  v16 = 80;
  v17 = 120;
  v18 = 40;
  v19 = 160;
  v20 = 80;
  v21 = 160;
  v22 = 40;
  v23 = 200;
  v24 = 80;
  v25 = 200;
  v26 = 40;
  v27 = 240;
  v28 = 80;
  if ( *(_DWORD *)(a1 + 116) < 100 && *(_DWORD *)(a1 + 64) < 950 )
  {
    playSoundEffect(SFXExplosion, 1);
    createDustClouds(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 148), 8);
    Spawn_Exp(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 68));
    *(_DWORD *)(a1 + 116) = 100;
    *(_WORD *)(a1 + 80) &= 0xFFDFu;
    *(_DWORD *)(a1 + 164) = 0;
  }
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 10;
      *(_DWORD *)(a1 + 108) = 0;
      goto LABEL_6;
    case 0xA:
LABEL_6:
      if ( ++*(_DWORD *)(a1 + 100) > 30 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 1 )
        *(_DWORD *)(a1 + 104) = 0;
      if ( *(_DWORD *)(a1 + 108) )
        --*(_DWORD *)(a1 + 108);
      if ( !*(_DWORD *)(a1 + 108)
        && quote.XPos > *(_DWORD *)(a1 + 8) - 57344
        && quote.XPos < *(_DWORD *)(a1 + 8) + 57344 )
      {
        *(_DWORD *)(a1 + 116) = 20;
      }
      break;
    case 0x14:
      *(_DWORD *)(a1 + 116) = 21;
      *(_DWORD *)(a1 + 120) = 0;
      goto LABEL_18;
    case 0x15:
LABEL_18:
      if ( ++*(_DWORD *)(a1 + 120) / 2 % 2 )
        *(_DWORD *)(a1 + 104) = 2;
      else
        *(_DWORD *)(a1 + 104) = 3;
      if ( *(_DWORD *)(a1 + 120) > 30 )
        *(_DWORD *)(a1 + 116) = 30;
      if ( quote.XPos >= *(_DWORD *)(a1 + 8) )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      break;
    case 0x1E:
      *(_DWORD *)(a1 + 116) = 31;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 104) = 4;
      *(_DWORD *)(a1 + 32) = quote.XPos;
      *(_DWORD *)(a1 + 36) = quote.YPos;
      goto LABEL_28;
    case 0x1F:
LABEL_28:
      if ( ++*(_DWORD *)(a1 + 120) < 40 && *(_DWORD *)(a1 + 120) % 8 == 1 )
      {
        v54 = *(_DWORD *)(a1 + 76) ? getArcTan(
                                       *(_DWORD *)(a1 + 8) + 7168 - *(_DWORD *)(a1 + 32),
                                       *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 36)) : getArcTan(
                                                                                        *(_DWORD *)(a1 + 8)
                                                                                      - 7168
                                                                                      - *(_DWORD *)(a1 + 32),
                                                                                        *(_DWORD *)(a1 + 12)
                                                                                      - *(_DWORD *)(a1 + 36));
        v54 += random(-6, 6);
        Y_Vel = 3 * getSin(v54);
        X_Vel = 3 * getCos(v54);
        if ( *(_DWORD *)(a1 + 76) )
          createNPC((NPCNames)202, *(_DWORD *)(a1 + 8) + 7168, *(_DWORD *)(a1 + 12), X_Vel, Y_Vel, 0, 0, 256);
        else
          createNPC((NPCNames)202, *(_DWORD *)(a1 + 8) - 7168, *(_DWORD *)(a1 + 12), X_Vel, Y_Vel, 0, 0, 256);
        if ( !(quote.flags & 2) )
          playSoundEffect(SFXFireballShoot, 1);
      }
      if ( *(_DWORD *)(a1 + 120) > 60 )
      {
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 108) = random(100, 200);
        *(_DWORD *)(a1 + 100) = 0;
      }
      break;
    case 0x64:
      *(_DWORD *)(a1 + 104) = 5;
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v30 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}

//----- (0044EC40) --------------------------------------------------------
int __cdecl NPC201(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+0h] [ebp-20h]
  int v5; // [esp+4h] [ebp-1Ch]
  int v6; // [esp+8h] [ebp-18h]
  int v7; // [esp+Ch] [ebp-14h]
  int v8; // [esp+10h] [ebp-10h]
  int v9; // [esp+14h] [ebp-Ch]
  int v10; // [esp+18h] [ebp-8h]
  int v11; // [esp+1Ch] [ebp-4h]

  v8 = 200;
  v9 = 0;
  v10 = 240;
  v11 = 40;
  v4 = 200;
  v5 = 40;
  v6 = 240;
  v7 = 80;
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v8 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (0044ECE0) --------------------------------------------------------
void __cdecl NPC202(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int v3; // [esp+0h] [ebp-30h]
  int v4; // [esp+4h] [ebp-2Ch]
  int v5; // [esp+8h] [ebp-28h]
  int v6; // [esp+Ch] [ebp-24h]
  int v7; // [esp+10h] [ebp-20h]
  int v8; // [esp+14h] [ebp-1Ch]
  int v9; // [esp+18h] [ebp-18h]
  int v10; // [esp+1Ch] [ebp-14h]
  int v11; // [esp+20h] [ebp-10h]
  int v12; // [esp+24h] [ebp-Ch]
  int v13; // [esp+28h] [ebp-8h]
  int v14; // [esp+2Ch] [ebp-4h]

  if ( *(_DWORD *)(a1 + 4) & 0xFF )
  {
    *(_BYTE *)a1 = 0;
    createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectRisingDisc, 0);
  }
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  v3 = 184;
  v4 = 216;
  v5 = 200;
  v6 = 240;
  v7 = 200;
  v8 = 216;
  v9 = 216;
  v10 = 240;
  v11 = 216;
  v12 = 216;
  v13 = 232;
  v14 = 240;
  if ( ++*(_DWORD *)(a1 + 100) > 1 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 2 )
    *(_DWORD *)(a1 + 104) = 0;
  v1 = &v3 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  v2[3] = v1[3];
  if ( ++*(_DWORD *)(a1 + 108) > 300 )
  {
    *(_BYTE *)a1 = 0;
    createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectRisingDisc, 0);
  }
}

//----- (0044EE40) --------------------------------------------------------
int *__cdecl NPC203(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+4h] [ebp-60h]
  int v4; // [esp+8h] [ebp-5Ch]
  int v5; // [esp+Ch] [ebp-58h]
  int v6; // [esp+10h] [ebp-54h]
  int v7; // [esp+14h] [ebp-50h]
  int v8; // [esp+18h] [ebp-4Ch]
  int v9; // [esp+1Ch] [ebp-48h]
  int v10; // [esp+20h] [ebp-44h]
  int v11; // [esp+24h] [ebp-40h]
  int v12; // [esp+28h] [ebp-3Ch]
  int v13; // [esp+2Ch] [ebp-38h]
  int v14; // [esp+30h] [ebp-34h]
  int v15; // [esp+34h] [ebp-30h]
  int v16; // [esp+38h] [ebp-2Ch]
  int v17; // [esp+3Ch] [ebp-28h]
  int v18; // [esp+40h] [ebp-24h]
  int v19; // [esp+44h] [ebp-20h]
  int v20; // [esp+48h] [ebp-1Ch]
  int v21; // [esp+4Ch] [ebp-18h]
  int v22; // [esp+50h] [ebp-14h]
  int v23; // [esp+54h] [ebp-10h]
  int v24; // [esp+58h] [ebp-Ch]
  int v25; // [esp+5Ch] [ebp-8h]
  int v26; // [esp+60h] [ebp-4h]

  v15 = 0;
  v16 = 80;
  v17 = 16;
  v18 = 96;
  v19 = 16;
  v20 = 80;
  v21 = 32;
  v22 = 96;
  v23 = 32;
  v24 = 80;
  v25 = 48;
  v26 = 96;
  v3 = 0;
  v4 = 96;
  v5 = 16;
  v6 = 112;
  v7 = 16;
  v8 = 96;
  v9 = 32;
  v10 = 112;
  v11 = 32;
  v12 = 96;
  v13 = 48;
  v14 = 112;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 12) += 1536;
      *(_DWORD *)(a1 + 116) = 1;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      if ( *(_DWORD *)(a1 + 120) < 8
        || *(_DWORD *)(a1 + 8) - 57344 >= quote.XPos
        || *(_DWORD *)(a1 + 8) + 57344 <= quote.XPos
        || *(_DWORD *)(a1 + 12) - 40960 >= quote.YPos
        || *(_DWORD *)(a1 + 12) + 40960 <= quote.YPos )
      {
        if ( *(_DWORD *)(a1 + 120) < 8 )
          ++*(_DWORD *)(a1 + 120);
        *(_DWORD *)(a1 + 104) = 0;
      }
      else
      {
        *(_DWORD *)(a1 + 104) = 1;
      }
      if ( *(_BYTE *)(a1 + 156) )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 120) = 0;
      }
      if ( *(_DWORD *)(a1 + 120) >= 8
        && *(_DWORD *)(a1 + 8) - 24576 < quote.XPos
        && *(_DWORD *)(a1 + 8) + 24576 > quote.XPos
        && *(_DWORD *)(a1 + 12) - 40960 < quote.YPos
        && *(_DWORD *)(a1 + 12) + 24576 > quote.YPos )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 3;
        *(_DWORD *)(a1 + 104) = 2;
        *(_DWORD *)(a1 + 20) = -1535;
        if ( !(quote.flags & 2) )
          playSoundEffect(SFXCritterHop, 1);
        if ( *(_DWORD *)(a1 + 76) )
          *(_DWORD *)(a1 + 16) = 256;
        else
          *(_DWORD *)(a1 + 16) = -256;
      }
      break;
    case 3:
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 16) = 0;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 116) = 1;
        if ( !(quote.flags & 2) )
          playSoundEffect(SFXQuoteHitGround, 1);
      }
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 20) += 64;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v3 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v15 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (0044F1F0) --------------------------------------------------------
int *__cdecl NPC204(int a1)
{
  int *result; // eax
  int *v2; // edx
  int v3; // [esp+4h] [ebp-20h]
  int v4; // [esp+8h] [ebp-1Ch]
  int v5; // [esp+Ch] [ebp-18h]
  int v6; // [esp+10h] [ebp-14h]
  int v7; // [esp+14h] [ebp-10h]
  int v8; // [esp+18h] [ebp-Ch]
  int v9; // [esp+1Ch] [ebp-8h]
  int v10; // [esp+20h] [ebp-4h]

  v3 = 240;
  v4 = 80;
  v5 = 256;
  v6 = 96;
  v7 = 240;
  v8 = 144;
  v9 = 256;
  v10 = 160;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 8);
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( quote.XPos > *(_DWORD *)(a1 + 8) - 6144
        && quote.XPos < *(_DWORD *)(a1 + 8) + 6144
        && quote.YPos > *(_DWORD *)(a1 + 12) )
      {
        *(_DWORD *)(a1 + 116) = 2;
      }
      goto LABEL_18;
    case 2:
      if ( ++*(_DWORD *)(a1 + 120) / 6 % 2 )
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 32) - 512;
      else
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 32);
      if ( *(_DWORD *)(a1 + 120) > 30 )
      {
        *(_DWORD *)(a1 + 116) = 3;
        *(_DWORD *)(a1 + 104) = 1;
      }
      goto LABEL_18;
    case 3:
      *(_DWORD *)(a1 + 20) += 32;
      if ( !(*(_DWORD *)(a1 + 4) & 0xFF) )
        goto LABEL_18;
      if ( !(quote.flags & 2) )
        playSoundEffect(SFXDestroyBreakableBlock, 1);
      createDustClouds(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 148), 4);
      *(_BYTE *)a1 = 0;
      break;
    default:
LABEL_18:
      if ( *(_DWORD *)(a1 + 20) > 3072 )
        *(_DWORD *)(a1 + 20) = 3072;
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
      v2 = &v3 + 4 * *(_DWORD *)(a1 + 104);
      result = (int *)(a1 + 84);
      *result = *v2;
      result[1] = v2[1];
      result[2] = v2[2];
      result[3] = v2[3];
      break;
  }
  return result;
}

//----- (0044F3E0) --------------------------------------------------------
void __cdecl NPC205(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int v3; // [esp+4h] [ebp-20h]
  int v4; // [esp+8h] [ebp-1Ch]
  int v5; // [esp+Ch] [ebp-18h]
  int v6; // [esp+10h] [ebp-14h]
  int v7; // [esp+14h] [ebp-10h]
  int v8; // [esp+18h] [ebp-Ch]
  int v9; // [esp+1Ch] [ebp-8h]
  int v10; // [esp+20h] [ebp-4h]

  v3 = 112;
  v4 = 80;
  v5 = 128;
  v6 = 112;
  v7 = 128;
  v8 = 80;
  v9 = 144;
  v10 = 112;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 12) += 2048;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( quote.XPos > *(_DWORD *)(a1 + 8) - 6144
        && quote.XPos < *(_DWORD *)(a1 + 8) + 6144
        && quote.YPos > *(_DWORD *)(a1 + 12) )
      {
        *(_DWORD *)(a1 + 116) = 2;
      }
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 120) / 6 % 2 )
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 32) - 512;
      else
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 32);
      if ( *(_DWORD *)(a1 + 120) > 30 )
      {
        *(_DWORD *)(a1 + 116) = 3;
        *(_DWORD *)(a1 + 104) = 1;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    case 3:
      *(_DWORD *)(a1 + 20) += 32;
      if ( quote.YPos <= *(_DWORD *)(a1 + 12) )
      {
        *(_WORD *)(a1 + 80) |= 0x40u;
        *(_DWORD *)(a1 + 164) = 0;
      }
      else
      {
        *(_WORD *)(a1 + 80) &= 0xFFBFu;
        *(_DWORD *)(a1 + 164) = 127;
      }
      if ( ++*(_DWORD *)(a1 + 120) <= 8 || !(*(_DWORD *)(a1 + 4) & 0xFF) )
        break;
      *(_WORD *)(a1 + 80) |= 0x40u;
      *(_DWORD *)(a1 + 116) = 4;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 20) = 0;
      *(_DWORD *)(a1 + 164) = 0;
      playSoundEffect(SFXDestroyBreakableBlock, 1);
      createDustClouds(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 148), 4);
      createBullet(bulletUnused, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 0);
      return;
    case 4:
      if ( ++*(_DWORD *)(a1 + 120) > 4 )
      {
        *(_DWORD *)(a1 + 116) = 5;
        *(_WORD *)(a1 + 80) |= 0x20u;
      }
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 20) > 3072 )
    *(_DWORD *)(a1 + 20) = 3072;
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v1 = &v3 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  v2[3] = v1[3];
}

//----- (0044F6D0) --------------------------------------------------------
int __cdecl NPC206(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  signed int v4; // [esp+0h] [ebp-38h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]
  int v15; // [esp+30h] [ebp-8h]
  int v16; // [esp+34h] [ebp-4h]

  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 108) = 120;
      *(_DWORD *)(a1 + 120) = random(0, 50);
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( ++*(_DWORD *)(a1 + 120) >= 50 )
      {
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 20) = 768;
      }
      break;
    case 2:
      if ( quote.XPos > *(_DWORD *)(a1 + 8) - 40960 && quote.XPos < *(_DWORD *)(a1 + 8) + 40960 )
      {
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 116) = 3;
      }
      if ( *(_BYTE *)(a1 + 156) )
      {
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 116) = 3;
      }
      break;
    case 3:
      v4 = *(_DWORD *)(a1 + 120);
      if ( v4 > 180 )
      {
        if ( v4 == 240 )
        {
          createNPC(
            NPCTreasureChestClosed|0xC0,
            *(_DWORD *)(a1 + 8) + 0x2000,
            *(_DWORD *)(a1 + 12) + 2048,
            0,
            0,
            (Directions)4,
            0,
            256);
        }
        else if ( v4 == 300 )
        {
          *(_DWORD *)(a1 + 132) = 0x10000;
          *(_DWORD *)(a1 + 124) = 0x10000;
          *(_DWORD *)(a1 + 128) = 51200;
          *(_DWORD *)(a1 + 136) = 51200;
          *(_DWORD *)(a1 + 164) = 30;
          playSoundEffect(SFXlargeExplosion, 1);
          createDustClouds(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 0x10000, 100);
          setQuake(20);
          *(_BYTE *)a1 |= 8u;
        }
      }
      else if ( v4 == 180 )
      {
        createNPC(
          NPCTreasureChestClosed|0xC0,
          *(_DWORD *)(a1 + 8) + 0x2000,
          *(_DWORD *)(a1 + 12) + 2048,
          0,
          0,
          down,
          0,
          256);
      }
      else if ( v4 )
      {
        if ( v4 == 60 )
        {
          createNPC(
            NPCTreasureChestClosed|0xC0,
            *(_DWORD *)(a1 + 8) + 0x2000,
            *(_DWORD *)(a1 + 12) + 2048,
            0,
            0,
            up,
            0,
            256);
        }
        else if ( v4 == 120 )
        {
          createNPC(
            NPCTreasureChestClosed|0xC0,
            *(_DWORD *)(a1 + 8) + 0x2000,
            *(_DWORD *)(a1 + 12) + 2048,
            0,
            0,
            right,
            0,
            256);
        }
      }
      else
      {
        createNPC(
          NPCTreasureChestClosed|0xC0,
          *(_DWORD *)(a1 + 8) + 0x2000,
          *(_DWORD *)(a1 + 12) + 2048,
          0,
          0,
          0,
          0,
          256);
      }
      ++*(_DWORD *)(a1 + 120);
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 116) > 1 )
  {
    if ( *(_DWORD *)(a1 + 36) < *(_DWORD *)(a1 + 12) )
      *(_DWORD *)(a1 + 20) -= 16;
    if ( *(_DWORD *)(a1 + 36) > *(_DWORD *)(a1 + 12) )
      *(_DWORD *)(a1 + 20) += 16;
    if ( *(_DWORD *)(a1 + 20) > 256 )
      *(_DWORD *)(a1 + 20) = 256;
    if ( *(_DWORD *)(a1 + 20) < -256 )
      *(_DWORD *)(a1 + 20) = -256;
  }
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v5 = 80;
  v6 = 80;
  v7 = 120;
  v8 = 120;
  v9 = 120;
  v10 = 80;
  v11 = 160;
  v12 = 120;
  v13 = 160;
  v14 = 80;
  v15 = 200;
  v16 = 120;
  if ( ++*(_DWORD *)(a1 + 100) > 4 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 2 )
    *(_DWORD *)(a1 + 104) = 0;
  v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}

//----- (0044FB40) --------------------------------------------------------
int __cdecl NPC207(int a1)
{
  int result; // eax
  int *v2; // ecx
  int *v3; // edx
  int v4; // [esp+0h] [ebp-54h]
  int v5; // [esp+4h] [ebp-50h]
  int v6; // [esp+8h] [ebp-4Ch]
  int v7; // [esp+Ch] [ebp-48h]
  int v8; // [esp+10h] [ebp-44h]
  int v9; // [esp+14h] [ebp-40h]
  int v10; // [esp+18h] [ebp-3Ch]
  int v11; // [esp+1Ch] [ebp-38h]
  int v12; // [esp+20h] [ebp-34h]
  int v13; // [esp+24h] [ebp-30h]
  int v14; // [esp+28h] [ebp-2Ch]
  int v15; // [esp+2Ch] [ebp-28h]
  int v16; // [esp+30h] [ebp-24h]
  int v17; // [esp+34h] [ebp-20h]
  int v18; // [esp+38h] [ebp-1Ch]
  int v19; // [esp+3Ch] [ebp-18h]
  int v20; // [esp+40h] [ebp-14h]
  int v21; // [esp+44h] [ebp-10h]
  int v22; // [esp+48h] [ebp-Ch]
  int v23; // [esp+4Ch] [ebp-8h]
  int v24; // [esp+50h] [ebp-4h]

  v5 = 0;
  v6 = 144;
  v7 = 16;
  v8 = 160;
  v9 = 16;
  v10 = 144;
  v11 = 32;
  v12 = 160;
  v13 = 32;
  v14 = 144;
  v15 = 48;
  v16 = 160;
  v17 = 48;
  v18 = 144;
  v19 = 64;
  v20 = 160;
  v21 = 64;
  v22 = 144;
  v23 = 80;
  v24 = 160;
  v4 = *(_DWORD *)(a1 + 116);
  switch ( v4 )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = *(_DWORD *)(a1 + 76);
      playSoundEffect(SFXComputerScreenOn, 1);
LABEL_6:
      *(_DWORD *)(a1 + 8) += 512;
      if ( ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 116) = 2;
      }
      break;
    case 1:
      goto LABEL_6;
    case 2:
      ++*(_DWORD *)(a1 + 120);
      result = a1;
      if ( *(_DWORD *)(a1 + 120) > 30 )
      {
        *(_BYTE *)a1 = 0;
        return result;
      }
      break;
  }
  v2 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  v3 = (int *)(a1 + 84);
  *v3 = *v2;
  v3[1] = v2[1];
  result = v2[2];
  v3[2] = result;
  v3[3] = v2[3];
  return result;
}

//----- (0044FCB0) --------------------------------------------------------
int *__cdecl NPC208(int a1)
{
  int *result; // eax
  int v2; // eax
  unsigned __int8 v3; // ST2F_1
  unsigned __int8 v4; // ST2F_1
  int Y_Vel; // ST24_4
  int X_Vel; // ST28_4
  int *v7; // edx
  int v8; // [esp+0h] [ebp-70h]
  int v9; // [esp+10h] [ebp-60h]
  int v10; // [esp+14h] [ebp-5Ch]
  int v11; // [esp+18h] [ebp-58h]
  int v12; // [esp+1Ch] [ebp-54h]
  int v13; // [esp+20h] [ebp-50h]
  int v14; // [esp+24h] [ebp-4Ch]
  int v15; // [esp+28h] [ebp-48h]
  int v16; // [esp+2Ch] [ebp-44h]
  int v17; // [esp+30h] [ebp-40h]
  int v18; // [esp+34h] [ebp-3Ch]
  int v19; // [esp+38h] [ebp-38h]
  int v20; // [esp+3Ch] [ebp-34h]
  int v21; // [esp+40h] [ebp-30h]
  int v22; // [esp+44h] [ebp-2Ch]
  int v23; // [esp+48h] [ebp-28h]
  int v24; // [esp+4Ch] [ebp-24h]
  int v25; // [esp+50h] [ebp-20h]
  int v26; // [esp+54h] [ebp-1Ch]
  int v27; // [esp+58h] [ebp-18h]
  int v28; // [esp+5Ch] [ebp-14h]
  int v29; // [esp+60h] [ebp-10h]
  int v30; // [esp+64h] [ebp-Ch]
  int v31; // [esp+68h] [ebp-8h]
  int v32; // [esp+6Ch] [ebp-4h]

  v21 = 248;
  v22 = 80;
  v23 = 272;
  v24 = 104;
  v25 = 272;
  v26 = 80;
  v27 = 296;
  v28 = 104;
  v29 = 296;
  v30 = 80;
  v31 = 320;
  v32 = 104;
  v9 = 248;
  v10 = 104;
  v11 = 272;
  v12 = 128;
  v13 = 272;
  v14 = 104;
  v15 = 296;
  v16 = 128;
  v17 = 296;
  v18 = 104;
  v19 = 320;
  v20 = 128;
  v8 = *(_DWORD *)(a1 + 116);
  if ( v8 )
  {
    if ( v8 != 1 )
      goto LABEL_59;
    if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
    {
      *(_DWORD *)(a1 + 76) = 2;
      *(_DWORD *)(a1 + 16) += 16;
    }
    else
    {
      *(_DWORD *)(a1 + 76) = 0;
      *(_DWORD *)(a1 + 16) -= 16;
    }
    if ( *(_DWORD *)(a1 + 4) & 1 )
      *(_DWORD *)(a1 + 16) = 512;
    if ( *(_DWORD *)(a1 + 4) & 4 )
      *(_DWORD *)(a1 + 16) = -512;
    if ( *(_DWORD *)(a1 + 12) >= *(_DWORD *)(a1 + 36) )
      v2 = *(_DWORD *)(a1 + 20) - 8;
    else
      v2 = *(_DWORD *)(a1 + 20) + 8;
    *(_DWORD *)(a1 + 20) = v2;
    if ( *(_DWORD *)(a1 + 16) > 767 )
      *(_DWORD *)(a1 + 16) = 767;
    if ( *(_DWORD *)(a1 + 16) < -767 )
      *(_DWORD *)(a1 + 16) = -767;
    if ( *(_DWORD *)(a1 + 20) > 512 )
      *(_DWORD *)(a1 + 20) = 512;
    if ( *(_DWORD *)(a1 + 20) < -512 )
      *(_DWORD *)(a1 + 20) = -512;
    if ( *(_BYTE *)(a1 + 156) )
    {
      *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16) / 2;
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20) / 2;
    }
    else
    {
      *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
    }
    if ( quote.XPos <= *(_DWORD *)(a1 + 8) + 204800 && quote.XPos >= *(_DWORD *)(a1 + 8) - 204800 )
    {
LABEL_59:
      if ( *(_DWORD *)(a1 + 116) )
      {
        if ( *(_DWORD *)(a1 + 120) < 150 )
          ++*(_DWORD *)(a1 + 120);
        if ( *(_DWORD *)(a1 + 120) == 150 )
        {
          if ( !(++*(_DWORD *)(a1 + 112) % 8)
            && *(_DWORD *)(a1 + 8) < quote.XPos + 81920
            && *(_DWORD *)(a1 + 8) > quote.XPos - 81920 )
          {
            v3 = getArcTan(*(_DWORD *)(a1 + 8) - quote.XPos, *(_DWORD *)(a1 + 12) - quote.YPos);
            v4 = random(-6, 6) + v3;
            Y_Vel = 3 * getSin(v4);
            X_Vel = 3 * getCos(v4);
            createNPC((NPCNames)209, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), X_Vel, Y_Vel, 0, 0, 256);
            playSoundEffect(SFXEnemyShootProjectile, 1);
          }
          if ( *(_DWORD *)(a1 + 112) > 16 )
          {
            *(_DWORD *)(a1 + 120) = 0;
            *(_DWORD *)(a1 + 112) = 0;
          }
        }
      }
      if ( ++*(_DWORD *)(a1 + 100) > 1 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 1 )
        *(_DWORD *)(a1 + 104) = 0;
      if ( *(_DWORD *)(a1 + 120) > 120 && *(_DWORD *)(a1 + 120) / 2 % 2 == 1 && *(_DWORD *)(a1 + 104) == 1 )
        *(_DWORD *)(a1 + 104) = 2;
      if ( *(_DWORD *)(a1 + 76) )
        v7 = &v9 + 4 * *(_DWORD *)(a1 + 104);
      else
        v7 = &v21 + 4 * *(_DWORD *)(a1 + 104);
      result = (int *)(a1 + 84);
      *result = *v7;
      result[1] = v7[1];
      result[2] = v7[2];
      result[3] = v7[3];
    }
    else
    {
      *(_DWORD *)(a1 + 116) = 0;
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 76) = *(_DWORD *)(a1 + 108);
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 32);
      *(_DWORD *)(a1 + 92) = 0;
      result = (int *)a1;
      *(_DWORD *)(a1 + 164) = 0;
    }
  }
  else if ( quote.XPos >= *(_DWORD *)(a1 + 8) + 0x2000 || quote.XPos <= *(_DWORD *)(a1 + 8) - 0x2000 )
  {
    *(_DWORD *)(a1 + 92) = 0;
    *(_DWORD *)(a1 + 164) = 0;
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    result = (int *)a1;
    *(_WORD *)(a1 + 80) &= 0xFFDFu;
  }
  else
  {
    *(_WORD *)(a1 + 80) |= 0x20u;
    *(_DWORD *)(a1 + 20) = -512;
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 108) = *(_DWORD *)(a1 + 76);
    *(_DWORD *)(a1 + 112) = 0;
    *(_DWORD *)(a1 + 164) = 6;
    if ( *(_DWORD *)(a1 + 76) )
    {
      result = (int *)(quote.XPos - 0x20000);
      *(_DWORD *)(a1 + 8) = quote.XPos - 0x20000;
      *(_DWORD *)(a1 + 16) = 767;
    }
    else
    {
      result = (int *)(quote.XPos + 0x20000);
      *(_DWORD *)(a1 + 8) = quote.XPos + 0x20000;
      *(_DWORD *)(a1 + 16) = -767;
    }
  }
  return result;
}

//----- (00450280) --------------------------------------------------------
void __cdecl NPC209(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int v3; // [esp+0h] [ebp-40h]
  int v4; // [esp+4h] [ebp-3Ch]
  int v5; // [esp+8h] [ebp-38h]
  int v6; // [esp+Ch] [ebp-34h]
  int v7; // [esp+10h] [ebp-30h]
  int v8; // [esp+14h] [ebp-2Ch]
  int v9; // [esp+18h] [ebp-28h]
  int v10; // [esp+1Ch] [ebp-24h]
  int v11; // [esp+20h] [ebp-20h]
  int v12; // [esp+24h] [ebp-1Ch]
  int v13; // [esp+28h] [ebp-18h]
  int v14; // [esp+2Ch] [ebp-14h]
  int v15; // [esp+30h] [ebp-10h]
  int v16; // [esp+34h] [ebp-Ch]
  int v17; // [esp+38h] [ebp-8h]
  int v18; // [esp+3Ch] [ebp-4h]

  if ( *(_DWORD *)(a1 + 4) & 0xFF )
  {
    *(_BYTE *)a1 = 0;
    createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectRisingDisc, 0);
  }
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  v3 = 232;
  v4 = 96;
  v5 = 248;
  v6 = 112;
  v7 = 200;
  v8 = 112;
  v9 = 216;
  v10 = 128;
  v11 = 216;
  v12 = 112;
  v13 = 232;
  v14 = 128;
  v15 = 232;
  v16 = 112;
  v17 = 248;
  v18 = 128;
  if ( ++*(_DWORD *)(a1 + 100) > 2 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 3 )
    *(_DWORD *)(a1 + 104) = 0;
  v1 = &v3 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  v2[3] = v1[3];
  if ( ++*(_DWORD *)(a1 + 108) > 300 )
  {
    *(_BYTE *)a1 = 0;
    createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectRisingDisc, 0);
  }
}

//----- (00450400) --------------------------------------------------------
int __cdecl NPC210(int a1)
{
  int result; // eax
  int v2; // edx
  int *v3; // eax
  int *v4; // ecx
  int v5; // [esp+0h] [ebp-44h]
  int v6; // [esp+4h] [ebp-40h]
  int v7; // [esp+8h] [ebp-3Ch]
  int v8; // [esp+Ch] [ebp-38h]
  int v9; // [esp+10h] [ebp-34h]
  int v10; // [esp+14h] [ebp-30h]
  int v11; // [esp+18h] [ebp-2Ch]
  int v12; // [esp+1Ch] [ebp-28h]
  int v13; // [esp+20h] [ebp-24h]
  int v14; // [esp+24h] [ebp-20h]
  int v15; // [esp+28h] [ebp-1Ch]
  int v16; // [esp+2Ch] [ebp-18h]
  int v17; // [esp+30h] [ebp-14h]
  int v18; // [esp+34h] [ebp-10h]
  int v19; // [esp+38h] [ebp-Ch]
  int v20; // [esp+3Ch] [ebp-8h]
  int v21; // [esp+40h] [ebp-4h]

  v14 = 0;
  v15 = 112;
  v16 = 16;
  v17 = 128;
  v18 = 16;
  v19 = 112;
  v20 = 32;
  v21 = 128;
  v6 = 32;
  v7 = 112;
  v8 = 48;
  v9 = 128;
  v10 = 48;
  v11 = 112;
  v12 = 64;
  v13 = 128;
  v5 = *(_DWORD *)(a1 + 116);
  if ( v5 )
  {
    if ( v5 == 1 )
    {
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
      {
        *(_DWORD *)(a1 + 76) = 2;
        *(_DWORD *)(a1 + 16) += 16;
      }
      else
      {
        *(_DWORD *)(a1 + 76) = 0;
        *(_DWORD *)(a1 + 16) -= 16;
      }
      if ( *(_DWORD *)(a1 + 16) > 767 )
        *(_DWORD *)(a1 + 16) = 767;
      if ( *(_DWORD *)(a1 + 16) < -767 )
        *(_DWORD *)(a1 + 16) = -767;
      if ( *(_DWORD *)(a1 + 12) >= *(_DWORD *)(a1 + 36) )
        v2 = *(_DWORD *)(a1 + 20) - 8;
      else
        v2 = *(_DWORD *)(a1 + 20) + 8;
      *(_DWORD *)(a1 + 20) = v2;
      if ( *(_DWORD *)(a1 + 20) > 512 )
        *(_DWORD *)(a1 + 20) = 512;
      if ( *(_DWORD *)(a1 + 20) < -512 )
        *(_DWORD *)(a1 + 20) = -512;
      if ( *(_BYTE *)(a1 + 156) )
      {
        *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16) / 2;
        *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20) / 2;
      }
      else
      {
        *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
      }
    }
  }
  else
  {
    if ( quote.XPos >= *(_DWORD *)(a1 + 8) + 0x2000 || quote.XPos <= *(_DWORD *)(a1 + 8) - 0x2000 )
    {
      *(_WORD *)(a1 + 80) &= 0xFFDFu;
      *(_DWORD *)(a1 + 92) = 0;
      *(_DWORD *)(a1 + 164) = 0;
      result = a1;
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 20) = 0;
      return result;
    }
    *(_WORD *)(a1 + 80) |= 0x20u;
    *(_DWORD *)(a1 + 20) = -512;
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 164) = 2;
    if ( *(_DWORD *)(a1 + 76) )
    {
      *(_DWORD *)(a1 + 8) = quote.XPos - 0x20000;
      *(_DWORD *)(a1 + 16) = 767;
    }
    else
    {
      *(_DWORD *)(a1 + 8) = quote.XPos + 0x20000;
      *(_DWORD *)(a1 + 16) = -767;
    }
  }
  if ( ++*(_DWORD *)(a1 + 100) > 1 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 1 )
    *(_DWORD *)(a1 + 104) = 0;
  if ( *(_DWORD *)(a1 + 76) )
    v3 = &v6 + 4 * *(_DWORD *)(a1 + 104);
  else
    v3 = &v14 + 4 * *(_DWORD *)(a1 + 104);
  v4 = (int *)(a1 + 84);
  *v4 = *v3;
  v4[1] = v3[1];
  v4[2] = v3[2];
  result = v3[3];
  v4[3] = result;
  return result;
}

//----- (00450760) --------------------------------------------------------
int *__cdecl NPC211(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+0h] [ebp-40h]
  int v4; // [esp+4h] [ebp-3Ch]
  int v5; // [esp+8h] [ebp-38h]
  int v6; // [esp+Ch] [ebp-34h]
  int v7; // [esp+10h] [ebp-30h]
  int v8; // [esp+14h] [ebp-2Ch]
  int v9; // [esp+18h] [ebp-28h]
  int v10; // [esp+1Ch] [ebp-24h]
  int v11; // [esp+20h] [ebp-20h]
  int v12; // [esp+24h] [ebp-1Ch]
  int v13; // [esp+28h] [ebp-18h]
  int v14; // [esp+2Ch] [ebp-14h]
  int v15; // [esp+30h] [ebp-10h]
  int v16; // [esp+34h] [ebp-Ch]
  int v17; // [esp+38h] [ebp-8h]
  int v18; // [esp+3Ch] [ebp-4h]

  v3 = 256;
  v4 = 200;
  v5 = 272;
  v6 = 216;
  v7 = 272;
  v8 = 200;
  v9 = 288;
  v10 = 216;
  v11 = 288;
  v12 = 200;
  v13 = 304;
  v14 = 216;
  v15 = 304;
  v16 = 200;
  v17 = 320;
  v18 = 216;
  v1 = &v3 + 4 * *(_DWORD *)(a1 + 48);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (00450810) --------------------------------------------------------
NPC *__cdecl NPC212(NPC *a1)
{
  int v1; // edx
  int v2; // edx
  int v3; // eax
  int *v4; // ecx
  RECT *v5; // edx
  NPC *result; // eax
  int v7; // [esp+4h] [ebp-40h]
  int v8; // [esp+8h] [ebp-3Ch]
  int v9; // [esp+Ch] [ebp-38h]
  int v10; // [esp+10h] [ebp-34h]
  int v11; // [esp+14h] [ebp-30h]
  int v12; // [esp+18h] [ebp-2Ch]
  int v13; // [esp+1Ch] [ebp-28h]
  int v14; // [esp+20h] [ebp-24h]
  int v15; // [esp+24h] [ebp-20h]
  int v16; // [esp+28h] [ebp-1Ch]
  int v17; // [esp+2Ch] [ebp-18h]
  int v18; // [esp+30h] [ebp-14h]
  int v19; // [esp+34h] [ebp-10h]
  int v20; // [esp+38h] [ebp-Ch]
  int v21; // [esp+3Ch] [ebp-8h]
  int v22; // [esp+40h] [ebp-4h]

  v7 = 160;
  v8 = 152;
  v9 = 200;
  v10 = 192;
  v11 = 200;
  v12 = 152;
  v13 = 240;
  v14 = 192;
  v15 = 240;
  v16 = 112;
  v17 = 280;
  v18 = 152;
  v19 = 280;
  v20 = 112;
  v21 = 320;
  v22 = 152;
  switch ( a1->currentState )
  {
    case 0:
      a1->currentState = 1;
      a1->YPos -= 2048;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( ++a1->animationTimer > 30 )
      {
        a1->animationTimer = 0;
        ++a1->animationNumber;
      }
      if ( a1->animationNumber > 1 )
        a1->animationNumber = 0;
      break;
    case 0xA:
      a1->currentState = 11;
      a1->animationNumber = 2;
      a1->animationTimer = 0;
      a1->curlyTargetY = a1->YPos - 0x2000;
      a1->curlyTargetX = a1->XPos - 3072;
      a1->YVel = 0;
      a1->entityFlags |= 8u;
      goto LABEL_9;
    case 0xB:
LABEL_9:
      if ( a1->XPos >= a1->curlyTargetX )
        v1 = a1->XVel - 8;
      else
        v1 = a1->XVel + 8;
      a1->XVel = v1;
      if ( a1->YPos >= a1->curlyTargetY )
        v2 = a1->YVel - 8;
      else
        v2 = a1->YVel + 8;
      a1->YVel = v2;
      a1->XPos += a1->XVel;
      a1->YPos += a1->YVel;
      if ( ++a1->animationTimer > 5 )
      {
        a1->animationTimer = 0;
        ++a1->animationNumber;
      }
      if ( a1->animationNumber > 3 )
        a1->animationNumber = 2;
      break;
    case 0x14:
      a1->currentState = 21;
      a1->entityFlags |= 8u;
      goto LABEL_21;
    case 0x15:
LABEL_21:
      if ( a1->YPos >= a1->curlyTargetY )
        v3 = a1->YVel - 16;
      else
        v3 = a1->YVel + 16;
      a1->YVel = v3;
      a1->XVel += 32;
      if ( a1->XVel > 1536 )
        a1->XVel = 1536;
      if ( a1->XVel < -1536 )
        a1->XVel = -1536;
      a1->XPos += a1->XVel;
      a1->YPos += a1->YVel;
      if ( ++a1->animationTimer > 2 )
      {
        a1->animationTimer = 0;
        ++a1->animationNumber;
      }
      if ( a1->animationNumber > 3 )
        a1->animationNumber = 2;
      break;
    case 0x1E:
      a1->currentState = 31;
      createNPC((NPCNames)297, 0, 0, 0, 0, 0, a1, 256);
      break;
    default:
      break;
  }
  v4 = &v7 + 4 * a1->animationNumber;
  v5 = &a1->rect;
  v5->left = *v4;
  v5->top = v4[1];
  result = (NPC *)v4[2];
  v5->right = (LONG)result;
  v5->bottom = v4[3];
  if ( quote.equippedItems & 0x40 )
  {
    result = a1;
    if ( a1->animationNumber > 1 )
    {
      a1->rect.top += 40;
      result = a1;
      a1->rect.bottom += 40;
    }
  }
  return result;
}

//----- (00450BF0) --------------------------------------------------------
int *__cdecl NPC213(int a1)
{
  int v1; // edx
  int v2; // ST10_4
  int v3; // eax
  int v4; // edx
  int v5; // eax
  int v6; // ecx
  int *v7; // edx
  int *result; // eax
  int v9; // [esp+4h] [ebp-A0h]
  int v10; // [esp+8h] [ebp-9Ch]
  int v11; // [esp+Ch] [ebp-98h]
  int v12; // [esp+10h] [ebp-94h]
  int v13; // [esp+14h] [ebp-90h]
  int v14; // [esp+18h] [ebp-8Ch]
  int v15; // [esp+1Ch] [ebp-88h]
  int v16; // [esp+20h] [ebp-84h]
  int v17; // [esp+24h] [ebp-80h]
  int v18; // [esp+28h] [ebp-7Ch]
  int v19; // [esp+2Ch] [ebp-78h]
  int v20; // [esp+30h] [ebp-74h]
  int v21; // [esp+34h] [ebp-70h]
  int v22; // [esp+38h] [ebp-6Ch]
  int v23; // [esp+3Ch] [ebp-68h]
  int v24; // [esp+40h] [ebp-64h]
  int v25; // [esp+44h] [ebp-60h]
  int v26; // [esp+48h] [ebp-5Ch]
  int v27; // [esp+4Ch] [ebp-58h]
  int v28; // [esp+50h] [ebp-54h]
  int v29; // [esp+54h] [ebp-50h]
  int v30; // [esp+58h] [ebp-4Ch]
  int v31; // [esp+5Ch] [ebp-48h]
  int v32; // [esp+60h] [ebp-44h]
  int v33; // [esp+64h] [ebp-40h]
  int v34; // [esp+68h] [ebp-3Ch]
  int v35; // [esp+6Ch] [ebp-38h]
  int v36; // [esp+70h] [ebp-34h]
  int v37; // [esp+74h] [ebp-30h]
  int v38; // [esp+78h] [ebp-2Ch]
  int v39; // [esp+7Ch] [ebp-28h]
  int v40; // [esp+80h] [ebp-24h]
  int v41; // [esp+84h] [ebp-20h]
  int v42; // [esp+88h] [ebp-1Ch]
  int v43; // [esp+8Ch] [ebp-18h]
  int v44; // [esp+90h] [ebp-14h]
  int v45; // [esp+94h] [ebp-10h]
  int v46; // [esp+98h] [ebp-Ch]
  int v47; // [esp+9Ch] [ebp-8h]
  int v48; // [esp+A0h] [ebp-4h]

  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 48;
  v16 = 48;
  v17 = 48;
  v18 = 0;
  v19 = 96;
  v20 = 48;
  v21 = 96;
  v22 = 0;
  v23 = 144;
  v24 = 48;
  v25 = 144;
  v26 = 0;
  v27 = 192;
  v28 = 48;
  v29 = 192;
  v30 = 0;
  v31 = 240;
  v32 = 48;
  v33 = 240;
  v34 = 0;
  v35 = 288;
  v36 = 48;
  v37 = 0;
  v38 = 48;
  v39 = 48;
  v40 = 96;
  v41 = 48;
  v42 = 48;
  v43 = 96;
  v44 = 96;
  v45 = 96;
  v46 = 48;
  v47 = 144;
  v48 = 96;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 12);
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( quote.YPos > *(_DWORD *)(a1 + 12) - 4096 && quote.YPos < *(_DWORD *)(a1 + 12) + 4096 )
      {
        if ( *(_DWORD *)(a1 + 76) )
          v1 = *(_DWORD *)(a1 + 12) + 122880;
        else
          v1 = *(_DWORD *)(a1 + 12) - 122880;
        *(_DWORD *)(a1 + 12) = v1;
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
        *(_DWORD *)(a1 + 20) = 0;
        *(_WORD *)(a1 + 80) |= 0x20u;
      }
      break;
    case 0xA:
      if ( ++*(_DWORD *)(a1 + 100) > 2 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 3 )
        *(_DWORD *)(a1 + 104) = 1;
      if ( ++*(_DWORD *)(a1 + 120) > 200 )
      {
        *(_DWORD *)(a1 + 116) = 20;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 4;
      }
      break;
    case 0x14:
      if ( ++*(_DWORD *)(a1 + 100) > 2 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 6 )
        *(_DWORD *)(a1 + 104) = 4;
      if ( ++*(_DWORD *)(a1 + 120) > 50 )
      {
        *(_DWORD *)(a1 + 116) = 30;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 7;
      }
      break;
    case 0x1E:
      if ( ++*(_DWORD *)(a1 + 100) > 2 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 9 )
        *(_DWORD *)(a1 + 104) = 7;
      if ( ++*(_DWORD *)(a1 + 120) % 5 == 1 )
      {
        v2 = random(-512, 512);
        v3 = random(2, 12);
        createNPC((NPCNames)214, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), (v3 << 9) / 4, v2, 0, 0, 256);
        playSoundEffect(SFXBubble, 1);
      }
      if ( *(_DWORD *)(a1 + 120) > 50 )
      {
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      break;
    case 0x28:
      if ( *(_DWORD *)(a1 + 12) >= *(_DWORD *)(a1 + 36) )
        v4 = *(_DWORD *)(a1 + 20) - 64;
      else
        v4 = *(_DWORD *)(a1 + 20) + 64;
      *(_DWORD *)(a1 + 20) = v4;
      if ( *(_DWORD *)(a1 + 20) < -1024 )
        *(_DWORD *)(a1 + 20) = -1024;
      if ( *(_DWORD *)(a1 + 20) > 1024 )
        *(_DWORD *)(a1 + 20) = 1024;
      if ( *(_BYTE *)(a1 + 156) )
        v5 = *(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 20) / 2;
      else
        v5 = *(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 12) = v5;
      if ( ++*(_DWORD *)(a1 + 100) > 2 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 6 )
        *(_DWORD *)(a1 + 104) = 4;
      if ( quote.YPos < *(_DWORD *)(a1 + 36) + 122880 && quote.YPos > *(_DWORD *)(a1 + 36) - 122880 )
      {
        *(_DWORD *)(a1 + 116) = 20;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 4;
      }
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 116) >= 10 && *(_DWORD *)(a1 + 116) <= 30 )
  {
    if ( *(_DWORD *)(a1 + 12) >= quote.YPos )
      v6 = *(_DWORD *)(a1 + 20) - 25;
    else
      v6 = *(_DWORD *)(a1 + 20) + 25;
    *(_DWORD *)(a1 + 20) = v6;
    if ( *(_DWORD *)(a1 + 20) < -1024 )
      *(_DWORD *)(a1 + 20) = -1024;
    if ( *(_DWORD *)(a1 + 20) > 1024 )
      *(_DWORD *)(a1 + 20) = 1024;
    if ( *(_DWORD *)(a1 + 4) & 2 )
      *(_DWORD *)(a1 + 20) = 512;
    if ( *(_DWORD *)(a1 + 4) & 8 )
      *(_DWORD *)(a1 + 20) = -512;
    if ( *(_BYTE *)(a1 + 156) )
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20) / 2;
    else
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
    if ( quote.YPos > *(_DWORD *)(a1 + 36) + 122880 || quote.YPos < *(_DWORD *)(a1 + 36) - 122880 )
      *(_DWORD *)(a1 + 116) = 40;
  }
  v7 = &v9 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v7;
  result[1] = v7[1];
  result[2] = v7[2];
  result[3] = v7[3];
  return result;
}

//----- (004512A0) --------------------------------------------------------
int __cdecl NPC214(int Entity_Vars)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+0h] [ebp-34h]
  int v5; // [esp+4h] [ebp-30h]
  int v6; // [esp+8h] [ebp-2Ch]
  int v7; // [esp+Ch] [ebp-28h]
  int v8; // [esp+10h] [ebp-24h]
  int v9; // [esp+14h] [ebp-20h]
  int v10; // [esp+18h] [ebp-1Ch]
  int v11; // [esp+1Ch] [ebp-18h]
  int v12; // [esp+20h] [ebp-14h]
  int v13; // [esp+24h] [ebp-10h]
  int v14; // [esp+28h] [ebp-Ch]
  int v15; // [esp+2Ch] [ebp-8h]
  int v16; // [esp+30h] [ebp-4h]

  v5 = 144;
  v6 = 48;
  v7 = 176;
  v8 = 64;
  v9 = 176;
  v10 = 48;
  v11 = 208;
  v12 = 64;
  v13 = 208;
  v14 = 48;
  v15 = 240;
  v16 = 64;
  v4 = *(_DWORD *)(Entity_Vars + 116);
  if ( v4 )
  {
    if ( v4 != 1 )
      goto LABEL_13;
  }
  else
  {
    *(_DWORD *)(Entity_Vars + 116) = 1;
    *(_WORD *)(Entity_Vars + 80) |= 8u;
  }
  if ( ++*(_DWORD *)(Entity_Vars + 100) > 2 )
  {
    *(_DWORD *)(Entity_Vars + 100) = 0;
    ++*(_DWORD *)(Entity_Vars + 104);
  }
  if ( *(_DWORD *)(Entity_Vars + 104) > 2 )
    *(_DWORD *)(Entity_Vars + 104) = 0;
  *(_DWORD *)(Entity_Vars + 0x10) -= 25;
  *(_DWORD *)(Entity_Vars + 8) += *(_DWORD *)(Entity_Vars + 16);
  *(_DWORD *)(Entity_Vars + 0xC) += *(_DWORD *)(Entity_Vars + 20);
  if ( *(_DWORD *)(Entity_Vars + 16) < 0 )
    *(_WORD *)(Entity_Vars + 80) &= 0xFFF7u;
  if ( *(_DWORD *)(Entity_Vars + 4) & 0xFF )
  {
    createDustClouds(*(_DWORD *)(Entity_Vars + 8), *(_DWORD *)(Entity_Vars + 12), *(_DWORD *)(Entity_Vars + 148), 4);
    playSoundEffect(SFXShotHitWall, 1);
    *(_BYTE *)Entity_Vars = 0;
  }
LABEL_13:
  v1 = &v5 + 4 * *(_DWORD *)(Entity_Vars + 104);
  v2 = (int *)(Entity_Vars + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (00451430) --------------------------------------------------------
int __cdecl NPC215(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+4h] [ebp-50h]
  int v5; // [esp+8h] [ebp-4Ch]
  int v6; // [esp+Ch] [ebp-48h]
  int v7; // [esp+10h] [ebp-44h]
  int v8; // [esp+14h] [ebp-40h]
  int v9; // [esp+18h] [ebp-3Ch]
  int v10; // [esp+1Ch] [ebp-38h]
  int v11; // [esp+20h] [ebp-34h]
  int v12; // [esp+24h] [ebp-30h]
  int v13; // [esp+28h] [ebp-2Ch]
  int v14; // [esp+2Ch] [ebp-28h]
  int v15; // [esp+30h] [ebp-24h]
  int v16; // [esp+34h] [ebp-20h]
  int v17; // [esp+38h] [ebp-1Ch]
  int v18; // [esp+3Ch] [ebp-18h]
  int v19; // [esp+40h] [ebp-14h]
  int v20; // [esp+44h] [ebp-10h]
  int v21; // [esp+48h] [ebp-Ch]
  int v22; // [esp+4Ch] [ebp-8h]
  int v23; // [esp+50h] [ebp-4h]

  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 12);
      *(_WORD *)(a1 + 80) &= 0xFFDFu;
      *(_WORD *)(a1 + 80) &= 0xFFFBu;
      *(_WORD *)(a1 + 80) &= 0xFFFEu;
      *(_WORD *)(a1 + 80) &= 0xFFF7u;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( quote.XPos > *(_DWORD *)(a1 + 8) - 6144
        && quote.XPos < *(_DWORD *)(a1 + 8) + 6144
        && quote.YPos > *(_DWORD *)(a1 + 12)
        && quote.YPos < *(_DWORD *)(a1 + 12) + 4096 )
      {
        *(_DWORD *)(a1 + 116) = 15;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    case 0xF:
      if ( ++*(_DWORD *)(a1 + 120) > 10 )
      {
        playSoundEffect(SFXSandCroc, 1);
        *(_DWORD *)(a1 + 116) = 20;
      }
      break;
    case 0x14:
      if ( ++*(_DWORD *)(a1 + 100) > 3 )
      {
        ++*(_DWORD *)(a1 + 104);
        *(_DWORD *)(a1 + 100) = 0;
      }
      if ( *(_DWORD *)(a1 + 104) == 3 )
        *(_DWORD *)(a1 + 164) = 15;
      if ( *(_DWORD *)(a1 + 104) == 4 )
      {
        *(_WORD *)(a1 + 80) |= 0x20u;
        *(_DWORD *)(a1 + 116) = 30;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    case 0x1E:
      *(_WORD *)(a1 + 80) |= 1u;
      *(_DWORD *)(a1 + 164) = 0;
      ++*(_DWORD *)(a1 + 120);
      if ( *(_BYTE *)(a1 + 156) )
      {
        *(_DWORD *)(a1 + 116) = 40;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    case 0x28:
      *(_WORD *)(a1 + 80) |= 8u;
      *(_DWORD *)(a1 + 12) += 512;
      if ( ++*(_DWORD *)(a1 + 120) == 32 )
      {
        *(_WORD *)(a1 + 80) &= 0xFFFEu;
        *(_WORD *)(a1 + 80) &= 0xFFDFu;
        *(_DWORD *)(a1 + 116) = 50;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    case 0x32:
      if ( *(_DWORD *)(a1 + 120) >= 100 )
      {
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 36);
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 116) = 0;
      }
      else
      {
        ++*(_DWORD *)(a1 + 120);
      }
      break;
    default:
      break;
  }
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 96;
  v10 = 48;
  v11 = 128;
  v12 = 48;
  v13 = 96;
  v14 = 96;
  v15 = 128;
  v16 = 96;
  v17 = 96;
  v18 = 144;
  v19 = 128;
  v20 = 144;
  v21 = 96;
  v22 = 192;
  v23 = 128;
  v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (004517F0) --------------------------------------------------------
void __cdecl NPC216_Debug_Cat(NPC *npc)
{
  RECT *npc_Rect; // eax

  // Render
  npc_Rect = &npc->rect;
  npc_Rect->left = 256;
  npc_Rect->top = 192;
  npc_Rect->right = 272;
  npc_Rect->bottom = 216;
}

//----- (00451840) --------------------------------------------------------
int *__cdecl NPC217(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+4h] [ebp-80h]
  int v4; // [esp+8h] [ebp-7Ch]
  int v5; // [esp+Ch] [ebp-78h]
  int v6; // [esp+10h] [ebp-74h]
  int v7; // [esp+14h] [ebp-70h]
  int v8; // [esp+18h] [ebp-6Ch]
  int v9; // [esp+1Ch] [ebp-68h]
  int v10; // [esp+20h] [ebp-64h]
  int v11; // [esp+24h] [ebp-60h]
  int v12; // [esp+28h] [ebp-5Ch]
  int v13; // [esp+2Ch] [ebp-58h]
  int v14; // [esp+30h] [ebp-54h]
  int v15; // [esp+34h] [ebp-50h]
  int v16; // [esp+38h] [ebp-4Ch]
  int v17; // [esp+3Ch] [ebp-48h]
  int v18; // [esp+40h] [ebp-44h]
  int v19; // [esp+44h] [ebp-40h]
  int v20; // [esp+48h] [ebp-3Ch]
  int v21; // [esp+4Ch] [ebp-38h]
  int v22; // [esp+50h] [ebp-34h]
  int v23; // [esp+54h] [ebp-30h]
  int v24; // [esp+58h] [ebp-2Ch]
  int v25; // [esp+5Ch] [ebp-28h]
  int v26; // [esp+60h] [ebp-24h]
  int v27; // [esp+64h] [ebp-20h]
  int v28; // [esp+68h] [ebp-1Ch]
  int v29; // [esp+6Ch] [ebp-18h]
  int v30; // [esp+70h] [ebp-14h]
  int v31; // [esp+74h] [ebp-10h]
  int v32; // [esp+78h] [ebp-Ch]
  int v33; // [esp+7Ch] [ebp-8h]
  int v34; // [esp+80h] [ebp-4h]

  v3 = 144;
  v4 = 64;
  v5 = 160;
  v6 = 80;
  v7 = 160;
  v8 = 64;
  v9 = 176;
  v10 = 80;
  v11 = 176;
  v12 = 64;
  v13 = 192;
  v14 = 80;
  v15 = 192;
  v16 = 64;
  v17 = 208;
  v18 = 80;
  v19 = 144;
  v20 = 80;
  v21 = 160;
  v22 = 96;
  v23 = 160;
  v24 = 80;
  v25 = 176;
  v26 = 96;
  v27 = 144;
  v28 = 80;
  v29 = 160;
  v30 = 96;
  v31 = 176;
  v32 = 80;
  v33 = 192;
  v34 = 96;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      *(_DWORD *)(a1 + 16) = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( random(0, 120) == 10 )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    case 0xA:
      *(_DWORD *)(a1 + 104) = 2;
      *(_DWORD *)(a1 + 16) = 0;
      break;
    case 0x14:
      *(_DWORD *)(a1 + 116) = 21;
      *(_DWORD *)(a1 + 104) = 2;
      *(_DWORD *)(a1 + 16) += 512;
      *(_DWORD *)(a1 + 20) -= 1024;
      break;
    case 0x15:
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 104) = 3;
        *(_DWORD *)(a1 + 116) = 30;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 16) = 0;
        *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 8);
      }
      break;
    case 0x1E:
      *(_DWORD *)(a1 + 104) = 3;
      if ( ++*(_DWORD *)(a1 + 120) / 2 % 2 )
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 32) + 512;
      else
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 32);
      break;
    case 0x28:
      *(_DWORD *)(a1 + 116) = 41;
      *(_DWORD *)(a1 + 20) = -512;
      *(_DWORD *)(a1 + 104) = 2;
      goto LABEL_19;
    case 0x29:
LABEL_19:
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 116) = 42;
        *(_DWORD *)(a1 + 104) = 4;
      }
      break;
    case 0x2A:
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 104) = 4;
      break;
    case 0x32:
      *(_DWORD *)(a1 + 116) = 51;
      *(_DWORD *)(a1 + 120) = 0;
      goto LABEL_24;
    case 0x33:
LABEL_24:
      if ( ++*(_DWORD *)(a1 + 120) > 32 )
        *(_DWORD *)(a1 + 116) = 42;
      *(_DWORD *)(a1 + 16) = 512;
      if ( ++*(_DWORD *)(a1 + 100) > 3 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 7 )
        *(_DWORD *)(a1 + 104) = 4;
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 20) += 64;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v1 = &v3 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (00451CA0) --------------------------------------------------------
int __cdecl NPC218(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  int v4; // [esp+0h] [ebp-20h]
  int v5; // [esp+4h] [ebp-1Ch]
  int v6; // [esp+8h] [ebp-18h]
  int v7; // [esp+Ch] [ebp-14h]
  int v8; // [esp+10h] [ebp-10h]
  int v9; // [esp+14h] [ebp-Ch]
  int v10; // [esp+18h] [ebp-8h]
  int v11; // [esp+1Ch] [ebp-4h]

  v4 = 256;
  v5 = 120;
  v6 = 288;
  v7 = 152;
  v8 = 288;
  v9 = 120;
  v10 = 320;
  v11 = 152;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( ++*(_DWORD *)(a1 + 120) > 200 )
    *(_BYTE *)a1 = 0;
  if ( ++*(_DWORD *)(a1 + 100) > 2 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 1 )
    *(_DWORD *)(a1 + 104) = 0;
  v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}

//----- (00451DA0) --------------------------------------------------------
int __cdecl NPC219(int a1)
{
  int v1; // ST08_4
  int v2; // eax
  int v3; // ST08_4
  int v4; // eax
  _DWORD *v5; // edx
  int result; // eax

  if ( *(_DWORD *)(a1 + 76) )
  {
    v3 = *(_DWORD *)(a1 + 12) + (random(-128, 128) << 9);
    v4 = random(-160, 160);
    createNPC(NPCEnemyBasil|0xC0, *(_DWORD *)(a1 + 8) + (v4 << 9), v3, 0, 0, right, 0, 256);
  }
  else if ( random(0, 40) == 1 )
  {
    v1 = *(_DWORD *)(a1 + 12);
    v2 = random(-20, 20);
    createNPC(NPCSmoke, *(_DWORD *)(a1 + 8) + (v2 << 9), v1, 0, -512, 0, 0, 256);
  }
  v5 = (_DWORD *)(a1 + 84);
  *v5 = 0;
  v5[1] = 0;
  result = 0;
  v5[2] = 0;
  v5[3] = 0;
  return result;
}

//----- (00451E90) --------------------------------------------------------
void __cdecl NPC220(NPC *npc)
{
  RECT *v1; // edx
  int npc_Current_State; // [esp+0h] [ebp-44h]
  RECT Rects_Right[2]; // [esp+4h] [ebp-40h]
  RECT Rects_Left[2]; // [esp+24h] [ebp-20h]

  // ==============================
  // ====<///FRAMARECTS\\\>========
  // ==============================

  // ===sprite 0 (stand still face left do nothing)===
  Rects_Left[0].left = 0;
  Rects_Left[0].top = 0x40;
  Rects_Left[0].right = 0x10;
  Rects_Left[0].bottom = 0x50;

  // ===sprite 1 (stand still face left blink)===
  Rects_Left[1].left = 0x10;
  Rects_Left[1].top = 0x40;
  Rects_Left[1].right = 0x20;
  Rects_Left[1].bottom = 0x50;

  // ===sprite 2 (stand still face left do nothing)===
  Rects_Right[0].left = 0;
  Rects_Right[0].top = 0x50;
  Rects_Right[0].right = 0x10;
  Rects_Right[0].bottom = 0x60;

  // ===sprite 3 (stand still face left blink)===
  Rects_Right[1].left = 0x10;
  Rects_Right[1].top = 0x50;
  Rects_Right[1].right = 0x20;
  Rects_Right[1].bottom = 0x60;
  // ================================
  // =======<///BEHAVIOUR\\\>========
  // ================================
  npc_Current_State = npc->currentState;
  if ( npc_Current_State )
  {
    if ( npc_Current_State != 1 )
    {
      if ( npc_Current_State == 2 && ++npc->waitTimer > 8 )
      {
        npc->currentState = 1;
        npc->animationNumber = 0;
      }
      goto if_not_any;
    }
  }
  else
  {
    npc->currentState = 1;
    npc->animationNumber = 0;
    npc->animationTimer = 0;
  }
  // npc_Current_State == 1
  if ( random(0, 120) == 10 )
  {
    npc->currentState = 2;
    npc->waitTimer = 0;
    npc->animationNumber = 1;
  }
if_not_any:
  if ( npc->direction )
    v1 = &Rects_Right[npc->animationNumber];
  else
    v1 = &Rects_Left[npc->animationNumber];
  npc->rect = *v1;
}

//----- (00452000) --------------------------------------------------------
int __cdecl NPC221(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+4h] [ebp-C0h]
  int v5; // [esp+8h] [ebp-BCh]
  int v6; // [esp+Ch] [ebp-B8h]
  int v7; // [esp+10h] [ebp-B4h]
  int v8; // [esp+14h] [ebp-B0h]
  int v9; // [esp+18h] [ebp-ACh]
  int v10; // [esp+1Ch] [ebp-A8h]
  int v11; // [esp+20h] [ebp-A4h]
  int v12; // [esp+24h] [ebp-A0h]
  int v13; // [esp+28h] [ebp-9Ch]
  int v14; // [esp+2Ch] [ebp-98h]
  int v15; // [esp+30h] [ebp-94h]
  int v16; // [esp+34h] [ebp-90h]
  int v17; // [esp+38h] [ebp-8Ch]
  int v18; // [esp+3Ch] [ebp-88h]
  int v19; // [esp+40h] [ebp-84h]
  int v20; // [esp+44h] [ebp-80h]
  int v21; // [esp+48h] [ebp-7Ch]
  int v22; // [esp+4Ch] [ebp-78h]
  int v23; // [esp+50h] [ebp-74h]
  int v24; // [esp+54h] [ebp-70h]
  int v25; // [esp+58h] [ebp-6Ch]
  int v26; // [esp+5Ch] [ebp-68h]
  int v27; // [esp+60h] [ebp-64h]
  int v28; // [esp+64h] [ebp-60h]
  int v29; // [esp+68h] [ebp-5Ch]
  int v30; // [esp+6Ch] [ebp-58h]
  int v31; // [esp+70h] [ebp-54h]
  int v32; // [esp+74h] [ebp-50h]
  int v33; // [esp+78h] [ebp-4Ch]
  int v34; // [esp+7Ch] [ebp-48h]
  int v35; // [esp+80h] [ebp-44h]
  int v36; // [esp+84h] [ebp-40h]
  int v37; // [esp+88h] [ebp-3Ch]
  int v38; // [esp+8Ch] [ebp-38h]
  int v39; // [esp+90h] [ebp-34h]
  int v40; // [esp+94h] [ebp-30h]
  int v41; // [esp+98h] [ebp-2Ch]
  int v42; // [esp+9Ch] [ebp-28h]
  int v43; // [esp+A0h] [ebp-24h]
  int v44; // [esp+A4h] [ebp-20h]
  int v45; // [esp+A8h] [ebp-1Ch]
  int v46; // [esp+ACh] [ebp-18h]
  int v47; // [esp+B0h] [ebp-14h]
  int v48; // [esp+B4h] [ebp-10h]
  int v49; // [esp+B8h] [ebp-Ch]
  int v50; // [esp+BCh] [ebp-8h]
  int v51; // [esp+C0h] [ebp-4h]

  v28 = 0;
  v29 = 64;
  v30 = 16;
  v31 = 80;
  v32 = 16;
  v33 = 64;
  v34 = 32;
  v35 = 80;
  v36 = 32;
  v37 = 64;
  v38 = 48;
  v39 = 80;
  v40 = 0;
  v41 = 64;
  v42 = 16;
  v43 = 80;
  v44 = 48;
  v45 = 64;
  v46 = 64;
  v47 = 80;
  v48 = 0;
  v49 = 64;
  v50 = 16;
  v51 = 80;
  v4 = 0;
  v5 = 80;
  v6 = 16;
  v7 = 96;
  v8 = 16;
  v9 = 80;
  v10 = 32;
  v11 = 96;
  v12 = 32;
  v13 = 80;
  v14 = 48;
  v15 = 96;
  v16 = 0;
  v17 = 80;
  v18 = 16;
  v19 = 96;
  v20 = 48;
  v21 = 80;
  v22 = 64;
  v23 = 96;
  v24 = 0;
  v25 = 80;
  v26 = 16;
  v27 = 96;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      *(_DWORD *)(a1 + 16) = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( random(0, 60) == 1 )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      if ( random(0, 60) == 1 )
      {
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 120) = random(0, 16);
      *(_DWORD *)(a1 + 104) = 2;
      *(_DWORD *)(a1 + 100) = 0;
      if ( random(0, 9) % 2 )
        *(_DWORD *)(a1 + 76) = 0;
      else
        *(_DWORD *)(a1 + 76) = 2;
      goto LABEL_14;
    case 0xB:
LABEL_14:
      if ( *(_DWORD *)(a1 + 76) || !(*(_DWORD *)(a1 + 4) & 1) )
      {
        if ( *(_DWORD *)(a1 + 76) == 2 && *(_DWORD *)(a1 + 4) & 4 )
          *(_DWORD *)(a1 + 76) = 0;
      }
      else
      {
        *(_DWORD *)(a1 + 76) = 2;
      }
      if ( *(_DWORD *)(a1 + 76) )
        *(_DWORD *)(a1 + 16) = 512;
      else
        *(_DWORD *)(a1 + 16) = -512;
      if ( ++*(_DWORD *)(a1 + 100) > 4 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 5 )
        *(_DWORD *)(a1 + 104) = 2;
      if ( ++*(_DWORD *)(a1 + 120) > 32 )
        *(_DWORD *)(a1 + 116) = 0;
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 20) += 32;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v28 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (00452470) --------------------------------------------------------
signed int __cdecl NPC222(int a1)
{
  _DWORD *v1; // ecx
  signed int result; // eax

  if ( !*(_DWORD *)(a1 + 116) )
  {
    ++*(_DWORD *)(a1 + 116);
    *(_DWORD *)(a1 + 12) -= 4096;
  }
  v1 = (_DWORD *)(a1 + 84);
  *v1 = 96;
  v1[1] = 168;
  v1[2] = 112;
  result = 200;
  v1[3] = 200;
  return result;
}

//----- (004524E0) --------------------------------------------------------
int __cdecl NPC223(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  int v4; // [esp+4h] [ebp-60h]
  int v5; // [esp+8h] [ebp-5Ch]
  int v6; // [esp+Ch] [ebp-58h]
  int v7; // [esp+10h] [ebp-54h]
  int v8; // [esp+14h] [ebp-50h]
  int v9; // [esp+18h] [ebp-4Ch]
  int v10; // [esp+1Ch] [ebp-48h]
  int v11; // [esp+20h] [ebp-44h]
  int v12; // [esp+24h] [ebp-40h]
  int v13; // [esp+28h] [ebp-3Ch]
  int v14; // [esp+2Ch] [ebp-38h]
  int v15; // [esp+30h] [ebp-34h]
  int v16; // [esp+34h] [ebp-30h]
  int v17; // [esp+38h] [ebp-2Ch]
  int v18; // [esp+3Ch] [ebp-28h]
  int v19; // [esp+40h] [ebp-24h]
  int v20; // [esp+44h] [ebp-20h]
  int v21; // [esp+48h] [ebp-1Ch]
  int v22; // [esp+4Ch] [ebp-18h]
  int v23; // [esp+50h] [ebp-14h]
  int v24; // [esp+54h] [ebp-10h]
  int v25; // [esp+58h] [ebp-Ch]
  int v26; // [esp+5Ch] [ebp-8h]
  int v27; // [esp+60h] [ebp-4h]

  v16 = 80;
  v17 = 192;
  v18 = 96;
  v19 = 216;
  v20 = 96;
  v21 = 192;
  v22 = 112;
  v23 = 216;
  v24 = 112;
  v25 = 192;
  v26 = 128;
  v27 = 216;
  v4 = 80;
  v5 = 216;
  v6 = 96;
  v7 = 240;
  v8 = 96;
  v9 = 216;
  v10 = 112;
  v11 = 240;
  v12 = 112;
  v13 = 216;
  v14 = 128;
  v15 = 240;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( random(0, 160) == 1 )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 120) > 12 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    case 3:
      *(_DWORD *)(a1 + 104) = 2;
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 116) < 2
    && quote.YPos < *(_DWORD *)(a1 + 12) + 0x2000
    && quote.YPos > *(_DWORD *)(a1 + 12) - 0x2000 )
  {
    if ( quote.XPos >= *(_DWORD *)(a1 + 8) )
      *(_DWORD *)(a1 + 76) = 2;
    else
      *(_DWORD *)(a1 + 76) = 0;
  }
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v16 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}

//----- (00452700) --------------------------------------------------------
int *__cdecl NPC224(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+0h] [ebp-44h]
  int v4; // [esp+4h] [ebp-40h]
  int v5; // [esp+8h] [ebp-3Ch]
  int v6; // [esp+Ch] [ebp-38h]
  int v7; // [esp+10h] [ebp-34h]
  int v8; // [esp+14h] [ebp-30h]
  int v9; // [esp+18h] [ebp-2Ch]
  int v10; // [esp+1Ch] [ebp-28h]
  int v11; // [esp+20h] [ebp-24h]
  int v12; // [esp+24h] [ebp-20h]
  int v13; // [esp+28h] [ebp-1Ch]
  int v14; // [esp+2Ch] [ebp-18h]
  int v15; // [esp+30h] [ebp-14h]
  int v16; // [esp+34h] [ebp-10h]
  int v17; // [esp+38h] [ebp-Ch]
  int v18; // [esp+3Ch] [ebp-8h]
  int v19; // [esp+40h] [ebp-4h]

  v12 = 112;
  v13 = 32;
  v14 = 128;
  v15 = 48;
  v16 = 128;
  v17 = 32;
  v18 = 144;
  v19 = 48;
  v4 = 112;
  v5 = 48;
  v6 = 128;
  v7 = 64;
  v8 = 128;
  v9 = 48;
  v10 = 144;
  v11 = 64;
  v3 = *(_DWORD *)(a1 + 116);
  if ( v3 )
  {
    if ( v3 != 1 )
    {
      if ( v3 == 2 && ++*(_DWORD *)(a1 + 120) > 12 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      goto LABEL_11;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 100) = 0;
  }
  if ( random(0, 160) == 1 )
  {
    *(_DWORD *)(a1 + 116) = 2;
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 104) = 1;
  }
LABEL_11:
  if ( *(_DWORD *)(a1 + 116) < 2
    && quote.YPos < *(_DWORD *)(a1 + 12) + 0x2000
    && quote.YPos > *(_DWORD *)(a1 + 12) - 0x2000 )
  {
    if ( quote.XPos >= *(_DWORD *)(a1 + 8) )
      *(_DWORD *)(a1 + 76) = 2;
    else
      *(_DWORD *)(a1 + 76) = 0;
  }
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v12 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (004528D0) --------------------------------------------------------
int *__cdecl NPC225(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+0h] [ebp-44h]
  int v4; // [esp+4h] [ebp-40h]
  int v5; // [esp+8h] [ebp-3Ch]
  int v6; // [esp+Ch] [ebp-38h]
  int v7; // [esp+10h] [ebp-34h]
  int v8; // [esp+14h] [ebp-30h]
  int v9; // [esp+18h] [ebp-2Ch]
  int v10; // [esp+1Ch] [ebp-28h]
  int v11; // [esp+20h] [ebp-24h]
  int v12; // [esp+24h] [ebp-20h]
  int v13; // [esp+28h] [ebp-1Ch]
  int v14; // [esp+2Ch] [ebp-18h]
  int v15; // [esp+30h] [ebp-14h]
  int v16; // [esp+34h] [ebp-10h]
  int v17; // [esp+38h] [ebp-Ch]
  int v18; // [esp+3Ch] [ebp-8h]
  int v19; // [esp+40h] [ebp-4h]

  v12 = 64;
  v13 = 64;
  v14 = 80;
  v15 = 80;
  v16 = 80;
  v17 = 64;
  v18 = 96;
  v19 = 80;
  v4 = 64;
  v5 = 80;
  v6 = 80;
  v7 = 96;
  v8 = 80;
  v9 = 80;
  v10 = 96;
  v11 = 96;
  v3 = *(_DWORD *)(a1 + 116);
  if ( v3 )
  {
    if ( v3 != 1 )
    {
      if ( v3 == 2 && ++*(_DWORD *)(a1 + 120) > 12 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      goto LABEL_11;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 100) = 0;
  }
  if ( random(0, 160) == 1 )
  {
    *(_DWORD *)(a1 + 116) = 2;
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 104) = 1;
  }
LABEL_11:
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v12 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (00452A50) --------------------------------------------------------
int __cdecl NPC226(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+4h] [ebp-70h]
  int v5; // [esp+8h] [ebp-6Ch]
  int v6; // [esp+Ch] [ebp-68h]
  int v7; // [esp+10h] [ebp-64h]
  int v8; // [esp+14h] [ebp-60h]
  int v9; // [esp+18h] [ebp-5Ch]
  int v10; // [esp+1Ch] [ebp-58h]
  int v11; // [esp+20h] [ebp-54h]
  int v12; // [esp+24h] [ebp-50h]
  int v13; // [esp+28h] [ebp-4Ch]
  int v14; // [esp+2Ch] [ebp-48h]
  int v15; // [esp+30h] [ebp-44h]
  int v16; // [esp+34h] [ebp-40h]
  int v17; // [esp+38h] [ebp-3Ch]
  int v18; // [esp+3Ch] [ebp-38h]
  int v19; // [esp+40h] [ebp-34h]
  int v20; // [esp+44h] [ebp-30h]
  int v21; // [esp+48h] [ebp-2Ch]
  int v22; // [esp+4Ch] [ebp-28h]
  int v23; // [esp+50h] [ebp-24h]
  int v24; // [esp+54h] [ebp-20h]
  int v25; // [esp+58h] [ebp-1Ch]
  int v26; // [esp+5Ch] [ebp-18h]
  int v27; // [esp+60h] [ebp-14h]
  int v28; // [esp+64h] [ebp-10h]
  int v29; // [esp+68h] [ebp-Ch]
  int v30; // [esp+6Ch] [ebp-8h]
  int v31; // [esp+70h] [ebp-4h]

  v4 = 256;
  v5 = 56;
  v6 = 272;
  v7 = 80;
  v8 = 272;
  v9 = 56;
  v10 = 288;
  v11 = 80;
  v12 = 288;
  v13 = 56;
  v14 = 304;
  v15 = 80;
  v16 = 256;
  v17 = 56;
  v18 = 272;
  v19 = 80;
  v20 = 304;
  v21 = 56;
  v22 = 320;
  v23 = 80;
  v24 = 256;
  v25 = 56;
  v26 = 272;
  v27 = 80;
  v28 = 240;
  v29 = 56;
  v30 = 256;
  v31 = 80;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      *(_DWORD *)(a1 + 16) = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( random(0, 60) == 1 )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 104) = 2;
      *(_DWORD *)(a1 + 100) = 0;
      goto LABEL_10;
    case 0xB:
LABEL_10:
      *(_DWORD *)(a1 + 16) = 512;
      if ( ++*(_DWORD *)(a1 + 100) > 4 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 5 )
        *(_DWORD *)(a1 + 104) = 2;
      ++*(_DWORD *)(a1 + 120);
      break;
    case 0x14:
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 104) = 6;
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 20) += 32;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (00452D10) --------------------------------------------------------
void __cdecl NPC227_Bucket(NPC *npc)
{
  RECT *npc_Rect; // eax

  npc_Rect = &npc->rect;
  npc_Rect->left = 208;
  npc_Rect->top = 32;
  npc_Rect->right = 224;
  npc_Rect->bottom = 48;
}

//----- (00452D60) --------------------------------------------------------
int __cdecl NPC228(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+4h] [ebp-80h]
  int v5; // [esp+8h] [ebp-7Ch]
  int v6; // [esp+Ch] [ebp-78h]
  int v7; // [esp+10h] [ebp-74h]
  int v8; // [esp+14h] [ebp-70h]
  int v9; // [esp+18h] [ebp-6Ch]
  int v10; // [esp+1Ch] [ebp-68h]
  int v11; // [esp+20h] [ebp-64h]
  int v12; // [esp+24h] [ebp-60h]
  int v13; // [esp+28h] [ebp-5Ch]
  int v14; // [esp+2Ch] [ebp-58h]
  int v15; // [esp+30h] [ebp-54h]
  int v16; // [esp+34h] [ebp-50h]
  int v17; // [esp+38h] [ebp-4Ch]
  int v18; // [esp+3Ch] [ebp-48h]
  int v19; // [esp+40h] [ebp-44h]
  int v20; // [esp+44h] [ebp-40h]
  int v21; // [esp+48h] [ebp-3Ch]
  int v22; // [esp+4Ch] [ebp-38h]
  int v23; // [esp+50h] [ebp-34h]
  int v24; // [esp+54h] [ebp-30h]
  int v25; // [esp+58h] [ebp-2Ch]
  int v26; // [esp+5Ch] [ebp-28h]
  int v27; // [esp+60h] [ebp-24h]
  int v28; // [esp+64h] [ebp-20h]
  int v29; // [esp+68h] [ebp-1Ch]
  int v30; // [esp+6Ch] [ebp-18h]
  int v31; // [esp+70h] [ebp-14h]
  int v32; // [esp+74h] [ebp-10h]
  int v33; // [esp+78h] [ebp-Ch]
  int v34; // [esp+7Ch] [ebp-8h]
  int v35; // [esp+80h] [ebp-4h]

  v20 = 0;
  v21 = 0;
  v22 = 32;
  v23 = 40;
  v24 = 32;
  v25 = 0;
  v26 = 64;
  v27 = 40;
  v28 = 64;
  v29 = 0;
  v30 = 96;
  v31 = 40;
  v32 = 96;
  v33 = 0;
  v34 = 128;
  v35 = 40;
  v4 = 0;
  v5 = 40;
  v6 = 32;
  v7 = 80;
  v8 = 32;
  v9 = 40;
  v10 = 64;
  v11 = 80;
  v12 = 64;
  v13 = 40;
  v14 = 96;
  v15 = 80;
  v16 = 96;
  v17 = 40;
  v18 = 128;
  v19 = 80;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 12) -= 4096;
      goto LABEL_3;
    case 1:
LABEL_3:
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 116) = 2;
      *(_DWORD *)(a1 + 104) = 0;
      goto LABEL_4;
    case 2:
LABEL_4:
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      if ( ++*(_DWORD *)(a1 + 100) > 50 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 1 )
        *(_DWORD *)(a1 + 104) = 0;
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 104) = 2;
      *(_DWORD *)(a1 + 120) = 0;
      goto LABEL_13;
    case 0xB:
LABEL_13:
      if ( ++*(_DWORD *)(a1 + 120) > 10 )
      {
        *(_DWORD *)(a1 + 116) = 12;
        *(_DWORD *)(a1 + 104) = 3;
        *(_DWORD *)(a1 + 20) = -1536;
        if ( *(_DWORD *)(a1 + 76) )
          *(_DWORD *)(a1 + 16) = 512;
        else
          *(_DWORD *)(a1 + 16) = -512;
      }
      break;
    case 0xC:
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 104) = 2;
        *(_DWORD *)(a1 + 116) = 13;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    case 0xD:
      *(_DWORD *)(a1 + 16) /= 2;
      if ( ++*(_DWORD *)(a1 + 120) > 10 )
        *(_DWORD *)(a1 + 116) = 1;
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 20) += 64;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v20 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (004530D0) --------------------------------------------------------
signed int __cdecl NPC229(int a1)
{
  _DWORD *v1; // ecx
  signed int result; // eax
  _DWORD *v3; // ecx

  if ( !*(_DWORD *)(a1 + 116) )
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 12) -= 0x2000;
  }
  if ( *(_DWORD *)(a1 + 76) )
  {
    v3 = (_DWORD *)(a1 + 84);
    *v3 = 0;
    v3[1] = 112;
    v3[2] = 48;
    result = 128;
    v3[3] = 128;
  }
  else
  {
    v1 = (_DWORD *)(a1 + 84);
    *v1 = 0;
    v1[1] = 96;
    v1[2] = 48;
    result = 112;
    v1[3] = 112;
  }
  return result;
}

//----- (00453190) --------------------------------------------------------
signed int __cdecl NPC230(int a1)
{
  _DWORD *v1; // ecx
  signed int result; // eax

  if ( !*(_DWORD *)(a1 + 116) )
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 8) -= 0x2000;
    *(_DWORD *)(a1 + 12) -= 0x2000;
  }
  if ( *(_DWORD *)(a1 + 76) )
  {
    v1 = (_DWORD *)(a1 + 84);
    *v1 = 96;
    v1[1] = 96;
    v1[2] = 144;
  }
  else
  {
    v1 = (_DWORD *)(a1 + 84);
    *v1 = 48;
    v1[1] = 96;
    v1[2] = 96;
  }
  result = 128;
  v1[3] = 128;
  return result;
}

//----- (00453260) --------------------------------------------------------
int __cdecl NPC231(int a1)
{
  int v1; // ST08_4
  int v2; // eax
  int v3; // ST08_4
  int v4; // eax
  int *v5; // ecx
  int *v6; // edx
  int result; // eax
  signed int i; // [esp+4h] [ebp-24h]
  signed int j; // [esp+4h] [ebp-24h]
  int v10; // [esp+8h] [ebp-20h]
  int v11; // [esp+Ch] [ebp-1Ch]
  int v12; // [esp+10h] [ebp-18h]
  int v13; // [esp+14h] [ebp-14h]
  int v14; // [esp+18h] [ebp-10h]
  int v15; // [esp+1Ch] [ebp-Ch]
  int v16; // [esp+20h] [ebp-8h]
  int v17; // [esp+24h] [ebp-4h]

  v10 = 176;
  v11 = 32;
  v12 = 208;
  v13 = 48;
  v14 = 176;
  v15 = 48;
  v16 = 208;
  v17 = 64;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      goto LABEL_3;
    case 1:
LABEL_3:
      *(_DWORD *)(a1 + 104) = 0;
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 120) = 0;
      goto LABEL_5;
    case 0xB:
LABEL_5:
      ++*(_DWORD *)(a1 + 120);
      *(_DWORD *)(a1 + 20) += 8;
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        if ( *(_DWORD *)(a1 + 120) >= 10 )
          *(_DWORD *)(a1 + 116) = 1;
        else
          *(_DWORD *)(a1 + 116) = 12;
      }
      break;
    case 0xC:
      *(_WORD *)(a1 + 80) &= 0xDFFFu;
      *(_DWORD *)(a1 + 116) = 13;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 104) = 1;
      for ( i = 0; i < 10; ++i )
      {
        v1 = *(_DWORD *)(a1 + 12) + (random(-8, 8) << 9);
        v2 = random(-16, 16);
        createNPC(NPCSmoke, *(_DWORD *)(a1 + 8) + (v2 << 9), v1, 0, 0, 0, 0, 256);
        playSoundEffect(SFXDestroyBreakableBlock, 1);
      }
      goto LABEL_13;
    case 0xD:
LABEL_13:
      *(_DWORD *)(a1 + 20) -= 8;
      if ( !(++*(_DWORD *)(a1 + 120) % 2) )
        createEffect(*(_DWORD *)(a1 + 8) - 5120, *(_DWORD *)(a1 + 12) + 4096, effectDrownedQuote, down);
      if ( *(_DWORD *)(a1 + 120) % 2 == 1 )
        createEffect(*(_DWORD *)(a1 + 8) + 5120, *(_DWORD *)(a1 + 12) + 4096, effectDrownedQuote, down);
      if ( *(_DWORD *)(a1 + 120) % 4 == 1 )
        playSoundEffect(SFXFireballBounce, 1);
      if ( *(_DWORD *)(a1 + 4) & 2 || quote.collisionFlags & 2 || *(_DWORD *)(a1 + 120) > 450 )
      {
        if ( *(_DWORD *)(a1 + 4) & 2 || quote.collisionFlags & 2 )
          *(_DWORD *)(a1 + 20) = 0;
        *(_DWORD *)(a1 + 116) = 15;
        for ( j = 0; j < 6; ++j )
        {
          v3 = *(_DWORD *)(a1 + 12) + (random(-8, 8) << 9);
          v4 = random(-16, 16);
          createNPC(NPCSmoke, *(_DWORD *)(a1 + 8) + (v4 << 9), v3, 0, 0, 0, 0, 256);
          playSoundEffect(SFXDestroyBreakableBlock, 1);
        }
      }
      break;
    case 0xF:
      *(_DWORD *)(a1 + 20) += 8;
      ++*(_DWORD *)(a1 + 120);
      if ( *(_DWORD *)(a1 + 20) < 0 )
      {
        if ( !(*(_DWORD *)(a1 + 120) % 8) )
          createEffect(*(_DWORD *)(a1 + 8) - 5120, *(_DWORD *)(a1 + 12) + 4096, effectDrownedQuote, down);
        if ( *(_DWORD *)(a1 + 120) % 8 == 4 )
          createEffect(*(_DWORD *)(a1 + 8) + 5120, *(_DWORD *)(a1 + 12) + 4096, effectDrownedQuote, down);
        if ( *(_DWORD *)(a1 + 120) % 16 == 1 )
          playSoundEffect(SFXFireballBounce, 1);
      }
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_WORD *)(a1 + 80) |= 0x2000u;
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 20) < -1535 )
    *(_DWORD *)(a1 + 20) = -1535;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v5 = &v10 + 4 * *(_DWORD *)(a1 + 104);
  v6 = (int *)(a1 + 84);
  *v6 = *v5;
  v6[1] = v5[1];
  result = v5[2];
  v6[2] = result;
  v6[3] = v5[3];
  return result;
}

//----- (004536F0) --------------------------------------------------------
LONG __cdecl NPC232(NPC *a1)
{
  int v1; // eax
  int *v2; // eax
  RECT *v3; // ecx
  LONG result; // eax
  int v5; // [esp+0h] [ebp-68h]
  int v6; // [esp+4h] [ebp-64h]
  int v7; // [esp+8h] [ebp-60h]
  int v8; // [esp+Ch] [ebp-5Ch]
  int v9; // [esp+10h] [ebp-58h]
  int v10; // [esp+14h] [ebp-54h]
  int v11; // [esp+18h] [ebp-50h]
  int v12; // [esp+1Ch] [ebp-4Ch]
  int v13; // [esp+20h] [ebp-48h]
  int v14; // [esp+24h] [ebp-44h]
  int v15; // [esp+28h] [ebp-40h]
  int v16; // [esp+2Ch] [ebp-3Ch]
  int v17; // [esp+30h] [ebp-38h]
  int i; // [esp+34h] [ebp-34h]
  int v19; // [esp+38h] [ebp-30h]
  int v20; // [esp+3Ch] [ebp-2Ch]
  int v21; // [esp+40h] [ebp-28h]
  int v22; // [esp+44h] [ebp-24h]
  int v23; // [esp+48h] [ebp-20h]
  int v24; // [esp+4Ch] [ebp-1Ch]
  int v25; // [esp+50h] [ebp-18h]
  int v26; // [esp+54h] [ebp-14h]
  int v27; // [esp+58h] [ebp-10h]
  int v28; // [esp+5Ch] [ebp-Ch]
  int v29; // [esp+60h] [ebp-8h]
  int v30; // [esp+64h] [ebp-4h]

  v5 = a1->currentState;
  if ( v5 )
  {
    if ( v5 != 1 )
      goto LABEL_27;
  }
  else
  {
    a1->currentState = 1;
    a1->curlyTargetX = a1->XPos;
    a1->curlyTargetY = a1->YPos;
    a1->YVel = 512;
    for ( i = 0; i < 8; ++i )
      createNPC((NPCNames)233, a1->XPos, a1->YPos, 0, 0, (Directions)a1->direction, a1, 256);
  }
  if ( a1->XVel < 0 && a1->collisionFlags & 1 )
    a1->direction = 2;
  if ( a1->XVel > 0 && a1->collisionFlags & 4 )
    a1->direction = 0;
  if ( a1->direction )
    a1->XVel = 256;
  else
    a1->XVel = -256;
  if ( a1->YPos >= a1->curlyTargetY )
    v1 = a1->YVel - 8;
  else
    v1 = a1->YVel + 8;
  a1->YVel = v1;
  if ( a1->YVel > 512 )
    a1->YVel = 512;
  if ( a1->YVel < -512 )
    a1->YVel = -512;
  if ( ++a1->animationTimer > 5 )
  {
    a1->animationTimer = 0;
    ++a1->animationNumber;
  }
  if ( a1->animationNumber > 2 )
    a1->animationNumber = 0;
LABEL_27:
  a1->YPos += a1->YVel;
  a1->XPos += a1->XVel;
  v19 = 128;
  v20 = 0;
  v21 = 160;
  v22 = 32;
  v23 = 160;
  v24 = 0;
  v25 = 192;
  v26 = 32;
  v27 = 192;
  v28 = 0;
  v29 = 224;
  v30 = 32;
  v6 = 128;
  v7 = 32;
  v8 = 160;
  v9 = 64;
  v10 = 160;
  v11 = 32;
  v12 = 192;
  v13 = 64;
  v14 = 192;
  v15 = 32;
  v16 = 224;
  v17 = 64;
  if ( a1->direction )
    v2 = &v6 + 4 * a1->animationNumber;
  else
    v2 = &v19 + 4 * a1->animationNumber;
  v3 = &a1->rect;
  v3->left = *v2;
  v3->top = v2[1];
  v3->right = v2[2];
  result = v2[3];
  v3->bottom = result;
  return result;
}

//----- (004539B0) --------------------------------------------------------
void __cdecl NPC233(NPC *npc)
{
  unsigned __int8 v1; // al
  int *v2; // ecx
  RECT *v3; // edx
  int npc_Current_State; // [esp+0h] [ebp-8Ch]
  int v5; // [esp+4h] [ebp-88h]
  int v6; // [esp+8h] [ebp-84h]
  int v7; // [esp+Ch] [ebp-80h]
  int v8; // [esp+10h] [ebp-7Ch]
  int v9; // [esp+14h] [ebp-78h]
  int v10; // [esp+18h] [ebp-74h]
  int v11; // [esp+1Ch] [ebp-70h]
  int v12; // [esp+20h] [ebp-6Ch]
  int v13; // [esp+24h] [ebp-68h]
  int v14; // [esp+28h] [ebp-64h]
  int v15; // [esp+2Ch] [ebp-60h]
  int v16; // [esp+30h] [ebp-5Ch]
  int v17; // [esp+34h] [ebp-58h]
  int v18; // [esp+38h] [ebp-54h]
  int v19; // [esp+3Ch] [ebp-50h]
  int v20; // [esp+40h] [ebp-4Ch]
  int v21; // [esp+44h] [ebp-48h]
  int v22; // [esp+48h] [ebp-44h]
  int v23; // [esp+4Ch] [ebp-40h]
  int v24; // [esp+50h] [ebp-3Ch]
  int v25; // [esp+54h] [ebp-38h]
  int v26; // [esp+58h] [ebp-34h]
  int v27; // [esp+5Ch] [ebp-30h]
  int v28; // [esp+60h] [ebp-2Ch]
  int v29; // [esp+64h] [ebp-28h]
  int v30; // [esp+68h] [ebp-24h]
  int v31; // [esp+6Ch] [ebp-20h]
  int v32; // [esp+70h] [ebp-1Ch]
  int v33; // [esp+74h] [ebp-18h]
  int v34; // [esp+78h] [ebp-14h]
  int v35; // [esp+7Ch] [ebp-10h]
  int v36; // [esp+80h] [ebp-Ch]
  unsigned __int8 v37; // [esp+8Bh] [ebp-1h]

  npc_Current_State = npc->currentState;
  if ( npc_Current_State )
  {
    if ( npc_Current_State != 1 )
    {
      if ( npc_Current_State == 3 )
      {
        npc->YVel += 64;
        if ( npc->YVel > 1535 )
          npc->YVel = 1535;
        if ( npc->collisionFlags & 8 )
        {
          npc->YVel = 0;
          npc->XVel *= 2;
          npc->count1 = 0;
          npc->currentState = 1;
          npc->entityFlags |= 8u;
        }
      }
      goto LABEL_36;
    }
  }
  else
  {
    npc->currentState = 1;
    v1 = random(0, 255);
    npc->XVel = getCos(v1);
    v37 = random(0, 255);
    npc->YVel = getSin(v37);
    npc->count1 = 120;
    npc->count2 = random(-32, 32) << 9;
  }
  if ( npc->parentNPC->entityType == 232 )
  {
    npc->curlyTargetX = npc->parentNPC->XPos;
    npc->curlyTargetY = npc->parentNPC->YPos;
    npc->direction = npc->parentNPC->direction;
  }
  if ( npc->curlyTargetX < npc->XPos )
    npc->XVel -= 8;
  if ( npc->curlyTargetX > npc->XPos )
    npc->XVel += 8;
  if ( npc->count2 + npc->curlyTargetY < npc->YPos )
    npc->YVel -= 32;
  if ( npc->count2 + npc->curlyTargetY > npc->YPos )
    npc->YVel += 32;
  if ( npc->XVel > 1024 )
    npc->XVel = 1024;
  if ( npc->XVel < -1024 )
    npc->XVel = -1024;
  if ( npc->YVel > 1024 )
    npc->YVel = 1024;
  if ( npc->YVel < -1024 )
    npc->YVel = -1024;
  if ( npc->count1 >= 120 )
  {
    if ( npc->XPos - 4096 < quote.XPos
      && npc->XPos + 4096 > quote.XPos
      && npc->YPos < quote.YPos
      && npc->YPos + 90112 > quote.YPos )
    {
      npc->XVel /= 4;
      npc->YVel = 0;
      npc->currentState = 3;
      npc->entityFlags &= 0xFFF7u;
    }
  }
  else
  {
    ++npc->count1;
  }
LABEL_36:
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  v21 = 256;
  v22 = 0;
  v23 = 272;
  v24 = 16;
  v25 = 272;
  v26 = 0;
  v27 = 288;
  v28 = 16;
  v29 = 288;
  v30 = 0;
  v31 = 304;
  v32 = 16;
  v33 = 304;
  v34 = 0;
  v35 = 320;
  v36 = 16;
  v5 = 256;
  v6 = 16;
  v7 = 272;
  v8 = 32;
  v9 = 272;
  v10 = 16;
  v11 = 288;
  v12 = 32;
  v13 = 288;
  v14 = 16;
  v15 = 304;
  v16 = 32;
  v17 = 304;
  v18 = 16;
  v19 = 320;
  v20 = 32;
  if ( npc->currentState == 3 )
  {
    npc->animationNumber = 3;
  }
  else
  {
    if ( ++npc->animationTimer > 1 )
    {
      npc->animationTimer = 0;
      ++npc->animationNumber;
    }
    if ( npc->animationNumber > 2 )
      npc->animationNumber = 0;
  }
  if ( npc->direction )
    v2 = &v5 + 4 * npc->animationNumber;
  else
    v2 = &v21 + 4 * npc->animationNumber;
  v3 = &npc->rect;
  v3->left = *v2;
  v3->top = v2[1];
  v3->right = v2[2];
  v3->bottom = v2[3];
}

//----- (00453E60) --------------------------------------------------------
signed int __cdecl NPC234(int a1)
{
  _DWORD *v1; // ecx
  signed int result; // eax
  _DWORD *v3; // ecx

  if ( !*(_DWORD *)(a1 + 116) )
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 12) += 0x2000;
  }
  if ( *(_DWORD *)(a1 + 76) )
  {
    v3 = (_DWORD *)(a1 + 84);
    *v3 = 144;
    v3[1] = 112;
    v3[2] = 192;
    result = 128;
    v3[3] = 128;
  }
  else
  {
    v1 = (_DWORD *)(a1 + 84);
    *v1 = 144;
    v1[1] = 96;
    v1[2] = 192;
    result = 112;
    v1[3] = 112;
  }
  return result;
}

//----- (00453F20) --------------------------------------------------------
int __cdecl NPC235(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+4h] [ebp-80h]
  int v5; // [esp+8h] [ebp-7Ch]
  int v6; // [esp+Ch] [ebp-78h]
  int v7; // [esp+10h] [ebp-74h]
  int v8; // [esp+14h] [ebp-70h]
  int v9; // [esp+18h] [ebp-6Ch]
  int v10; // [esp+1Ch] [ebp-68h]
  int v11; // [esp+20h] [ebp-64h]
  int v12; // [esp+24h] [ebp-60h]
  int v13; // [esp+28h] [ebp-5Ch]
  int v14; // [esp+2Ch] [ebp-58h]
  int v15; // [esp+30h] [ebp-54h]
  int v16; // [esp+34h] [ebp-50h]
  int v17; // [esp+38h] [ebp-4Ch]
  int v18; // [esp+3Ch] [ebp-48h]
  int v19; // [esp+40h] [ebp-44h]
  int v20; // [esp+44h] [ebp-40h]
  int v21; // [esp+48h] [ebp-3Ch]
  int v22; // [esp+4Ch] [ebp-38h]
  int v23; // [esp+50h] [ebp-34h]
  int v24; // [esp+54h] [ebp-30h]
  int v25; // [esp+58h] [ebp-2Ch]
  int v26; // [esp+5Ch] [ebp-28h]
  int v27; // [esp+60h] [ebp-24h]
  int v28; // [esp+64h] [ebp-20h]
  int v29; // [esp+68h] [ebp-1Ch]
  int v30; // [esp+6Ch] [ebp-18h]
  int v31; // [esp+70h] [ebp-14h]
  int v32; // [esp+74h] [ebp-10h]
  int v33; // [esp+78h] [ebp-Ch]
  int v34; // [esp+7Ch] [ebp-8h]
  int v35; // [esp+80h] [ebp-4h]

  v20 = 192;
  v21 = 96;
  v22 = 208;
  v23 = 112;
  v24 = 208;
  v25 = 96;
  v26 = 224;
  v27 = 112;
  v28 = 224;
  v29 = 96;
  v30 = 240;
  v31 = 112;
  v32 = 192;
  v33 = 96;
  v34 = 208;
  v35 = 112;
  v4 = 192;
  v5 = 112;
  v6 = 208;
  v7 = 128;
  v8 = 208;
  v9 = 112;
  v10 = 224;
  v11 = 128;
  v12 = 224;
  v13 = 112;
  v14 = 240;
  v15 = 128;
  v16 = 192;
  v17 = 112;
  v18 = 208;
  v19 = 128;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      *(_DWORD *)(a1 + 16) = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( random(0, 30) == 1 )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      if ( random(0, 30) == 1 )
      {
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 120) = random(0, 16);
      *(_DWORD *)(a1 + 104) = 2;
      *(_DWORD *)(a1 + 100) = 0;
      if ( random(0, 9) % 2 )
        *(_DWORD *)(a1 + 76) = 0;
      else
        *(_DWORD *)(a1 + 76) = 2;
      goto LABEL_14;
    case 0xB:
LABEL_14:
      if ( *(_DWORD *)(a1 + 76) || !(*(_DWORD *)(a1 + 4) & 1) )
      {
        if ( *(_DWORD *)(a1 + 76) == 2 && *(_DWORD *)(a1 + 4) & 4 )
          *(_DWORD *)(a1 + 76) = 0;
      }
      else
      {
        *(_DWORD *)(a1 + 76) = 2;
      }
      if ( *(_DWORD *)(a1 + 76) )
        *(_DWORD *)(a1 + 16) = 1024;
      else
        *(_DWORD *)(a1 + 16) = -1024;
      if ( ++*(_DWORD *)(a1 + 100) > 1 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 3 )
        *(_DWORD *)(a1 + 104) = 2;
      if ( ++*(_DWORD *)(a1 + 120) > 64 )
        *(_DWORD *)(a1 + 116) = 0;
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 20) += 32;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 104) == 2 )
    *(_DWORD *)(a1 + 128) = 2560;
  else
    *(_DWORD *)(a1 + 128) = 2048;
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v20 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (00454310) --------------------------------------------------------
int *__cdecl NPC236(int a1)
{
  int v1; // ecx
  int *v2; // edx
  int *result; // eax
  int v4; // [esp+4h] [ebp-C0h]
  int v5; // [esp+8h] [ebp-BCh]
  int v6; // [esp+Ch] [ebp-B8h]
  int v7; // [esp+10h] [ebp-B4h]
  int v8; // [esp+14h] [ebp-B0h]
  int v9; // [esp+18h] [ebp-ACh]
  int v10; // [esp+1Ch] [ebp-A8h]
  int v11; // [esp+20h] [ebp-A4h]
  int v12; // [esp+24h] [ebp-A0h]
  int v13; // [esp+28h] [ebp-9Ch]
  int v14; // [esp+2Ch] [ebp-98h]
  int v15; // [esp+30h] [ebp-94h]
  int v16; // [esp+34h] [ebp-90h]
  int v17; // [esp+38h] [ebp-8Ch]
  int v18; // [esp+3Ch] [ebp-88h]
  int v19; // [esp+40h] [ebp-84h]
  int v20; // [esp+44h] [ebp-80h]
  int v21; // [esp+48h] [ebp-7Ch]
  int v22; // [esp+4Ch] [ebp-78h]
  int v23; // [esp+50h] [ebp-74h]
  int v24; // [esp+54h] [ebp-70h]
  int v25; // [esp+58h] [ebp-6Ch]
  int v26; // [esp+5Ch] [ebp-68h]
  int v27; // [esp+60h] [ebp-64h]
  int v28; // [esp+64h] [ebp-60h]
  int v29; // [esp+68h] [ebp-5Ch]
  int v30; // [esp+6Ch] [ebp-58h]
  int v31; // [esp+70h] [ebp-54h]
  int v32; // [esp+74h] [ebp-50h]
  int v33; // [esp+78h] [ebp-4Ch]
  int v34; // [esp+7Ch] [ebp-48h]
  int v35; // [esp+80h] [ebp-44h]
  int v36; // [esp+84h] [ebp-40h]
  int v37; // [esp+88h] [ebp-3Ch]
  int v38; // [esp+8Ch] [ebp-38h]
  int v39; // [esp+90h] [ebp-34h]
  int v40; // [esp+94h] [ebp-30h]
  int v41; // [esp+98h] [ebp-2Ch]
  int v42; // [esp+9Ch] [ebp-28h]
  int v43; // [esp+A0h] [ebp-24h]
  int v44; // [esp+A4h] [ebp-20h]
  int v45; // [esp+A8h] [ebp-1Ch]
  int v46; // [esp+ACh] [ebp-18h]
  int v47; // [esp+B0h] [ebp-14h]
  int v48; // [esp+B4h] [ebp-10h]
  int v49; // [esp+B8h] [ebp-Ch]
  int v50; // [esp+BCh] [ebp-8h]
  int v51; // [esp+C0h] [ebp-4h]

  v28 = 128;
  v29 = 64;
  v30 = 152;
  v31 = 88;
  v32 = 152;
  v33 = 64;
  v34 = 176;
  v35 = 88;
  v36 = 176;
  v37 = 64;
  v38 = 200;
  v39 = 88;
  v40 = 200;
  v41 = 64;
  v42 = 224;
  v43 = 88;
  v44 = 224;
  v45 = 64;
  v46 = 248;
  v47 = 88;
  v48 = 248;
  v49 = 64;
  v50 = 272;
  v51 = 88;
  v4 = 128;
  v5 = 88;
  v6 = 152;
  v7 = 112;
  v8 = 152;
  v9 = 88;
  v10 = 176;
  v11 = 112;
  v12 = 176;
  v13 = 88;
  v14 = 200;
  v15 = 112;
  v16 = 200;
  v17 = 88;
  v18 = 224;
  v19 = 112;
  v20 = 224;
  v21 = 88;
  v22 = 248;
  v23 = 112;
  v24 = 248;
  v25 = 88;
  v26 = 272;
  v27 = 112;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 120) = random(0, 50);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 20) = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( *(_DWORD *)(a1 + 120) )
      {
        --*(_DWORD *)(a1 + 120);
      }
      else
      {
        *(_DWORD *)(a1 + 20) = 512;
        *(_DWORD *)(a1 + 116) = 2;
      }
      break;
    case 2:
      if ( *(_DWORD *)(a1 + 8) >= quote.XPos )
        *(_DWORD *)(a1 + 76) = 0;
      else
        *(_DWORD *)(a1 + 76) = 2;
      if ( quote.XPos < *(_DWORD *)(a1 + 8) + 0x10000
        && quote.XPos > *(_DWORD *)(a1 + 8) - 0x10000
        && quote.YPos < *(_DWORD *)(a1 + 12) + 0x4000
        && quote.YPos > *(_DWORD *)(a1 + 12) - 81920 )
      {
        ++*(_DWORD *)(a1 + 120);
      }
      if ( *(_DWORD *)(a1 + 120) > 80 )
      {
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 120) = 0;
      }
      if ( ++*(_DWORD *)(a1 + 100) > 1 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 1 )
        *(_DWORD *)(a1 + 104) = 0;
      break;
    case 0xA:
      if ( ++*(_DWORD *)(a1 + 120) > 20 )
      {
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 116) = 20;
      }
      if ( ++*(_DWORD *)(a1 + 100) > 1 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 3 )
        *(_DWORD *)(a1 + 104) = 2;
      break;
    case 0x14:
      if ( ++*(_DWORD *)(a1 + 120) > 60 )
      {
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 116) = 2;
      }
      if ( *(_DWORD *)(a1 + 120) % 10 == 3 )
      {
        playSoundEffect(SFXEnemyShootProjectile, 1);
        if ( *(_DWORD *)(a1 + 76) )
          createNPC((NPCNames)237, *(_DWORD *)(a1 + 8) + 4096, *(_DWORD *)(a1 + 12) - 4096, 1024, -1024, 0, 0, 256);
        else
          createNPC((NPCNames)237, *(_DWORD *)(a1 + 8) - 4096, *(_DWORD *)(a1 + 12) - 4096, -1024, -1024, 0, 0, 256);
      }
      if ( ++*(_DWORD *)(a1 + 100) > 1 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 5 )
        *(_DWORD *)(a1 + 104) = 4;
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 12) >= *(_DWORD *)(a1 + 36) )
    v1 = *(_DWORD *)(a1 + 20) - 16;
  else
    v1 = *(_DWORD *)(a1 + 20) + 16;
  *(_DWORD *)(a1 + 20) = v1;
  if ( *(_DWORD *)(a1 + 20) > 256 )
    *(_DWORD *)(a1 + 20) = 256;
  if ( *(_DWORD *)(a1 + 20) < -256 )
    *(_DWORD *)(a1 + 20) = -256;
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v2 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v2 = &v28 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v2;
  result[1] = v2[1];
  result[2] = v2[2];
  result[3] = v2[3];
  return result;
}

//----- (004548B0) --------------------------------------------------------
void __cdecl NPC237(int a1)
{
  _DWORD *v1; // eax
  int v2; // [esp+0h] [ebp-1Ch]
  signed int v3; // [esp+4h] [ebp-18h]
  signed int i; // [esp+8h] [ebp-14h]

  v2 = *(_DWORD *)(a1 + 116);
  if ( v2 )
  {
    if ( v2 != 1 )
      goto LABEL_15;
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
  }
  v3 = 0;
  ++*(_DWORD *)(a1 + 120);
  if ( *(_DWORD *)(a1 + 4) & 0xFF )
    v3 = 1;
  if ( *(_DWORD *)(a1 + 120) > 10 && *(_DWORD *)(a1 + 4) & 0x100 )
    v3 = 1;
  if ( v3 )
  {
    for ( i = 0; i < 5; ++i )
      createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectfountainDisk, 0);
    playSoundEffect(SFXBubble, 1);
    *(_BYTE *)a1 = 0;
    return;
  }
LABEL_15:
  *(_DWORD *)(a1 + 20) += 32;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v1 = (_DWORD *)(a1 + 84);
  *v1 = 312;
  v1[1] = 32;
  v1[2] = 320;
  v1[3] = 40;
}

//----- (00454A00) --------------------------------------------------------
int __cdecl NPC238(int a1)
{
  int v1; // ecx
  int v2; // ST08_4
  int v3; // eax
  int v4; // eax
  int *v5; // ecx
  int *v6; // edx
  int result; // eax
  signed int i; // [esp+4h] [ebp-34h]
  int v9; // [esp+8h] [ebp-30h]
  int v10; // [esp+Ch] [ebp-2Ch]
  int v11; // [esp+10h] [ebp-28h]
  int v12; // [esp+14h] [ebp-24h]
  int v13; // [esp+18h] [ebp-20h]
  int v14; // [esp+1Ch] [ebp-1Ch]
  int v15; // [esp+20h] [ebp-18h]
  int v16; // [esp+24h] [ebp-14h]
  int v17; // [esp+28h] [ebp-10h]
  int v18; // [esp+2Ch] [ebp-Ch]
  int v19; // [esp+30h] [ebp-8h]
  int v20; // [esp+34h] [ebp-4h]

  v9 = 184;
  v10 = 200;
  v11 = 208;
  v12 = 216;
  v13 = 208;
  v14 = 200;
  v15 = 232;
  v16 = 216;
  v17 = 232;
  v18 = 200;
  v19 = 256;
  v20 = 216;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 140) = 0x2000;
      *(_DWORD *)(a1 + 148) = 4096;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( !*(_DWORD *)(a1 + 76)
        && quote.XPos < *(_DWORD *)(a1 + 8)
        && quote.XPos > *(_DWORD *)(a1 + 8) - 98304
        && quote.YPos > *(_DWORD *)(a1 + 12) - 2048
        && quote.YPos < *(_DWORD *)(a1 + 12) + 4096 )
      {
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 2;
      }
      if ( *(_DWORD *)(a1 + 76) == 2
        && quote.XPos > *(_DWORD *)(a1 + 8)
        && quote.XPos < *(_DWORD *)(a1 + 8) + 98304
        && quote.YPos > *(_DWORD *)(a1 + 12) - 2048
        && quote.YPos < *(_DWORD *)(a1 + 12) + 4096 )
      {
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 2;
      }
      break;
    case 0xA:
      *(_DWORD *)(a1 + 164) = 127;
      if ( *(_DWORD *)(a1 + 76) )
        v1 = *(_DWORD *)(a1 + 8) + 3072;
      else
        v1 = *(_DWORD *)(a1 + 8) - 3072;
      *(_DWORD *)(a1 + 8) = v1;
      if ( ++*(_DWORD *)(a1 + 120) == 8 )
      {
        *(_DWORD *)(a1 + 116) = 20;
        *(_DWORD *)(a1 + 120) = 0;
        for ( i = 0; i < 4; ++i )
        {
          v2 = *(_DWORD *)(a1 + 12) + (random(-8, 8) << 9);
          v3 = random(-16, 16);
          createNPC(NPCSmoke, *(_DWORD *)(a1 + 8) + (v3 << 9), v2, 0, 0, 0, 0, 256);
          playSoundEffect(SFXDestroyBreakableBlock, 1);
        }
      }
      break;
    case 0x14:
      *(_DWORD *)(a1 + 164) = 0;
      if ( ++*(_DWORD *)(a1 + 120) > 50 )
      {
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 116) = 30;
      }
      break;
    case 0x1E:
      *(_DWORD *)(a1 + 164) = 0;
      *(_DWORD *)(a1 + 104) = 1;
      if ( ++*(_DWORD *)(a1 + 120) == 12 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 0;
      }
      if ( *(_DWORD *)(a1 + 76) )
        v4 = *(_DWORD *)(a1 + 8) - 2048;
      else
        v4 = *(_DWORD *)(a1 + 8) + 2048;
      *(_DWORD *)(a1 + 8) = v4;
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 76) || quote.XPos >= *(_DWORD *)(a1 + 8) )
  {
    if ( *(_DWORD *)(a1 + 76) != 2 || quote.XPos <= *(_DWORD *)(a1 + 8) )
      *(_DWORD *)(a1 + 132) = 4096;
    else
      *(_DWORD *)(a1 + 132) = 0x2000;
  }
  else
  {
    *(_DWORD *)(a1 + 132) = 0x2000;
  }
  v5 = &v9 + 4 * *(_DWORD *)(a1 + 104);
  v6 = (int *)(a1 + 84);
  *v6 = *v5;
  v6[1] = v5[1];
  result = v5[2];
  v6[2] = result;
  v6[3] = v5[3];
  return result;
}

//----- (00454DF0) --------------------------------------------------------
_DWORD *__cdecl NPC239(int a1)
{
  _DWORD *result; // eax

  if ( !*(_DWORD *)(a1 + 116) )
  {
    *(_DWORD *)(a1 + 116) = 1;
    if ( *(_DWORD *)(a1 + 76) )
    {
      *(_DWORD *)(a1 + 140) = 12288;
      *(_DWORD *)(a1 + 148) = 12288;
      *(_DWORD *)(a1 + 144) = 4096;
      *(_DWORD *)(a1 + 148) = 12288;
    }
    else
    {
      *(_DWORD *)(a1 + 8) += 4096;
      *(_DWORD *)(a1 + 12) += 0x2000;
    }
  }
  if ( *(_DWORD *)(a1 + 76) )
  {
    result = (_DWORD *)(a1 + 84);
    *result = 96;
    result[1] = 112;
    result[2] = 144;
    result[3] = 144;
  }
  else
  {
    result = (_DWORD *)(a1 + 84);
    *result = 192;
    result[1] = 48;
    result[2] = 256;
    result[3] = 80;
  }
  return result;
}

//----- (00454F00) --------------------------------------------------------
int __cdecl NPC240(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+4h] [ebp-C0h]
  int v5; // [esp+8h] [ebp-BCh]
  int v6; // [esp+Ch] [ebp-B8h]
  int v7; // [esp+10h] [ebp-B4h]
  int v8; // [esp+14h] [ebp-B0h]
  int v9; // [esp+18h] [ebp-ACh]
  int v10; // [esp+1Ch] [ebp-A8h]
  int v11; // [esp+20h] [ebp-A4h]
  int v12; // [esp+24h] [ebp-A0h]
  int v13; // [esp+28h] [ebp-9Ch]
  int v14; // [esp+2Ch] [ebp-98h]
  int v15; // [esp+30h] [ebp-94h]
  int v16; // [esp+34h] [ebp-90h]
  int v17; // [esp+38h] [ebp-8Ch]
  int v18; // [esp+3Ch] [ebp-88h]
  int v19; // [esp+40h] [ebp-84h]
  int v20; // [esp+44h] [ebp-80h]
  int v21; // [esp+48h] [ebp-7Ch]
  int v22; // [esp+4Ch] [ebp-78h]
  int v23; // [esp+50h] [ebp-74h]
  int v24; // [esp+54h] [ebp-70h]
  int v25; // [esp+58h] [ebp-6Ch]
  int v26; // [esp+5Ch] [ebp-68h]
  int v27; // [esp+60h] [ebp-64h]
  int v28; // [esp+64h] [ebp-60h]
  int v29; // [esp+68h] [ebp-5Ch]
  int v30; // [esp+6Ch] [ebp-58h]
  int v31; // [esp+70h] [ebp-54h]
  int v32; // [esp+74h] [ebp-50h]
  int v33; // [esp+78h] [ebp-4Ch]
  int v34; // [esp+7Ch] [ebp-48h]
  int v35; // [esp+80h] [ebp-44h]
  int v36; // [esp+84h] [ebp-40h]
  int v37; // [esp+88h] [ebp-3Ch]
  int v38; // [esp+8Ch] [ebp-38h]
  int v39; // [esp+90h] [ebp-34h]
  int v40; // [esp+94h] [ebp-30h]
  int v41; // [esp+98h] [ebp-2Ch]
  int v42; // [esp+9Ch] [ebp-28h]
  int v43; // [esp+A0h] [ebp-24h]
  int v44; // [esp+A4h] [ebp-20h]
  int v45; // [esp+A8h] [ebp-1Ch]
  int v46; // [esp+ACh] [ebp-18h]
  int v47; // [esp+B0h] [ebp-14h]
  int v48; // [esp+B4h] [ebp-10h]
  int v49; // [esp+B8h] [ebp-Ch]
  int v50; // [esp+BCh] [ebp-8h]
  int v51; // [esp+C0h] [ebp-4h]

  v28 = 160;
  v29 = 64;
  v30 = 176;
  v31 = 80;
  v32 = 176;
  v33 = 64;
  v34 = 192;
  v35 = 80;
  v36 = 192;
  v37 = 64;
  v38 = 208;
  v39 = 80;
  v40 = 160;
  v41 = 64;
  v42 = 176;
  v43 = 80;
  v44 = 208;
  v45 = 64;
  v46 = 224;
  v47 = 80;
  v48 = 160;
  v49 = 64;
  v50 = 176;
  v51 = 80;
  v4 = 160;
  v5 = 80;
  v6 = 176;
  v7 = 96;
  v8 = 176;
  v9 = 80;
  v10 = 192;
  v11 = 96;
  v12 = 192;
  v13 = 80;
  v14 = 208;
  v15 = 96;
  v16 = 160;
  v17 = 80;
  v18 = 176;
  v19 = 96;
  v20 = 208;
  v21 = 80;
  v22 = 224;
  v23 = 96;
  v24 = 160;
  v25 = 80;
  v26 = 176;
  v27 = 96;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      *(_DWORD *)(a1 + 16) = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( random(0, 60) == 1 )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      if ( random(0, 60) == 1 )
      {
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 120) = random(0, 16);
      *(_DWORD *)(a1 + 104) = 2;
      *(_DWORD *)(a1 + 100) = 0;
      if ( random(0, 9) % 2 )
        *(_DWORD *)(a1 + 76) = 0;
      else
        *(_DWORD *)(a1 + 76) = 2;
      goto LABEL_14;
    case 0xB:
LABEL_14:
      if ( *(_DWORD *)(a1 + 76) || !(*(_DWORD *)(a1 + 4) & 1) )
      {
        if ( *(_DWORD *)(a1 + 76) == 2 && *(_DWORD *)(a1 + 4) & 4 )
          *(_DWORD *)(a1 + 76) = 0;
      }
      else
      {
        *(_DWORD *)(a1 + 76) = 2;
      }
      if ( *(_DWORD *)(a1 + 76) )
        *(_DWORD *)(a1 + 16) = 512;
      else
        *(_DWORD *)(a1 + 16) = -512;
      if ( ++*(_DWORD *)(a1 + 100) > 4 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 5 )
        *(_DWORD *)(a1 + 104) = 2;
      if ( ++*(_DWORD *)(a1 + 120) > 32 )
        *(_DWORD *)(a1 + 116) = 0;
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 20) += 32;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v28 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (00455370) --------------------------------------------------------
int __cdecl NPC241(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+4h] [ebp-60h]
  int v5; // [esp+8h] [ebp-5Ch]
  int v6; // [esp+Ch] [ebp-58h]
  int v7; // [esp+10h] [ebp-54h]
  int v8; // [esp+14h] [ebp-50h]
  int v9; // [esp+18h] [ebp-4Ch]
  int v10; // [esp+1Ch] [ebp-48h]
  int v11; // [esp+20h] [ebp-44h]
  int v12; // [esp+24h] [ebp-40h]
  int v13; // [esp+28h] [ebp-3Ch]
  int v14; // [esp+2Ch] [ebp-38h]
  int v15; // [esp+30h] [ebp-34h]
  int v16; // [esp+34h] [ebp-30h]
  int v17; // [esp+38h] [ebp-2Ch]
  int v18; // [esp+3Ch] [ebp-28h]
  int v19; // [esp+40h] [ebp-24h]
  int v20; // [esp+44h] [ebp-20h]
  int v21; // [esp+48h] [ebp-1Ch]
  int v22; // [esp+4Ch] [ebp-18h]
  int v23; // [esp+50h] [ebp-14h]
  int v24; // [esp+54h] [ebp-10h]
  int v25; // [esp+58h] [ebp-Ch]
  int v26; // [esp+5Ch] [ebp-8h]
  int v27; // [esp+60h] [ebp-4h]

  v16 = 0;
  v17 = 0;
  v18 = 16;
  v19 = 16;
  v20 = 16;
  v21 = 0;
  v22 = 32;
  v23 = 16;
  v24 = 32;
  v25 = 0;
  v26 = 48;
  v27 = 16;
  v4 = 0;
  v5 = 16;
  v6 = 16;
  v7 = 32;
  v8 = 16;
  v9 = 16;
  v10 = 32;
  v11 = 32;
  v12 = 32;
  v13 = 16;
  v14 = 48;
  v15 = 32;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 12) += 1536;
      *(_DWORD *)(a1 + 116) = 1;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      if ( *(_DWORD *)(a1 + 120) < 8
        || *(_DWORD *)(a1 + 8) - 73728 >= quote.XPos
        || *(_DWORD *)(a1 + 8) + 73728 <= quote.XPos
        || *(_DWORD *)(a1 + 12) - 40960 >= quote.YPos
        || *(_DWORD *)(a1 + 12) + 40960 <= quote.YPos )
      {
        if ( *(_DWORD *)(a1 + 120) < 8 )
          ++*(_DWORD *)(a1 + 120);
        *(_DWORD *)(a1 + 104) = 0;
      }
      else
      {
        *(_DWORD *)(a1 + 104) = 1;
      }
      if ( *(_BYTE *)(a1 + 156) )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 120) = 0;
      }
      if ( *(_DWORD *)(a1 + 120) >= 8
        && *(_DWORD *)(a1 + 8) - 49152 < quote.XPos
        && *(_DWORD *)(a1 + 8) + 49152 > quote.XPos
        && *(_DWORD *)(a1 + 12) - 40960 < quote.YPos
        && *(_DWORD *)(a1 + 12) + 49152 > quote.YPos )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 3;
        *(_DWORD *)(a1 + 104) = 2;
        *(_DWORD *)(a1 + 20) = -1535;
        playSoundEffect(SFXCritterHop, 1);
        if ( *(_DWORD *)(a1 + 76) )
          *(_DWORD *)(a1 + 16) = 512;
        else
          *(_DWORD *)(a1 + 16) = -512;
      }
      break;
    case 3:
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 16) = 0;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 116) = 1;
        playSoundEffect(SFXQuoteHitGround, 1);
      }
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 20) += 85;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v16 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (00455710) --------------------------------------------------------
void __cdecl NPC242(void *npc)
{
  int *v1; // eax
  int *v2; // ecx
  int v3; // [esp+0h] [ebp-84h]
  int v4; // [esp+4h] [ebp-80h]
  int v5; // [esp+8h] [ebp-7Ch]
  int v6; // [esp+Ch] [ebp-78h]
  int v7; // [esp+10h] [ebp-74h]
  int v8; // [esp+14h] [ebp-70h]
  int v9; // [esp+18h] [ebp-6Ch]
  int v10; // [esp+1Ch] [ebp-68h]
  int v11; // [esp+20h] [ebp-64h]
  int v12; // [esp+24h] [ebp-60h]
  int v13; // [esp+28h] [ebp-5Ch]
  int v14; // [esp+2Ch] [ebp-58h]
  int v15; // [esp+30h] [ebp-54h]
  int v16; // [esp+34h] [ebp-50h]
  int v17; // [esp+38h] [ebp-4Ch]
  int v18; // [esp+3Ch] [ebp-48h]
  int v19; // [esp+40h] [ebp-44h]
  int v20; // [esp+44h] [ebp-40h]
  int v21; // [esp+48h] [ebp-3Ch]
  int v22; // [esp+4Ch] [ebp-38h]
  int v23; // [esp+50h] [ebp-34h]
  int v24; // [esp+54h] [ebp-30h]
  int v25; // [esp+58h] [ebp-2Ch]
  int v26; // [esp+5Ch] [ebp-28h]
  int v27; // [esp+60h] [ebp-24h]
  int v28; // [esp+64h] [ebp-20h]
  int v29; // [esp+68h] [ebp-1Ch]
  int v30; // [esp+6Ch] [ebp-18h]
  int v31; // [esp+70h] [ebp-14h]
  int v32; // [esp+74h] [ebp-10h]
  int v33; // [esp+78h] [ebp-Ch]
  int v34; // [esp+7Ch] [ebp-8h]
  int v35; // [esp+80h] [ebp-4h]

  if ( *((_DWORD *)npc + 2) < 0 || *((_DWORD *)npc + 2) > currentMap.width << 13 )
  {
    Vanish_NPC((NPC *)npc);
    return;
  }
  v3 = *((_DWORD *)npc + 29);
  if ( v3 )
  {
    if ( v3 != 1 )
    {
      if ( v3 != 2 )
        goto LABEL_23;
LABEL_12:
      if ( *((_DWORD *)npc + 19) )
        *((_DWORD *)npc + 4) = 256;
      else
        *((_DWORD *)npc + 4) = -256;
      if ( *((_DWORD *)npc + 9) < *((_DWORD *)npc + 3) )
        *((_DWORD *)npc + 5) -= 16;
      if ( *((_DWORD *)npc + 9) > *((_DWORD *)npc + 3) )
        *((_DWORD *)npc + 5) += 16;
      if ( *((_DWORD *)npc + 5) > 768 )
        *((_DWORD *)npc + 5) = 768;
      if ( *((_DWORD *)npc + 5) < -768 )
        *((_DWORD *)npc + 5) = -768;
      goto LABEL_23;
    }
  }
  else
  {
    *((_DWORD *)npc + 29) = 1;
    *((_DWORD *)npc + 8) = *((_DWORD *)npc + 2);
    *((_DWORD *)npc + 9) = *((_DWORD *)npc + 3);
    *((_DWORD *)npc + 30) = random(0, 50);
  }
  if ( !*((_DWORD *)npc + 30) )
  {
    *((_DWORD *)npc + 29) = 2;
    *((_DWORD *)npc + 5) = 1024;
    goto LABEL_12;
  }
  --*((_DWORD *)npc + 30);
LABEL_23:
  *((_DWORD *)npc + 2) += *((_DWORD *)npc + 4);
  *((_DWORD *)npc + 3) += *((_DWORD *)npc + 5);
  v20 = 32;
  v21 = 32;
  v22 = 48;
  v23 = 48;
  v24 = 48;
  v25 = 32;
  v26 = 64;
  v27 = 48;
  v28 = 64;
  v29 = 32;
  v30 = 80;
  v31 = 48;
  v32 = 80;
  v33 = 32;
  v34 = 96;
  v35 = 48;
  v4 = 32;
  v5 = 48;
  v6 = 48;
  v7 = 64;
  v8 = 48;
  v9 = 48;
  v10 = 64;
  v11 = 64;
  v12 = 64;
  v13 = 48;
  v14 = 80;
  v15 = 64;
  v16 = 80;
  v17 = 48;
  v18 = 96;
  v19 = 64;
  if ( ++*((_DWORD *)npc + 25) > 1 )
  {
    *((_DWORD *)npc + 25) = 0;
    ++*((_DWORD *)npc + 26);
  }
  if ( *((_DWORD *)npc + 26) > 2 )
    *((_DWORD *)npc + 26) = 0;
  if ( *((_DWORD *)npc + 19) )
    v1 = &v4 + 4 * *((_DWORD *)npc + 26);
  else
    v1 = &v20 + 4 * *((_DWORD *)npc + 26);
  v2 = (int *)((char *)npc + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  v2[3] = v1[3];
}

//----- (00455A10) --------------------------------------------------------
void __cdecl NPC243(int a1)
{
  Directions v1; // ST14_4
  int v2; // eax
  int v3; // [esp+0h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 116);
  if ( v3 )
  {
    if ( v3 != 1 )
      return;
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 120) = random(0, 500);
  }
  if ( *(_DWORD *)(a1 + 120) )
  {
    --*(_DWORD *)(a1 + 120);
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 0;
    v1 = *(_DWORD *)(a1 + 76);
    v2 = random(-32, 32);
    createNPC((NPCNames)242, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12) + (v2 << 9), 0, 0, v1, 0, 256);
  }
}

//----- (00455AB0) --------------------------------------------------------
signed int __cdecl NPC244(signed int a1)
{
  signed int result; // eax
  _DWORD *v2; // ecx
  signed int v3; // [esp+0h] [ebp-18h]
  signed int i; // [esp+4h] [ebp-14h]

  *(_DWORD *)(a1 + 20) += 64;
  v3 = 0;
  if ( *(_DWORD *)(a1 + 4) & 0xFF )
    v3 = 1;
  if ( *(_DWORD *)(a1 + 120) > 10 && *(_DWORD *)(a1 + 4) & 0x100 )
    v3 = 1;
  if ( v3 )
  {
    for ( i = 0; i < 3; ++i )
      createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12) + 2048, effectfountainDisk, right);
    if ( *(_DWORD *)(a1 + 8) > quote.XPos - 0x20000
      && *(_DWORD *)(a1 + 8) < quote.XPos + 0x20000
      && *(_DWORD *)(a1 + 12) > quote.YPos - 81920
      && *(_DWORD *)(a1 + 12) < quote.YPos + 81920 )
    {
      playSoundEffect(SFXBubble, 1);
    }
    result = a1;
    *(_BYTE *)a1 = 0;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 20) > 1535 )
      *(_DWORD *)(a1 + 20) = 1535;
    *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
    v2 = (_DWORD *)(a1 + 84);
    *v2 = 96;
    v2[1] = 0;
    v2[2] = 104;
    result = 16;
    v2[3] = 16;
  }
  return result;
}

//----- (00455C10) --------------------------------------------------------
int __cdecl NPC245(int a1)
{
  int result; // eax
  int *v2; // ecx
  int *v3; // edx
  int v4; // [esp+0h] [ebp-44h]
  int v5; // [esp+4h] [ebp-40h]
  int v6; // [esp+8h] [ebp-3Ch]
  int v7; // [esp+Ch] [ebp-38h]
  int v8; // [esp+10h] [ebp-34h]
  int v9; // [esp+14h] [ebp-30h]
  int v10; // [esp+18h] [ebp-2Ch]
  int v11; // [esp+1Ch] [ebp-28h]
  int v12; // [esp+20h] [ebp-24h]
  int v13; // [esp+24h] [ebp-20h]
  int v14; // [esp+28h] [ebp-1Ch]
  int v15; // [esp+2Ch] [ebp-18h]
  int v16; // [esp+30h] [ebp-14h]
  int v17; // [esp+34h] [ebp-10h]
  int v18; // [esp+38h] [ebp-Ch]
  int v19; // [esp+3Ch] [ebp-8h]
  int v20; // [esp+40h] [ebp-4h]

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 104;
  v10 = 0;
  v11 = 112;
  v12 = 16;
  v13 = 112;
  v14 = 0;
  v15 = 120;
  v16 = 16;
  v17 = 120;
  v18 = 0;
  v19 = 128;
  v20 = 16;
  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      if ( v4 == 10 )
      {
        if ( ++*(_DWORD *)(a1 + 100) > 10 )
        {
          *(_DWORD *)(a1 + 100) = 0;
          ++*(_DWORD *)(a1 + 104);
        }
        if ( *(_DWORD *)(a1 + 104) > 3 )
        {
          *(_DWORD *)(a1 + 104) = 0;
          *(_DWORD *)(a1 + 116) = 1;
          *(_DWORD *)(a1 + 120) = *(_DWORD *)(a1 + 44);
          createNPC((NPCNames)244, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 0, 0, 0, 0, 256);
        }
      }
      goto LABEL_13;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 120) = *(_DWORD *)(a1 + 48);
  }
  *(_DWORD *)(a1 + 104) = 0;
  if ( *(_DWORD *)(a1 + 120) )
  {
    result = *(_DWORD *)(a1 + 120) - 1;
    *(_DWORD *)(a1 + 120) = result;
    return result;
  }
  *(_DWORD *)(a1 + 116) = 10;
  *(_DWORD *)(a1 + 100) = 0;
LABEL_13:
  if ( *(_DWORD *)(a1 + 100) / 2 % 2 )
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 32);
  else
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 32) + 512;
  v2 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  v3 = (int *)(a1 + 84);
  *v3 = *v2;
  v3[1] = v2[1];
  result = v2[2];
  v3[2] = result;
  v3[3] = v2[3];
  return result;
}

//----- (00455E00) --------------------------------------------------------
int __cdecl NPC246(int a1)
{
  int v1; // ST10_4
  int v2; // eax
  int *v3; // eax
  int *v4; // ecx
  int result; // eax
  signed int i; // [esp+4h] [ebp-34h]
  int v7; // [esp+8h] [ebp-30h]
  int v8; // [esp+Ch] [ebp-2Ch]
  int v9; // [esp+10h] [ebp-28h]
  int v10; // [esp+14h] [ebp-24h]
  int v11; // [esp+18h] [ebp-20h]
  int v12; // [esp+1Ch] [ebp-1Ch]
  int v13; // [esp+20h] [ebp-18h]
  int v14; // [esp+24h] [ebp-14h]
  int v15; // [esp+28h] [ebp-10h]
  int v16; // [esp+2Ch] [ebp-Ch]
  int v17; // [esp+30h] [ebp-8h]
  int v18; // [esp+34h] [ebp-4h]

  v7 = 144;
  v8 = 112;
  v9 = 160;
  v10 = 136;
  v11 = 160;
  v12 = 112;
  v13 = 176;
  v14 = 136;
  v15 = 176;
  v16 = 112;
  v17 = 192;
  v18 = 136;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 12) -= 2048;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( quote.XPos < *(_DWORD *)(a1 + 8) + 4096
        && quote.XPos > *(_DWORD *)(a1 + 8) - 4096
        && quote.YPos > *(_DWORD *)(a1 + 12) + 4096
        && quote.YPos < *(_DWORD *)(a1 + 12) + 0x10000 )
      {
        *(_DWORD *)(a1 + 116) = 5;
      }
      break;
    case 5:
      if ( !(*(_DWORD *)(a1 + 4) & 8) )
      {
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 100) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      break;
    case 0xA:
      if ( ++*(_DWORD *)(a1 + 100) > 2 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 2 )
        *(_DWORD *)(a1 + 104) = 2;
      if ( quote.YPos <= *(_DWORD *)(a1 + 12) )
      {
        *(_WORD *)(a1 + 80) |= 0x40u;
        *(_DWORD *)(a1 + 164) = 0;
      }
      else
      {
        *(_WORD *)(a1 + 80) &= 0xFFBFu;
        *(_DWORD *)(a1 + 164) = 127;
      }
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        if ( *(_DWORD *)(a1 + 104) > 1 )
        {
          for ( i = 0; i < 4; ++i )
          {
            v1 = random(-1536, 0);
            v2 = random(-341, 341);
            createNPC(NPCSmoke, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), v2, v1, 0, 0, 256);
          }
          playSoundEffect(SFXLargeObjectHitGround, 1);
          setQuake(10);
        }
        *(_DWORD *)(a1 + 116) = 20;
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 100) = 0;
        *(_WORD *)(a1 + 80) |= 0x40u;
        *(_DWORD *)(a1 + 164) = 0;
      }
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 116) >= 5 )
  {
    *(_DWORD *)(a1 + 20) += 128;
    if ( *(_DWORD *)(a1 + 20) > 1535 )
      *(_DWORD *)(a1 + 20) = 1535;
    *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  }
  v3 = &v7 + 4 * *(_DWORD *)(a1 + 104);
  v4 = (int *)(a1 + 84);
  *v4 = *v3;
  v4[1] = v3[1];
  v4[2] = v3[2];
  result = v3[3];
  v4[3] = result;
  return result;
}

//----- (00456110) --------------------------------------------------------
void __cdecl NPC247(NPC *npc)
{
  int v1; // edx
  int Y_Vel; // ST24_4
  int v3; // edx
  int *v4; // edx
  RECT *v5; // eax
  int v6; // [esp+0h] [ebp-138h]
  int v7; // [esp+8h] [ebp-130h]
  int v8; // [esp+Ch] [ebp-12Ch]
  int v9; // [esp+10h] [ebp-128h]
  int v10; // [esp+14h] [ebp-124h]
  int v11; // [esp+18h] [ebp-120h]
  int v12; // [esp+1Ch] [ebp-11Ch]
  int v13; // [esp+20h] [ebp-118h]
  int v14; // [esp+24h] [ebp-114h]
  int v15; // [esp+28h] [ebp-110h]
  int v16; // [esp+2Ch] [ebp-10Ch]
  int v17; // [esp+30h] [ebp-108h]
  int v18; // [esp+34h] [ebp-104h]
  int v19; // [esp+38h] [ebp-100h]
  int v20; // [esp+3Ch] [ebp-FCh]
  int v21; // [esp+40h] [ebp-F8h]
  int v22; // [esp+44h] [ebp-F4h]
  int v23; // [esp+48h] [ebp-F0h]
  int v24; // [esp+4Ch] [ebp-ECh]
  int v25; // [esp+50h] [ebp-E8h]
  int v26; // [esp+54h] [ebp-E4h]
  int v27; // [esp+58h] [ebp-E0h]
  int v28; // [esp+5Ch] [ebp-DCh]
  int v29; // [esp+60h] [ebp-D8h]
  int v30; // [esp+64h] [ebp-D4h]
  int v31; // [esp+68h] [ebp-D0h]
  int v32; // [esp+6Ch] [ebp-CCh]
  int v33; // [esp+70h] [ebp-C8h]
  int v34; // [esp+74h] [ebp-C4h]
  int v35; // [esp+78h] [ebp-C0h]
  int v36; // [esp+7Ch] [ebp-BCh]
  int v37; // [esp+80h] [ebp-B8h]
  int v38; // [esp+84h] [ebp-B4h]
  int v39; // [esp+88h] [ebp-B0h]
  int v40; // [esp+8Ch] [ebp-ACh]
  int v41; // [esp+90h] [ebp-A8h]
  int v42; // [esp+94h] [ebp-A4h]
  int X_Vel; // [esp+9Ch] [ebp-9Ch]
  int v44; // [esp+A0h] [ebp-98h]
  int v45; // [esp+A4h] [ebp-94h]
  int v46; // [esp+A8h] [ebp-90h]
  int v47; // [esp+ACh] [ebp-8Ch]
  int v48; // [esp+B0h] [ebp-88h]
  int v49; // [esp+B4h] [ebp-84h]
  int v50; // [esp+B8h] [ebp-80h]
  int v51; // [esp+BCh] [ebp-7Ch]
  int v52; // [esp+C0h] [ebp-78h]
  int v53; // [esp+C4h] [ebp-74h]
  int v54; // [esp+C8h] [ebp-70h]
  int v55; // [esp+CCh] [ebp-6Ch]
  int v56; // [esp+D0h] [ebp-68h]
  int v57; // [esp+D4h] [ebp-64h]
  int v58; // [esp+D8h] [ebp-60h]
  int v59; // [esp+DCh] [ebp-5Ch]
  int v60; // [esp+E0h] [ebp-58h]
  int v61; // [esp+E4h] [ebp-54h]
  int v62; // [esp+E8h] [ebp-50h]
  int v63; // [esp+ECh] [ebp-4Ch]
  int v64; // [esp+F0h] [ebp-48h]
  int v65; // [esp+F4h] [ebp-44h]
  int v66; // [esp+F8h] [ebp-40h]
  int v67; // [esp+FCh] [ebp-3Ch]
  int v68; // [esp+100h] [ebp-38h]
  int v69; // [esp+104h] [ebp-34h]
  int v70; // [esp+108h] [ebp-30h]
  int v71; // [esp+10Ch] [ebp-2Ch]
  int v72; // [esp+110h] [ebp-28h]
  int v73; // [esp+114h] [ebp-24h]
  int v74; // [esp+118h] [ebp-20h]
  int v75; // [esp+11Ch] [ebp-1Ch]
  int v76; // [esp+120h] [ebp-18h]
  int v77; // [esp+124h] [ebp-14h]
  int v78; // [esp+128h] [ebp-10h]
  int v79; // [esp+12Ch] [ebp-Ch]
  unsigned __int8 v80; // [esp+137h] [ebp-1h]

  v44 = 0;
  v45 = 0;
  v46 = 16;
  v47 = 16;
  v48 = 16;
  v49 = 0;
  v50 = 32;
  v51 = 16;
  v52 = 32;
  v53 = 0;
  v54 = 48;
  v55 = 16;
  v56 = 48;
  v57 = 0;
  v58 = 64;
  v59 = 16;
  v60 = 64;
  v61 = 0;
  v62 = 80;
  v63 = 16;
  v64 = 80;
  v65 = 0;
  v66 = 96;
  v67 = 16;
  v68 = 96;
  v69 = 0;
  v70 = 112;
  v71 = 16;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 112;
  v77 = 0;
  v78 = 128;
  v79 = 16;
  v7 = 0;
  v8 = 16;
  v9 = 16;
  v10 = 32;
  v11 = 16;
  v12 = 16;
  v13 = 32;
  v14 = 32;
  v15 = 32;
  v16 = 16;
  v17 = 48;
  v18 = 32;
  v19 = 48;
  v20 = 16;
  v21 = 64;
  v22 = 32;
  v23 = 64;
  v24 = 16;
  v25 = 80;
  v26 = 32;
  v27 = 80;
  v28 = 16;
  v29 = 96;
  v30 = 32;
  v31 = 96;
  v32 = 16;
  v33 = 112;
  v34 = 32;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 112;
  v40 = 16;
  v41 = 128;
  v42 = 32;
  v6 = npc->currentState;
  if ( v6 <= 111 )
  {
    if ( v6 == 111 )
    {
LABEL_46:
      if ( ++npc->waitTimer % 2 )
        npc->animationNumber = 5;
      else
        npc->animationNumber = 6;
      if ( npc->waitTimer > 30 )
      {
        npc->waitTimer = 0;
        if ( ++npc->count1 % 3 )
          npc->currentState = 112;
        else
          npc->currentState = 113;
        npc->animationNumber = 4;
      }
    }
    else
    {
      switch ( v6 )
      {
        case 0:
          npc->currentState = 1;
          npc->YPos += 3072;
          npc->curlyTargetY = 0x8000;
          goto LABEL_15;
        case 1:
LABEL_15:
          if ( random(0, 120) == 10 )
          {
            npc->currentState = 2;
            npc->waitTimer = 0;
            npc->animationNumber = 1;
          }
          goto LABEL_100;
        case 2:
          if ( ++npc->waitTimer > 8 )
          {
            npc->currentState = 1;
            npc->animationNumber = 0;
          }
          goto LABEL_100;
        case 20:
          npc->XVel = 0;
          npc->YVel += 64;
          if ( npc->collisionFlags & 8 )
          {
            npc->currentState = 21;
            npc->animationNumber = 2;
          }
          goto LABEL_100;
        case 21:
          if ( random(0, 120) == 10 )
          {
            npc->currentState = 22;
            npc->waitTimer = 0;
            npc->animationNumber = 3;
          }
          goto LABEL_100;
        case 22:
          if ( ++npc->waitTimer > 8 )
          {
            npc->currentState = 21;
            npc->animationNumber = 2;
          }
          goto LABEL_100;
        case 100:
          npc->currentState = 101;
          npc->waitTimer = 0;
          npc->animationNumber = 0;
          npc->XVel = 0;
          npc->entityFlags |= 0x20u;
          npc->count2 = npc->life;
          goto LABEL_31;
        case 101:
LABEL_31:
          if ( quote.XPos >= npc->XPos )
            npc->direction = 2;
          else
            npc->direction = 0;
          if ( npc->YPos >= npc->curlyTargetY )
            v1 = npc->YVel - 32;
          else
            v1 = npc->YVel + 32;
          npc->YVel = v1;
          if ( npc->YVel < -512 )
            npc->YVel = -512;
          if ( npc->YVel > 512 )
            npc->YVel = 512;
          if ( ++npc->waitTimer > 200 || npc->life <= npc->count2 - 80 )
          {
            npc->waitTimer = 0;
            npc->currentState = 110;
          }
          break;
        case 110:
          npc->currentState = 111;
          npc->waitTimer = 0;
          npc->XVel = 0;
          npc->YVel = 0;
          npc->entityFlags &= 0xFFDFu;
          goto LABEL_46;
        default:
          goto LABEL_100;
      }
    }
    goto LABEL_100;
  }
  if ( v6 <= 160 )
  {
    if ( v6 != 160 )
    {
      switch ( v6 )
      {
        case 112:
          if ( !(++npc->waitTimer % 6) )
          {
            v80 = getArcTan(npc->XPos - quote.XPos, npc->YPos - quote.YPos);
            v80 += random(-4, 4);
            Y_Vel = 4 * getSin(v80);
            X_Vel = 4 * getCos(v80);
            createNPC((NPCNames)248, npc->XPos, npc->YPos + 2048, X_Vel, Y_Vel, 0, 0, 256);
            playSoundEffect(SFXFireballBounce, 1);
          }
          if ( npc->waitTimer > 30 )
          {
            npc->waitTimer = 0;
            npc->currentState = 150;
          }
          break;
        case 113:
          if ( ++npc->waitTimer == 10 )
            createNPC(NPCEnemyBasil|0x110, quote.XPos, quote.YPos - 0x8000, 0, 0, up, 0, 256);
          if ( npc->waitTimer > 30 )
          {
            npc->waitTimer = 0;
            npc->currentState = 150;
          }
          break;
        case 150:
          npc->currentState = 151;
          npc->waitTimer = 0;
          npc->animationNumber = 7;
          createNPC((NPCNames)249, npc->XPos, npc->YPos, 0, 0, 0, 0, 256);
          createNPC((NPCNames)249, npc->XPos, npc->YPos, 0, 0, right, 0, 256);
          npc->curlyTargetX = random(9, 31) << 13;
          npc->curlyTargetY = random(5, 7) << 13;
          playSoundEffect(SFXTeleport, 1);
          goto LABEL_66;
        case 151:
LABEL_66:
          if ( ++npc->waitTimer == 42 )
          {
            createNPC((NPCNames)249, npc->curlyTargetX + 0x2000, npc->curlyTargetY, 0, 0, 0, 0, 256);
            createNPC((NPCNames)249, npc->curlyTargetX - 0x2000, npc->curlyTargetY, 0, 0, right, 0, 256);
          }
          if ( npc->waitTimer > 50 )
          {
            npc->waitTimer = 0;
            npc->YVel = -512;
            npc->entityFlags |= 0x20u;
            npc->XPos = npc->curlyTargetX;
            npc->YPos = npc->curlyTargetY;
            if ( npc->life < 340 )
            {
              createNPC((NPCNames)252, 0, 0, 0, 0, 0, npc, 256);
              createNPC((NPCNames)252, 0, 0, 0, 0, (Directions)128, npc, 256);
            }
            if ( npc->life < 180 )
            {
              createNPC((NPCNames)252, 0, 0, 0, 0, (Directions)64, npc, 256);
              createNPC((NPCNames)252, 0, 0, 0, 0, (Directions)192, npc, 256);
            }
            if ( quote.XPos >= npc->XPos - 57344 && quote.XPos <= npc->XPos + 57344 )
              npc->currentState = 100;
            else
              npc->currentState = 160;
          }
          break;
        default:
          goto LABEL_100;
      }
      goto LABEL_100;
    }
    npc->currentState = 161;
    npc->waitTimer = 0;
    npc->animationNumber = 4;
    if ( quote.XPos >= npc->XPos )
      npc->direction = 2;
    else
      npc->direction = 0;
    goto LABEL_81;
  }
  if ( v6 <= 1001 )
  {
    if ( v6 != 1001 )
    {
      if ( v6 == 161 )
      {
LABEL_81:
        if ( npc->YPos >= npc->curlyTargetY )
          v3 = npc->YVel - 32;
        else
          v3 = npc->YVel + 32;
        npc->YVel = v3;
        if ( npc->YVel < -512 )
          npc->YVel = -512;
        if ( npc->YVel > 512 )
          npc->YVel = 512;
        if ( !(++npc->waitTimer % 24) )
        {
          createNPC((NPCNames)250, npc->XPos, npc->YPos + 2048, 0, 0, 0, 0, 256);
          playSoundEffect(SFXFireballBounce, 1);
        }
        if ( npc->waitTimer > 72 )
        {
          npc->waitTimer = 0;
          npc->currentState = 100;
        }
        goto LABEL_100;
      }
      if ( v6 != 1000 )
        goto LABEL_100;
      npc->entityFlags &= 0xFFDFu;
      npc->currentState = 1001;
      npc->waitTimer = 0;
      npc->animationNumber = 4;
      npc->curlyTargetX = npc->XPos;
      npc->curlyTargetY = npc->YPos;
      npc->XVel = 0;
      npc->YVel = 0;
      killNPC(252, 1);
      createNPC(NPCSmoke, npc->XPos, npc->YPos, 0, 0, 0, 0, 256);
      createNPC(NPCSmoke, npc->XPos, npc->YPos, 0, 0, 0, 0, 256);
      createNPC(NPCSmoke, npc->XPos, npc->YPos, 0, 0, 0, 0, 256);
    }
    if ( ++npc->waitTimer / 2 % 2 )
      npc->XPos = npc->curlyTargetX + 512;
    else
      npc->XPos = npc->curlyTargetX;
    goto LABEL_100;
  }
  if ( v6 == 1010 )
  {
    npc->YVel += 16;
    if ( npc->collisionFlags & 8 )
    {
      npc->currentState = 1020;
      npc->animationNumber = 8;
    }
  }
LABEL_100:
  if ( npc->XVel < -512 )
    npc->XVel = -512;
  if ( npc->XVel > 512 )
    npc->XVel = 512;
  if ( npc->YVel < -1024 )
    npc->YVel = -1024;
  if ( npc->YVel > 1024 )
    npc->YVel = 1024;
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  if ( npc->direction )
    v4 = &v7 + 4 * npc->animationNumber;
  else
    v4 = &v44 + 4 * npc->animationNumber;
  v5 = &npc->rect;
  v5->left = *v4;
  v5->top = v4[1];
  v5->right = v4[2];
  v5->bottom = v4[3];
}

//----- (00456F50) --------------------------------------------------------
void __cdecl NPC248(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int v3; // [esp+0h] [ebp-30h]
  int v4; // [esp+4h] [ebp-2Ch]
  int v5; // [esp+8h] [ebp-28h]
  int v6; // [esp+Ch] [ebp-24h]
  int v7; // [esp+10h] [ebp-20h]
  int v8; // [esp+14h] [ebp-1Ch]
  int v9; // [esp+18h] [ebp-18h]
  int v10; // [esp+1Ch] [ebp-14h]
  int v11; // [esp+20h] [ebp-10h]
  int v12; // [esp+24h] [ebp-Ch]
  int v13; // [esp+28h] [ebp-8h]
  int v14; // [esp+2Ch] [ebp-4h]

  if ( *(_DWORD *)(a1 + 4) & 0xFF )
  {
    *(_BYTE *)a1 = 0;
    createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectRisingDisc, 0);
  }
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  v3 = 0;
  v4 = 48;
  v5 = 16;
  v6 = 64;
  v7 = 16;
  v8 = 48;
  v9 = 32;
  v10 = 64;
  v11 = 32;
  v12 = 48;
  v13 = 48;
  v14 = 64;
  if ( ++*(_DWORD *)(a1 + 100) > 1 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    if ( ++*(_DWORD *)(a1 + 104) > 2 )
      *(_DWORD *)(a1 + 104) = 0;
  }
  v1 = &v3 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  v2[3] = v1[3];
  if ( ++*(_DWORD *)(a1 + 108) > 300 )
  {
    *(_BYTE *)a1 = 0;
    createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectRisingDisc, 0);
  }
}

//----- (004570B0) --------------------------------------------------------
int __cdecl NPC249(int a1)
{
  _DWORD *v1; // eax
  int result; // eax
  int v3; // ecx
  _DWORD *v4; // eax

  if ( ++*(_DWORD *)(a1 + 120) > 8 )
    *(_BYTE *)a1 = 0;
  if ( *(_DWORD *)(a1 + 76) )
  {
    v4 = (_DWORD *)(a1 + 84);
    *v4 = 64;
    v4[1] = 48;
    v4[2] = 80;
    v4[3] = 64;
    result = a1;
    v3 = *(_DWORD *)(a1 + 8) + 1024;
  }
  else
  {
    v1 = (_DWORD *)(a1 + 84);
    *v1 = 48;
    v1[1] = 48;
    v1[2] = 64;
    v1[3] = 64;
    result = a1;
    v3 = *(_DWORD *)(a1 + 8) - 1024;
  }
  *(_DWORD *)(a1 + 8) = v3;
  return result;
}

//----- (00457180) --------------------------------------------------------
void __cdecl NPC250(int a1)
{
  int v1; // ecx
  int v2; // ecx
  int *v3; // ecx
  int *v4; // edx
  int v5; // [esp+4h] [ebp-30h]
  int v6; // [esp+8h] [ebp-2Ch]
  int v7; // [esp+Ch] [ebp-28h]
  int v8; // [esp+10h] [ebp-24h]
  int v9; // [esp+14h] [ebp-20h]
  int v10; // [esp+18h] [ebp-1Ch]
  int v11; // [esp+1Ch] [ebp-18h]
  int v12; // [esp+20h] [ebp-14h]
  int v13; // [esp+24h] [ebp-10h]
  int v14; // [esp+28h] [ebp-Ch]
  int v15; // [esp+2Ch] [ebp-8h]
  int v16; // [esp+30h] [ebp-4h]

  v5 = 0;
  v6 = 32;
  v7 = 16;
  v8 = 48;
  v9 = 16;
  v10 = 32;
  v11 = 32;
  v12 = 48;
  v13 = 32;
  v14 = 32;
  v15 = 48;
  v16 = 48;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 20) = -512;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( *(_DWORD *)(a1 + 8) >= quote.XPos )
        v1 = *(_DWORD *)(a1 + 16) - 16;
      else
        v1 = *(_DWORD *)(a1 + 16) + 16;
      *(_DWORD *)(a1 + 16) = v1;
      if ( *(_DWORD *)(a1 + 12) >= *(_DWORD *)(a1 + 36) )
        v2 = *(_DWORD *)(a1 + 20) - 32;
      else
        v2 = *(_DWORD *)(a1 + 20) + 32;
      *(_DWORD *)(a1 + 20) = v2;
      if ( *(_DWORD *)(a1 + 16) > 512 )
        *(_DWORD *)(a1 + 16) = 512;
      if ( *(_DWORD *)(a1 + 16) < -512 )
        *(_DWORD *)(a1 + 16) = -512;
      if ( *(_DWORD *)(a1 + 20) > 512 )
        *(_DWORD *)(a1 + 20) = 512;
      if ( *(_DWORD *)(a1 + 20) < -512 )
        *(_DWORD *)(a1 + 20) = -512;
      *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
      if ( ++*(_DWORD *)(a1 + 100) > 2 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 1 )
        *(_DWORD *)(a1 + 104) = 0;
      if ( quote.XPos > *(_DWORD *)(a1 + 8) - 4096
        && quote.XPos < *(_DWORD *)(a1 + 8) + 4096
        && quote.YPos > *(_DWORD *)(a1 + 12) )
      {
        *(_DWORD *)(a1 + 116) = 10;
      }
      goto LABEL_32;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 120) = 0;
      goto LABEL_27;
    case 0xB:
LABEL_27:
      if ( ++*(_DWORD *)(a1 + 120) <= 10 )
      {
        if ( *(_DWORD *)(a1 + 120) / 2 % 2 )
          *(_DWORD *)(a1 + 104) = 2;
        else
          *(_DWORD *)(a1 + 104) = 1;
LABEL_32:
        v3 = &v5 + 4 * *(_DWORD *)(a1 + 104);
        v4 = (int *)(a1 + 84);
        *v4 = *v3;
        v4[1] = v3[1];
        v4[2] = v3[2];
        v4[3] = v3[3];
      }
      else
      {
        createNPC((NPCNames)251, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 0, 0, 0, 0, 256);
        playSoundEffect(SFXLightning, 1);
        *(_BYTE *)a1 = 0;
      }
      return;
    default:
      goto LABEL_32;
  }
}

//----- (00457470) --------------------------------------------------------
int __cdecl NPC251(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  int v4; // [esp+0h] [ebp-24h]
  int v5; // [esp+4h] [ebp-20h]
  int v6; // [esp+8h] [ebp-1Ch]
  int v7; // [esp+Ch] [ebp-18h]
  int v8; // [esp+10h] [ebp-14h]
  int v9; // [esp+14h] [ebp-10h]
  int v10; // [esp+18h] [ebp-Ch]
  int v11; // [esp+1Ch] [ebp-8h]
  int v12; // [esp+20h] [ebp-4h]

  v5 = 80;
  v6 = 32;
  v7 = 96;
  v8 = 64;
  v9 = 96;
  v10 = 32;
  v11 = 112;
  v12 = 64;
  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 != 1 )
      goto LABEL_9;
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
  }
  if ( ++*(_DWORD *)(a1 + 104) > 1 )
    *(_DWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 12) += 4096;
  if ( *(_DWORD *)(a1 + 4) & 0xFF )
  {
    createDustClouds(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 148), 3);
    *(_BYTE *)a1 = 0;
  }
LABEL_9:
  v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}

//----- (00457570) --------------------------------------------------------
int *__cdecl NPC252(int a1)
{
  int v1; // esi
  int v2; // esi
  int *v3; // edx
  int *result; // eax
  int v5; // [esp+4h] [ebp-88h]
  int v6; // [esp+8h] [ebp-84h]
  int v7; // [esp+Ch] [ebp-80h]
  int v8; // [esp+10h] [ebp-7Ch]
  int v9; // [esp+14h] [ebp-78h]
  int v10; // [esp+18h] [ebp-74h]
  int v11; // [esp+1Ch] [ebp-70h]
  int v12; // [esp+20h] [ebp-6Ch]
  int v13; // [esp+24h] [ebp-68h]
  int v14; // [esp+28h] [ebp-64h]
  int v15; // [esp+2Ch] [ebp-60h]
  int v16; // [esp+30h] [ebp-5Ch]
  int v17; // [esp+34h] [ebp-58h]
  int v18; // [esp+38h] [ebp-54h]
  int v19; // [esp+3Ch] [ebp-50h]
  int v20; // [esp+40h] [ebp-4Ch]
  int v21; // [esp+44h] [ebp-48h]
  int v22; // [esp+48h] [ebp-44h]
  int v23; // [esp+4Ch] [ebp-40h]
  int v24; // [esp+50h] [ebp-3Ch]
  int v25; // [esp+54h] [ebp-38h]
  int v26; // [esp+58h] [ebp-34h]
  int v27; // [esp+5Ch] [ebp-30h]
  int v28; // [esp+60h] [ebp-2Ch]
  int v29; // [esp+64h] [ebp-28h]
  int v30; // [esp+68h] [ebp-24h]
  int v31; // [esp+6Ch] [ebp-20h]
  int v32; // [esp+70h] [ebp-1Ch]
  int v33; // [esp+74h] [ebp-18h]
  int v34; // [esp+78h] [ebp-14h]
  int v35; // [esp+7Ch] [ebp-10h]
  int v36; // [esp+80h] [ebp-Ch]
  unsigned __int8 v37; // [esp+8Bh] [ebp-1h]

  v21 = 48;
  v22 = 32;
  v23 = 64;
  v24 = 48;
  v25 = 112;
  v26 = 32;
  v27 = 128;
  v28 = 48;
  v29 = 128;
  v30 = 32;
  v31 = 144;
  v32 = 48;
  v33 = 144;
  v34 = 32;
  v35 = 160;
  v36 = 48;
  v5 = 48;
  v6 = 32;
  v7 = 64;
  v8 = 48;
  v9 = 112;
  v10 = 48;
  v11 = 128;
  v12 = 64;
  v13 = 128;
  v14 = 48;
  v15 = 144;
  v16 = 64;
  v17 = 144;
  v18 = 48;
  v19 = 160;
  v20 = 64;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 108) = *(_DWORD *)(a1 + 76);
      goto LABEL_3;
    case 1:
LABEL_3:
      *(_DWORD *)(a1 + 108) += 2;
      *(_DWORD *)(a1 + 108) %= 256;
      v37 = *(_BYTE *)(a1 + 108);
      if ( *(_DWORD *)(a1 + 120) < 192 )
        ++*(_DWORD *)(a1 + 120);
      v1 = *(_DWORD *)(a1 + 168);
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(v1 + 8) + *(_DWORD *)(a1 + 120) * getCos(v37) / 4;
      v2 = *(_DWORD *)(a1 + 168);
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(v2 + 12) + *(_DWORD *)(a1 + 120) * getSin(v37) / 4;
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 116) == 151 )
      {
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_WORD *)(a1 + 80) |= 0x20u;
      *(_WORD *)(a1 + 80) &= 0xFFFBu;
      *(_WORD *)(a1 + 80) &= 0xFFF7u;
      v37 = getArcTan(*(_DWORD *)(a1 + 8) - quote.XPos, *(_DWORD *)(a1 + 12) - quote.YPos);
      v37 += random(-3, 3);
      *(_DWORD *)(a1 + 16) = getCos(v37);
      *(_DWORD *)(a1 + 20) = getSin(v37);
      *(_DWORD *)(a1 + 104) = 1;
      *(_DWORD *)(a1 + 100) = 0;
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      goto LABEL_11;
    case 0xB:
LABEL_11:
      *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
      if ( *(_DWORD *)(a1 + 4) & 0xFF )
      {
        createNPC(NPCSmoke, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 0, 0, 0, 0, 256);
        createNPC(NPCSmoke, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 0, 0, 0, 0, 256);
        createNPC(NPCSmoke, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 0, 0, 0, 0, 256);
        *(_BYTE *)a1 = 0;
      }
      if ( ++*(_DWORD *)(a1 + 100) > 4 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 3 )
        *(_DWORD *)(a1 + 104) = 1;
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 76) )
    v3 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  else
    v3 = &v21 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v3;
  result[1] = v3[1];
  result[2] = v3[2];
  result[3] = v3[3];
  return result;
}

//----- (004579D0) --------------------------------------------------------
int *__cdecl NPC253(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+0h] [ebp-24h]
  int v4; // [esp+4h] [ebp-20h]
  int v5; // [esp+8h] [ebp-1Ch]
  int v6; // [esp+Ch] [ebp-18h]
  int v7; // [esp+10h] [ebp-14h]
  int v8; // [esp+14h] [ebp-10h]
  int v9; // [esp+18h] [ebp-Ch]
  int v10; // [esp+1Ch] [ebp-8h]
  int v11; // [esp+20h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 116);
  if ( v3 )
  {
    if ( v3 != 1 )
      goto LABEL_9;
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
  }
  if ( ++*(_DWORD *)(a1 + 100) > 4 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 1 )
    *(_DWORD *)(a1 + 104) = 0;
LABEL_9:
  if ( *(_DWORD *)(a1 + 64) <= 100 )
  {
    Spawn_Exp(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 44));
    createDustClouds(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 148), 8);
    playSoundEffect(SFXSillyExplosion, 1);
    *(_BYTE *)a1 = 0;
  }
  v4 = 0;
  v5 = 64;
  v6 = 16;
  v7 = 80;
  v8 = 16;
  v9 = 64;
  v10 = 32;
  v11 = 80;
  v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (00457B00) --------------------------------------------------------
signed int __cdecl NPC254(NPC *a1)
{
  RECT *v1; // ecx
  signed int result; // eax
  RECT *v3; // ecx

  switch ( a1->currentState )
  {
    case 0:
      a1->currentState = 1;
      createNPC((NPCNames)255, a1->XPos + 9216, a1->YPos - 29184, 0, 0, 0, a1, 256);
      createNPC((NPCNames)255, a1->XPos - 0x4000, a1->YPos - 26624, 0, 0, right, a1, 256);
      break;
    case 0x14:
      a1->waitTimer = 0;
      a1->count1 = 60;
      a1->currentState = 21;
      break;
    case 0x1E:
      a1->currentState = 21;
      createNPC(NPCTreasureChestClosed|0xD0, a1->XPos - 5632, a1->YPos - 7168, 0, 0, 0, 0, 256);
      break;
    case 0x28:
      a1->currentState = 21;
      createNPC(NPCTreasureChestClosed|0xD0, a1->XPos - 4608, a1->YPos - 7168, 0, 0, 0, 0, 256);
      createNPC((NPCNames)40, a1->XPos - 11264, a1->YPos - 7168, 0, 0, 0, 0, 256);
      createNPC(NPCForcefield|0x50, a1->XPos - 17920, a1->YPos - 7168, 0, 0, 0, 0, 256);
      break;
    default:
      break;
  }
  if ( a1->direction )
  {
    v3 = &a1->rect;
    v3->left = 0;
    v3->top = 64;
    v3->right = 128;
    result = 128;
    v3->bottom = 128;
  }
  else
  {
    v1 = &a1->rect;
    v1->left = 0;
    v1->top = 0;
    v1->right = 128;
    result = 64;
    v1->bottom = 64;
  }
  return result;
}

//----- (00457D70) --------------------------------------------------------
int __cdecl NPC255(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+4h] [ebp-80h]
  int v5; // [esp+8h] [ebp-7Ch]
  int v6; // [esp+Ch] [ebp-78h]
  int v7; // [esp+10h] [ebp-74h]
  int v8; // [esp+14h] [ebp-70h]
  int v9; // [esp+18h] [ebp-6Ch]
  int v10; // [esp+1Ch] [ebp-68h]
  int v11; // [esp+20h] [ebp-64h]
  int v12; // [esp+24h] [ebp-60h]
  int v13; // [esp+28h] [ebp-5Ch]
  int v14; // [esp+2Ch] [ebp-58h]
  int v15; // [esp+30h] [ebp-54h]
  int v16; // [esp+34h] [ebp-50h]
  int v17; // [esp+38h] [ebp-4Ch]
  int v18; // [esp+3Ch] [ebp-48h]
  int v19; // [esp+40h] [ebp-44h]
  int v20; // [esp+44h] [ebp-40h]
  int v21; // [esp+48h] [ebp-3Ch]
  int v22; // [esp+4Ch] [ebp-38h]
  int v23; // [esp+50h] [ebp-34h]
  int v24; // [esp+54h] [ebp-30h]
  int v25; // [esp+58h] [ebp-2Ch]
  int v26; // [esp+5Ch] [ebp-28h]
  int v27; // [esp+60h] [ebp-24h]
  int v28; // [esp+64h] [ebp-20h]
  int v29; // [esp+68h] [ebp-1Ch]
  int v30; // [esp+6Ch] [ebp-18h]
  int v31; // [esp+70h] [ebp-14h]
  int v32; // [esp+74h] [ebp-10h]
  int v33; // [esp+78h] [ebp-Ch]
  int v34; // [esp+7Ch] [ebp-8h]
  int v35; // [esp+80h] [ebp-4h]

  v20 = 128;
  v21 = 0;
  v22 = 240;
  v23 = 16;
  v24 = 128;
  v25 = 16;
  v26 = 240;
  v27 = 32;
  v28 = 128;
  v29 = 32;
  v30 = 240;
  v31 = 48;
  v32 = 128;
  v33 = 16;
  v34 = 240;
  v35 = 32;
  v4 = 240;
  v5 = 0;
  v6 = 320;
  v7 = 16;
  v8 = 240;
  v9 = 16;
  v10 = 320;
  v11 = 32;
  v12 = 240;
  v13 = 32;
  v14 = 320;
  v15 = 48;
  v16 = 240;
  v17 = 16;
  v18 = 320;
  v19 = 32;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      if ( *(_DWORD *)(a1 + 76) )
      {
        *(_DWORD *)(a1 + 140) = 20480;
        *(_DWORD *)(a1 + 148) = 20480;
      }
      else
      {
        *(_DWORD *)(a1 + 140) = 28672;
        *(_DWORD *)(a1 + 148) = 28672;
      }
      goto LABEL_5;
    case 1:
LABEL_5:
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 116) >= 20 )
        *(_DWORD *)(a1 + 116) = 10;
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      goto LABEL_9;
    case 0xB:
LABEL_9:
      if ( ++*(_DWORD *)(a1 + 104) > 3 )
        *(_DWORD *)(a1 + 104) = 0;
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 76) )
  {
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) - 0x4000;
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12) - 26624;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) + 9216;
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12) - 29184;
  }
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v20 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (00458010) --------------------------------------------------------
int __cdecl NPC256(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  int v4; // [esp+4h] [ebp-60h]
  int v5; // [esp+8h] [ebp-5Ch]
  int v6; // [esp+Ch] [ebp-58h]
  int v7; // [esp+10h] [ebp-54h]
  int v8; // [esp+14h] [ebp-50h]
  int v9; // [esp+18h] [ebp-4Ch]
  int v10; // [esp+1Ch] [ebp-48h]
  int v11; // [esp+20h] [ebp-44h]
  int v12; // [esp+24h] [ebp-40h]
  int v13; // [esp+28h] [ebp-3Ch]
  int v14; // [esp+2Ch] [ebp-38h]
  int v15; // [esp+30h] [ebp-34h]
  int v16; // [esp+34h] [ebp-30h]
  int v17; // [esp+38h] [ebp-2Ch]
  int v18; // [esp+3Ch] [ebp-28h]
  int v19; // [esp+40h] [ebp-24h]
  int v20; // [esp+44h] [ebp-20h]
  int v21; // [esp+48h] [ebp-1Ch]
  int v22; // [esp+4Ch] [ebp-18h]
  int v23; // [esp+50h] [ebp-14h]
  int v24; // [esp+54h] [ebp-10h]
  int v25; // [esp+58h] [ebp-Ch]
  int v26; // [esp+5Ch] [ebp-8h]
  int v27; // [esp+60h] [ebp-4h]

  v4 = 48;
  v5 = 160;
  v6 = 72;
  v7 = 192;
  v8 = 72;
  v9 = 160;
  v10 = 96;
  v11 = 192;
  v12 = 0;
  v13 = 128;
  v14 = 24;
  v15 = 160;
  v16 = 24;
  v17 = 128;
  v18 = 48;
  v19 = 160;
  v20 = 0;
  v21 = 160;
  v22 = 24;
  v23 = 192;
  v24 = 24;
  v25 = 160;
  v26 = 48;
  v27 = 192;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      superYPos = 0;
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 12) -= 4096;
      goto LABEL_3;
    case 1:
LABEL_3:
      *(_DWORD *)(a1 + 104) = 0;
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 100) = 0;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 108) = 0;
      goto LABEL_5;
    case 0xB:
LABEL_5:
      if ( ++*(_DWORD *)(a1 + 100) > 5 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 1 )
      {
        *(_DWORD *)(a1 + 104) = 0;
        ++*(_DWORD *)(a1 + 108);
      }
      if ( *(_DWORD *)(a1 + 108) > 5 )
        *(_DWORD *)(a1 + 116) = 1;
      break;
    case 0x14:
      *(_DWORD *)(a1 + 116) = 21;
      goto LABEL_13;
    case 0x15:
LABEL_13:
      *(_DWORD *)(a1 + 104) = 2;
      break;
    case 0x28:
      *(_DWORD *)(a1 + 116) = 41;
      createNPC((NPCNames)257, *(_DWORD *)(a1 + 8) - 7168, *(_DWORD *)(a1 + 12) - 0x2000, 0, 0, 0, 0, 256);
      createNPC((NPCNames)257, *(_DWORD *)(a1 + 8) - 7168, *(_DWORD *)(a1 + 12) - 0x2000, 0, 0, right, 0, 170);
      goto LABEL_15;
    case 0x29:
LABEL_15:
      *(_DWORD *)(a1 + 104) = 4;
      break;
    case 0x32:
      *(_DWORD *)(a1 + 116) = 51;
      *(_DWORD *)(a1 + 100) = 0;
      *(_DWORD *)(a1 + 104) = 4;
      *(_DWORD *)(a1 + 108) = 0;
      goto LABEL_17;
    case 0x33:
LABEL_17:
      if ( ++*(_DWORD *)(a1 + 100) > 5 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 5 )
      {
        *(_DWORD *)(a1 + 104) = 4;
        ++*(_DWORD *)(a1 + 108);
      }
      if ( *(_DWORD *)(a1 + 108) > 5 )
        *(_DWORD *)(a1 + 116) = 41;
      break;
    default:
      break;
  }
  v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}
// 4BBA30: using guessed type int superYPos;

//----- (00458360) --------------------------------------------------------
int __cdecl NPC257(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  int v4; // [esp+0h] [ebp-34h]
  int v5; // [esp+4h] [ebp-30h]
  int v6; // [esp+8h] [ebp-2Ch]
  int v7; // [esp+Ch] [ebp-28h]
  int v8; // [esp+10h] [ebp-24h]
  int v9; // [esp+14h] [ebp-20h]
  int v10; // [esp+18h] [ebp-1Ch]
  int v11; // [esp+1Ch] [ebp-18h]
  int v12; // [esp+20h] [ebp-14h]
  int v13; // [esp+24h] [ebp-10h]
  int v14; // [esp+28h] [ebp-Ch]
  int v15; // [esp+2Ch] [ebp-8h]
  int v16; // [esp+30h] [ebp-4h]

  v5 = 176;
  v6 = 32;
  v7 = 184;
  v8 = 48;
  v9 = 184;
  v10 = 32;
  v11 = 192;
  v12 = 48;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      if ( v4 == 10 )
      {
        if ( *(_DWORD *)(a1 + 8) < superYPos )
          *(_DWORD *)(a1 + 16) += 85;
        if ( *(_DWORD *)(a1 + 8) > superYPos )
          *(_DWORD *)(a1 + 16) -= 85;
        if ( *(_DWORD *)(a1 + 12) < curlyShootY )
          *(_DWORD *)(a1 + 20) += 85;
        if ( *(_DWORD *)(a1 + 12) > curlyShootY )
          *(_DWORD *)(a1 + 20) -= 85;
        if ( *(_DWORD *)(a1 + 16) > 1024 )
          *(_DWORD *)(a1 + 16) = 1024;
        if ( *(_DWORD *)(a1 + 16) < -1024 )
          *(_DWORD *)(a1 + 16) = -1024;
        if ( *(_DWORD *)(a1 + 20) > 1024 )
          *(_DWORD *)(a1 + 20) = 1024;
        if ( *(_DWORD *)(a1 + 20) < -1024 )
          *(_DWORD *)(a1 + 20) = -1024;
        *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
      }
      goto LABEL_26;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
  }
  if ( superYPos )
    *(_DWORD *)(a1 + 116) = 10;
LABEL_26:
  if ( ++*(_DWORD *)(a1 + 100) > 3 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 1 )
    *(_DWORD *)(a1 + 104) = 0;
  if ( !*(_DWORD *)(a1 + 76) && *(_DWORD *)(a1 + 16) > 0 )
    *(_DWORD *)(a1 + 104) = 2;
  if ( *(_DWORD *)(a1 + 76) == 2 && *(_DWORD *)(a1 + 16) < 0 )
    *(_DWORD *)(a1 + 104) = 2;
  v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}
// 4BBA28: using guessed type int curlyShootY;
// 4BBA30: using guessed type int superYPos;

//----- (004585A0) --------------------------------------------------------
_DWORD *__cdecl NPC258(int a1)
{
  _DWORD *result; // eax

  result = (_DWORD *)(a1 + 84);
  *result = 48;
  result[1] = 32;
  result[2] = 64;
  result[3] = 48;
  return result;
}

//----- (004585F0) --------------------------------------------------------
void __cdecl NPC259(void *a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // edx
  _DWORD *v3; // eax

  switch ( *((_DWORD *)a1 + 29) )
  {
    case 0:
      *((_WORD *)a1 + 40) &= 0xDFFFu;
      *((_DWORD *)a1 + 29) = 1;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( quote.direction )
        *((_DWORD *)a1 + 19) = 2;
      else
        *((_DWORD *)a1 + 19) = 0;
      *((_DWORD *)a1 + 3) = quote.YPos - 2048;
      if ( *((_DWORD *)a1 + 19) )
      {
        *((_DWORD *)a1 + 2) = quote.XPos - 1536;
        v2 = (char *)a1 + 84;
        *v2 = 224;
        v2[1] = 112;
        v2[2] = 240;
        v2[3] = 128;
      }
      else
      {
        *((_DWORD *)a1 + 2) = quote.XPos + 1536;
        v1 = (char *)a1 + 84;
        *v1 = 224;
        v1[1] = 96;
        v1[2] = 240;
        v1[3] = 112;
      }
      if ( quote.animationNumber % 2 )
        ++*((_DWORD *)a1 + 22);
      break;
    case 0xA:
      *((_DWORD *)a1 + 29) = 11;
      *((_DWORD *)a1 + 4) = 64;
      *((_DWORD *)a1 + 5) = -32;
      v3 = (char *)a1 + 84;
      *v3 = 224;
      v3[1] = 96;
      v3[2] = 240;
      v3[3] = 112;
      break;
    case 0xB:
      if ( *((_DWORD *)a1 + 3) < 0x8000 )
        *((_DWORD *)a1 + 5) = 32;
      *((_DWORD *)a1 + 2) += *((_DWORD *)a1 + 4);
      *((_DWORD *)a1 + 3) += *((_DWORD *)a1 + 5);
      break;
    case 0x14:
      Vanish_NPC((NPC *)a1);
      createDustCloudsUp(*((_DWORD *)a1 + 2), *((_DWORD *)a1 + 3), 0x2000, 64);
      break;
    default:
      return;
  }
}

//----- (00458810) --------------------------------------------------------
int *__cdecl NPC260(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+4h] [ebp-60h]
  int v4; // [esp+8h] [ebp-5Ch]
  int v5; // [esp+Ch] [ebp-58h]
  int v6; // [esp+10h] [ebp-54h]
  int v7; // [esp+14h] [ebp-50h]
  int v8; // [esp+18h] [ebp-4Ch]
  int v9; // [esp+1Ch] [ebp-48h]
  int v10; // [esp+20h] [ebp-44h]
  int v11; // [esp+24h] [ebp-40h]
  int v12; // [esp+28h] [ebp-3Ch]
  int v13; // [esp+2Ch] [ebp-38h]
  int v14; // [esp+30h] [ebp-34h]
  int v15; // [esp+34h] [ebp-30h]
  int v16; // [esp+38h] [ebp-2Ch]
  int v17; // [esp+3Ch] [ebp-28h]
  int v18; // [esp+40h] [ebp-24h]
  int v19; // [esp+44h] [ebp-20h]
  int v20; // [esp+48h] [ebp-1Ch]
  int v21; // [esp+4Ch] [ebp-18h]
  int v22; // [esp+50h] [ebp-14h]
  int v23; // [esp+54h] [ebp-10h]
  int v24; // [esp+58h] [ebp-Ch]
  int v25; // [esp+5Ch] [ebp-8h]
  int v26; // [esp+60h] [ebp-4h]

  v15 = 128;
  v16 = 64;
  v17 = 144;
  v18 = 80;
  v19 = 144;
  v20 = 64;
  v21 = 160;
  v22 = 80;
  v23 = 224;
  v24 = 64;
  v25 = 240;
  v26 = 80;
  v3 = 128;
  v4 = 80;
  v5 = 144;
  v6 = 96;
  v7 = 144;
  v8 = 80;
  v9 = 160;
  v10 = 96;
  v11 = 224;
  v12 = 80;
  v13 = 240;
  v14 = 96;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 8) += 512;
      *(_DWORD *)(a1 + 12) -= 1024;
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( random(0, 160) == 1 )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 120) > 12 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 104) = 2;
      createNPC(NPCEnemyBasil|0x50, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12) - 0x2000, 0, 0, 0, 0, 256);
      break;
    default:
      break;
  }
  if ( quote.XPos >= *(_DWORD *)(a1 + 8) )
    *(_DWORD *)(a1 + 76) = 2;
  else
    *(_DWORD *)(a1 + 76) = 0;
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v3 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v15 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (00458A70) --------------------------------------------------------
int __cdecl NPC261(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+0h] [ebp-44h]
  int v5; // [esp+4h] [ebp-40h]
  int v6; // [esp+8h] [ebp-3Ch]
  int v7; // [esp+Ch] [ebp-38h]
  int v8; // [esp+10h] [ebp-34h]
  int v9; // [esp+14h] [ebp-30h]
  int v10; // [esp+18h] [ebp-2Ch]
  int v11; // [esp+1Ch] [ebp-28h]
  int v12; // [esp+20h] [ebp-24h]
  int v13; // [esp+24h] [ebp-20h]
  int v14; // [esp+28h] [ebp-1Ch]
  int v15; // [esp+2Ch] [ebp-18h]
  int v16; // [esp+30h] [ebp-14h]
  int v17; // [esp+34h] [ebp-10h]
  int v18; // [esp+38h] [ebp-Ch]
  int v19; // [esp+3Ch] [ebp-8h]
  int v20; // [esp+40h] [ebp-4h]

  v13 = 112;
  v14 = 32;
  v15 = 128;
  v16 = 48;
  v17 = 128;
  v18 = 32;
  v19 = 144;
  v20 = 48;
  v5 = 112;
  v6 = 48;
  v7 = 128;
  v8 = 64;
  v9 = 128;
  v10 = 48;
  v11 = 144;
  v12 = 64;
  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      if ( v4 == 2 && ++*(_DWORD *)(a1 + 120) > 12 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      goto LABEL_11;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 8) -= 512;
    *(_DWORD *)(a1 + 12) -= 1024;
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 100) = 0;
  }
  if ( random(0, 160) == 1 )
  {
    *(_DWORD *)(a1 + 116) = 2;
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 104) = 1;
  }
LABEL_11:
  if ( quote.XPos >= *(_DWORD *)(a1 + 8) )
    *(_DWORD *)(a1 + 76) = 2;
  else
    *(_DWORD *)(a1 + 76) = 0;
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v13 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (00458C30) --------------------------------------------------------
int __cdecl NPC262(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+0h] [ebp-44h]
  int v5; // [esp+4h] [ebp-40h]
  int v6; // [esp+8h] [ebp-3Ch]
  int v7; // [esp+Ch] [ebp-38h]
  int v8; // [esp+10h] [ebp-34h]
  int v9; // [esp+14h] [ebp-30h]
  int v10; // [esp+18h] [ebp-2Ch]
  int v11; // [esp+1Ch] [ebp-28h]
  int v12; // [esp+20h] [ebp-24h]
  int v13; // [esp+24h] [ebp-20h]
  int v14; // [esp+28h] [ebp-1Ch]
  int v15; // [esp+2Ch] [ebp-18h]
  int v16; // [esp+30h] [ebp-14h]
  int v17; // [esp+34h] [ebp-10h]
  int v18; // [esp+38h] [ebp-Ch]
  int v19; // [esp+3Ch] [ebp-8h]
  int v20; // [esp+40h] [ebp-4h]

  v13 = 128;
  v14 = 0;
  v15 = 144;
  v16 = 16;
  v17 = 144;
  v18 = 0;
  v19 = 160;
  v20 = 16;
  v5 = 128;
  v6 = 16;
  v7 = 144;
  v8 = 32;
  v9 = 144;
  v10 = 16;
  v11 = 160;
  v12 = 32;
  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      if ( v4 == 2 && ++*(_DWORD *)(a1 + 120) > 12 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      goto LABEL_11;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 8) -= 512;
    *(_DWORD *)(a1 + 12) -= 1024;
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 100) = 0;
  }
  if ( random(0, 160) == 1 )
  {
    *(_DWORD *)(a1 + 116) = 2;
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 104) = 1;
  }
LABEL_11:
  if ( quote.XPos >= *(_DWORD *)(a1 + 8) )
    *(_DWORD *)(a1 + 76) = 2;
  else
    *(_DWORD *)(a1 + 76) = 0;
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v13 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (00458DF0) --------------------------------------------------------
void __cdecl NPC263(NPC *NPC)
{
  int Y_Vel; // ST24_4
  int *v2; // edx
  RECT *v3; // eax
  int NPC_Current_State; // [esp+0h] [ebp-138h]
  int v5; // [esp+8h] [ebp-130h]
  int v6; // [esp+Ch] [ebp-12Ch]
  int v7; // [esp+10h] [ebp-128h]
  int v8; // [esp+14h] [ebp-124h]
  int v9; // [esp+18h] [ebp-120h]
  int v10; // [esp+1Ch] [ebp-11Ch]
  int v11; // [esp+20h] [ebp-118h]
  int v12; // [esp+24h] [ebp-114h]
  int v13; // [esp+28h] [ebp-110h]
  int v14; // [esp+2Ch] [ebp-10Ch]
  int v15; // [esp+30h] [ebp-108h]
  int v16; // [esp+34h] [ebp-104h]
  int v17; // [esp+38h] [ebp-100h]
  int v18; // [esp+3Ch] [ebp-FCh]
  int v19; // [esp+40h] [ebp-F8h]
  int v20; // [esp+44h] [ebp-F4h]
  int v21; // [esp+48h] [ebp-F0h]
  int v22; // [esp+4Ch] [ebp-ECh]
  int v23; // [esp+50h] [ebp-E8h]
  int v24; // [esp+54h] [ebp-E4h]
  int v25; // [esp+58h] [ebp-E0h]
  int v26; // [esp+5Ch] [ebp-DCh]
  int v27; // [esp+60h] [ebp-D8h]
  int v28; // [esp+64h] [ebp-D4h]
  int v29; // [esp+68h] [ebp-D0h]
  int v30; // [esp+6Ch] [ebp-CCh]
  int v31; // [esp+70h] [ebp-C8h]
  int v32; // [esp+74h] [ebp-C4h]
  int v33; // [esp+78h] [ebp-C0h]
  int v34; // [esp+7Ch] [ebp-BCh]
  int v35; // [esp+80h] [ebp-B8h]
  int v36; // [esp+84h] [ebp-B4h]
  int v37; // [esp+88h] [ebp-B0h]
  int v38; // [esp+8Ch] [ebp-ACh]
  int v39; // [esp+90h] [ebp-A8h]
  int v40; // [esp+94h] [ebp-A4h]
  int X_Vel; // [esp+9Ch] [ebp-9Ch]
  int v42; // [esp+A0h] [ebp-98h]
  int v43; // [esp+A4h] [ebp-94h]
  int v44; // [esp+A8h] [ebp-90h]
  int v45; // [esp+ACh] [ebp-8Ch]
  int v46; // [esp+B0h] [ebp-88h]
  int v47; // [esp+B4h] [ebp-84h]
  int v48; // [esp+B8h] [ebp-80h]
  int v49; // [esp+BCh] [ebp-7Ch]
  int v50; // [esp+C0h] [ebp-78h]
  int v51; // [esp+C4h] [ebp-74h]
  int v52; // [esp+C8h] [ebp-70h]
  int v53; // [esp+CCh] [ebp-6Ch]
  int v54; // [esp+D0h] [ebp-68h]
  int v55; // [esp+D4h] [ebp-64h]
  int v56; // [esp+D8h] [ebp-60h]
  int v57; // [esp+DCh] [ebp-5Ch]
  int v58; // [esp+E0h] [ebp-58h]
  int v59; // [esp+E4h] [ebp-54h]
  int v60; // [esp+E8h] [ebp-50h]
  int v61; // [esp+ECh] [ebp-4Ch]
  int v62; // [esp+F0h] [ebp-48h]
  int v63; // [esp+F4h] [ebp-44h]
  int v64; // [esp+F8h] [ebp-40h]
  int v65; // [esp+FCh] [ebp-3Ch]
  int v66; // [esp+100h] [ebp-38h]
  int v67; // [esp+104h] [ebp-34h]
  int v68; // [esp+108h] [ebp-30h]
  int v69; // [esp+10Ch] [ebp-2Ch]
  int v70; // [esp+110h] [ebp-28h]
  int v71; // [esp+114h] [ebp-24h]
  int v72; // [esp+118h] [ebp-20h]
  int v73; // [esp+11Ch] [ebp-1Ch]
  int v74; // [esp+120h] [ebp-18h]
  int v75; // [esp+124h] [ebp-14h]
  int v76; // [esp+128h] [ebp-10h]
  int v77; // [esp+12Ch] [ebp-Ch]
  int i; // [esp+134h] [ebp-4h]

  v42 = 0;
  v43 = 0;
  v44 = 24;
  v45 = 32;
  v46 = 24;
  v47 = 0;
  v48 = 48;
  v49 = 32;
  v50 = 48;
  v51 = 0;
  v52 = 72;
  v53 = 32;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  v57 = 0;
  v58 = 72;
  v59 = 0;
  v60 = 96;
  v61 = 32;
  v62 = 96;
  v63 = 0;
  v64 = 120;
  v65 = 32;
  v66 = 120;
  v67 = 0;
  v68 = 144;
  v69 = 32;
  v70 = 144;
  v71 = 0;
  v72 = 168;
  v73 = 32;
  v74 = 264;
  v75 = 0;
  v76 = 288;
  v77 = 32;
  v5 = 0;
  v6 = 32;
  v7 = 24;
  v8 = 64;
  v9 = 24;
  v10 = 32;
  v11 = 48;
  v12 = 64;
  v13 = 48;
  v14 = 32;
  v15 = 72;
  v16 = 64;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 72;
  v22 = 32;
  v23 = 96;
  v24 = 64;
  v25 = 96;
  v26 = 32;
  v27 = 120;
  v28 = 64;
  v29 = 120;
  v30 = 32;
  v31 = 144;
  v32 = 64;
  v33 = 144;
  v34 = 32;
  v35 = 168;
  v36 = 64;
  v37 = 264;
  v38 = 32;
  v39 = 288;
  v40 = 64;
  NPC_Current_State = NPC->currentState;
  if ( NPC_Current_State <= 32 )
  {
    if ( NPC_Current_State == 32 )
    {
      if ( ++NPC->waitTimer > 50 )
        NPC->currentState = 100;
    }
    else
    {
      switch ( NPC_Current_State )
      {
        case 0:
          NPC->currentState = 1;
          NPC->YPos += 4096;
          NPC->animationNumber = 3;
          break;
        case 2:
          if ( ++NPC->waitTimer / 2 % 2 )
            NPC->animationNumber = 0;
          else
            NPC->animationNumber = 3;
          if ( NPC->waitTimer > 50 )
            NPC->currentState = 10;
          break;
        case 10:
          NPC->YVel += 128;
          NPC->entityFlags |= 0x20u;
          NPC->damage = 3;
          if ( NPC->collisionFlags & 8 )
          {
            NPC->currentState = 20;
            NPC->waitTimer = 0;
            NPC->animationNumber = 0;
            NPC->count2 = NPC->life;
            if ( NPC->XPos <= quote.XPos )
              NPC->direction = 2;
            else
              NPC->direction = 0;
          }
          break;
        case 20:
          if ( ++NPC->waitTimer < 50 && NPC->life < NPC->count2 - 20 )
            NPC->waitTimer = 50;
          if ( NPC->waitTimer == 50 )
          {
            if ( NPC->XPos <= quote.XPos )
              NPC->direction = 2;
            else
              NPC->direction = 0;
            NPC->animationNumber = 4;
          }
          if ( NPC->waitTimer == 80 )
          {
            NPC->animationNumber = 5;
            playSoundEffect(SFXSillyExplosion, 1);
            if ( NPC->direction )
            {
              createNPC((NPCNames)264, NPC->XPos + 0x2000, NPC->YPos, 0, 0, right, 0, 256);
              createNPC((NPCNames)264, NPC->XPos + 0x2000, NPC->YPos, 0, 0, (Directions)1026, 0, 256);
            }
            else
            {
              createNPC((NPCNames)264, NPC->XPos - 0x2000, NPC->YPos, 0, 0, 0, 0, 256);
              createNPC((NPCNames)264, NPC->XPos - 0x2000, NPC->YPos, 0, 0, (Directions)1024, 0, 256);
            }
          }
          if ( NPC->waitTimer == 120 )
            NPC->animationNumber = 0;
          if ( NPC->waitTimer > 130 && NPC->life < NPC->count2 - 50 )
            NPC->waitTimer = 161;
          if ( NPC->waitTimer > 160 )
          {
            NPC->currentState = 100;
            NPC->animationNumber = 0;
          }
          break;
        case 30:
          NPC->currentState = 31;
          NPC->waitTimer = 0;
          NPC->animationNumber = 6;
          NPC->curlyTargetX = NPC->XPos;
          NPC->entityFlags |= 0x20u;
          goto LABEL_46;
        case 31:
LABEL_46:
          if ( ++NPC->waitTimer / 2 % 2 )
            NPC->XPos = NPC->curlyTargetX;
          else
            NPC->XPos = NPC->curlyTargetX + 512;
          if ( NPC->waitTimer > 50 )
          {
            NPC->currentState = 32;
            NPC->waitTimer = 0;
            NPC->animationNumber = 7;
            playSoundEffect(SFXLightning, 1);
            for ( i = 8; i < 256; i += 16 )
            {
              X_Vel = 2 * getCos(i);
              Y_Vel = 2 * getSin(i);
              createNPC(NPCBossBalrogShooting|0x100, NPC->XPos, NPC->YPos, X_Vel, Y_Vel, 0, 0, 256);
            }
          }
          break;
        default:
          goto LABEL_82;
      }
    }
    goto LABEL_82;
  }
  if ( NPC_Current_State > 103 )
  {
    if ( NPC_Current_State == 500 )
    {
      NPC->entityFlags &= 0xFFDFu;
      NPC->animationNumber = 6;
      NPC->YVel += 16;
      if ( NPC->collisionFlags & 8 )
      {
        NPC->currentState = 501;
        NPC->waitTimer = 0;
        NPC->curlyTargetX = NPC->XPos;
        if ( NPC->XPos <= quote.XPos )
          NPC->direction = 2;
        else
          NPC->direction = 0;
      }
    }
    else if ( NPC_Current_State == 501 )
    {
      if ( NPC->XPos <= quote.XPos )
        NPC->direction = 2;
      else
        NPC->direction = 0;
      NPC->animationNumber = 8;
      if ( ++NPC->waitTimer / 2 % 2 )
        NPC->XPos = NPC->curlyTargetX;
      else
        NPC->XPos = NPC->curlyTargetX + 512;
    }
  }
  else if ( NPC_Current_State == 103 )
  {
    NPC->waitTimer -= 2;
    if ( NPC->waitTimer <= 0 )
    {
      NPC->entityFlags |= 0x20u;
      NPC->damage = 3;
      if ( NPC->count1 >= 3 )
      {
        NPC->count1 = 0;
        NPC->currentState = 30;
      }
      else
      {
        ++NPC->count1;
        NPC->currentState = 10;
      }
    }
  }
  else
  {
    if ( NPC_Current_State == 100 )
    {
      NPC->currentState = 101;
      NPC->entityFlags &= 0xFFDFu;
      NPC->damage = 0;
      NPC->waitTimer = 0;
      playSoundEffect(SFXTeleport, 1);
    }
    else if ( NPC_Current_State != 101 )
    {
      if ( NPC_Current_State == 102 && ++NPC->waitTimer > 40 )
      {
        NPC->currentState = 103;
        NPC->waitTimer = 16;
        NPC->animationNumber = 2;
        NPC->YVel = 0;
        NPC->XPos = NPC->curlyTargetX;
        NPC->YPos = NPC->curlyTargetY;
        if ( NPC->XPos <= quote.XPos )
          NPC->direction = 2;
        else
          NPC->direction = 0;
      }
      goto LABEL_82;
    }
    NPC->waitTimer += 2;
    if ( NPC->waitTimer > 16 )
    {
      NPC->currentState = 102;
      NPC->waitTimer = 0;
      NPC->animationNumber = 3;
      NPC->curlyTargetX = random(5, 35) << 13;
      NPC->curlyTargetY = random(5, 7) << 13;
    }
  }
LABEL_82:
  if ( NPC->currentState >= 10 )
  {
    if ( NPC->currentState == 102 )
    {
      superYPos = NPC->curlyTargetX;
      curlyShootY = NPC->curlyTargetY;
    }
    else
    {
      superYPos = NPC->XPos;
      curlyShootY = NPC->YPos;
    }
  }
  if ( NPC->YVel > 1535 )
    NPC->YVel = 1535;
  NPC->XPos += NPC->XVel;
  NPC->YPos += NPC->YVel;
  if ( NPC->direction )
    v2 = &v5 + 4 * NPC->animationNumber;
  else
    v2 = &v42 + 4 * NPC->animationNumber;
  v3 = &NPC->rect;
  v3->left = *v2;
  v3->top = v2[1];
  v3->right = v2[2];
  v3->bottom = v2[3];
  if ( NPC->currentState != 101 && NPC->currentState != 103 )
  {
    NPC->view.top = 0x2000;
  }
  else
  {
    NPC->rect.top += NPC->waitTimer;
    NPC->rect.bottom -= NPC->waitTimer;
    NPC->view.top = (16 - NPC->waitTimer) << 9;
  }
}
// 4BBA28: using guessed type int curlyShootY;
// 4BBA30: using guessed type int superYPos;

//----- (00459950) --------------------------------------------------------
void __cdecl NPC264(void *a1)
{
  int v1; // edx
  _DWORD *v2; // eax
  int v3; // [esp+0h] [ebp-18h]
  unsigned __int8 v4; // [esp+17h] [ebp-1h]

  if ( *((_DWORD *)a1 + 2) < 0 || *((_DWORD *)a1 + 2) > currentMap.width << 13 )
  {
    Vanish_NPC((NPC *)a1);
    return;
  }
  v3 = *((_DWORD *)a1 + 29);
  if ( !v3 )
  {
    *((_DWORD *)a1 + 29) = 1;
    *((_DWORD *)a1 + 8) = *((_DWORD *)a1 + 2);
    *((_DWORD *)a1 + 9) = *((_DWORD *)a1 + 3);
    *((_DWORD *)a1 + 27) = *((_DWORD *)a1 + 19) / 8;
    *((_DWORD *)a1 + 19) %= 8;
    goto LABEL_8;
  }
  if ( v3 == 1 )
  {
LABEL_8:
    *((_DWORD *)a1 + 27) += 6;
    *((_DWORD *)a1 + 27) %= 256;
    v4 = *((_BYTE *)a1 + 108);
    if ( *((_DWORD *)a1 + 30) < 128 )
      ++*((_DWORD *)a1 + 30);
    if ( *((_DWORD *)a1 + 19) )
      v1 = *((_DWORD *)a1 + 4) + 21;
    else
      v1 = *((_DWORD *)a1 + 4) - 21;
    *((_DWORD *)a1 + 4) = v1;
    *((_DWORD *)a1 + 8) += *((_DWORD *)a1 + 4);
    *((_DWORD *)a1 + 2) = *((_DWORD *)a1 + 8) + *((_DWORD *)a1 + 30) * getCos(v4) / 2 / 4;
    *((_DWORD *)a1 + 3) = *((_DWORD *)a1 + 9) + *((_DWORD *)a1 + 30) * getSin(v4) / 2;
    createNPC(NPCBalrogDropIn|0x100, *((_DWORD *)a1 + 2), *((_DWORD *)a1 + 3), 0, 0, 0, 0, 256);
  }
  v2 = (char *)a1 + 84;
  *v2 = 288;
  v2[1] = 0;
  v2[2] = 304;
  v2[3] = 16;
}

//----- (00459B30) --------------------------------------------------------
int __cdecl NPC265(int a1)
{
  int result; // eax
  int *v2; // eax
  int *v3; // ecx
  int v4; // [esp+0h] [ebp-30h]
  int v5; // [esp+4h] [ebp-2Ch]
  int v6; // [esp+8h] [ebp-28h]
  int v7; // [esp+Ch] [ebp-24h]
  int v8; // [esp+10h] [ebp-20h]
  int v9; // [esp+14h] [ebp-1Ch]
  int v10; // [esp+18h] [ebp-18h]
  int v11; // [esp+1Ch] [ebp-14h]
  int v12; // [esp+20h] [ebp-10h]
  int v13; // [esp+24h] [ebp-Ch]
  int v14; // [esp+28h] [ebp-8h]
  int v15; // [esp+2Ch] [ebp-4h]

  v4 = 288;
  v5 = 16;
  v6 = 304;
  v7 = 32;
  v8 = 288;
  v9 = 32;
  v10 = 304;
  v11 = 48;
  v12 = 288;
  v13 = 48;
  v14 = 304;
  v15 = 64;
  if ( ++*(_DWORD *)(a1 + 100) > 3 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) <= 2 )
  {
    v2 = &v4 + 4 * *(_DWORD *)(a1 + 104);
    v3 = (int *)(a1 + 84);
    *v3 = *v2;
    v3[1] = v2[1];
    v3[2] = v2[2];
    result = v2[3];
    v3[3] = result;
  }
  else
  {
    result = a1;
    *(_BYTE *)a1 = 0;
  }
  return result;
}

//----- (00459C00) --------------------------------------------------------
void __cdecl NPC266(void *a1)
{
  int *v1; // ecx
  int *v2; // edx
  int v3; // [esp+0h] [ebp-20h]
  int v4; // [esp+4h] [ebp-1Ch]
  int v5; // [esp+8h] [ebp-18h]
  int v6; // [esp+Ch] [ebp-14h]
  int v7; // [esp+10h] [ebp-10h]
  int v8; // [esp+14h] [ebp-Ch]
  int v9; // [esp+18h] [ebp-8h]
  int v10; // [esp+1Ch] [ebp-4h]

  v3 = 304;
  v4 = 16;
  v5 = 320;
  v6 = 32;
  v7 = 304;
  v8 = 32;
  v9 = 320;
  v10 = 48;
  if ( *((_DWORD *)a1 + 1) & 1 )
    *((_DWORD *)a1 + 4) = -*((_DWORD *)a1 + 4);
  if ( *((_DWORD *)a1 + 1) & 4 )
    *((_DWORD *)a1 + 4) = -*((_DWORD *)a1 + 4);
  if ( *((_DWORD *)a1 + 1) & 2 )
    *((_DWORD *)a1 + 5) = 512;
  if ( *((_DWORD *)a1 + 1) & 8 )
    *((_DWORD *)a1 + 5) = -512;
  *((_DWORD *)a1 + 2) += *((_DWORD *)a1 + 4);
  *((_DWORD *)a1 + 3) += *((_DWORD *)a1 + 5);
  if ( ++*((_DWORD *)a1 + 26) > 1 )
    *((_DWORD *)a1 + 26) = 0;
  v1 = &v3 + 4 * *((_DWORD *)a1 + 26);
  v2 = (int *)((char *)a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  v2[3] = v1[3];
  if ( ++*((_DWORD *)a1 + 30) % 4 == 1 )
    createNPC(NPCBalrogDropIn|0x100, *((_DWORD *)a1 + 2), *((_DWORD *)a1 + 3), 0, 0, 0, 0, 256);
  if ( *((_DWORD *)a1 + 30) > 250 )
    Vanish_NPC((NPC *)a1);
}

//----- (00459D80) --------------------------------------------------------
void __cdecl NPC267(NPC *npc)
{
  int v1; // ST10_4
  int v2; // ST0C_4
  int v3; // ST08_4
  int v4; // eax
  int v5; // ST0C_4
  int v6; // ST08_4
  int v7; // eax
  int v8; // ST10_4
  int v9; // ST0C_4
  int v10; // ST08_4
  int v11; // eax
  int v12; // ST10_4
  int v13; // ST0C_4
  int v14; // ST08_4
  int v15; // eax
  int v16; // ST10_4
  int v17; // ST08_4
  int v18; // eax
  int v19; // ST10_4
  int v20; // ST08_4
  int v21; // eax
  int *v22; // eax
  RECT *v23; // ecx
  int v24; // [esp+4h] [ebp-154h]
  int v25; // [esp+8h] [ebp-150h]
  int v26; // [esp+Ch] [ebp-14Ch]
  int v27; // [esp+10h] [ebp-148h]
  int v28; // [esp+14h] [ebp-144h]
  int v29; // [esp+18h] [ebp-140h]
  int v30; // [esp+1Ch] [ebp-13Ch]
  int v31; // [esp+20h] [ebp-138h]
  int v32; // [esp+24h] [ebp-134h]
  int v33; // [esp+28h] [ebp-130h]
  int v34; // [esp+2Ch] [ebp-12Ch]
  int v35; // [esp+30h] [ebp-128h]
  int v36; // [esp+34h] [ebp-124h]
  int v37; // [esp+38h] [ebp-120h]
  int v38; // [esp+3Ch] [ebp-11Ch]
  int v39; // [esp+40h] [ebp-118h]
  int v40; // [esp+44h] [ebp-114h]
  int v41; // [esp+48h] [ebp-110h]
  int v42; // [esp+4Ch] [ebp-10Ch]
  int v43; // [esp+50h] [ebp-108h]
  int v44; // [esp+54h] [ebp-104h]
  int v45; // [esp+58h] [ebp-100h]
  int v46; // [esp+5Ch] [ebp-FCh]
  int v47; // [esp+60h] [ebp-F8h]
  int v48; // [esp+64h] [ebp-F4h]
  int v49; // [esp+68h] [ebp-F0h]
  int v50; // [esp+6Ch] [ebp-ECh]
  int v51; // [esp+70h] [ebp-E8h]
  int v52; // [esp+74h] [ebp-E4h]
  int v53; // [esp+78h] [ebp-E0h]
  int v54; // [esp+7Ch] [ebp-DCh]
  int v55; // [esp+80h] [ebp-D8h]
  int v56; // [esp+84h] [ebp-D4h]
  int v57; // [esp+88h] [ebp-D0h]
  int v58; // [esp+8Ch] [ebp-CCh]
  int v59; // [esp+90h] [ebp-C8h]
  int v60; // [esp+94h] [ebp-C4h]
  int v61; // [esp+98h] [ebp-C0h]
  int v62; // [esp+9Ch] [ebp-BCh]
  int v63; // [esp+A0h] [ebp-B8h]
  int v64; // [esp+A4h] [ebp-B4h]
  int Y_Vel; // [esp+ACh] [ebp-ACh]
  int X_Vel; // [esp+B0h] [ebp-A8h]
  int i; // [esp+B4h] [ebp-A4h]
  int v68; // [esp+B8h] [ebp-A0h]
  int v69; // [esp+BCh] [ebp-9Ch]
  int v70; // [esp+C0h] [ebp-98h]
  int v71; // [esp+C4h] [ebp-94h]
  int v72; // [esp+C8h] [ebp-90h]
  int v73; // [esp+CCh] [ebp-8Ch]
  int v74; // [esp+D0h] [ebp-88h]
  int v75; // [esp+D4h] [ebp-84h]
  int v76; // [esp+D8h] [ebp-80h]
  int v77; // [esp+DCh] [ebp-7Ch]
  int v78; // [esp+E0h] [ebp-78h]
  int v79; // [esp+E4h] [ebp-74h]
  int v80; // [esp+E8h] [ebp-70h]
  int v81; // [esp+ECh] [ebp-6Ch]
  int v82; // [esp+F0h] [ebp-68h]
  int v83; // [esp+F4h] [ebp-64h]
  int v84; // [esp+F8h] [ebp-60h]
  int v85; // [esp+FCh] [ebp-5Ch]
  int v86; // [esp+100h] [ebp-58h]
  int v87; // [esp+104h] [ebp-54h]
  int v88; // [esp+108h] [ebp-50h]
  int v89; // [esp+10Ch] [ebp-4Ch]
  int v90; // [esp+110h] [ebp-48h]
  int v91; // [esp+114h] [ebp-44h]
  int v92; // [esp+118h] [ebp-40h]
  int v93; // [esp+11Ch] [ebp-3Ch]
  int v94; // [esp+120h] [ebp-38h]
  int v95; // [esp+124h] [ebp-34h]
  int v96; // [esp+128h] [ebp-30h]
  int v97; // [esp+12Ch] [ebp-2Ch]
  int v98; // [esp+130h] [ebp-28h]
  int v99; // [esp+134h] [ebp-24h]
  int v100; // [esp+138h] [ebp-20h]
  int v101; // [esp+13Ch] [ebp-1Ch]
  int v102; // [esp+140h] [ebp-18h]
  int v103; // [esp+144h] [ebp-14h]
  int v104; // [esp+148h] [ebp-10h]
  int v105; // [esp+14Ch] [ebp-Ch]
  int v106; // [esp+150h] [ebp-8h]
  int v107; // [esp+154h] [ebp-4h]

  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 64;
  v74 = 40;
  v75 = 112;
  v76 = 40;
  v77 = 64;
  v78 = 80;
  v79 = 112;
  v80 = 80;
  v81 = 64;
  v82 = 120;
  v83 = 112;
  v84 = 120;
  v85 = 64;
  v86 = 160;
  v87 = 112;
  v88 = 160;
  v89 = 64;
  v90 = 200;
  v91 = 112;
  v92 = 200;
  v93 = 64;
  v94 = 240;
  v95 = 112;
  v96 = 240;
  v97 = 64;
  v98 = 280;
  v99 = 112;
  v100 = 280;
  v101 = 64;
  v102 = 320;
  v103 = 112;
  v104 = 0;
  v105 = 160;
  v106 = 40;
  v107 = 208;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 112;
  v31 = 40;
  v32 = 160;
  v33 = 40;
  v34 = 112;
  v35 = 80;
  v36 = 160;
  v37 = 80;
  v38 = 112;
  v39 = 120;
  v40 = 160;
  v41 = 120;
  v42 = 112;
  v43 = 160;
  v44 = 160;
  v45 = 160;
  v46 = 112;
  v47 = 200;
  v48 = 160;
  v49 = 200;
  v50 = 112;
  v51 = 240;
  v52 = 160;
  v53 = 240;
  v54 = 112;
  v55 = 280;
  v56 = 160;
  v57 = 280;
  v58 = 112;
  v59 = 320;
  v60 = 160;
  v61 = 40;
  v62 = 160;
  v63 = 80;
  v64 = 208;
  v24 = npc->currentState;
  if ( v24 <= 100 )
  {
    if ( v24 != 100 )
    {
      switch ( v24 )
      {
        case 0:
          if ( superYPos <= quote.XPos )
            npc->direction = 2;
          else
            npc->direction = 0;
          if ( npc->direction )
            npc->XPos = superYPos + 3072;
          else
            npc->XPos = superYPos - 3072;
          npc->YPos = curlyShootY;
          goto LABEL_24;
        case 1:
LABEL_24:
          npc->currentState = 2;
          goto LABEL_25;
        case 2:
LABEL_25:
          npc->YVel += 128;
          if ( ++npc->waitTimer / 2 % 2 )
            npc->animationNumber = 0;
          else
            npc->animationNumber = 3;
          goto LABEL_176;
        case 5:
          npc->currentState = 6;
          npc->animationNumber = 1;
          npc->animationTimer = 0;
          goto LABEL_30;
        case 6:
LABEL_30:
          npc->YVel += 128;
          if ( ++npc->animationTimer > 40 )
          {
            npc->animationTimer = 0;
            ++npc->animationNumber;
          }
          if ( npc->animationNumber > 2 )
            npc->animationNumber = 1;
          goto LABEL_176;
        case 7:
          npc->currentState = 8;
          npc->waitTimer = 0;
          npc->animationNumber = 3;
          goto LABEL_36;
        case 8:
LABEL_36:
          npc->YVel += 64;
          if ( ++npc->waitTimer > 40 )
            npc->currentState = 10;
          goto LABEL_176;
        case 10:
          npc->entityFlags |= 4u;
          npc->XVel = 0;
          npc->currentState = 11;
          npc->waitTimer = 0;
          npc->animationNumber = 1;
          npc->animationTimer = 0;
          npc->count2 = npc->life;
          goto LABEL_40;
        case 11:
LABEL_40:
          npc->YVel += 128;
          if ( npc->XPos <= quote.XPos )
            npc->direction = 2;
          else
            npc->direction = 0;
          if ( npc->collisionFlags & 8 )
          {
            if ( npc->life >= npc->count2 - 20 )
            {
              if ( ++npc->animationTimer > 10 )
              {
                npc->animationTimer = 0;
                if ( ++npc->animationNumber > 2 )
                  npc->animationNumber = 1;
              }
            }
            else if ( quote.collisionFlags & 8
                   && quote.XPos > npc->XPos - 24576
                   && quote.XPos < npc->XPos + 24576
                   && npc->animationNumber != 6 )
            {
              npc->animationNumber = 6;
              damagePlayer(5);
              setQuake(10);
              playSoundEffect(SFXLargeObjectHitGround, 1);
              quote.YVel = -1024;
              if ( npc->XPos <= quote.XPos )
                quote.XVel = 1535;
              else
                quote.XVel = -1535;
              for ( i = 0; i < 100; ++i )
              {
                v1 = 3 * random(-512, 512);
                v2 = 3 * random(-512, 512);
                v3 = npc->YPos + (random(-16, 16) << 9);
                v4 = random(-16, 16);
                createNPC(NPCSantasKey|0x100, npc->XPos + (v4 << 9), v3, v2, v1, down, 0, 170);
              }
            }
          }
          else
          {
            npc->animationNumber = 4;
          }
          if ( ++npc->waitTimer > 30 || npc->life < npc->count2 - 20 )
          {
            if ( ++npc->count1 > 10 )
              npc->count1 = 0;
            switch ( npc->count1 )
            {
              case 1:
              case 9:
                npc->currentState = 40;
                break;
              case 2:
              case 7:
                npc->currentState = 100;
                break;
              case 3:
              case 6:
                npc->currentState = 30;
                break;
              case 8:
                npc->currentState = 20;
                break;
              default:
                npc->currentState = 15;
                npc->waitTimer = 0;
                break;
            }
          }
          goto LABEL_176;
        case 15:
          npc->animationNumber = 3;
          ++npc->waitTimer;
          if ( npc->XPos <= quote.XPos )
            npc->direction = 2;
          else
            npc->direction = 0;
          if ( npc->waitTimer > 20 )
          {
            npc->currentState = 16;
            npc->animationNumber = 4;
            npc->animationTimer = 0;
            npc->YVel = -1536;
            if ( npc->direction )
              npc->XVel = 1024;
            else
              npc->XVel = -1024;
          }
          goto LABEL_176;
        case 16:
          npc->YVel += 64;
          if ( ++npc->animationTimer > 1 )
          {
            npc->animationTimer = 0;
            ++npc->animationNumber;
          }
          if ( npc->animationNumber > 5 )
            npc->animationNumber = 4;
          if ( npc->XPos <= quote.XPos )
            npc->direction = 2;
          else
            npc->direction = 0;
          if ( npc->YVel > 0 && npc->collisionFlags & 8 )
            npc->currentState = 17;
          goto LABEL_176;
        case 17:
          npc->currentState = 18;
          npc->waitTimer = 0;
          setQuake(10);
          playSoundEffect(SFXLargeObjectHitGround, 1);
          goto LABEL_92;
        case 18:
LABEL_92:
          npc->animationNumber = 3;
          ++npc->waitTimer;
          npc->XVel = 7 * npc->XVel / 8;
          npc->YVel += 128;
          if ( npc->waitTimer > 10 )
            npc->currentState = 10;
          goto LABEL_176;
        case 20:
          npc->currentState = 21;
          npc->waitTimer = 0;
          goto LABEL_96;
        case 21:
LABEL_96:
          ++npc->waitTimer;
          npc->animationNumber = 6;
          if ( npc->waitTimer > 20 && npc->waitTimer % 3 == 1 )
          {
            Y_Vel = random(-512, 512);
            X_Vel = 4 * random(256, 512);
            if ( npc->direction )
              createNPC(NPCForcefield|0x100, npc->XPos + 4096, npc->YPos - 2048, X_Vel, Y_Vel, right, 0, 256);
            else
              createNPC(NPCForcefield|0x100, npc->XPos - 4096, npc->YPos - 2048, -X_Vel, Y_Vel, 0, 0, 256);
            playSoundEffect(SFXEnemyShootProjectile, 1);
          }
          if ( npc->waitTimer > 90 )
            npc->currentState = 10;
          goto LABEL_176;
        case 30:
          npc->currentState = 31;
          npc->waitTimer = 0;
          npc->entityFlags |= 1u;
          npc->entityFlags &= 0xFFDFu;
          goto LABEL_106;
        case 31:
LABEL_106:
          npc->animationNumber = 3;
          if ( ++npc->waitTimer > 20 )
          {
            npc->currentState = 32;
            npc->waitTimer = 0;
            npc->animationNumber = 7;
            npc->entityFlags |= 0x80u;
            npc->damage = 10;
            playSoundEffect(SFXSillyExplosion, 1);
            if ( npc->direction )
              npc->XVel = 1535;
            else
              npc->XVel = -1535;
          }
          break;
        case 32:
          ++npc->waitTimer;
          npc->YVel = 0;
          if ( npc->waitTimer / 2 % 2 )
            npc->animationNumber = 7;
          else
            npc->animationNumber = 8;
          if ( npc->waitTimer > 30 )
          {
            npc->waitTimer = 0;
            npc->currentState = 18;
            npc->damage = 5;
            npc->entityFlags &= 0xFF7Eu;
            npc->entityFlags |= 0x20u;
          }
          if ( npc->collisionFlags & 1 || npc->collisionFlags & 4 )
          {
            npc->currentState = 15;
            npc->waitTimer = 0;
            npc->damage = 5;
            npc->entityFlags &= 0xFF7Eu;
            npc->entityFlags |= 0x20u;
          }
          break;
        case 40:
          npc->animationNumber = 3;
          ++npc->waitTimer;
          if ( npc->XPos <= quote.XPos )
            npc->direction = 2;
          else
            npc->direction = 0;
          if ( npc->waitTimer > 20 )
          {
            npc->currentState = 41;
            npc->animationNumber = 4;
            npc->animationTimer = 0;
            npc->YVel = -2048;
            if ( npc->direction )
              npc->XVel = 1024;
            else
              npc->XVel = -1024;
          }
          break;
        case 41:
          npc->YVel += 64;
          if ( ++npc->animationTimer > 1 )
          {
            npc->animationTimer = 0;
            ++npc->animationNumber;
          }
          if ( npc->animationNumber > 5 )
            npc->animationNumber = 4;
          if ( quote.YPos > npc->YPos && quote.XPos > npc->XPos - 4096 && quote.XPos < npc->XPos + 4096 )
          {
            npc->currentState = 16;
            npc->YVel = 1535;
            npc->XVel = 0;
          }
          if ( npc->YVel > 0 && npc->collisionFlags & 8 )
            npc->currentState = 17;
          break;
        default:
          goto LABEL_176;
      }
      goto LABEL_176;
    }
    npc->currentState = 101;
    npc->waitTimer = 0;
    npc->entityFlags &= 0xFFDBu;
    npc->damage = 0;
    playSoundEffect(SFXTeleport, 1);
    goto LABEL_141;
  }
  if ( v24 > 501 )
  {
    if ( v24 == 510 )
    {
      npc->currentState = 511;
      npc->waitTimer = 0;
      npc->animationNumber = 9;
      npc->curlyTargetX = npc->XPos;
      npc->YPos += 0x2000;
      npc->entityFlags |= 8u;
    }
    else if ( v24 != 511 )
    {
      if ( v24 == 520 )
      {
        npc->damage = 0;
        curlyShootY = -16384;
      }
      goto LABEL_176;
    }
    setQuake(2);
    if ( ++npc->waitTimer % 6 == 3 )
      playSoundEffect(SFXSillyExplosion, 1);
    if ( npc->waitTimer / 2 % 2 )
      npc->XPos = npc->curlyTargetX;
    else
      npc->XPos = npc->curlyTargetX + 512;
    if ( npc->waitTimer > 352 )
    {
      npc->animationNumber = 0;
      npc->currentState = 512;
    }
  }
  else
  {
    if ( v24 == 501 )
    {
      npc->animationNumber = 9;
      if ( ++npc->waitTimer / 2 % 2 )
        npc->XPos = npc->curlyTargetX;
      else
        npc->XPos = npc->curlyTargetX + 512;
      goto LABEL_176;
    }
    if ( v24 > 103 )
    {
      if ( v24 == 500 )
      {
        killNPC(269, 1);
        npc->entityFlags &= 0xFFDFu;
        npc->animationNumber = 4;
        npc->YVel += 32;
        npc->XVel = 0;
        if ( npc->collisionFlags & 8 )
        {
          npc->currentState = 501;
          npc->waitTimer = 0;
          npc->curlyTargetX = npc->XPos;
          if ( npc->XPos <= quote.XPos )
            npc->direction = 2;
          else
            npc->direction = 0;
        }
      }
    }
    else if ( v24 == 103 )
    {
      npc->waitTimer -= 2;
      if ( npc->waitTimer <= 0 )
      {
        npc->entityFlags |= 0x24u;
        npc->damage = 5;
        npc->currentState = 16;
        npc->YVel = -512;
        npc->XVel = 0;
      }
    }
    else
    {
      if ( v24 == 101 )
      {
LABEL_141:
        npc->waitTimer += 2;
        if ( npc->waitTimer > 28 )
        {
          npc->currentState = 102;
          npc->waitTimer = 0;
          npc->animationNumber = 0;
          npc->curlyTargetX = quote.XPos;
          npc->curlyTargetY = quote.YPos - 0x4000;
          if ( npc->curlyTargetY < 0x8000 )
            npc->curlyTargetY = 0x8000;
          if ( npc->curlyTargetX < 0x8000 )
            npc->curlyTargetX = 0x8000;
          if ( npc->curlyTargetX > 294912 )
            npc->curlyTargetX = 294912;
        }
        goto LABEL_176;
      }
      if ( v24 == 102 && ++npc->waitTimer > 40 )
      {
        npc->currentState = 103;
        npc->waitTimer = 28;
        npc->animationNumber = 4;
        npc->YVel = 0;
        npc->XPos = npc->curlyTargetX;
        npc->YPos = npc->curlyTargetY;
        if ( npc->XPos <= quote.XPos )
          npc->direction = 2;
        else
          npc->direction = 0;
      }
    }
  }
LABEL_176:
  if ( npc->currentState >= 11 && npc->currentState < 501 )
  {
    if ( npc->currentState == 102 )
    {
      superYPos = npc->curlyTargetX;
      curlyShootY = npc->curlyTargetY;
    }
    else
    {
      superYPos = npc->XPos;
      curlyShootY = npc->YPos;
    }
  }
  if ( npc->YVel > 1535 )
    npc->YVel = 1535;
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  if ( npc->currentState < 512 )
  {
    if ( npc->currentState >= 510 )
    {
      v8 = 2 * random(-512, 0);
      v9 = random(-512, 512);
      v10 = npc->YPos - ((336 - npc->waitTimer) / 8 << 9);
      v11 = random(-16, 16);
      createNPC(NPCSantasKey|0x100, npc->XPos + (v11 << 9), v10, v9, v8, down, 0, 170);
      v12 = 2 * random(-512, 0);
      v13 = random(-512, 512);
      v14 = npc->YPos - ((336 - npc->waitTimer) / 8 << 9);
      v15 = random(-16, 16);
      createNPC(NPCSantasKey|0x100, npc->XPos + (v15 << 9), v14, v13, v12, down, 0, 170);
      v16 = 2 * random(-512, 0);
      v17 = npc->YPos - ((336 - npc->waitTimer) / 8 << 9);
      v18 = random(-16, 16);
      createNPC(NPCSantasKey|0x100, npc->XPos + (v18 << 9), v17, 0, v16, down, 0, 170);
      v19 = 2 * random(-512, 0);
      v20 = npc->YPos - ((336 - npc->waitTimer) / 8 << 9);
      v21 = random(-16, 16);
      createNPC(NPCSantasKey|0x100, npc->XPos + (v21 << 9), v20, 0, v19, down, 0, 170);
    }
    else if ( npc->currentState != 102 && npc->currentState != 103 && random(0, 3) == 2 )
    {
      v5 = npc->XVel;
      v6 = npc->YPos + (random(-8, 4) << 9);
      v7 = random(-16, 16);
      createNPC(NPCSantasKey|0x100, npc->XPos + (v7 << 9), v6, v5, 0, down, 0, 256);
    }
  }
  if ( npc->direction )
    v22 = &v25 + 4 * npc->animationNumber;
  else
    v22 = &v68 + 4 * npc->animationNumber;
  v23 = &npc->rect;
  v23->left = *v22;
  v23->top = v22[1];
  v23->right = v22[2];
  v23->bottom = v22[3];
  if ( npc->currentState == 511 )
  {
    npc->rect.top += npc->waitTimer / 8;
    npc->view.top = (44 - npc->waitTimer / 8) << 9;
    npc->view.bottom = 2048;
  }
  else if ( npc->currentState != 101 && npc->currentState != 103 )
  {
    npc->view.top = 14336;
  }
  else
  {
    npc->rect.top += npc->waitTimer;
    npc->rect.bottom -= npc->waitTimer;
    npc->view.top = (28 - npc->waitTimer) << 9;
  }
}
// 4BBA28: using guessed type int curlyShootY;
// 4BBA30: using guessed type int superYPos;

//----- (0045B3D0) --------------------------------------------------------
int __cdecl NPC268(int a1)
{
  int Y_Vel; // ST24_4
  int *v2; // ecx
  int *v3; // edx
  int result; // eax
  int v5; // [esp+8h] [ebp-150h]
  int v6; // [esp+Ch] [ebp-14Ch]
  int v7; // [esp+10h] [ebp-148h]
  int v8; // [esp+14h] [ebp-144h]
  int v9; // [esp+18h] [ebp-140h]
  int v10; // [esp+1Ch] [ebp-13Ch]
  int v11; // [esp+20h] [ebp-138h]
  int v12; // [esp+24h] [ebp-134h]
  int v13; // [esp+28h] [ebp-130h]
  int v14; // [esp+2Ch] [ebp-12Ch]
  int v15; // [esp+30h] [ebp-128h]
  int v16; // [esp+34h] [ebp-124h]
  int v17; // [esp+38h] [ebp-120h]
  int v18; // [esp+3Ch] [ebp-11Ch]
  int v19; // [esp+40h] [ebp-118h]
  int v20; // [esp+44h] [ebp-114h]
  int v21; // [esp+48h] [ebp-110h]
  int v22; // [esp+4Ch] [ebp-10Ch]
  int v23; // [esp+50h] [ebp-108h]
  int v24; // [esp+54h] [ebp-104h]
  int v25; // [esp+58h] [ebp-100h]
  int v26; // [esp+5Ch] [ebp-FCh]
  int v27; // [esp+60h] [ebp-F8h]
  int v28; // [esp+64h] [ebp-F4h]
  int v29; // [esp+68h] [ebp-F0h]
  int v30; // [esp+6Ch] [ebp-ECh]
  int v31; // [esp+70h] [ebp-E8h]
  int v32; // [esp+74h] [ebp-E4h]
  int v33; // [esp+78h] [ebp-E0h]
  int v34; // [esp+7Ch] [ebp-DCh]
  int v35; // [esp+80h] [ebp-D8h]
  int v36; // [esp+84h] [ebp-D4h]
  int v37; // [esp+88h] [ebp-D0h]
  int v38; // [esp+8Ch] [ebp-CCh]
  int v39; // [esp+90h] [ebp-C8h]
  int v40; // [esp+94h] [ebp-C4h]
  int v41; // [esp+98h] [ebp-C0h]
  int v42; // [esp+9Ch] [ebp-BCh]
  int v43; // [esp+A0h] [ebp-B8h]
  int v44; // [esp+A4h] [ebp-B4h]
  int X_Vel; // [esp+ACh] [ebp-ACh]
  int v46; // [esp+B0h] [ebp-A8h]
  int v47; // [esp+B4h] [ebp-A4h]
  int v48; // [esp+B8h] [ebp-A0h]
  int v49; // [esp+BCh] [ebp-9Ch]
  int v50; // [esp+C0h] [ebp-98h]
  int v51; // [esp+C4h] [ebp-94h]
  int v52; // [esp+C8h] [ebp-90h]
  int v53; // [esp+CCh] [ebp-8Ch]
  int v54; // [esp+D0h] [ebp-88h]
  int v55; // [esp+D4h] [ebp-84h]
  int v56; // [esp+D8h] [ebp-80h]
  int v57; // [esp+DCh] [ebp-7Ch]
  int v58; // [esp+E0h] [ebp-78h]
  int v59; // [esp+E4h] [ebp-74h]
  int v60; // [esp+E8h] [ebp-70h]
  int v61; // [esp+ECh] [ebp-6Ch]
  int v62; // [esp+F0h] [ebp-68h]
  int v63; // [esp+F4h] [ebp-64h]
  int v64; // [esp+F8h] [ebp-60h]
  int v65; // [esp+FCh] [ebp-5Ch]
  int v66; // [esp+100h] [ebp-58h]
  int v67; // [esp+104h] [ebp-54h]
  int v68; // [esp+108h] [ebp-50h]
  int v69; // [esp+10Ch] [ebp-4Ch]
  int v70; // [esp+110h] [ebp-48h]
  int v71; // [esp+114h] [ebp-44h]
  int v72; // [esp+118h] [ebp-40h]
  int v73; // [esp+11Ch] [ebp-3Ch]
  int v74; // [esp+120h] [ebp-38h]
  int v75; // [esp+124h] [ebp-34h]
  int v76; // [esp+128h] [ebp-30h]
  int v77; // [esp+12Ch] [ebp-2Ch]
  int v78; // [esp+130h] [ebp-28h]
  int v79; // [esp+134h] [ebp-24h]
  int v80; // [esp+138h] [ebp-20h]
  int v81; // [esp+13Ch] [ebp-1Ch]
  int v82; // [esp+140h] [ebp-18h]
  int v83; // [esp+144h] [ebp-14h]
  int v84; // [esp+148h] [ebp-10h]
  int v85; // [esp+14Ch] [ebp-Ch]
  unsigned __int8 v86; // [esp+157h] [ebp-1h]

  v46 = 0;
  v47 = 0;
  v48 = 40;
  v49 = 40;
  v50 = 40;
  v51 = 0;
  v52 = 80;
  v53 = 40;
  v54 = 80;
  v55 = 0;
  v56 = 120;
  v57 = 40;
  v58 = 0;
  v59 = 0;
  v60 = 40;
  v61 = 40;
  v62 = 120;
  v63 = 0;
  v64 = 160;
  v65 = 40;
  v66 = 0;
  v67 = 0;
  v68 = 40;
  v69 = 40;
  v70 = 40;
  v71 = 80;
  v72 = 80;
  v73 = 120;
  v74 = 0;
  v75 = 80;
  v76 = 40;
  v77 = 120;
  v78 = 240;
  v79 = 0;
  v80 = 280;
  v81 = 40;
  v82 = 280;
  v83 = 0;
  v84 = 320;
  v85 = 40;
  v5 = 0;
  v6 = 40;
  v7 = 40;
  v8 = 80;
  v9 = 40;
  v10 = 40;
  v11 = 80;
  v12 = 80;
  v13 = 80;
  v14 = 40;
  v15 = 120;
  v16 = 80;
  v17 = 0;
  v18 = 40;
  v19 = 40;
  v20 = 80;
  v21 = 120;
  v22 = 40;
  v23 = 160;
  v24 = 80;
  v25 = 0;
  v26 = 40;
  v27 = 40;
  v28 = 80;
  v29 = 160;
  v30 = 80;
  v31 = 200;
  v32 = 120;
  v33 = 120;
  v34 = 80;
  v35 = 160;
  v36 = 120;
  v37 = 240;
  v38 = 40;
  v39 = 280;
  v40 = 80;
  v41 = 280;
  v42 = 40;
  v43 = 320;
  v44 = 80;
  if ( *(_DWORD *)(a1 + 8) < quote.XPos - 163840
    || *(_DWORD *)(a1 + 8) > quote.XPos + 163840
    || *(_DWORD *)(a1 + 12) < quote.YPos - 122880
    || *(_DWORD *)(a1 + 12) > quote.YPos + 122880 )
  {
    *(_DWORD *)(a1 + 116) = 1;
  }
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 12) += 4096;
      goto LABEL_8;
    case 1:
LABEL_8:
      if ( ++*(_DWORD *)(a1 + 100) > 20 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 1 )
        *(_DWORD *)(a1 + 104) = 0;
      if ( *(_DWORD *)(a1 + 8) < quote.XPos + 57344
        && *(_DWORD *)(a1 + 8) > quote.XPos - 57344
        && *(_DWORD *)(a1 + 8) < quote.XPos + 24576
        && *(_DWORD *)(a1 + 8) > quote.XPos - 57344 )
      {
        *(_DWORD *)(a1 + 116) = 10;
      }
      if ( *(_BYTE *)(a1 + 156) )
        *(_DWORD *)(a1 + 116) = 10;
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      if ( quote.XPos >= *(_DWORD *)(a1 + 8) )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      goto LABEL_23;
    case 0xB:
LABEL_23:
      if ( *(_DWORD *)(a1 + 76) )
        *(_DWORD *)(a1 + 16) = 512;
      else
        *(_DWORD *)(a1 + 16) = -512;
      if ( *(_DWORD *)(a1 + 8) < quote.XPos + 0x8000 && *(_DWORD *)(a1 + 8) > quote.XPos - 0x8000 )
      {
        *(_DWORD *)(a1 + 116) = 20;
        *(_DWORD *)(a1 + 120) = 0;
      }
      if ( *(_DWORD *)(a1 + 16) < 0 && *(_DWORD *)(a1 + 4) & 1 )
      {
        *(_DWORD *)(a1 + 116) = 20;
        *(_DWORD *)(a1 + 120) = 0;
      }
      if ( *(_DWORD *)(a1 + 16) > 0 && *(_DWORD *)(a1 + 4) & 4 )
      {
        *(_DWORD *)(a1 + 116) = 20;
        *(_DWORD *)(a1 + 120) = 0;
      }
      if ( ++*(_DWORD *)(a1 + 100) > 4 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 5 )
        *(_DWORD *)(a1 + 104) = 2;
      break;
    case 0x14:
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 104) = 6;
      if ( ++*(_DWORD *)(a1 + 120) > 10 )
      {
        *(_DWORD *)(a1 + 116) = 30;
        *(_DWORD *)(a1 + 20) = -1535;
        if ( *(_DWORD *)(a1 + 76) )
          *(_DWORD *)(a1 + 16) = 512;
        else
          *(_DWORD *)(a1 + 16) = -512;
        playSoundEffect(SFXPowerCritterLargeEnemyJump, 1);
      }
      break;
    case 0x1E:
      *(_DWORD *)(a1 + 104) = 7;
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 116) = 40;
        *(_DWORD *)(a1 + 120) = 0;
        setQuake(20);
        playSoundEffect(SFXLargeObjectHitGround, 1);
      }
      break;
    case 0x28:
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 104) = 6;
      if ( ++*(_DWORD *)(a1 + 120) > 30 )
        *(_DWORD *)(a1 + 116) = 50;
      break;
    case 0x32:
      *(_DWORD *)(a1 + 116) = 51;
      *(_DWORD *)(a1 + 120) = 0;
      if ( quote.XPos >= *(_DWORD *)(a1 + 8) )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      goto LABEL_55;
    case 0x33:
LABEL_55:
      if ( ++*(_DWORD *)(a1 + 120) > 30 && *(_DWORD *)(a1 + 120) % 4 == 1 )
      {
        if ( *(_DWORD *)(a1 + 76) )
          v86 = -8;
        else
          v86 = -120;
        v86 += random(-16, 16);
        Y_Vel = 5 * getSin(v86);
        X_Vel = 5 * getCos(v86);
        createNPC(
          NPCProjectileBalrogEnemyBounce,
          *(_DWORD *)(a1 + 8),
          *(_DWORD *)(a1 + 12) + 2048,
          X_Vel,
          Y_Vel,
          0,
          0,
          256);
        playSoundEffect(SFXDestroyBreakableBlock, 1);
      }
      if ( *(_DWORD *)(a1 + 120) < 50 && *(_DWORD *)(a1 + 120) / 2 % 2 )
        *(_DWORD *)(a1 + 104) = 9;
      else
        *(_DWORD *)(a1 + 104) = 8;
      if ( *(_DWORD *)(a1 + 120) > 82 )
      {
        *(_DWORD *)(a1 + 116) = 10;
        if ( quote.XPos >= *(_DWORD *)(a1 + 8) )
          *(_DWORD *)(a1 + 76) = 2;
        else
          *(_DWORD *)(a1 + 76) = 0;
      }
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 20) += 51;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v2 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  else
    v2 = &v46 + 4 * *(_DWORD *)(a1 + 104);
  v3 = (int *)(a1 + 84);
  *v3 = *v2;
  v3[1] = v2[1];
  result = v2[2];
  v3[2] = result;
  v3[3] = v2[3];
  return result;
}

//----- (0045BCB0) --------------------------------------------------------
int *__cdecl NPC269(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+0h] [ebp-64h]
  int v4; // [esp+4h] [ebp-60h]
  int v5; // [esp+8h] [ebp-5Ch]
  int v6; // [esp+Ch] [ebp-58h]
  int v7; // [esp+10h] [ebp-54h]
  int v8; // [esp+14h] [ebp-50h]
  int v9; // [esp+18h] [ebp-4Ch]
  int v10; // [esp+1Ch] [ebp-48h]
  int v11; // [esp+20h] [ebp-44h]
  int v12; // [esp+24h] [ebp-40h]
  int v13; // [esp+28h] [ebp-3Ch]
  int v14; // [esp+2Ch] [ebp-38h]
  int v15; // [esp+30h] [ebp-34h]
  int v16; // [esp+34h] [ebp-30h]
  int v17; // [esp+38h] [ebp-2Ch]
  int v18; // [esp+3Ch] [ebp-28h]
  int v19; // [esp+40h] [ebp-24h]
  int v20; // [esp+44h] [ebp-20h]
  int v21; // [esp+48h] [ebp-1Ch]
  int v22; // [esp+4Ch] [ebp-18h]
  int v23; // [esp+50h] [ebp-14h]
  int v24; // [esp+54h] [ebp-10h]
  int v25; // [esp+58h] [ebp-Ch]
  int v26; // [esp+5Ch] [ebp-8h]
  int v27; // [esp+60h] [ebp-4h]

  v16 = 232;
  v17 = 0;
  v18 = 248;
  v19 = 16;
  v20 = 248;
  v21 = 0;
  v22 = 264;
  v23 = 16;
  v24 = 248;
  v25 = 16;
  v26 = 264;
  v27 = 32;
  v4 = 232;
  v5 = 32;
  v6 = 248;
  v7 = 48;
  v8 = 248;
  v9 = 32;
  v10 = 264;
  v11 = 48;
  v12 = 248;
  v13 = 48;
  v14 = 264;
  v15 = 64;
  v3 = *(_DWORD *)(a1 + 116);
  if ( v3 )
  {
    if ( v3 != 1 )
      goto LABEL_21;
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 20);
  }
  if ( *(_DWORD *)(a1 + 24) < 0 && *(_DWORD *)(a1 + 4) & 1 )
  {
    *(_DWORD *)(a1 + 76) = 2;
    *(_DWORD *)(a1 + 24) = -*(_DWORD *)(a1 + 24);
  }
  else if ( *(_DWORD *)(a1 + 24) > 0 && *(_DWORD *)(a1 + 4) & 4 )
  {
    *(_DWORD *)(a1 + 76) = 0;
    *(_DWORD *)(a1 + 24) = -*(_DWORD *)(a1 + 24);
  }
  else if ( *(_DWORD *)(a1 + 28) < 0 && *(_DWORD *)(a1 + 4) & 2 )
  {
    *(_DWORD *)(a1 + 28) = -*(_DWORD *)(a1 + 28);
  }
  else if ( *(_DWORD *)(a1 + 28) > 0 && *(_DWORD *)(a1 + 4) & 8 )
  {
    *(_DWORD *)(a1 + 28) = -*(_DWORD *)(a1 + 28);
  }
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 28);
  if ( ++*(_DWORD *)(a1 + 100) > 2 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 2 )
    *(_DWORD *)(a1 + 104) = 0;
LABEL_21:
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v16 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (0045BF10) --------------------------------------------------------
int *__cdecl NPC270(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+4h] [ebp-20h]
  int v4; // [esp+8h] [ebp-1Ch]
  int v5; // [esp+Ch] [ebp-18h]
  int v6; // [esp+10h] [ebp-14h]
  int v7; // [esp+14h] [ebp-10h]
  int v8; // [esp+18h] [ebp-Ch]
  int v9; // [esp+1Ch] [ebp-8h]
  int v10; // [esp+20h] [ebp-4h]

  v3 = 170;
  v4 = 34;
  v5 = 174;
  v6 = 38;
  v7 = 170;
  v8 = 42;
  v9 = 174;
  v10 = 46;
  if ( *(_DWORD *)(a1 + 76) != 3 && *(_DWORD *)(a1 + 76) != 1 )
  {
    if ( *(_DWORD *)(a1 + 76) == 2 )
    {
      if ( !*(_DWORD *)(a1 + 116) )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_WORD *)(a1 + 80) |= 8u;
        *(_DWORD *)(a1 + 16) = 3 * random(-512, 512);
        *(_DWORD *)(a1 + 20) = 3 * random(-512, 512);
        *(_DWORD *)(a1 + 108) = random(16, 51);
        *(_DWORD *)(a1 + 112) = random(128, 256);
      }
      if ( *(_DWORD *)(a1 + 8) < *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) )
        *(_DWORD *)(a1 + 16) += 512 / *(_DWORD *)(a1 + 108);
      if ( *(_DWORD *)(a1 + 8) > *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) )
        *(_DWORD *)(a1 + 16) -= 512 / *(_DWORD *)(a1 + 108);
      if ( *(_DWORD *)(a1 + 12) < *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12) )
        *(_DWORD *)(a1 + 20) += 512 / *(_DWORD *)(a1 + 108);
      if ( *(_DWORD *)(a1 + 12) > *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12) )
        *(_DWORD *)(a1 + 20) -= 512 / *(_DWORD *)(a1 + 108);
      if ( *(_DWORD *)(a1 + 16) > 2 * *(_DWORD *)(a1 + 112) )
        *(_DWORD *)(a1 + 16) = 2 * *(_DWORD *)(a1 + 112);
      if ( *(_DWORD *)(a1 + 16) < -2 * *(_DWORD *)(a1 + 112) )
        *(_DWORD *)(a1 + 16) = -2 * *(_DWORD *)(a1 + 112);
      if ( *(_DWORD *)(a1 + 20) > 3 * *(_DWORD *)(a1 + 112) )
        *(_DWORD *)(a1 + 20) = 3 * *(_DWORD *)(a1 + 112);
      if ( *(_DWORD *)(a1 + 20) < -3 * *(_DWORD *)(a1 + 112) )
        *(_DWORD *)(a1 + 20) = -3 * *(_DWORD *)(a1 + 112);
      *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
    }
  }
  else
  {
    if ( *(_DWORD *)(a1 + 76) == 3 )
      *(_DWORD *)(a1 + 20) += 64;
    if ( *(_DWORD *)(a1 + 76) == 1 )
      *(_DWORD *)(a1 + 20) -= 64;
    ++*(_DWORD *)(a1 + 120);
    if ( *(_DWORD *)(a1 + 20) > 1535 )
      *(_DWORD *)(a1 + 20) = 1535;
    *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
    if ( *(_DWORD *)(a1 + 120) > 50 )
      *(_BYTE *)a1 = 0;
    if ( *(_DWORD *)(a1 + 4) & 0xFF )
      *(_BYTE *)a1 = 0;
  }
  v1 = &v3 + 4 * random(0, 1);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (0045C230) --------------------------------------------------------
void __cdecl NPC271(void *a1)
{
  int v1; // [esp+0h] [ebp-4h]

  if ( *((_DWORD *)a1 + 4) >= 0 || *((_DWORD *)a1 + 2) >= -8192 )
  {
    if ( *((_DWORD *)a1 + 4) <= 0 || *((_DWORD *)a1 + 2) <= (currentMap.width << 13) + 0x2000 )
    {
      if ( !*((_DWORD *)a1 + 29) )
      {
        *((_DWORD *)a1 + 29) = 1;
        v1 = random(0, 9);
        if ( v1 == 9 )
        {
          *((_DWORD *)a1 + 21) = 0;
          *((_DWORD *)a1 + 23) = 32;
          *((_DWORD *)a1 + 22) = 64;
          *((_DWORD *)a1 + 24) = 96;
          *((_DWORD *)a1 + 35) = 0x2000;
          *((_DWORD *)a1 + 37) = 0x2000;
          *((_DWORD *)a1 + 36) = 0x2000;
          *((_DWORD *)a1 + 38) = 0x2000;
          *((_DWORD *)a1 + 31) = 6144;
          *((_DWORD *)a1 + 33) = 6144;
          *((_DWORD *)a1 + 32) = 6144;
          *((_DWORD *)a1 + 34) = 6144;
        }
        else
        {
          *((_DWORD *)a1 + 21) = 16 * (v1 % 3) + 112;
          *((_DWORD *)a1 + 22) = 16 * (v1 / 3);
          *((_DWORD *)a1 + 23) = *((_DWORD *)a1 + 21) + 16;
          *((_DWORD *)a1 + 24) = *((_DWORD *)a1 + 22) + 16;
        }
        if ( *((_DWORD *)a1 + 19) )
          *((_DWORD *)a1 + 4) = 2 * random(256, 512);
        else
          *((_DWORD *)a1 + 4) = -2 * random(256, 512);
        *((_DWORD *)a1 + 5) = random(-512, 512);
      }
      if ( *((_DWORD *)a1 + 5) < 0 && *((_DWORD *)a1 + 3) - *((_DWORD *)a1 + 32) < 4096 )
      {
        *((_DWORD *)a1 + 5) = -*((_DWORD *)a1 + 5);
        createEffect(*((_DWORD *)a1 + 2), *((_DWORD *)a1 + 3) - 4096, effectUnknownUnused, 0);
        createEffect(*((_DWORD *)a1 + 2), *((_DWORD *)a1 + 3) - 4096, effectUnknownUnused, 0);
      }
      if ( *((_DWORD *)a1 + 5) > 0 && *((_DWORD *)a1 + 34) + *((_DWORD *)a1 + 3) > 118784 )
      {
        *((_DWORD *)a1 + 5) = -*((_DWORD *)a1 + 5);
        createEffect(*((_DWORD *)a1 + 2), *((_DWORD *)a1 + 3) + 4096, effectUnknownUnused, 0);
        createEffect(*((_DWORD *)a1 + 2), *((_DWORD *)a1 + 3) + 4096, effectUnknownUnused, 0);
      }
      *((_DWORD *)a1 + 2) += *((_DWORD *)a1 + 4);
      *((_DWORD *)a1 + 3) += *((_DWORD *)a1 + 5);
    }
    else
    {
      Vanish_NPC((NPC *)a1);
    }
  }
  else
  {
    Vanish_NPC((NPC *)a1);
  }
}

//----- (0045C500) --------------------------------------------------------
void __cdecl NPC272(int a1)
{
  Directions v1; // ST14_4
  int v2; // eax
  int v3; // [esp+0h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 116);
  if ( v3 )
  {
    if ( v3 != 1 )
      return;
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 120) = random(0, 200);
  }
  if ( *(_DWORD *)(a1 + 120) )
  {
    --*(_DWORD *)(a1 + 120);
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 0;
    v1 = *(_DWORD *)(a1 + 76);
    v2 = random(-32, 32);
    createNPC(NPCTreasureChestClosed|0x100, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12) + (v2 << 9), 0, 0, v1, 0, 256);
  }
}

//----- (0045C5A0) --------------------------------------------------------
void __cdecl NPC273(void *npc)
{
  int *v1; // eax
  int *v2; // ecx
  int v3; // [esp+0h] [ebp-34h]
  int v4; // [esp+4h] [ebp-30h]
  int v5; // [esp+8h] [ebp-2Ch]
  int v6; // [esp+Ch] [ebp-28h]
  int v7; // [esp+10h] [ebp-24h]
  int v8; // [esp+14h] [ebp-20h]
  int v9; // [esp+18h] [ebp-1Ch]
  int v10; // [esp+1Ch] [ebp-18h]
  int v11; // [esp+20h] [ebp-14h]
  int v12; // [esp+24h] [ebp-10h]
  int v13; // [esp+28h] [ebp-Ch]
  int v14; // [esp+2Ch] [ebp-8h]
  int v15; // [esp+30h] [ebp-4h]

  v4 = 248;
  v5 = 40;
  v6 = 272;
  v7 = 64;
  v8 = 272;
  v9 = 40;
  v10 = 296;
  v11 = 64;
  v12 = 296;
  v13 = 40;
  v14 = 320;
  v15 = 64;
  v3 = *((_DWORD *)npc + 29);
  if ( v3 )
  {
    if ( v3 != 1 )
      goto LABEL_11;
  }
  else
  {
    *((_DWORD *)npc + 29) = 1;
  }
  *((_DWORD *)npc + 2) += *((_DWORD *)npc + 4);
  *((_DWORD *)npc + 3) += *((_DWORD *)npc + 5);
  if ( *((_DWORD *)npc + 1) & 0xFF )
  {
    createNPC(NPCSmoke, *((_DWORD *)npc + 2), *((_DWORD *)npc + 3), 0, 0, 0, 0, 256);
    createNPC(NPCSmoke, *((_DWORD *)npc + 2), *((_DWORD *)npc + 3), 0, 0, 0, 0, 256);
    createNPC(NPCSmoke, *((_DWORD *)npc + 2), *((_DWORD *)npc + 3), 0, 0, 0, 0, 256);
    Vanish_NPC((NPC *)npc);
    return;
  }
  if ( !(++*((_DWORD *)npc + 30) % 5) )
    playSoundEffect(SFXPowerCritterFlys, 1);
  if ( ++*((_DWORD *)npc + 26) > 2 )
    *((_DWORD *)npc + 26) = 0;
LABEL_11:
  v1 = &v4 + 4 * *((_DWORD *)npc + 26);
  v2 = (int *)((char *)npc + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  v2[3] = v1[3];
}

//----- (0045C750) --------------------------------------------------------
int __cdecl NPC274(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+4h] [ebp-D0h]
  int v5; // [esp+8h] [ebp-CCh]
  int v6; // [esp+Ch] [ebp-C8h]
  int v7; // [esp+10h] [ebp-C4h]
  int v8; // [esp+14h] [ebp-C0h]
  int v9; // [esp+18h] [ebp-BCh]
  int v10; // [esp+1Ch] [ebp-B8h]
  int v11; // [esp+20h] [ebp-B4h]
  int v12; // [esp+24h] [ebp-B0h]
  int v13; // [esp+28h] [ebp-ACh]
  int v14; // [esp+2Ch] [ebp-A8h]
  int v15; // [esp+30h] [ebp-A4h]
  int v16; // [esp+34h] [ebp-A0h]
  int v17; // [esp+38h] [ebp-9Ch]
  int v18; // [esp+3Ch] [ebp-98h]
  int v19; // [esp+40h] [ebp-94h]
  int v20; // [esp+44h] [ebp-90h]
  int v21; // [esp+48h] [ebp-8Ch]
  int v22; // [esp+4Ch] [ebp-88h]
  int v23; // [esp+50h] [ebp-84h]
  int v24; // [esp+54h] [ebp-80h]
  int v25; // [esp+58h] [ebp-7Ch]
  int v26; // [esp+5Ch] [ebp-78h]
  int v27; // [esp+60h] [ebp-74h]
  int Y_Vel; // [esp+64h] [ebp-70h]
  int X_Vel; // [esp+68h] [ebp-6Ch]
  int v30; // [esp+6Ch] [ebp-68h]
  int v31; // [esp+70h] [ebp-64h]
  int v32; // [esp+74h] [ebp-60h]
  int v33; // [esp+78h] [ebp-5Ch]
  int v34; // [esp+7Ch] [ebp-58h]
  int v35; // [esp+80h] [ebp-54h]
  int v36; // [esp+84h] [ebp-50h]
  int v37; // [esp+88h] [ebp-4Ch]
  int v38; // [esp+8Ch] [ebp-48h]
  int v39; // [esp+90h] [ebp-44h]
  int v40; // [esp+94h] [ebp-40h]
  int v41; // [esp+98h] [ebp-3Ch]
  int v42; // [esp+9Ch] [ebp-38h]
  int v43; // [esp+A0h] [ebp-34h]
  int v44; // [esp+A4h] [ebp-30h]
  int v45; // [esp+A8h] [ebp-2Ch]
  int v46; // [esp+ACh] [ebp-28h]
  int v47; // [esp+B0h] [ebp-24h]
  int v48; // [esp+B4h] [ebp-20h]
  int v49; // [esp+B8h] [ebp-1Ch]
  int v50; // [esp+BCh] [ebp-18h]
  int v51; // [esp+C0h] [ebp-14h]
  int v52; // [esp+C4h] [ebp-10h]
  int v53; // [esp+C8h] [ebp-Ch]
  unsigned __int8 v54; // [esp+D3h] [ebp-1h]

  v30 = 0;
  v31 = 0;
  v32 = 32;
  v33 = 40;
  v34 = 32;
  v35 = 0;
  v36 = 64;
  v37 = 40;
  v38 = 64;
  v39 = 0;
  v40 = 96;
  v41 = 40;
  v42 = 64;
  v43 = 80;
  v44 = 96;
  v45 = 120;
  v46 = 96;
  v47 = 80;
  v48 = 128;
  v49 = 120;
  v50 = 96;
  v51 = 0;
  v52 = 128;
  v53 = 40;
  v4 = 0;
  v5 = 40;
  v6 = 32;
  v7 = 80;
  v8 = 32;
  v9 = 40;
  v10 = 64;
  v11 = 80;
  v12 = 64;
  v13 = 40;
  v14 = 96;
  v15 = 80;
  v16 = 64;
  v17 = 120;
  v18 = 96;
  v19 = 160;
  v20 = 96;
  v21 = 120;
  v22 = 128;
  v23 = 160;
  v24 = 96;
  v25 = 40;
  v26 = 128;
  v27 = 80;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 12) -= 4096;
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 8);
      goto LABEL_3;
    case 1:
LABEL_3:
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 116) = 2;
      *(_DWORD *)(a1 + 104) = 0;
      goto LABEL_4;
    case 2:
LABEL_4:
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      if ( ++*(_DWORD *)(a1 + 100) > 40 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 1 )
        *(_DWORD *)(a1 + 104) = 0;
      if ( *(_BYTE *)(a1 + 156) )
        *(_DWORD *)(a1 + 116) = 10;
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 104) = 2;
      *(_DWORD *)(a1 + 120) = 0;
      goto LABEL_15;
    case 0xB:
LABEL_15:
      if ( ++*(_DWORD *)(a1 + 120) > 10 )
      {
        *(_DWORD *)(a1 + 116) = 12;
        *(_DWORD *)(a1 + 104) = 3;
        *(_DWORD *)(a1 + 20) = -1536;
        *(_DWORD *)(a1 + 108) = 0;
        if ( *(_DWORD *)(a1 + 32) <= *(_DWORD *)(a1 + 8) )
          *(_DWORD *)(a1 + 16) = -512;
        else
          *(_DWORD *)(a1 + 16) = 512;
      }
      break;
    case 0xC:
      if ( *(_DWORD *)(a1 + 20) > 0 )
      {
        *(_DWORD *)(a1 + 104) = 4;
        if ( !*(_DWORD *)(a1 + 108) )
        {
          ++*(_DWORD *)(a1 + 108);
          v54 = getArcTan(*(_DWORD *)(a1 + 8) - quote.XPos, *(_DWORD *)(a1 + 12) - 5120 - quote.YPos);
          Y_Vel = 4 * getSin(v54);
          X_Vel = 4 * getCos(v54);
          createNPC((NPCNames)273, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12) - 5120, X_Vel, Y_Vel, 0, 0, 256);
          playSoundEffect(SFXEnemyShootProjectile, 1);
        }
      }
      if ( *(_DWORD *)(a1 + 20) > 512 )
        *(_DWORD *)(a1 + 104) = 5;
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 104) = 2;
        *(_DWORD *)(a1 + 116) = 13;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 16) = 0;
      }
      break;
    case 0xD:
      *(_DWORD *)(a1 + 16) /= 2;
      if ( ++*(_DWORD *)(a1 + 120) > 10 )
        *(_DWORD *)(a1 + 116) = 1;
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 20) += 85;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v30 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (0045CC80) --------------------------------------------------------
int *__cdecl NPC275(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+0h] [ebp-44h]
  int v4; // [esp+4h] [ebp-40h]
  int v5; // [esp+8h] [ebp-3Ch]
  int v6; // [esp+Ch] [ebp-38h]
  int v7; // [esp+10h] [ebp-34h]
  int v8; // [esp+14h] [ebp-30h]
  int v9; // [esp+18h] [ebp-2Ch]
  int v10; // [esp+1Ch] [ebp-28h]
  int v11; // [esp+20h] [ebp-24h]
  int v12; // [esp+24h] [ebp-20h]
  int v13; // [esp+28h] [ebp-1Ch]
  int v14; // [esp+2Ch] [ebp-18h]
  int v15; // [esp+30h] [ebp-14h]
  int v16; // [esp+34h] [ebp-10h]
  int v17; // [esp+38h] [ebp-Ch]
  int v18; // [esp+3Ch] [ebp-8h]
  int v19; // [esp+40h] [ebp-4h]

  v4 = 272;
  v5 = 80;
  v6 = 288;
  v7 = 96;
  v8 = 288;
  v9 = 80;
  v10 = 304;
  v11 = 96;
  v12 = 272;
  v13 = 80;
  v14 = 288;
  v15 = 96;
  v16 = 304;
  v17 = 80;
  v18 = 320;
  v19 = 96;
  v3 = *(_DWORD *)(a1 + 116);
  if ( v3 )
  {
    if ( v3 != 1 )
    {
      if ( v3 == 2 && ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      goto LABEL_19;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 100) = 0;
  }
  if ( random(0, 120) == 10 )
  {
    *(_DWORD *)(a1 + 116) = 2;
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 104) = 1;
  }
  if ( *(_DWORD *)(a1 + 8) - 0x8000 < quote.XPos
    && *(_DWORD *)(a1 + 8) + 0x8000 > quote.XPos
    && *(_DWORD *)(a1 + 12) - 0x4000 < quote.YPos
    && *(_DWORD *)(a1 + 12) + 0x2000 > quote.YPos )
  {
    if ( ++*(_DWORD *)(a1 + 100) > 3 )
    {
      *(_DWORD *)(a1 + 100) = 0;
      ++*(_DWORD *)(a1 + 104);
    }
    if ( *(_DWORD *)(a1 + 104) > 3 )
      *(_DWORD *)(a1 + 104) = 2;
  }
LABEL_19:
  *(_DWORD *)(a1 + 20) += 64;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (0045CEA0) --------------------------------------------------------
int __cdecl NPC276(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  int v4; // [esp+Ch] [ebp-130h]
  int v5; // [esp+10h] [ebp-12Ch]
  int v6; // [esp+14h] [ebp-128h]
  int v7; // [esp+18h] [ebp-124h]
  int v8; // [esp+1Ch] [ebp-120h]
  int v9; // [esp+20h] [ebp-11Ch]
  int v10; // [esp+24h] [ebp-118h]
  int v11; // [esp+28h] [ebp-114h]
  int v12; // [esp+2Ch] [ebp-110h]
  int v13; // [esp+30h] [ebp-10Ch]
  int v14; // [esp+34h] [ebp-108h]
  int v15; // [esp+38h] [ebp-104h]
  int v16; // [esp+3Ch] [ebp-100h]
  int v17; // [esp+40h] [ebp-FCh]
  int v18; // [esp+44h] [ebp-F8h]
  int v19; // [esp+48h] [ebp-F4h]
  int v20; // [esp+4Ch] [ebp-F0h]
  int v21; // [esp+50h] [ebp-ECh]
  int v22; // [esp+54h] [ebp-E8h]
  int v23; // [esp+58h] [ebp-E4h]
  int v24; // [esp+5Ch] [ebp-E0h]
  int v25; // [esp+60h] [ebp-DCh]
  int v26; // [esp+64h] [ebp-D8h]
  int v27; // [esp+68h] [ebp-D4h]
  int v28; // [esp+6Ch] [ebp-D0h]
  int v29; // [esp+70h] [ebp-CCh]
  int v30; // [esp+74h] [ebp-C8h]
  int v31; // [esp+78h] [ebp-C4h]
  int v32; // [esp+7Ch] [ebp-C0h]
  int v33; // [esp+80h] [ebp-BCh]
  int v34; // [esp+84h] [ebp-B8h]
  int v35; // [esp+88h] [ebp-B4h]
  int v36; // [esp+8Ch] [ebp-B0h]
  int v37; // [esp+90h] [ebp-ACh]
  int v38; // [esp+94h] [ebp-A8h]
  int v39; // [esp+98h] [ebp-A4h]
  int Y_Vel; // [esp+9Ch] [ebp-A0h]
  int X_Vel; // [esp+A0h] [ebp-9Ch]
  int v42; // [esp+A4h] [ebp-98h]
  int v43; // [esp+A8h] [ebp-94h]
  int v44; // [esp+ACh] [ebp-90h]
  int v45; // [esp+B0h] [ebp-8Ch]
  int v46; // [esp+B4h] [ebp-88h]
  int v47; // [esp+B8h] [ebp-84h]
  int v48; // [esp+BCh] [ebp-80h]
  int v49; // [esp+C0h] [ebp-7Ch]
  int v50; // [esp+C4h] [ebp-78h]
  int v51; // [esp+C8h] [ebp-74h]
  int v52; // [esp+CCh] [ebp-70h]
  int v53; // [esp+D0h] [ebp-6Ch]
  int v54; // [esp+D4h] [ebp-68h]
  int v55; // [esp+D8h] [ebp-64h]
  int v56; // [esp+DCh] [ebp-60h]
  int v57; // [esp+E0h] [ebp-5Ch]
  int v58; // [esp+E4h] [ebp-58h]
  int v59; // [esp+E8h] [ebp-54h]
  int v60; // [esp+ECh] [ebp-50h]
  int v61; // [esp+F0h] [ebp-4Ch]
  int v62; // [esp+F4h] [ebp-48h]
  int v63; // [esp+F8h] [ebp-44h]
  int v64; // [esp+FCh] [ebp-40h]
  int v65; // [esp+100h] [ebp-3Ch]
  int v66; // [esp+104h] [ebp-38h]
  int v67; // [esp+108h] [ebp-34h]
  int v68; // [esp+10Ch] [ebp-30h]
  int v69; // [esp+110h] [ebp-2Ch]
  int v70; // [esp+114h] [ebp-28h]
  int v71; // [esp+118h] [ebp-24h]
  int v72; // [esp+11Ch] [ebp-20h]
  int v73; // [esp+120h] [ebp-1Ch]
  int v74; // [esp+124h] [ebp-18h]
  int v75; // [esp+128h] [ebp-14h]
  int v76; // [esp+12Ch] [ebp-10h]
  int v77; // [esp+130h] [ebp-Ch]
  unsigned __int8 v78; // [esp+13Bh] [ebp-1h]

  v42 = 0;
  v43 = 64;
  v44 = 32;
  v45 = 104;
  v46 = 32;
  v47 = 64;
  v48 = 64;
  v49 = 104;
  v50 = 64;
  v51 = 64;
  v52 = 96;
  v53 = 104;
  v54 = 96;
  v55 = 64;
  v56 = 128;
  v57 = 104;
  v58 = 128;
  v59 = 64;
  v60 = 160;
  v61 = 104;
  v62 = 160;
  v63 = 64;
  v64 = 192;
  v65 = 104;
  v66 = 192;
  v67 = 64;
  v68 = 224;
  v69 = 104;
  v70 = 224;
  v71 = 64;
  v72 = 256;
  v73 = 104;
  v74 = 256;
  v75 = 64;
  v76 = 288;
  v77 = 104;
  v4 = 0;
  v5 = 104;
  v6 = 32;
  v7 = 144;
  v8 = 32;
  v9 = 104;
  v10 = 64;
  v11 = 144;
  v12 = 64;
  v13 = 104;
  v14 = 96;
  v15 = 144;
  v16 = 96;
  v17 = 104;
  v18 = 128;
  v19 = 144;
  v20 = 128;
  v21 = 104;
  v22 = 160;
  v23 = 144;
  v24 = 160;
  v25 = 104;
  v26 = 192;
  v27 = 144;
  v28 = 192;
  v29 = 104;
  v30 = 224;
  v31 = 144;
  v32 = 224;
  v33 = 104;
  v34 = 256;
  v35 = 144;
  v36 = 256;
  v37 = 104;
  v38 = 288;
  v39 = 144;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 12) -= 4096;
      goto LABEL_3;
    case 1:
LABEL_3:
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 116) = 2;
      *(_DWORD *)(a1 + 104) = 0;
      goto LABEL_4;
    case 2:
LABEL_4:
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      if ( ++*(_DWORD *)(a1 + 100) > 20 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 1 )
        *(_DWORD *)(a1 + 104) = 0;
      if ( *(_BYTE *)(a1 + 156) )
        *(_DWORD *)(a1 + 116) = 10;
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 104) = 3;
      *(_WORD *)(a1 + 80) |= 0x20u;
      goto LABEL_15;
    case 0xB:
LABEL_15:
      switch ( ++*(_DWORD *)(a1 + 120) )
      {
        case 0x1E:
        case 0x28:
        case 0x32:
          *(_DWORD *)(a1 + 104) = 4;
          v78 = getArcTan(*(_DWORD *)(a1 + 8) - quote.XPos, *(_DWORD *)(a1 + 12) - quote.YPos);
          Y_Vel = 4 * getSin(v78);
          X_Vel = 4 * getCos(v78);
          createNPC((NPCNames)277, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), X_Vel, Y_Vel, 0, 0, 256);
          playSoundEffect(SFXEnemyShootProjectile, 1);
          break;
        case 0x22:
        case 0x2C:
        case 0x36:
          *(_DWORD *)(a1 + 104) = 3;
          break;
        default:
          break;
      }
      if ( *(_DWORD *)(a1 + 120) > 60 )
      {
        *(_DWORD *)(a1 + 116) = 20;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 2;
      }
      break;
    case 0x14:
      if ( ++*(_DWORD *)(a1 + 120) > 20 )
      {
        *(_DWORD *)(a1 + 116) = 21;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 5;
        *(_DWORD *)(a1 + 20) = -1535;
        if ( *(_DWORD *)(a1 + 8) >= quote.XPos )
          *(_DWORD *)(a1 + 16) = -256;
        else
          *(_DWORD *)(a1 + 16) = 256;
      }
      break;
    case 0x15:
      switch ( ++*(_DWORD *)(a1 + 120) )
      {
        case 0x1E:
        case 0x28:
        case 0x32:
          *(_DWORD *)(a1 + 104) = 6;
          v78 = getArcTan(*(_DWORD *)(a1 + 8) - quote.XPos, *(_DWORD *)(a1 + 12) - 5120 - quote.YPos);
          Y_Vel = 4 * getSin(v78);
          X_Vel = 4 * getCos(v78);
          createNPC((NPCNames)277, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12) - 5120, X_Vel, Y_Vel, 0, 0, 256);
          playSoundEffect(SFXEnemyShootProjectile, 1);
          break;
        case 0x22:
        case 0x2C:
          *(_DWORD *)(a1 + 104) = 5;
          break;
        default:
          break;
      }
      if ( *(_DWORD *)(a1 + 120) > 53 )
        *(_DWORD *)(a1 + 104) = 7;
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 116) = 22;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 2;
        setQuake(10);
        playSoundEffect(SFXLargeObjectHitGround, 1);
      }
      break;
    case 0x16:
      *(_DWORD *)(a1 + 16) /= 2;
      if ( ++*(_DWORD *)(a1 + 120) > 22 )
        *(_DWORD *)(a1 + 116) = 10;
      break;
    case 0x32:
      *(_WORD *)(a1 + 80) &= 0xFFDFu;
      *(_DWORD *)(a1 + 164) = 0;
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 116) = 51;
        *(_DWORD *)(a1 + 104) = 2;
        setQuake(10);
        Spawn_Exp(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 19);
        createDustClouds(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 148), 8);
        playSoundEffect(SFXExplosion, 1);
      }
      break;
    case 0x33:
      *(_DWORD *)(a1 + 16) = 7 * *(_DWORD *)(a1 + 16) / 8;
      *(_DWORD *)(a1 + 104) = 8;
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 20) += 32;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 116) < 50 )
  {
    if ( *(_DWORD *)(a1 + 8) >= quote.XPos )
      *(_DWORD *)(a1 + 76) = 0;
    else
      *(_DWORD *)(a1 + 76) = 2;
  }
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v42 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}

//----- (0045D780) --------------------------------------------------------
void __cdecl NPC277(void *npc)
{
  int *v1; // eax
  int *v2; // ecx
  int v3; // [esp+0h] [ebp-34h]
  int v4; // [esp+4h] [ebp-30h]
  int v5; // [esp+8h] [ebp-2Ch]
  int v6; // [esp+Ch] [ebp-28h]
  int v7; // [esp+10h] [ebp-24h]
  int v8; // [esp+14h] [ebp-20h]
  int v9; // [esp+18h] [ebp-1Ch]
  int v10; // [esp+1Ch] [ebp-18h]
  int v11; // [esp+20h] [ebp-14h]
  int v12; // [esp+24h] [ebp-10h]
  int v13; // [esp+28h] [ebp-Ch]
  int v14; // [esp+2Ch] [ebp-8h]
  int v15; // [esp+30h] [ebp-4h]

  v4 = 128;
  v5 = 0;
  v6 = 152;
  v7 = 24;
  v8 = 152;
  v9 = 0;
  v10 = 176;
  v11 = 24;
  v12 = 176;
  v13 = 0;
  v14 = 200;
  v15 = 24;
  v3 = *((_DWORD *)npc + 29);
  if ( v3 )
  {
    if ( v3 != 1 )
      goto LABEL_11;
  }
  else
  {
    *((_DWORD *)npc + 29) = 1;
  }
  *((_DWORD *)npc + 2) += *((_DWORD *)npc + 4);
  *((_DWORD *)npc + 3) += *((_DWORD *)npc + 5);
  if ( *((_DWORD *)npc + 1) & 0xFF )
  {
    createNPC(NPCSmoke, *((_DWORD *)npc + 2), *((_DWORD *)npc + 3), 0, 0, 0, 0, 256);
    createNPC(NPCSmoke, *((_DWORD *)npc + 2), *((_DWORD *)npc + 3), 0, 0, 0, 0, 256);
    createNPC(NPCSmoke, *((_DWORD *)npc + 2), *((_DWORD *)npc + 3), 0, 0, 0, 0, 256);
    Vanish_NPC((NPC *)npc);
    return;
  }
  if ( !(++*((_DWORD *)npc + 30) % 5) )
    playSoundEffect(SFXPowerCritterFlys, 1);
  if ( ++*((_DWORD *)npc + 26) > 2 )
    *((_DWORD *)npc + 26) = 0;
LABEL_11:
  v1 = &v4 + 4 * *((_DWORD *)npc + 26);
  v2 = (int *)((char *)npc + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  v2[3] = v1[3];
}

//----- (0045D930) --------------------------------------------------------
int __cdecl NPC278(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int *v3; // ecx
  int *v4; // edx
  int result; // eax
  int v6; // [esp+0h] [ebp-68h]
  int v7; // [esp+8h] [ebp-60h]
  int v8; // [esp+Ch] [ebp-5Ch]
  int v9; // [esp+10h] [ebp-58h]
  int v10; // [esp+14h] [ebp-54h]
  int v11; // [esp+18h] [ebp-50h]
  int v12; // [esp+1Ch] [ebp-4Ch]
  int v13; // [esp+20h] [ebp-48h]
  int v14; // [esp+24h] [ebp-44h]
  int v15; // [esp+28h] [ebp-40h]
  int v16; // [esp+2Ch] [ebp-3Ch]
  int v17; // [esp+30h] [ebp-38h]
  int v18; // [esp+34h] [ebp-34h]
  int v19; // [esp+38h] [ebp-30h]
  int v20; // [esp+3Ch] [ebp-2Ch]
  int v21; // [esp+40h] [ebp-28h]
  int v22; // [esp+44h] [ebp-24h]
  int v23; // [esp+48h] [ebp-20h]
  int v24; // [esp+4Ch] [ebp-1Ch]
  int v25; // [esp+50h] [ebp-18h]
  int v26; // [esp+54h] [ebp-14h]
  int v27; // [esp+58h] [ebp-10h]
  int v28; // [esp+5Ch] [ebp-Ch]
  int v29; // [esp+60h] [ebp-8h]
  int v30; // [esp+64h] [ebp-4h]

  v15 = 0;
  v16 = 120;
  v17 = 8;
  v18 = 128;
  v19 = 8;
  v20 = 120;
  v21 = 16;
  v22 = 128;
  v7 = 16;
  v8 = 120;
  v9 = 24;
  v10 = 128;
  v11 = 24;
  v12 = 120;
  v13 = 32;
  v14 = 128;
  v23 = 32;
  v24 = 120;
  v25 = 40;
  v26 = 128;
  v27 = 40;
  v28 = 120;
  v29 = 48;
  v30 = 128;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      *(_DWORD *)(a1 + 16) = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( random(0, 60) == 1 )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      if ( random(0, 60) == 1 )
      {
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      break;
    case 2:
      if ( ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 120) = random(0, 16);
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      if ( random(0, 9) % 2 )
        *(_DWORD *)(a1 + 76) = 0;
      else
        *(_DWORD *)(a1 + 76) = 2;
      goto LABEL_14;
    case 0xB:
LABEL_14:
      if ( *(_DWORD *)(a1 + 76) || !(*(_DWORD *)(a1 + 4) & 1) )
      {
        if ( *(_DWORD *)(a1 + 76) == 2 && *(_DWORD *)(a1 + 4) & 4 )
          *(_DWORD *)(a1 + 76) = 0;
      }
      else
      {
        *(_DWORD *)(a1 + 76) = 2;
      }
      if ( *(_DWORD *)(a1 + 76) )
        *(_DWORD *)(a1 + 16) = 256;
      else
        *(_DWORD *)(a1 + 16) = -256;
      if ( ++*(_DWORD *)(a1 + 100) > 4 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 1 )
        *(_DWORD *)(a1 + 104) = 0;
      if ( ++*(_DWORD *)(a1 + 120) > 32 )
        *(_DWORD *)(a1 + 116) = 0;
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 20) += 32;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v6 = *(_DWORD *)(a1 + 48);
  if ( v6 == 200 )
  {
    v1 = &v15 + 4 * *(_DWORD *)(a1 + 104);
    v2 = (int *)(a1 + 84);
    *v2 = *v1;
    v2[1] = v1[1];
    result = v1[2];
    v2[2] = result;
    v2[3] = v1[3];
  }
  else
  {
    if ( v6 == 210 )
      v3 = &v7 + 4 * *(_DWORD *)(a1 + 104);
    else
      v3 = &v23 + 4 * *(_DWORD *)(a1 + 104);
    v4 = (int *)(a1 + 84);
    *v4 = *v3;
    v4[1] = v3[1];
    result = v3[2];
    v4[2] = result;
    v4[3] = v3[3];
  }
  return result;
}

//----- (0045DCF0) --------------------------------------------------------
int __cdecl NPC279(int a1)
{
  int v1; // ST10_4
  int v2; // ST0C_4
  int v3; // ST08_4
  int v4; // eax
  int result; // eax
  int *v6; // ecx
  int *v7; // edx
  int v8; // [esp+0h] [ebp-2Ch]
  signed int i; // [esp+8h] [ebp-24h]
  int v10; // [esp+Ch] [ebp-20h]
  int v11; // [esp+10h] [ebp-1Ch]
  int v12; // [esp+14h] [ebp-18h]
  int v13; // [esp+18h] [ebp-14h]
  int v14; // [esp+1Ch] [ebp-10h]
  int v15; // [esp+20h] [ebp-Ch]
  int v16; // [esp+24h] [ebp-8h]
  int v17; // [esp+28h] [ebp-4h]

  v10 = 0;
  v11 = 16;
  v12 = 32;
  v13 = 48;
  v14 = 16;
  v15 = 0;
  v16 = 32;
  v17 = 16;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      v8 = *(_DWORD *)(a1 + 76);
      if ( v8 )
      {
        if ( v8 == 1 )
        {
          *(_DWORD *)(a1 + 104) = 0;
          *(_DWORD *)(a1 + 116) = 10;
        }
        else if ( v8 == 2 )
        {
          *(_DWORD *)(a1 + 116) = 100;
          *(_WORD *)(a1 + 80) |= 4u;
          *(_DWORD *)(a1 + 104) = 1;
          *(_DWORD *)(a1 + 148) = 4096;
          *(_DWORD *)(a1 + 140) = 4096;
          *(_DWORD *)(a1 + 144) = 4096;
          *(_DWORD *)(a1 + 152) = 4096;
          *(_DWORD *)(a1 + 132) = 4096;
          *(_DWORD *)(a1 + 124) = 4096;
          *(_DWORD *)(a1 + 128) = 4096;
          *(_DWORD *)(a1 + 136) = 4096;
        }
      }
      else
      {
        *(_DWORD *)(a1 + 116) = 100;
        *(_WORD *)(a1 + 80) |= 4u;
        *(_DWORD *)(a1 + 104) = 0;
      }
      if ( *(_DWORD *)(a1 + 76) != 1 )
        goto LABEL_25;
      goto LABEL_10;
    case 0xA:
LABEL_10:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 120) = 16;
      goto LABEL_11;
    case 0xB:
LABEL_11:
      *(_DWORD *)(a1 + 120) -= 2;
      if ( *(_DWORD *)(a1 + 120) <= 0 )
      {
        *(_DWORD *)(a1 + 116) = 100;
        *(_WORD *)(a1 + 80) |= 4u;
      }
      goto LABEL_25;
    case 0x64:
      *(_DWORD *)(a1 + 20) += 64;
      if ( *(_DWORD *)(a1 + 20) > 1792 )
        *(_DWORD *)(a1 + 20) = 1792;
      if ( *(_DWORD *)(a1 + 12) > 0x10000 )
        *(_WORD *)(a1 + 80) &= 0xFFF7u;
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 20) = -512;
        *(_DWORD *)(a1 + 116) = 110;
        *(_WORD *)(a1 + 80) |= 8u;
        playSoundEffect(SFXLargeObjectHitGround, 1);
        setQuake(10);
        for ( i = 0; i < 4; ++i )
        {
          v1 = random(-1536, 0);
          v2 = random(-341, 341);
          v3 = *(_DWORD *)(a1 + 12) + 0x2000;
          v4 = random(-12, 12);
          createNPC(NPCSmoke, *(_DWORD *)(a1 + 8) + (v4 << 9), v3, v2, v1, 0, 0, 256);
        }
      }
      goto LABEL_25;
    case 0x6E:
      *(_DWORD *)(a1 + 20) += 64;
      result = (currentMap.length << 13) + 0x4000;
      if ( *(_DWORD *)(a1 + 12) <= result )
        goto LABEL_25;
      *(_BYTE *)a1 = 0;
      break;
    default:
LABEL_25:
      if ( quote.YPos <= *(_DWORD *)(a1 + 12) )
        *(_DWORD *)(a1 + 164) = 0;
      else
        *(_DWORD *)(a1 + 164) = 10;
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
      v6 = &v10 + 4 * *(_DWORD *)(a1 + 104);
      v7 = (int *)(a1 + 84);
      *v7 = *v6;
      v7[1] = v6[1];
      result = v6[2];
      v7[2] = result;
      v7[3] = v6[3];
      if ( *(_DWORD *)(a1 + 116) == 11 )
      {
        *(_DWORD *)(a1 + 88) += *(_DWORD *)(a1 + 120);
        *(_DWORD *)(a1 + 96) -= *(_DWORD *)(a1 + 120);
        result = (16 - *(_DWORD *)(a1 + 120)) << 9;
        *(_DWORD *)(a1 + 144) = result;
      }
      break;
  }
  return result;
}

//----- (0045E110) --------------------------------------------------------
int __cdecl NPC280(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+0h] [ebp-44h]
  int v5; // [esp+4h] [ebp-40h]
  int v6; // [esp+8h] [ebp-3Ch]
  int v7; // [esp+Ch] [ebp-38h]
  int v8; // [esp+10h] [ebp-34h]
  int v9; // [esp+14h] [ebp-30h]
  int v10; // [esp+18h] [ebp-2Ch]
  int v11; // [esp+1Ch] [ebp-28h]
  int v12; // [esp+20h] [ebp-24h]
  int v13; // [esp+24h] [ebp-20h]
  int v14; // [esp+28h] [ebp-1Ch]
  int v15; // [esp+2Ch] [ebp-18h]
  int v16; // [esp+30h] [ebp-14h]
  int v17; // [esp+34h] [ebp-10h]
  int v18; // [esp+38h] [ebp-Ch]
  int v19; // [esp+3Ch] [ebp-8h]
  int v20; // [esp+40h] [ebp-4h]

  v13 = 112;
  v14 = 32;
  v15 = 128;
  v16 = 48;
  v17 = 144;
  v18 = 32;
  v19 = 160;
  v20 = 48;
  v5 = 112;
  v6 = 48;
  v7 = 128;
  v8 = 64;
  v9 = 144;
  v10 = 48;
  v11 = 160;
  v12 = 64;
  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      if ( v4 == 2 )
      {
        *(_DWORD *)(a1 + 104) = 0;
        if ( *(_DWORD *)(a1 + 4) & 8 )
        {
          *(_DWORD *)(a1 + 116) = 4;
          *(_DWORD *)(a1 + 120) = 0;
          *(_DWORD *)(a1 + 104) = 1;
          playSoundEffect(SFXQuoteHitGround, 1);
        }
      }
      goto LABEL_11;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 100) = 0;
    *(_DWORD *)(a1 + 8) += 3072;
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 8);
    playSoundEffect(SFXTeleport, 1);
  }
  if ( ++*(_DWORD *)(a1 + 120) == 64 )
  {
    *(_DWORD *)(a1 + 116) = 2;
    *(_DWORD *)(a1 + 120) = 0;
  }
LABEL_11:
  if ( *(_DWORD *)(a1 + 116) > 1 )
  {
    *(_DWORD *)(a1 + 20) += 32;
    if ( *(_DWORD *)(a1 + 20) > 1535 )
      *(_DWORD *)(a1 + 20) = 1535;
    *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  }
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v13 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  if ( *(_DWORD *)(a1 + 116) == 1 )
  {
    *(_DWORD *)(a1 + 96) = *(_DWORD *)(a1 + 88) + *(_DWORD *)(a1 + 120) / 4;
    if ( *(_DWORD *)(a1 + 120) / 2 % 2 )
    {
      result = *(_DWORD *)(a1 + 32);
      *(_DWORD *)(a1 + 8) = result;
    }
    else
    {
      result = a1;
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 32) + 512;
    }
  }
  return result;
}

//----- (0045E360) --------------------------------------------------------
RECT *__cdecl NPC281(NPC *a1)
{
  RECT *result; // eax

  switch ( a1->currentState )
  {
    case 0:
      a1->currentState = 1;
      break;
    case 0xA:
      a1->currentState = 11;
      a1->waitTimer = 0;
      goto LABEL_4;
    case 0xB:
LABEL_4:
      ++a1->waitTimer;
      createNPC(NPCSantasKey|0x100, a1->XPos, a1->YPos + 0x10000, 0, 0, right, a1, 256);
      if ( a1->waitTimer > 150 )
        a1->currentState = 12;
      break;
    case 0x14:
      a1->currentState = 21;
      a1->waitTimer = 0;
      goto LABEL_8;
    case 0x15:
LABEL_8:
      if ( ++a1->waitTimer > 250 )
      {
        killNPC(270, 0);
        a1->currentState = 22;
      }
      break;
    default:
      break;
  }
  result = &a1->rect;
  result->left = 0;
  result->top = 0;
  result->right = 0;
  result->bottom = 0;
  return result;
}

//----- (0045E4C0) --------------------------------------------------------
int __cdecl NPC282(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  int v4; // [esp+0h] [ebp-34h]
  int v5; // [esp+4h] [ebp-30h]
  int v6; // [esp+8h] [ebp-2Ch]
  int v7; // [esp+Ch] [ebp-28h]
  int v8; // [esp+10h] [ebp-24h]
  int v9; // [esp+14h] [ebp-20h]
  int v10; // [esp+18h] [ebp-1Ch]
  int v11; // [esp+1Ch] [ebp-18h]
  int v12; // [esp+20h] [ebp-14h]
  int v13; // [esp+24h] [ebp-10h]
  int v14; // [esp+28h] [ebp-Ch]
  int v15; // [esp+2Ch] [ebp-8h]
  int v16; // [esp+30h] [ebp-4h]

  v5 = 256;
  v6 = 80;
  v7 = 320;
  v8 = 120;
  v9 = 256;
  v10 = 0;
  v11 = 320;
  v12 = 40;
  v13 = 256;
  v14 = 120;
  v15 = 320;
  v16 = 160;
  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 != 20 )
      goto LABEL_48;
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 20;
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 12);
    if ( random(0, 100) % 2 )
      *(_DWORD *)(a1 + 20) = -256;
    else
      *(_DWORD *)(a1 + 20) = 256;
  }
  *(_DWORD *)(a1 + 16) = -512;
  if ( *(_DWORD *)(a1 + 8) < -32768 )
    *(_BYTE *)a1 = 0;
  if ( *(_DWORD *)(a1 + 36) < *(_DWORD *)(a1 + 12) )
    *(_DWORD *)(a1 + 20) -= 16;
  if ( *(_DWORD *)(a1 + 36) > *(_DWORD *)(a1 + 12) )
    *(_DWORD *)(a1 + 20) += 16;
  if ( *(_DWORD *)(a1 + 20) > 256 )
    *(_DWORD *)(a1 + 20) = 256;
  if ( *(_DWORD *)(a1 + 20) < -256 )
    *(_DWORD *)(a1 + 20) = -256;
  if ( quote.collisionFlags & 8
    && quote.YPos < *(_DWORD *)(a1 + 12) - 2048
    && quote.XPos > *(_DWORD *)(a1 + 8) - 12288
    && quote.XPos < *(_DWORD *)(a1 + 8) + 12288 )
  {
    *(_DWORD *)(a1 + 36) = 73728;
    *(_DWORD *)(a1 + 104) = 2;
  }
  else if ( *(_DWORD *)(a1 + 104) != 1 )
  {
    *(_DWORD *)(a1 + 104) = 0;
  }
  if ( quote.collisionFlags & 1
    && quote.XPos < *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 132)
    && quote.XPos > *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 132) - 4096
    && quote.Hitbox.bottom + quote.YPos > *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 128)
    && quote.YPos - quote.Hitbox.top < *(_DWORD *)(a1 + 136) + *(_DWORD *)(a1 + 12) )
  {
    *(_WORD *)(a1 + 80) &= 0xFFBFu;
    *(_DWORD *)(a1 + 104) = 1;
  }
  else if ( quote.collisionFlags & 4
         && quote.XPos > *(_DWORD *)(a1 + 132) + *(_DWORD *)(a1 + 8)
         && quote.XPos < *(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 132) + 4096
         && quote.Hitbox.bottom + quote.YPos > *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 128)
         && quote.YPos - quote.Hitbox.top < *(_DWORD *)(a1 + 136) + *(_DWORD *)(a1 + 12) )
  {
    *(_WORD *)(a1 + 80) &= 0xFFBFu;
    *(_DWORD *)(a1 + 104) = 1;
  }
  else if ( quote.collisionFlags & 2
         && quote.YPos < *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 128)
         && quote.YPos > *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 128) - 4096
         && quote.Hitbox.front + quote.XPos > *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 132)
         && quote.XPos - quote.Hitbox.back < *(_DWORD *)(a1 + 124) + *(_DWORD *)(a1 + 8) )
  {
    *(_WORD *)(a1 + 80) &= 0xFFBFu;
    *(_DWORD *)(a1 + 104) = 1;
  }
  else if ( quote.collisionFlags & 8
         && quote.YPos > *(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 136) - 2048
         && quote.YPos < *(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 136) + 6144
         && quote.Hitbox.front + quote.XPos > *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 132) - 2048
         && quote.XPos - quote.Hitbox.back < *(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 124) + 2048 )
  {
    *(_WORD *)(a1 + 80) &= 0xFFBFu;
    *(_DWORD *)(a1 + 104) = 1;
  }
LABEL_48:
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}

//----- (0045E950) --------------------------------------------------------
void __cdecl NPC283(NPC *npc)
{
  int v1; // ecx
  int v2; // eax
  int v3; // eax
  int *v4; // ecx
  RECT *v5; // edx
  int Direction; // [esp+14h] [ebp-16Ch]
  int v7; // [esp+18h] [ebp-168h]
  int v8; // [esp+1Ch] [ebp-164h]
  int v9; // [esp+20h] [ebp-160h]
  int v10; // [esp+24h] [ebp-15Ch]
  int v11; // [esp+28h] [ebp-158h]
  int v12; // [esp+2Ch] [ebp-154h]
  int v13; // [esp+30h] [ebp-150h]
  int v14; // [esp+34h] [ebp-14Ch]
  int v15; // [esp+38h] [ebp-148h]
  int v16; // [esp+3Ch] [ebp-144h]
  int v17; // [esp+40h] [ebp-140h]
  int v18; // [esp+44h] [ebp-13Ch]
  int v19; // [esp+48h] [ebp-138h]
  int v20; // [esp+4Ch] [ebp-134h]
  int v21; // [esp+50h] [ebp-130h]
  int v22; // [esp+54h] [ebp-12Ch]
  int v23; // [esp+58h] [ebp-128h]
  int v24; // [esp+5Ch] [ebp-124h]
  int v25; // [esp+60h] [ebp-120h]
  int v26; // [esp+64h] [ebp-11Ch]
  int v27; // [esp+68h] [ebp-118h]
  int v28; // [esp+6Ch] [ebp-114h]
  int v29; // [esp+70h] [ebp-110h]
  int v30; // [esp+74h] [ebp-10Ch]
  int v31; // [esp+78h] [ebp-108h]
  int v32; // [esp+7Ch] [ebp-104h]
  int v33; // [esp+80h] [ebp-100h]
  int v34; // [esp+84h] [ebp-FCh]
  int v35; // [esp+88h] [ebp-F8h]
  int v36; // [esp+8Ch] [ebp-F4h]
  int v37; // [esp+90h] [ebp-F0h]
  int v38; // [esp+94h] [ebp-ECh]
  int v39; // [esp+98h] [ebp-E8h]
  int v40; // [esp+9Ch] [ebp-E4h]
  int v41; // [esp+A0h] [ebp-E0h]
  int v42; // [esp+A4h] [ebp-DCh]
  int v43; // [esp+A8h] [ebp-D8h]
  int v44; // [esp+ACh] [ebp-D4h]
  int v45; // [esp+B0h] [ebp-D0h]
  int v46; // [esp+B4h] [ebp-CCh]
  int v47; // [esp+B8h] [ebp-C8h]
  int v48; // [esp+BCh] [ebp-C4h]
  int v49; // [esp+C0h] [ebp-C0h]
  int v50; // [esp+C4h] [ebp-BCh]
  int X_Pos; // [esp+C8h] [ebp-B8h]
  int Y_Pos; // [esp+CCh] [ebp-B4h]
  int v53; // [esp+D0h] [ebp-B0h]
  int v54; // [esp+D4h] [ebp-ACh]
  int v55; // [esp+D8h] [ebp-A8h]
  int v56; // [esp+DCh] [ebp-A4h]
  int v57; // [esp+E0h] [ebp-A0h]
  int v58; // [esp+E4h] [ebp-9Ch]
  int v59; // [esp+E8h] [ebp-98h]
  int v60; // [esp+ECh] [ebp-94h]
  int v61; // [esp+F0h] [ebp-90h]
  int v62; // [esp+F4h] [ebp-8Ch]
  int v63; // [esp+F8h] [ebp-88h]
  int v64; // [esp+FCh] [ebp-84h]
  int v65; // [esp+100h] [ebp-80h]
  int v66; // [esp+104h] [ebp-7Ch]
  int v67; // [esp+108h] [ebp-78h]
  int v68; // [esp+10Ch] [ebp-74h]
  int v69; // [esp+110h] [ebp-70h]
  int v70; // [esp+114h] [ebp-6Ch]
  int v71; // [esp+118h] [ebp-68h]
  int v72; // [esp+11Ch] [ebp-64h]
  int v73; // [esp+120h] [ebp-60h]
  int v74; // [esp+124h] [ebp-5Ch]
  int v75; // [esp+128h] [ebp-58h]
  int v76; // [esp+12Ch] [ebp-54h]
  int v77; // [esp+130h] [ebp-50h]
  int v78; // [esp+134h] [ebp-4Ch]
  int v79; // [esp+138h] [ebp-48h]
  int v80; // [esp+13Ch] [ebp-44h]
  int v81; // [esp+140h] [ebp-40h]
  int v82; // [esp+144h] [ebp-3Ch]
  int v83; // [esp+148h] [ebp-38h]
  int v84; // [esp+14Ch] [ebp-34h]
  int v85; // [esp+150h] [ebp-30h]
  int v86; // [esp+154h] [ebp-2Ch]
  int v87; // [esp+158h] [ebp-28h]
  int v88; // [esp+15Ch] [ebp-24h]
  int v89; // [esp+160h] [ebp-20h]
  int v90; // [esp+164h] [ebp-1Ch]
  int v91; // [esp+168h] [ebp-18h]
  int v92; // [esp+16Ch] [ebp-14h]
  int v93; // [esp+170h] [ebp-10h]
  int v94; // [esp+174h] [ebp-Ch]
  int v95; // [esp+178h] [ebp-8h]
  int v96; // [esp+17Ch] [ebp-4h]

  v53 = 0;
  v54 = 64;
  v55 = 32;
  v56 = 96;
  v57 = 32;
  v58 = 64;
  v59 = 64;
  v60 = 96;
  v61 = 64;
  v62 = 64;
  v63 = 96;
  v64 = 96;
  v65 = 96;
  v66 = 64;
  v67 = 128;
  v68 = 96;
  v69 = 128;
  v70 = 64;
  v71 = 160;
  v72 = 96;
  v73 = 160;
  v74 = 64;
  v75 = 192;
  v76 = 96;
  v77 = 192;
  v78 = 64;
  v79 = 224;
  v80 = 96;
  v81 = 224;
  v82 = 64;
  v83 = 256;
  v84 = 96;
  v85 = 0;
  v86 = 0;
  v87 = 0;
  v88 = 0;
  v89 = 256;
  v90 = 64;
  v91 = 288;
  v92 = 96;
  v93 = 288;
  v94 = 64;
  v95 = 320;
  v96 = 96;
  v7 = 0;
  v8 = 96;
  v9 = 32;
  v10 = 128;
  v11 = 32;
  v12 = 96;
  v13 = 64;
  v14 = 128;
  v15 = 64;
  v16 = 96;
  v17 = 96;
  v18 = 128;
  v19 = 96;
  v20 = 96;
  v21 = 128;
  v22 = 128;
  v23 = 128;
  v24 = 96;
  v25 = 160;
  v26 = 128;
  v27 = 160;
  v28 = 96;
  v29 = 192;
  v30 = 128;
  v31 = 192;
  v32 = 96;
  v33 = 224;
  v34 = 128;
  v35 = 224;
  v36 = 96;
  v37 = 256;
  v38 = 128;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v43 = 256;
  v44 = 96;
  v45 = 288;
  v46 = 128;
  v47 = 288;
  v48 = 96;
  v49 = 320;
  v50 = 128;
  if ( npc->currentState < 100 && (!bossObjects[0].isAlive || npc->life < 400) )
    npc->currentState = 100;
  switch ( npc->currentState )
  {
    case 0:
      npc->currentState = 1;
      npc->YPos -= 4096;
      playSoundEffect(SFXTeleport, 1);
      goto LABEL_7;
    case 1:
LABEL_7:
      if ( ++npc->waitTimer / 2 % 2 )
        npc->animationNumber = 9;
      else
        npc->animationNumber = 0;
      break;
    case 0xA:
      npc->currentState = 11;
      npc->animationNumber = 9;
      break;
    case 0x14:
      superYPos = 0;
      npc->currentState = 21;
      npc->waitTimer = 0;
      npc->animationNumber = 0;
      npc->animationTimer = 0;
      goto LABEL_13;
    case 0x15:
LABEL_13:
      npc->XVel = 7 * npc->XVel / 8;
      npc->YVel = 7 * npc->YVel / 8;
      if ( ++npc->animationTimer > 20 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 1 )
        npc->animationNumber = 0;
      if ( ++npc->waitTimer > 100 )
        npc->currentState = 30;
      if ( npc->XPos >= quote.XPos )
        npc->direction = 0;
      else
        npc->direction = 2;
      break;
    case 0x1E:
      npc->currentState = 31;
      npc->waitTimer = 0;
      npc->animationNumber = 2;
      npc->count2 = npc->life;
      goto LABEL_24;
    case 0x1F:
LABEL_24:
      if ( ++npc->animationTimer > 1 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 3 )
        npc->animationNumber = 2;
      if ( npc->collisionFlags & 8 )
        npc->YVel = -512;
      if ( npc->XPos <= bossObjects[0].XPos )
        v1 = npc->XVel + 32;
      else
        v1 = npc->XVel - 32;
      npc->XVel = v1;
      if ( npc->YPos <= quote.YPos )
        v2 = npc->YVel + 16;
      else
        v2 = npc->YVel - 16;
      npc->YVel = v2;
      if ( npc->XVel > 512 )
        npc->XVel = 512;
      if ( npc->XVel < -512 )
        npc->XVel = -512;
      if ( npc->YVel > 512 )
        npc->YVel = 512;
      if ( npc->YVel < -512 )
        npc->YVel = -512;
      if ( npc->XPos <= quote.XPos )
        npc->direction = 2;
      else
        npc->direction = 0;
      if ( ++npc->waitTimer > 150 && (npc->life < npc->count2 - 20 || superYPos) )
      {
        superYPos = 0;
        npc->currentState = 40;
      }
      if ( bossObjects[0].animationNumber && npc->waitTimer > 250 )
        npc->currentState = 50;
      break;
    case 0x28:
      npc->currentState = 41;
      npc->waitTimer = 0;
      npc->XVel = 0;
      npc->YVel = 0;
      if ( npc->XPos <= quote.XPos )
        npc->direction = 2;
      else
        npc->direction = 0;
      playSoundEffect(SFXBallosBallAndCurlyChargingHerGun, 1);
      if ( quote.YPos >= 81920 )
        npc->count2 = 289;
      else
        npc->count2 = 290;
      goto LABEL_61;
    case 0x29:
LABEL_61:
      if ( ++npc->waitTimer / 2 % 2 )
        npc->animationNumber = 4;
      else
        npc->animationNumber = 5;
      if ( npc->waitTimer % 6 == 1 )
      {
        if ( npc->count2 == 289 )
        {
          X_Pos = npc->XPos + (random(-64, 64) << 9);
          v3 = random(-32, 32);
        }
        else
        {
          X_Pos = npc->XPos + (random(-32, 32) << 9);
          v3 = random(-64, 64);
        }
        Y_Pos = npc->YPos + (v3 << 9);
        if ( X_Pos < 0x4000 )
          X_Pos = 0x4000;
        if ( X_Pos > (currentMap.width - 2) << 13 )
          X_Pos = (currentMap.width - 2) << 13;
        if ( Y_Pos < 0x4000 )
          Y_Pos = 0x4000;
        if ( Y_Pos > (currentMap.length - 2) << 13 )
          Y_Pos = (currentMap.length - 2) << 13;
        playSoundEffect(SFXEnemyShootProjectile, 1);
        createNPC((NPCNames)npc->count2, X_Pos, Y_Pos, 0, 0, 0, 0, 256);
      }
      if ( npc->waitTimer > 50 )
      {
        npc->currentState = 42;
        npc->waitTimer = 0;
        if ( npc->XPos <= quote.XPos )
          npc->direction = 2;
        else
          npc->direction = 0;
      }
      break;
    case 0x2A:
      ++npc->waitTimer;
      npc->animationNumber = 6;
      if ( npc->waitTimer > 50 )
      {
        npc->YVel = -512;
        if ( npc->direction )
          npc->XVel = -512;
        else
          npc->XVel = 512;
        npc->currentState = 30;
      }
      break;
    case 0x32:
      npc->currentState = 51;
      npc->waitTimer = 0;
      npc->XVel = 0;
      npc->YVel = 0;
      if ( npc->XPos <= quote.XPos )
        npc->direction = 2;
      else
        npc->direction = 0;
      playSoundEffect(SFXBallosBallAndCurlyChargingHerGun, 1);
      goto LABEL_92;
    case 0x33:
LABEL_92:
      if ( ++npc->waitTimer / 2 % 2 )
        npc->animationNumber = 4;
      else
        npc->animationNumber = 5;
      if ( quote.equippedItems & 0x20 )
      {
        if ( npc->waitTimer % 10 == 1 )
        {
          if ( npc->direction )
          {
            X_Pos = npc->XPos - 5120;
            Y_Pos = npc->YPos;
            switch ( npc->waitTimer / 6 % 4 )
            {
              case 0:
                Direction = 88;
                break;
              case 1:
                Direction = 108;
                break;
              case 2:
                Direction = 148;
                break;
              case 3:
                Direction = 168;
                break;
              default:
                break;
            }
          }
          else
          {
            X_Pos = npc->XPos + 5120;
            Y_Pos = npc->YPos;
            switch ( npc->waitTimer / 6 % 4 )
            {
              case 0:
                Direction = 216;
                break;
              case 1:
                Direction = 236;
                break;
              case 2:
                Direction = 20;
                break;
              case 3:
                Direction = 40;
                break;
              default:
                break;
            }
          }
          playSoundEffect(SFXEnemyShootProjectile, 1);
          createNPC(NPCForcefield|0x120, X_Pos, Y_Pos, 0, 0, (Directions)Direction, 0, 256);
        }
      }
      else if ( npc->waitTimer % 24 == 1 )
      {
        if ( npc->direction )
        {
          X_Pos = npc->XPos - 5120;
          Y_Pos = npc->YPos;
          switch ( npc->waitTimer / 6 % 4 )
          {
            case 0:
              Direction = 88;
              break;
            case 1:
              Direction = 108;
              break;
            case 2:
              Direction = 148;
              break;
            case 3:
              Direction = 168;
              break;
            default:
              break;
          }
        }
        else
        {
          X_Pos = npc->XPos + 5120;
          Y_Pos = npc->YPos;
          switch ( npc->waitTimer / 6 % 4 )
          {
            case 0:
              Direction = 216;
              break;
            case 1:
              Direction = 236;
              break;
            case 2:
              Direction = 20;
              break;
            case 3:
              Direction = 40;
              break;
            default:
              break;
          }
        }
        playSoundEffect(SFXEnemyShootProjectile, 1);
        createNPC(NPCForcefield|0x120, X_Pos, Y_Pos, 0, 0, (Directions)Direction, 0, 256);
      }
      if ( npc->waitTimer > 50 )
      {
        npc->currentState = 42;
        npc->waitTimer = 0;
        if ( npc->XPos <= quote.XPos )
          npc->direction = 2;
        else
          npc->direction = 0;
      }
      break;
    case 0x63:
      npc->XVel = 0;
      npc->YVel = 0;
      npc->animationNumber = 9;
      npc->entityFlags &= 0xFFDFu;
      break;
    case 0x64:
      npc->currentState = 101;
      npc->animationNumber = 9;
      npc->damage = 0;
      npc->entityFlags &= 0xFFDFu;
      npc->entityFlags |= 8u;
      npc->YVel = -512;
      npc->isBeingHit += 50;
      npc->hitbox.bottom = 6144;
      ++bossObjects[0].animationNumber;
      goto LABEL_132;
    case 0x65:
LABEL_132:
      npc->YVel += 32;
      if ( npc->YPos > 110592 - npc->hitbox.bottom )
      {
        npc->YPos = 110592 - npc->hitbox.bottom;
        npc->currentState = 102;
        npc->animationNumber = 10;
        npc->XVel = 0;
        npc->YVel = 0;
      }
      break;
    default:
      break;
  }
  npc->YPos += npc->YVel;
  if ( npc->isBeingHit )
    npc->XPos += npc->XVel / 2;
  else
    npc->XPos += npc->XVel;
  if ( npc->direction )
    v4 = &v7 + 4 * npc->animationNumber;
  else
    v4 = &v53 + 4 * npc->animationNumber;
  v5 = &npc->rect;
  v5->left = *v4;
  v5->top = v4[1];
  v5->right = v4[2];
  v5->bottom = v4[3];
}
// 4BBA30: using guessed type int superYPos;

//----- (0045F910) --------------------------------------------------------
void __cdecl NPC284(NPC *npc)
{
  int *v1; // ecx
  RECT *v2; // edx
  int v3; // [esp+8h] [ebp-1A8h]
  int v4; // [esp+Ch] [ebp-1A4h]
  int v5; // [esp+10h] [ebp-1A0h]
  int v6; // [esp+14h] [ebp-19Ch]
  int v7; // [esp+18h] [ebp-198h]
  int v8; // [esp+1Ch] [ebp-194h]
  int v9; // [esp+20h] [ebp-190h]
  int v10; // [esp+24h] [ebp-18Ch]
  int v11; // [esp+28h] [ebp-188h]
  int v12; // [esp+2Ch] [ebp-184h]
  int v13; // [esp+30h] [ebp-180h]
  int v14; // [esp+34h] [ebp-17Ch]
  int v15; // [esp+38h] [ebp-178h]
  int v16; // [esp+3Ch] [ebp-174h]
  int v17; // [esp+40h] [ebp-170h]
  int v18; // [esp+44h] [ebp-16Ch]
  int v19; // [esp+48h] [ebp-168h]
  int v20; // [esp+4Ch] [ebp-164h]
  int v21; // [esp+50h] [ebp-160h]
  int v22; // [esp+54h] [ebp-15Ch]
  int v23; // [esp+58h] [ebp-158h]
  int v24; // [esp+5Ch] [ebp-154h]
  int v25; // [esp+60h] [ebp-150h]
  int v26; // [esp+64h] [ebp-14Ch]
  int v27; // [esp+68h] [ebp-148h]
  int v28; // [esp+6Ch] [ebp-144h]
  int v29; // [esp+70h] [ebp-140h]
  int v30; // [esp+74h] [ebp-13Ch]
  int v31; // [esp+78h] [ebp-138h]
  int v32; // [esp+7Ch] [ebp-134h]
  int v33; // [esp+80h] [ebp-130h]
  int v34; // [esp+84h] [ebp-12Ch]
  int v35; // [esp+88h] [ebp-128h]
  int v36; // [esp+8Ch] [ebp-124h]
  int v37; // [esp+90h] [ebp-120h]
  int v38; // [esp+94h] [ebp-11Ch]
  int v39; // [esp+98h] [ebp-118h]
  int v40; // [esp+9Ch] [ebp-114h]
  int v41; // [esp+A0h] [ebp-110h]
  int v42; // [esp+A4h] [ebp-10Ch]
  int v43; // [esp+A8h] [ebp-108h]
  int v44; // [esp+ACh] [ebp-104h]
  int v45; // [esp+B0h] [ebp-100h]
  int v46; // [esp+B4h] [ebp-FCh]
  int v47; // [esp+B8h] [ebp-F8h]
  int v48; // [esp+BCh] [ebp-F4h]
  int v49; // [esp+C0h] [ebp-F0h]
  int v50; // [esp+C4h] [ebp-ECh]
  int v51; // [esp+C8h] [ebp-E8h]
  int v52; // [esp+CCh] [ebp-E4h]
  int v53; // [esp+D0h] [ebp-E0h]
  int v54; // [esp+D4h] [ebp-DCh]
  int v55; // [esp+D8h] [ebp-D8h]
  int v56; // [esp+DCh] [ebp-D4h]
  int v57; // [esp+E0h] [ebp-D0h]
  int v58; // [esp+E4h] [ebp-CCh]
  int v59; // [esp+E8h] [ebp-C8h]
  int v60; // [esp+ECh] [ebp-C4h]
  int v61; // [esp+F0h] [ebp-C0h]
  int v62; // [esp+F4h] [ebp-BCh]
  int v63; // [esp+F8h] [ebp-B8h]
  int v64; // [esp+FCh] [ebp-B4h]
  int v65; // [esp+100h] [ebp-B0h]
  int v66; // [esp+104h] [ebp-ACh]
  int v67; // [esp+108h] [ebp-A8h]
  int v68; // [esp+10Ch] [ebp-A4h]
  int v69; // [esp+110h] [ebp-A0h]
  int v70; // [esp+114h] [ebp-9Ch]
  int v71; // [esp+118h] [ebp-98h]
  int v72; // [esp+11Ch] [ebp-94h]
  int v73; // [esp+120h] [ebp-90h]
  int v74; // [esp+124h] [ebp-8Ch]
  int v75; // [esp+128h] [ebp-88h]
  int v76; // [esp+12Ch] [ebp-84h]
  int v77; // [esp+130h] [ebp-80h]
  int v78; // [esp+134h] [ebp-7Ch]
  int v79; // [esp+138h] [ebp-78h]
  int v80; // [esp+13Ch] [ebp-74h]
  int v81; // [esp+140h] [ebp-70h]
  int v82; // [esp+144h] [ebp-6Ch]
  int v83; // [esp+148h] [ebp-68h]
  int v84; // [esp+14Ch] [ebp-64h]
  int v85; // [esp+150h] [ebp-60h]
  int v86; // [esp+154h] [ebp-5Ch]
  int v87; // [esp+158h] [ebp-58h]
  int v88; // [esp+15Ch] [ebp-54h]
  int v89; // [esp+160h] [ebp-50h]
  int v90; // [esp+164h] [ebp-4Ch]
  int v91; // [esp+168h] [ebp-48h]
  int v92; // [esp+16Ch] [ebp-44h]
  int v93; // [esp+170h] [ebp-40h]
  int v94; // [esp+174h] [ebp-3Ch]
  int v95; // [esp+178h] [ebp-38h]
  int v96; // [esp+17Ch] [ebp-34h]
  int v97; // [esp+180h] [ebp-30h]
  int v98; // [esp+184h] [ebp-2Ch]
  int v99; // [esp+188h] [ebp-28h]
  int v100; // [esp+18Ch] [ebp-24h]
  int v101; // [esp+190h] [ebp-20h]
  int v102; // [esp+194h] [ebp-1Ch]
  int v103; // [esp+198h] [ebp-18h]
  int v104; // [esp+19Ch] [ebp-14h]
  int v105; // [esp+1A0h] [ebp-10h]
  int v106; // [esp+1A4h] [ebp-Ch]
  unsigned __int8 v107; // [esp+1AFh] [ebp-1h]

  v55 = 0;
  v56 = 128;
  v57 = 32;
  v58 = 160;
  v59 = 32;
  v60 = 128;
  v61 = 64;
  v62 = 160;
  v63 = 64;
  v64 = 128;
  v65 = 96;
  v66 = 160;
  v67 = 96;
  v68 = 128;
  v69 = 128;
  v70 = 160;
  v71 = 128;
  v72 = 128;
  v73 = 160;
  v74 = 160;
  v75 = 160;
  v76 = 128;
  v77 = 192;
  v78 = 160;
  v79 = 192;
  v80 = 128;
  v81 = 224;
  v82 = 160;
  v83 = 224;
  v84 = 128;
  v85 = 256;
  v86 = 160;
  v87 = 0;
  v88 = 0;
  v89 = 0;
  v90 = 0;
  v91 = 256;
  v92 = 128;
  v93 = 288;
  v94 = 160;
  v95 = 288;
  v96 = 128;
  v97 = 320;
  v98 = 160;
  v99 = 224;
  v100 = 64;
  v101 = 256;
  v102 = 96;
  v103 = 208;
  v104 = 32;
  v105 = 224;
  v106 = 48;
  v3 = 0;
  v4 = 160;
  v5 = 32;
  v6 = 192;
  v7 = 32;
  v8 = 160;
  v9 = 64;
  v10 = 192;
  v11 = 64;
  v12 = 160;
  v13 = 96;
  v14 = 192;
  v15 = 96;
  v16 = 160;
  v17 = 128;
  v18 = 192;
  v19 = 128;
  v20 = 160;
  v21 = 160;
  v22 = 192;
  v23 = 160;
  v24 = 160;
  v25 = 192;
  v26 = 192;
  v27 = 192;
  v28 = 160;
  v29 = 224;
  v30 = 192;
  v31 = 224;
  v32 = 160;
  v33 = 256;
  v34 = 192;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 256;
  v40 = 160;
  v41 = 288;
  v42 = 192;
  v43 = 288;
  v44 = 160;
  v45 = 320;
  v46 = 192;
  v47 = 224;
  v48 = 96;
  v49 = 256;
  v50 = 128;
  v51 = 208;
  v52 = 48;
  v53 = 224;
  v54 = 64;
  if ( npc->currentState < 100 && (!bossObjects[0].isAlive || npc->life < 500) )
    npc->currentState = 100;
  switch ( npc->currentState )
  {
    case 0:
      npc->currentState = 1;
      npc->YPos -= 2048;
      playSoundEffect(SFXTeleport, 1);
      npc->count2 = npc->life;
      goto LABEL_7;
    case 1:
LABEL_7:
      if ( ++npc->waitTimer / 2 % 2 )
      {
        npc->view.top = 0x2000;
        npc->view.back = 0x2000;
        npc->view.front = 0x2000;
        npc->animationNumber = 11;
      }
      else
      {
        npc->view.top = 1536;
        npc->view.back = 4096;
        npc->view.front = 4096;
        npc->animationNumber = 12;
      }
      if ( npc->waitTimer > 50 )
        npc->currentState = 10;
      break;
    case 0xA:
      npc->currentState = 11;
      npc->animationNumber = 11;
      npc->view.top = 0x2000;
      npc->view.back = 0x2000;
      npc->view.front = 0x2000;
      killNPC(257, 1);
      break;
    case 0x14:
      npc->currentState = 21;
      npc->waitTimer = 0;
      npc->animationNumber = 0;
      npc->animationTimer = 0;
      npc->damage = 0;
      npc->entityFlags |= 0x20u;
      npc->entityFlags &= 0xFFF7u;
      goto LABEL_15;
    case 0x15:
LABEL_15:
      npc->XVel = 7 * npc->XVel / 8;
      npc->YVel = 7 * npc->YVel / 8;
      if ( ++npc->animationTimer > 20 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 1 )
        npc->animationNumber = 0;
      if ( ++npc->waitTimer > 80 )
        npc->currentState = 30;
      if ( npc->XPos >= quote.XPos )
        npc->direction = 0;
      else
        npc->direction = 2;
      if ( npc->life < npc->count2 - 50 )
      {
        npc->count2 = npc->life;
        superYPos = 10;
      }
      break;
    case 0x1E:
      npc->currentState = 31;
      npc->waitTimer = 0;
      npc->animationNumber = 2;
      npc->XVel = 0;
      npc->YVel = 0;
      goto LABEL_28;
    case 0x1F:
LABEL_28:
      if ( ++npc->waitTimer > 16 )
      {
        ++npc->count1;
        npc->count1 %= 4;
        switch ( npc->count1 )
        {
          case 0:
            npc->currentState = 32;
            break;
          case 1:
          case 3:
            npc->currentState = 34;
            break;
          case 2:
            npc->currentState = 32;
            break;
          default:
            goto LABEL_115;
        }
      }
      break;
    case 0x20:
      npc->currentState = 33;
      npc->waitTimer = 0;
      npc->entityFlags &= 0xFFDFu;
      if ( quote.XPos >= npc->XPos )
        npc->curlyTargetX = quote.XPos + 81920;
      else
        npc->curlyTargetX = quote.XPos - 81920;
      npc->curlyTargetY = quote.YPos;
      v107 = getArcTan(npc->XPos - npc->curlyTargetX, npc->YPos - npc->curlyTargetY);
      npc->XVel = 3 * getCos(v107);
      npc->YVel = 3 * getSin(v107);
      npc->entityFlags &= 0xFFF7u;
      if ( npc->XPos < (currentMap.width << 13) / 2 && npc->XVel > 0 )
      {
        if ( npc->YPos < (currentMap.length << 13) / 2 && npc->YVel > 0 )
          npc->entityFlags |= 8u;
        if ( npc->YPos > (currentMap.length << 13) / 2 && npc->YVel < 0 )
          npc->entityFlags |= 8u;
      }
      if ( npc->XPos > (currentMap.width << 13) / 2 && npc->XVel < 0 )
      {
        if ( npc->YPos < (currentMap.length << 13) / 2 && npc->YVel > 0 )
          npc->entityFlags |= 8u;
        if ( npc->YPos > (currentMap.length << 13) / 2 && npc->YVel < 0 )
          npc->entityFlags |= 8u;
      }
      if ( npc->XVel <= 0 )
        npc->direction = 0;
      else
        npc->direction = 2;
      goto LABEL_56;
    case 0x21:
LABEL_56:
      if ( ++npc->waitTimer / 2 % 2 )
        npc->animationNumber = 3;
      else
        npc->animationNumber = 8;
      if ( npc->waitTimer > 50 || npc->collisionFlags & 5 )
        npc->currentState = 20;
      break;
    case 0x22:
      npc->currentState = 35;
      npc->waitTimer = 0;
      npc->damage = 4;
      npc->curlyTargetX = quote.XPos;
      npc->curlyTargetY = quote.YPos;
      v107 = getArcTan(npc->XPos - npc->curlyTargetX, npc->YPos - npc->curlyTargetY);
      npc->YVel = 3 * getSin(v107);
      npc->XVel = 3 * getCos(v107);
      npc->entityFlags &= 0xFFF7u;
      if ( npc->XPos < (currentMap.width << 13) / 2 && npc->XVel > 0 )
      {
        if ( npc->YPos < (currentMap.length << 13) / 2 && npc->YVel > 0 )
          npc->entityFlags |= 8u;
        if ( npc->YPos > (currentMap.length << 13) / 2 && npc->YVel < 0 )
          npc->entityFlags |= 8u;
      }
      if ( npc->XPos > (currentMap.width << 13) / 2 && npc->XVel < 0 )
      {
        if ( npc->YPos < (currentMap.length << 13) / 2 && npc->YVel > 0 )
          npc->entityFlags |= 8u;
        if ( npc->YPos > (currentMap.length << 13) / 2 && npc->YVel < 0 )
          npc->entityFlags |= 8u;
      }
      if ( npc->XVel <= 0 )
        npc->direction = 0;
      else
        npc->direction = 2;
      goto LABEL_82;
    case 0x23:
LABEL_82:
      if ( ++npc->waitTimer > 20 && npc->isBeingHit )
      {
        npc->currentState = 40;
      }
      else if ( npc->waitTimer > 50 || npc->collisionFlags & 5 )
      {
        npc->currentState = 20;
      }
      if ( ++npc->animationTimer > 1 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 7 )
        npc->animationNumber = 4;
      if ( npc->waitTimer % 5 == 1 )
        playSoundEffect(SFXCritterFly, 1);
      break;
    case 0x28:
      npc->currentState = 41;
      npc->waitTimer = 0;
      npc->animationNumber = 2;
      npc->damage = 0;
      npc->entityFlags &= 0xFFF7u;
      goto LABEL_96;
    case 0x29:
LABEL_96:
      npc->XVel = 7 * npc->XVel / 8;
      npc->YVel = 7 * npc->YVel / 8;
      if ( ++npc->waitTimer > 6 )
      {
        npc->currentState = 42;
        npc->waitTimer = 0;
        npc->YVel = -512;
        if ( npc->direction )
          npc->XVel = -512;
        else
          npc->XVel = 512;
      }
      break;
    case 0x2A:
      npc->animationNumber = 9;
      if ( npc->collisionFlags & 8 )
      {
        npc->currentState = 43;
        npc->waitTimer = 0;
        npc->animationNumber = 2;
        if ( npc->XPos >= quote.XPos )
          npc->direction = 0;
        else
          npc->direction = 2;
      }
      npc->YVel += 32;
      if ( npc->YVel > 1535 )
        npc->YVel = 1535;
      break;
    case 0x2B:
      if ( ++npc->waitTimer > 16 )
        npc->currentState = 20;
      break;
    case 0x63:
      npc->XVel = 0;
      npc->YVel = 0;
      npc->animationNumber = 9;
      npc->entityFlags &= 0xFFDFu;
      break;
    case 0x64:
      npc->currentState = 101;
      npc->animationNumber = 9;
      npc->damage = 0;
      npc->entityFlags &= 0xFFDFu;
      npc->entityFlags |= 8u;
      npc->YVel = -512;
      npc->isBeingHit += 50;
      ++bossObjects[0].animationNumber;
      goto LABEL_113;
    case 0x65:
LABEL_113:
      npc->YVel += 32;
      if ( npc->YPos > 110592 - npc->hitbox.bottom )
      {
        npc->YPos = 110592 - npc->hitbox.bottom;
        npc->currentState = 102;
        npc->animationNumber = 10;
        npc->XVel = 0;
        npc->YVel = 0;
      }
      break;
    default:
      break;
  }
LABEL_115:
  npc->YPos += npc->YVel;
  if ( npc->isBeingHit )
    npc->XPos += npc->XVel / 2;
  else
    npc->XPos += npc->XVel;
  if ( npc->direction )
    v1 = &v3 + 4 * npc->animationNumber;
  else
    v1 = &v55 + 4 * npc->animationNumber;
  v2 = &npc->rect;
  v2->left = *v1;
  v2->top = v1[1];
  v2->right = v1[2];
  v2->bottom = v1[3];
}
// 4BBA30: using guessed type int superYPos;

//----- (00460910) --------------------------------------------------------
void __cdecl NPC285(void *npc)
{
  int v1; // edx
  _DWORD *v2; // ecx
  int v3; // [esp+0h] [ebp-18h]
  unsigned __int8 v4; // [esp+17h] [ebp-1h]

  if ( *((_DWORD *)npc + 2) < 0 || *((_DWORD *)npc + 2) > currentMap.width << 13 )
  {
    Vanish_NPC((NPC *)npc);
    return;
  }
  v3 = *((_DWORD *)npc + 29);
  if ( !v3 )
  {
    *((_DWORD *)npc + 29) = 1;
    *((_DWORD *)npc + 8) = *((_DWORD *)npc + 2);
    *((_DWORD *)npc + 9) = *((_DWORD *)npc + 3);
    *((_DWORD *)npc + 27) = *((_DWORD *)npc + 19) / 8;
    *((_DWORD *)npc + 19) %= 8;
    goto LABEL_8;
  }
  if ( v3 == 1 )
  {
LABEL_8:
    *((_DWORD *)npc + 27) += 24;
    *((_DWORD *)npc + 27) %= 256;
    v4 = *((_BYTE *)npc + 108);
    if ( *((_DWORD *)npc + 30) < 128 )
      ++*((_DWORD *)npc + 30);
    if ( *((_DWORD *)npc + 19) )
      v1 = *((_DWORD *)npc + 4) + 21;
    else
      v1 = *((_DWORD *)npc + 4) - 21;
    *((_DWORD *)npc + 4) = v1;
    *((_DWORD *)npc + 8) += *((_DWORD *)npc + 4);
    *((_DWORD *)npc + 2) = *((_DWORD *)npc + 8) + 4 * getCos(v4);
    *((_DWORD *)npc + 3) = *((_DWORD *)npc + 9) + 6 * getSin(v4);
    createNPC(NPCSantasKey|0x110, *((_DWORD *)npc + 2), *((_DWORD *)npc + 3), 0, 0, 0, 0, 256);
  }
  v2 = (char *)npc + 84;
  *v2 = 232;
  v2[1] = 104;
  v2[2] = 248;
  v2[3] = 120;
}

//----- (00460AE0) --------------------------------------------------------
int __cdecl NPC286(int a1)
{
  int result; // eax
  int *v2; // eax
  int *v3; // ecx
  int v4; // [esp+0h] [ebp-30h]
  int v5; // [esp+4h] [ebp-2Ch]
  int v6; // [esp+8h] [ebp-28h]
  int v7; // [esp+Ch] [ebp-24h]
  int v8; // [esp+10h] [ebp-20h]
  int v9; // [esp+14h] [ebp-1Ch]
  int v10; // [esp+18h] [ebp-18h]
  int v11; // [esp+1Ch] [ebp-14h]
  int v12; // [esp+20h] [ebp-10h]
  int v13; // [esp+24h] [ebp-Ch]
  int v14; // [esp+28h] [ebp-8h]
  int v15; // [esp+2Ch] [ebp-4h]

  v4 = 232;
  v5 = 120;
  v6 = 248;
  v7 = 136;
  v8 = 232;
  v9 = 136;
  v10 = 248;
  v11 = 152;
  v12 = 232;
  v13 = 152;
  v14 = 248;
  v15 = 168;
  if ( ++*(_DWORD *)(a1 + 100) > 0 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) <= 2 )
  {
    v2 = &v4 + 4 * *(_DWORD *)(a1 + 104);
    v3 = (int *)(a1 + 84);
    *v3 = *v2;
    v3[1] = v2[1];
    v3[2] = v2[2];
    result = v2[3];
    v3[3] = result;
  }
  else
  {
    result = a1;
    *(_BYTE *)a1 = 0;
  }
  return result;
}

//----- (00460BB0) --------------------------------------------------------
int *__cdecl NPC287(int a1)
{
  int *result; // eax
  int *v2; // edx
  int v3; // [esp+0h] [ebp-70h]
  int v4; // [esp+4h] [ebp-6Ch]
  int v5; // [esp+8h] [ebp-68h]
  int v6; // [esp+Ch] [ebp-64h]
  int v7; // [esp+10h] [ebp-60h]
  int v8; // [esp+14h] [ebp-5Ch]
  int v9; // [esp+18h] [ebp-58h]
  int v10; // [esp+1Ch] [ebp-54h]
  int v11; // [esp+20h] [ebp-50h]
  int v12; // [esp+24h] [ebp-4Ch]
  int v13; // [esp+28h] [ebp-48h]
  int v14; // [esp+2Ch] [ebp-44h]
  int v15; // [esp+30h] [ebp-40h]
  int v16; // [esp+34h] [ebp-3Ch]
  int v17; // [esp+38h] [ebp-38h]
  int v18; // [esp+3Ch] [ebp-34h]
  int v19; // [esp+40h] [ebp-30h]
  int v20; // [esp+44h] [ebp-2Ch]
  int v21; // [esp+48h] [ebp-28h]
  int v22; // [esp+4Ch] [ebp-24h]
  int v23; // [esp+50h] [ebp-20h]
  int v24; // [esp+54h] [ebp-1Ch]
  int v25; // [esp+58h] [ebp-18h]
  int v26; // [esp+5Ch] [ebp-14h]
  int v27; // [esp+60h] [ebp-10h]
  int v28; // [esp+64h] [ebp-Ch]
  int v29; // [esp+68h] [ebp-8h]
  int v30; // [esp+6Ch] [ebp-4h]

  v3 = 0;
  v4 = 224;
  v5 = 16;
  v6 = 240;
  v7 = 16;
  v8 = 224;
  v9 = 32;
  v10 = 240;
  v11 = 32;
  v12 = 224;
  v13 = 48;
  v14 = 240;
  v15 = 48;
  v16 = 224;
  v17 = 64;
  v18 = 240;
  v19 = 64;
  v20 = 224;
  v21 = 80;
  v22 = 240;
  v23 = 80;
  v24 = 224;
  v25 = 96;
  v26 = 240;
  v27 = 96;
  v28 = 224;
  v29 = 112;
  v30 = 240;
  if ( *(_DWORD *)(a1 + 116) )
  {
    *(_DWORD *)(a1 + 16) = 20 * *(_DWORD *)(a1 + 16) / 21;
    *(_DWORD *)(a1 + 20) = 20 * *(_DWORD *)(a1 + 20) / 21;
    *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  }
  else
  {
    *(_DWORD *)(a1 + 16) = random(-4, 4) << 9;
    *(_DWORD *)(a1 + 116) = 1;
  }
  result = (int *)(*(_DWORD *)(a1 + 100) + 1);
  *(_DWORD *)(a1 + 100) = result;
  if ( *(_DWORD *)(a1 + 100) > 1 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    result = (int *)a1;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) <= 6 )
  {
    v2 = &v3 + 4 * *(_DWORD *)(a1 + 104);
    result = (int *)(a1 + 84);
    *result = *v2;
    result[1] = v2[1];
    result[2] = v2[2];
    result[3] = v2[3];
  }
  else
  {
    *(_BYTE *)a1 = 0;
  }
  return result;
}

//----- (00460D70) --------------------------------------------------------
int *__cdecl NPC288(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+4h] [ebp-50h]
  int v4; // [esp+8h] [ebp-4Ch]
  int v5; // [esp+Ch] [ebp-48h]
  int v6; // [esp+10h] [ebp-44h]
  int v7; // [esp+14h] [ebp-40h]
  int v8; // [esp+18h] [ebp-3Ch]
  int v9; // [esp+1Ch] [ebp-38h]
  int v10; // [esp+20h] [ebp-34h]
  int v11; // [esp+24h] [ebp-30h]
  int v12; // [esp+28h] [ebp-2Ch]
  int v13; // [esp+2Ch] [ebp-28h]
  int v14; // [esp+30h] [ebp-24h]
  int v15; // [esp+34h] [ebp-20h]
  int v16; // [esp+38h] [ebp-1Ch]
  int v17; // [esp+3Ch] [ebp-18h]
  int v18; // [esp+40h] [ebp-14h]
  int v19; // [esp+44h] [ebp-10h]
  int v20; // [esp+48h] [ebp-Ch]
  int v21; // [esp+4Ch] [ebp-8h]
  int v22; // [esp+50h] [ebp-4h]

  v3 = 232;
  v4 = 72;
  v5 = 248;
  v6 = 88;
  v7 = 232;
  v8 = 88;
  v9 = 248;
  v10 = 104;
  v11 = 232;
  v12 = 0;
  v13 = 256;
  v14 = 24;
  v15 = 232;
  v16 = 24;
  v17 = 256;
  v18 = 48;
  v19 = 232;
  v20 = 48;
  v21 = 256;
  v22 = 72;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 16) = -512;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( *(_DWORD *)(a1 + 76) == 1 )
      {
        *(_DWORD *)(a1 + 20) -= 32;
        if ( *(_DWORD *)(a1 + 20) < -1535 )
          *(_DWORD *)(a1 + 20) = -1535;
        if ( *(_DWORD *)(a1 + 4) & 2 )
          *(_DWORD *)(a1 + 116) = 2;
      }
      else if ( *(_DWORD *)(a1 + 76) == 3 )
      {
        *(_DWORD *)(a1 + 20) += 32;
        if ( *(_DWORD *)(a1 + 20) > 1535 )
          *(_DWORD *)(a1 + 20) = 1535;
        if ( *(_DWORD *)(a1 + 4) & 8 )
          *(_DWORD *)(a1 + 116) = 2;
      }
      if ( ++*(_DWORD *)(a1 + 100) > 3 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 1 )
        *(_DWORD *)(a1 + 104) = 0;
      break;
    case 2:
      playSoundEffect(SFXMissileImpact, 1);
      *(_DWORD *)(a1 + 116) = 3;
      *(_DWORD *)(a1 + 120) = 0;
      *(_WORD *)(a1 + 80) |= 8u;
      *(_DWORD *)(a1 + 20) = 0;
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
        *(_DWORD *)(a1 + 16) = 1024;
      else
        *(_DWORD *)(a1 + 16) = -1024;
      *(_DWORD *)(a1 + 148) = 6144;
      *(_DWORD *)(a1 + 140) = 6144;
      *(_DWORD *)(a1 + 144) = 6144;
      *(_DWORD *)(a1 + 152) = 6144;
      goto LABEL_23;
    case 3:
LABEL_23:
      if ( ++*(_DWORD *)(a1 + 104) > 4 )
        *(_DWORD *)(a1 + 104) = 2;
      if ( ++*(_DWORD *)(a1 + 120) % 4 == 1 )
      {
        if ( *(_DWORD *)(a1 + 76) == 1 )
          createNPC(NPCTreasureChestClosed|0x110, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 0, 1024, 0, 0, 256);
        else
          createNPC(NPCTreasureChestClosed|0x110, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 0, -1024, 0, 0, 256);
      }
      if ( *(_DWORD *)(a1 + 8) < 0x2000 || *(_DWORD *)(a1 + 8) > (currentMap.width << 13) - 0x2000 )
        *(_BYTE *)a1 = 0;
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v1 = &v3 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (004610D0) --------------------------------------------------------
void __cdecl NPC289(void *npc)
{
  int *v1; // eax
  int *v2; // ecx
  int v3; // [esp+4h] [ebp-60h]
  int v4; // [esp+8h] [ebp-5Ch]
  int v5; // [esp+Ch] [ebp-58h]
  int v6; // [esp+10h] [ebp-54h]
  int v7; // [esp+14h] [ebp-50h]
  int v8; // [esp+18h] [ebp-4Ch]
  int v9; // [esp+1Ch] [ebp-48h]
  int v10; // [esp+20h] [ebp-44h]
  int v11; // [esp+24h] [ebp-40h]
  int v12; // [esp+28h] [ebp-3Ch]
  int v13; // [esp+2Ch] [ebp-38h]
  int v14; // [esp+30h] [ebp-34h]
  int v15; // [esp+34h] [ebp-30h]
  int v16; // [esp+38h] [ebp-2Ch]
  int v17; // [esp+3Ch] [ebp-28h]
  int v18; // [esp+40h] [ebp-24h]
  int v19; // [esp+44h] [ebp-20h]
  int v20; // [esp+48h] [ebp-1Ch]
  int v21; // [esp+4Ch] [ebp-18h]
  int v22; // [esp+50h] [ebp-14h]
  int v23; // [esp+54h] [ebp-10h]
  int v24; // [esp+58h] [ebp-Ch]
  int v25; // [esp+5Ch] [ebp-8h]
  int v26; // [esp+60h] [ebp-4h]

  v15 = 160;
  v16 = 32;
  v17 = 176;
  v18 = 48;
  v19 = 176;
  v20 = 32;
  v21 = 192;
  v22 = 48;
  v23 = 192;
  v24 = 32;
  v25 = 208;
  v26 = 48;
  v3 = 160;
  v4 = 48;
  v5 = 176;
  v6 = 64;
  v7 = 176;
  v8 = 48;
  v9 = 192;
  v10 = 64;
  v11 = 192;
  v12 = 48;
  v13 = 208;
  v14 = 64;
  switch ( *((_DWORD *)npc + 29) )
  {
    case 0:
      *((_DWORD *)npc + 29) = 1;
      *((_DWORD *)npc + 26) = 2;
      if ( *((_DWORD *)npc + 2) <= quote.XPos )
        *((_DWORD *)npc + 19) = 2;
      else
        *((_DWORD *)npc + 19) = 0;
      goto LABEL_5;
    case 1:
LABEL_5:
      if ( ++*((_DWORD *)npc + 30) > 16 )
      {
        *((_DWORD *)npc + 29) = 10;
        *((_DWORD *)npc + 36) = 4096;
        *((_DWORD *)npc + 38) = 4096;
        *((_DWORD *)npc + 41) = 2;
        *((_WORD *)npc + 40) |= 0x20u;
      }
      goto LABEL_24;
    case 0xA:
      if ( *((_DWORD *)npc + 1) & 8 )
      {
        *((_DWORD *)npc + 29) = 11;
        *((_DWORD *)npc + 26) = 0;
        *((_DWORD *)npc + 30) = 0;
        *((_DWORD *)npc + 4) = 0;
        if ( *((_DWORD *)npc + 2) <= quote.XPos )
          *((_DWORD *)npc + 19) = 2;
        else
          *((_DWORD *)npc + 19) = 0;
      }
      goto LABEL_24;
    case 0xB:
      if ( ++*((_DWORD *)npc + 30) > 10 )
      {
        if ( ++*((_DWORD *)npc + 27) <= 4 )
          *((_DWORD *)npc + 29) = 10;
        else
          *((_DWORD *)npc + 29) = 12;
        playSoundEffect(SFXCritterHop, 1);
        *((_DWORD *)npc + 5) = -1536;
        if ( *((_DWORD *)npc + 19) )
          *((_DWORD *)npc + 4) = 512;
        else
          *((_DWORD *)npc + 4) = -512;
        *((_DWORD *)npc + 26) = 2;
      }
      goto LABEL_24;
    case 0xC:
      *((_WORD *)npc + 40) |= 8u;
      if ( *((_DWORD *)npc + 3) <= currentMap.length << 13 )
        goto LABEL_24;
      Vanish_NPC((NPC *)npc);
      break;
    default:
LABEL_24:
      if ( *((_DWORD *)npc + 29) >= 10 )
        *((_DWORD *)npc + 5) += 64;
      if ( *((_DWORD *)npc + 5) > 1535 )
        *((_DWORD *)npc + 5) = 1535;
      *((_DWORD *)npc + 2) += *((_DWORD *)npc + 4);
      *((_DWORD *)npc + 3) += *((_DWORD *)npc + 5);
      if ( *((_DWORD *)npc + 19) )
        v1 = &v3 + 4 * *((_DWORD *)npc + 26);
      else
        v1 = &v15 + 4 * *((_DWORD *)npc + 26);
      v2 = (int *)((char *)npc + 84);
      *v2 = *v1;
      v2[1] = v1[1];
      v2[2] = v1[2];
      v2[3] = v1[3];
      if ( *((_DWORD *)npc + 29) == 1 )
      {
        *((_DWORD *)npc + 22) += 8 - *((_DWORD *)npc + 30) / 2;
        *((_DWORD *)npc + 24) -= *((_DWORD *)npc + 30) / 2 + 8;
        *((_DWORD *)npc + 36) = (*((_DWORD *)npc + 30) << 9) / 2;
        *((_DWORD *)npc + 38) = (*((_DWORD *)npc + 30) << 9) / 2;
      }
      break;
  }
}

//----- (004614A0) --------------------------------------------------------
void __cdecl NPC290(void *npc)
{
  int v1; // ecx
  int v2; // edx
  int *v3; // ecx
  int *v4; // edx
  int v5; // [esp+0h] [ebp-64h]
  int v6; // [esp+4h] [ebp-60h]
  int v7; // [esp+8h] [ebp-5Ch]
  int v8; // [esp+Ch] [ebp-58h]
  int v9; // [esp+10h] [ebp-54h]
  int v10; // [esp+14h] [ebp-50h]
  int v11; // [esp+18h] [ebp-4Ch]
  int v12; // [esp+1Ch] [ebp-48h]
  int v13; // [esp+20h] [ebp-44h]
  int v14; // [esp+24h] [ebp-40h]
  int v15; // [esp+28h] [ebp-3Ch]
  int v16; // [esp+2Ch] [ebp-38h]
  int v17; // [esp+30h] [ebp-34h]
  int v18; // [esp+34h] [ebp-30h]
  int v19; // [esp+38h] [ebp-2Ch]
  int v20; // [esp+3Ch] [ebp-28h]
  int v21; // [esp+40h] [ebp-24h]
  int v22; // [esp+44h] [ebp-20h]
  int v23; // [esp+48h] [ebp-1Ch]
  int v24; // [esp+4Ch] [ebp-18h]
  int v25; // [esp+50h] [ebp-14h]
  int v26; // [esp+54h] [ebp-10h]
  int v27; // [esp+58h] [ebp-Ch]
  int v28; // [esp+5Ch] [ebp-8h]
  int v29; // [esp+60h] [ebp-4h]

  v18 = 112;
  v19 = 32;
  v20 = 128;
  v21 = 48;
  v22 = 128;
  v23 = 32;
  v24 = 144;
  v25 = 48;
  v26 = 144;
  v27 = 32;
  v28 = 160;
  v29 = 48;
  v6 = 112;
  v7 = 48;
  v8 = 128;
  v9 = 64;
  v10 = 128;
  v11 = 48;
  v12 = 144;
  v13 = 64;
  v14 = 144;
  v15 = 48;
  v16 = 160;
  v17 = 64;
  v5 = *((_DWORD *)npc + 29);
  switch ( v5 )
  {
    case 0:
      *((_DWORD *)npc + 29) = 1;
      *((_DWORD *)npc + 26) = 2;
      if ( *((_DWORD *)npc + 2) <= quote.XPos )
        *((_DWORD *)npc + 19) = 2;
      else
        *((_DWORD *)npc + 19) = 0;
LABEL_8:
      if ( ++*((_DWORD *)npc + 30) > 16 )
      {
        *((_DWORD *)npc + 29) = 10;
        *((_DWORD *)npc + 36) = 4096;
        *((_DWORD *)npc + 38) = 4096;
        *((_DWORD *)npc + 41) = 2;
        *((_WORD *)npc + 40) |= 0x20u;
        *((_DWORD *)npc + 9) = *((_DWORD *)npc + 3);
        *((_DWORD *)npc + 5) = 1024;
      }
      break;
    case 1:
      goto LABEL_8;
    case 10:
      if ( ++*((_DWORD *)npc + 25) > 2 )
      {
        *((_DWORD *)npc + 25) = 0;
        ++*((_DWORD *)npc + 26);
      }
      if ( *((_DWORD *)npc + 26) > 2 )
        *((_DWORD *)npc + 26) = 0;
      v1 = *((_DWORD *)npc + 3) >= *((_DWORD *)npc + 9) ? *((_DWORD *)npc + 5) - 64 : *((_DWORD *)npc + 5) + 64;
      *((_DWORD *)npc + 5) = v1;
      v2 = *((_DWORD *)npc + 19) ? *((_DWORD *)npc + 4) + 16 : *((_DWORD *)npc + 4) - 16;
      *((_DWORD *)npc + 4) = v2;
      if ( *((_DWORD *)npc + 2) < 0
        || *((_DWORD *)npc + 3) < 0
        || *((_DWORD *)npc + 2) > currentMap.width << 13
        || *((_DWORD *)npc + 3) > currentMap.length << 13 )
      {
        Vanish_NPC((NPC *)npc);
        return;
      }
      break;
  }
  *((_DWORD *)npc + 2) += *((_DWORD *)npc + 4);
  *((_DWORD *)npc + 3) += *((_DWORD *)npc + 5);
  if ( *((_DWORD *)npc + 19) )
    v3 = &v6 + 4 * *((_DWORD *)npc + 26);
  else
    v3 = &v18 + 4 * *((_DWORD *)npc + 26);
  v4 = (int *)((char *)npc + 84);
  *v4 = *v3;
  v4[1] = v3[1];
  v4[2] = v3[2];
  v4[3] = v3[3];
  if ( *((_DWORD *)npc + 29) == 1 )
  {
    *((_DWORD *)npc + 22) += 8 - *((_DWORD *)npc + 30) / 2;
    *((_DWORD *)npc + 24) -= *((_DWORD *)npc + 30) / 2 + 8;
    *((_DWORD *)npc + 36) = (*((_DWORD *)npc + 30) << 9) / 2;
    *((_DWORD *)npc + 38) = (*((_DWORD *)npc + 30) << 9) / 2;
  }
}

//----- (00461800) --------------------------------------------------------
int __cdecl NPC291(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  int v4; // [esp+4h] [ebp-20h]
  int v5; // [esp+8h] [ebp-1Ch]
  int v6; // [esp+Ch] [ebp-18h]
  int v7; // [esp+10h] [ebp-14h]
  int v8; // [esp+14h] [ebp-10h]
  int v9; // [esp+18h] [ebp-Ch]
  int v10; // [esp+1Ch] [ebp-8h]
  int v11; // [esp+20h] [ebp-4h]

  v4 = 256;
  v5 = 80;
  v6 = 320;
  v7 = 120;
  v8 = 256;
  v9 = 0;
  v10 = 320;
  v11 = 40;
  if ( !*(_DWORD *)(a1 + 116) )
  {
    *(_DWORD *)(a1 + 116) = 20;
    if ( *(_DWORD *)(a1 + 76) == 2 )
    {
      *(_WORD *)(a1 + 80) &= 0xFFBFu;
      *(_DWORD *)(a1 + 104) = 1;
    }
  }
  v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}

//----- (004618B0) --------------------------------------------------------
void NPC292()
{
  setQuake(10);
}

//----- (004618C0) --------------------------------------------------------
int __cdecl NPC293(int a1)
{
  int v1; // ST08_4
  int v2; // eax
  int *v3; // eax
  int *v4; // ecx
  int result; // eax
  int v6; // [esp+0h] [ebp-24h]
  int v7; // [esp+4h] [ebp-20h]
  int v8; // [esp+8h] [ebp-1Ch]
  int v9; // [esp+Ch] [ebp-18h]
  int v10; // [esp+10h] [ebp-14h]
  int v11; // [esp+14h] [ebp-10h]
  int v12; // [esp+18h] [ebp-Ch]
  int v13; // [esp+1Ch] [ebp-8h]
  int v14; // [esp+20h] [ebp-4h]

  v7 = 240;
  v8 = 200;
  v9 = 280;
  v10 = 240;
  v11 = 280;
  v12 = 200;
  v13 = 320;
  v14 = 240;
  v6 = *(_DWORD *)(a1 + 116);
  if ( v6 )
  {
    if ( v6 != 1 )
      goto LABEL_9;
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
  }
  if ( ++*(_DWORD *)(a1 + 104) > 1 )
    *(_DWORD *)(a1 + 104) = 0;
  v1 = *(_DWORD *)(a1 + 12) + (random(-16, 16) << 9);
  v2 = random(0, 16);
  createNPC(NPCSmoke, *(_DWORD *)(a1 + 8) + (v2 << 9), v1, 0, 0, 0, 0, 256);
  *(_DWORD *)(a1 + 8) -= 4096;
  if ( *(_DWORD *)(a1 + 8) < -16384 )
    *(_BYTE *)a1 = 0;
LABEL_9:
  v3 = &v7 + 4 * *(_DWORD *)(a1 + 104);
  v4 = (int *)(a1 + 84);
  *v4 = *v3;
  v4[1] = v3[1];
  v4[2] = v3[2];
  result = v3[3];
  v4[3] = result;
  return result;
}

//----- (004619E0) --------------------------------------------------------
int __cdecl NPC294(int a1)
{
  int result; // eax
  int v2; // eax
  int v3; // [esp+0h] [ebp-10h]
  int X_Pos; // [esp+8h] [ebp-8h]
  int Y_Pos; // [esp+Ch] [ebp-4h]

  result = a1;
  v3 = *(_DWORD *)(a1 + 116);
  if ( v3 )
  {
    if ( v3 == 1 )
    {
      ++*(_DWORD *)(a1 + 120);
      if ( quote.equippedItems & 0x20 )
      {
        *(_DWORD *)(a1 + 8) = quote.XPos + 0x8000;
        if ( *(_DWORD *)(a1 + 8) < 212992 )
          *(_DWORD *)(a1 + 8) = 212992;
      }
      else
      {
        *(_DWORD *)(a1 + 8) = quote.XPos + 49152;
        if ( *(_DWORD *)(a1 + 8) < 188416 )
          *(_DWORD *)(a1 + 8) = 188416;
      }
      if ( *(_DWORD *)(a1 + 8) > (currentMap.width - 10) << 13 )
        *(_DWORD *)(a1 + 8) = (currentMap.width - 10) << 13;
      result = a1;
      if ( *(_DWORD *)(a1 + 120) > 24 )
      {
        if ( quote.equippedItems & 0x20 )
          v2 = random(-14, 14);
        else
          v2 = random(-11, 11);
        X_Pos = *(_DWORD *)(a1 + 8) + (v2 << 13);
        Y_Pos = quote.YPos - 114688;
        if ( random(0, 10) % 2 )
          createNPC(NPCEnemyBasil|0x110, X_Pos, Y_Pos, 0, 0, 0, 0, 256);
        else
          createNPC(NPCEnemyBasil|0x110, X_Pos, Y_Pos, 0, 0, right, 0, 256);
        result = random(0, 15);
        *(_DWORD *)(a1 + 120) = result;
      }
    }
  }
  else if ( quote.XPos < (currentMap.width - 6) << 13 )
  {
    result = a1;
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 120) = 0;
  }
  return result;
}

//----- (00461B90) --------------------------------------------------------
int *__cdecl NPC295(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+4h] [ebp-44h]
  int v4; // [esp+8h] [ebp-40h]
  int v5; // [esp+Ch] [ebp-3Ch]
  int v6; // [esp+10h] [ebp-38h]
  int v7; // [esp+14h] [ebp-34h]
  int v8; // [esp+18h] [ebp-30h]
  int v9; // [esp+1Ch] [ebp-2Ch]
  int v10; // [esp+20h] [ebp-28h]
  int v11; // [esp+24h] [ebp-24h]
  int v12; // [esp+28h] [ebp-20h]
  int v13; // [esp+2Ch] [ebp-1Ch]
  int v14; // [esp+30h] [ebp-18h]
  int v15; // [esp+34h] [ebp-14h]
  int v16; // [esp+38h] [ebp-10h]
  int v17; // [esp+3Ch] [ebp-Ch]
  int v18; // [esp+40h] [ebp-8h]
  int v19; // [esp+44h] [ebp-4h]

  v4 = 0;
  v5 = 0;
  v6 = 208;
  v7 = 64;
  v8 = 32;
  v9 = 64;
  v10 = 144;
  v11 = 96;
  v12 = 32;
  v13 = 96;
  v14 = 104;
  v15 = 128;
  v16 = 104;
  v17 = 96;
  v18 = 144;
  v19 = 128;
  v3 = *(_DWORD *)(a1 + 116);
  if ( v3 )
  {
    if ( v3 == 1 )
    {
      *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
      if ( *(_DWORD *)(a1 + 8) < -32768 )
        *(_BYTE *)a1 = 0;
      if ( *(_DWORD *)(a1 + 12) < -16384 )
        *(_BYTE *)a1 = 0;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 104) = *(_DWORD *)(a1 + 76) % 4;
    switch ( *(_DWORD *)(a1 + 76) )
    {
      case 0:
        *(_DWORD *)(a1 + 20) = -4096;
        *(_DWORD *)(a1 + 148) = 53248;
        *(_DWORD *)(a1 + 140) = 53248;
        break;
      case 1:
        *(_DWORD *)(a1 + 20) = -2048;
        *(_DWORD *)(a1 + 148) = 28672;
        *(_DWORD *)(a1 + 140) = 28672;
        break;
      case 2:
        *(_DWORD *)(a1 + 20) = -1024;
        *(_DWORD *)(a1 + 148) = 0x4000;
        *(_DWORD *)(a1 + 140) = 0x4000;
        break;
      case 3:
        *(_DWORD *)(a1 + 20) = -512;
        *(_DWORD *)(a1 + 148) = 10240;
        *(_DWORD *)(a1 + 140) = 10240;
        break;
      case 4:
        *(_DWORD *)(a1 + 16) = -1024;
        *(_DWORD *)(a1 + 148) = 53248;
        *(_DWORD *)(a1 + 140) = 53248;
        break;
      case 5:
        *(_DWORD *)(a1 + 16) = -512;
        *(_DWORD *)(a1 + 148) = 28672;
        *(_DWORD *)(a1 + 140) = 28672;
        break;
      case 6:
        *(_DWORD *)(a1 + 16) = -256;
        *(_DWORD *)(a1 + 148) = 0x4000;
        *(_DWORD *)(a1 + 140) = 0x4000;
        break;
      case 7:
        *(_DWORD *)(a1 + 16) = -128;
        *(_DWORD *)(a1 + 148) = 10240;
        *(_DWORD *)(a1 + 140) = 10240;
        break;
      default:
        break;
    }
  }
  v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (00461E40) --------------------------------------------------------
void __cdecl NPC296(int a1)
{
  int v1; // eax
  int v2; // eax
  int X_Pos; // ST30_4
  int v4; // eax
  signed int Start_Index; // [esp+8h] [ebp-10h]
  int Direction; // [esp+Ch] [ebp-Ch]

  if ( ++*(_DWORD *)(a1 + 120) > 16 )
  {
    *(_DWORD *)(a1 + 120) = random(0, 16);
    v1 = random(0, 100) % 4;
    Direction = v1;
    if ( *(_DWORD *)(a1 + 76) )
    {
      switch ( v1 )
      {
        case 0:
          Start_Index = 128;
          break;
        case 1:
          Start_Index = 85;
          break;
        case 2:
          Start_Index = 64;
          break;
        case 3:
          Start_Index = 0;
          break;
        default:
          break;
      }
      X_Pos = *(_DWORD *)(a1 + 8);
      v4 = random(-7, 7);
      createNPC(
        NPCEnemyBasil|0x120,
        X_Pos,
        *(_DWORD *)(a1 + 12) + (v4 << 13),
        0,
        0,
        (Directions)(Direction + 4),
        0,
        Start_Index);
    }
    else
    {
      switch ( v1 )
      {
        case 0:
          Start_Index = 384;
          break;
        case 1:
          Start_Index = 128;
          break;
        case 2:
          Start_Index = 64;
          break;
        case 3:
          Start_Index = 0;
          break;
        default:
          break;
      }
      v2 = random(-10, 10);
      createNPC(
        NPCEnemyBasil|0x120,
        *(_DWORD *)(a1 + 8) + (v2 << 13),
        *(_DWORD *)(a1 + 12),
        0,
        0,
        (Directions)Direction,
        0,
        Start_Index);
    }
  }
}

//----- (00461FD0) --------------------------------------------------------
signed int __cdecl NPC297(int a1)
{
  _DWORD *v1; // edx
  signed int result; // eax

  *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) + 0x2000;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12) + 4096;
  v1 = (_DWORD *)(a1 + 84);
  *v1 = 112;
  v1[1] = 48;
  result = 128;
  v1[2] = 128;
  v1[3] = 64;
  return result;
}

//----- (00462050) --------------------------------------------------------
int *__cdecl NPC298(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+4h] [ebp-80h]
  int v4; // [esp+8h] [ebp-7Ch]
  int v5; // [esp+Ch] [ebp-78h]
  int v6; // [esp+10h] [ebp-74h]
  int v7; // [esp+14h] [ebp-70h]
  int v8; // [esp+18h] [ebp-6Ch]
  int v9; // [esp+1Ch] [ebp-68h]
  int v10; // [esp+20h] [ebp-64h]
  int v11; // [esp+24h] [ebp-60h]
  int v12; // [esp+28h] [ebp-5Ch]
  int v13; // [esp+2Ch] [ebp-58h]
  int v14; // [esp+30h] [ebp-54h]
  int v15; // [esp+34h] [ebp-50h]
  int v16; // [esp+38h] [ebp-4Ch]
  int v17; // [esp+3Ch] [ebp-48h]
  int v18; // [esp+40h] [ebp-44h]
  int v19; // [esp+44h] [ebp-40h]
  int v20; // [esp+48h] [ebp-3Ch]
  int v21; // [esp+4Ch] [ebp-38h]
  int v22; // [esp+50h] [ebp-34h]
  int v23; // [esp+54h] [ebp-30h]
  int v24; // [esp+58h] [ebp-2Ch]
  int v25; // [esp+5Ch] [ebp-28h]
  int v26; // [esp+60h] [ebp-24h]
  int v27; // [esp+64h] [ebp-20h]
  int v28; // [esp+68h] [ebp-1Ch]
  int v29; // [esp+6Ch] [ebp-18h]
  int v30; // [esp+70h] [ebp-14h]
  int v31; // [esp+74h] [ebp-10h]
  int v32; // [esp+78h] [ebp-Ch]
  int v33; // [esp+7Ch] [ebp-8h]
  int v34; // [esp+80h] [ebp-4h]

  v3 = 72;
  v4 = 128;
  v5 = 88;
  v6 = 160;
  v7 = 88;
  v8 = 128;
  v9 = 104;
  v10 = 160;
  v11 = 104;
  v12 = 128;
  v13 = 120;
  v14 = 160;
  v15 = 72;
  v16 = 128;
  v17 = 88;
  v18 = 160;
  v19 = 120;
  v20 = 128;
  v21 = 136;
  v22 = 160;
  v23 = 72;
  v24 = 128;
  v25 = 88;
  v26 = 160;
  v27 = 104;
  v28 = 160;
  v29 = 120;
  v30 = 192;
  v31 = 120;
  v32 = 160;
  v33 = 136;
  v34 = 192;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 12) -= 4096;
      goto LABEL_3;
    case 1:
LABEL_3:
      *(_DWORD *)(a1 + 104) = 0;
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 100) = 0;
      *(_DWORD *)(a1 + 108) = 0;
      goto LABEL_5;
    case 0xB:
LABEL_5:
      if ( ++*(_DWORD *)(a1 + 100) > 6 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 1 )
      {
        *(_DWORD *)(a1 + 104) = 0;
        if ( ++*(_DWORD *)(a1 + 108) > 7 )
        {
          *(_DWORD *)(a1 + 104) = 0;
          *(_DWORD *)(a1 + 116) = 1;
        }
      }
      break;
    case 0x14:
      *(_DWORD *)(a1 + 116) = 21;
      *(_DWORD *)(a1 + 104) = 2;
      *(_DWORD *)(a1 + 100) = 0;
      goto LABEL_12;
    case 0x15:
LABEL_12:
      if ( ++*(_DWORD *)(a1 + 100) > 10 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 5 )
        *(_DWORD *)(a1 + 104) = 2;
      *(_DWORD *)(a1 + 8) += 256;
      break;
    case 0x1E:
      *(_DWORD *)(a1 + 104) = 6;
      break;
    case 0x28:
      *(_DWORD *)(a1 + 116) = 41;
      *(_DWORD *)(a1 + 104) = 6;
      *(_DWORD *)(a1 + 100) = 0;
      *(_DWORD *)(a1 + 108) = 0;
      goto LABEL_19;
    case 0x29:
LABEL_19:
      if ( ++*(_DWORD *)(a1 + 100) > 6 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 7 )
      {
        *(_DWORD *)(a1 + 104) = 6;
        if ( ++*(_DWORD *)(a1 + 108) > 7 )
        {
          *(_DWORD *)(a1 + 104) = 6;
          *(_DWORD *)(a1 + 116) = 30;
        }
      }
      break;
    default:
      break;
  }
  v1 = &v3 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (004623D0) --------------------------------------------------------
int __cdecl NPC299(int a1)
{
  int v1; // eax
  int *v2; // ecx
  int *v3; // edx
  int result; // eax
  int v5; // [esp+0h] [ebp-20h]
  int v6; // [esp+4h] [ebp-1Ch]
  int v7; // [esp+8h] [ebp-18h]
  int v8; // [esp+Ch] [ebp-14h]
  int v9; // [esp+10h] [ebp-10h]
  int v10; // [esp+14h] [ebp-Ch]
  int v11; // [esp+18h] [ebp-8h]
  int v12; // [esp+1Ch] [ebp-4h]

  v5 = 0;
  v6 = 0;
  v7 = 48;
  v8 = 48;
  v9 = 48;
  v10 = 0;
  v11 = 96;
  v12 = 48;
  if ( !*(_DWORD *)(a1 + 116) )
  {
    *(_DWORD *)(a1 + 116) = 1;
    if ( *(_DWORD *)(a1 + 76) )
    {
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 120) = 0;
    }
    else
    {
      *(_DWORD *)(a1 + 104) = 1;
      *(_DWORD *)(a1 + 120) = 25;
      *(_DWORD *)(a1 + 12) -= 1600;
    }
  }
  if ( ++*(_DWORD *)(a1 + 120) / 50 % 2 )
    v1 = *(_DWORD *)(a1 + 12) + 64;
  else
    v1 = *(_DWORD *)(a1 + 12) - 64;
  *(_DWORD *)(a1 + 12) = v1;
  v2 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  v3 = (int *)(a1 + 84);
  *v3 = *v2;
  v3[1] = v2[1];
  result = v2[2];
  v3[2] = result;
  v3[3] = v2[3];
  return result;
}

//----- (004624E0) --------------------------------------------------------
signed int __cdecl NPC300(int a1)
{
  int v1; // ST08_4
  int v2; // eax
  _DWORD *v3; // edx
  signed int result; // eax

  if ( !*(_DWORD *)(a1 + 116) )
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 12) += 3072;
  }
  if ( ++*(_DWORD *)(a1 + 100) % 8 == 1 )
  {
    v1 = *(_DWORD *)(a1 + 12) + 4096;
    v2 = random(-8, 8);
    createEffect(*(_DWORD *)(a1 + 8) + (v2 << 9), v1, effectUnknownUnused, up);
  }
  v3 = (_DWORD *)(a1 + 84);
  *v3 = 192;
  v3[1] = 80;
  result = 208;
  v3[2] = 208;
  v3[3] = 96;
  return result;
}

//----- (004625A0) --------------------------------------------------------
int __cdecl NPC301(int a1)
{
  int v1; // eax
  int v2; // edx
  int *v3; // eax
  int *v4; // ecx
  int result; // eax
  int v6; // [esp+0h] [ebp-88h]
  int v7; // [esp+4h] [ebp-84h]
  int v8; // [esp+8h] [ebp-80h]
  int v9; // [esp+Ch] [ebp-7Ch]
  int v10; // [esp+10h] [ebp-78h]
  int v11; // [esp+14h] [ebp-74h]
  int v12; // [esp+18h] [ebp-70h]
  int v13; // [esp+1Ch] [ebp-6Ch]
  int v14; // [esp+20h] [ebp-68h]
  int v15; // [esp+24h] [ebp-64h]
  int v16; // [esp+28h] [ebp-60h]
  int v17; // [esp+2Ch] [ebp-5Ch]
  int v18; // [esp+30h] [ebp-58h]
  int v19; // [esp+34h] [ebp-54h]
  int v20; // [esp+38h] [ebp-50h]
  int v21; // [esp+3Ch] [ebp-4Ch]
  int v22; // [esp+40h] [ebp-48h]
  int v23; // [esp+44h] [ebp-44h]
  int v24; // [esp+48h] [ebp-40h]
  int v25; // [esp+4Ch] [ebp-3Ch]
  int v26; // [esp+50h] [ebp-38h]
  int v27; // [esp+54h] [ebp-34h]
  int v28; // [esp+58h] [ebp-30h]
  int v29; // [esp+5Ch] [ebp-2Ch]
  int v30; // [esp+60h] [ebp-28h]
  int v31; // [esp+64h] [ebp-24h]
  int v32; // [esp+68h] [ebp-20h]
  int v33; // [esp+6Ch] [ebp-1Ch]
  int v34; // [esp+70h] [ebp-18h]
  int v35; // [esp+74h] [ebp-14h]
  int v36; // [esp+78h] [ebp-10h]
  int v37; // [esp+7Ch] [ebp-Ch]
  int v38; // [esp+80h] [ebp-8h]
  int v39; // [esp+84h] [ebp-4h]

  v8 = 144;
  v9 = 0;
  v10 = 160;
  v11 = 16;
  v12 = 160;
  v13 = 0;
  v14 = 176;
  v15 = 16;
  v16 = 176;
  v17 = 0;
  v18 = 192;
  v19 = 16;
  v20 = 192;
  v21 = 0;
  v22 = 208;
  v23 = 16;
  v24 = 144;
  v25 = 16;
  v26 = 160;
  v27 = 32;
  v28 = 160;
  v29 = 16;
  v30 = 176;
  v31 = 32;
  v32 = 176;
  v33 = 16;
  v34 = 192;
  v35 = 32;
  v36 = 192;
  v37 = 16;
  v38 = 208;
  v39 = 32;
  v6 = *(_DWORD *)(a1 + 116);
  if ( v6 )
  {
    if ( v6 != 1 )
      goto LABEL_18;
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 108) = *(_DWORD *)(a1 + 76);
  }
  *(_DWORD *)(a1 + 16) = 2 * getCos(*(_BYTE *)(a1 + 108));
  *(_DWORD *)(a1 + 20) = 2 * getSin(*(_BYTE *)(a1 + 108));
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  v7 = getArcTan(*(_DWORD *)(a1 + 8) - quote.XPos, *(_DWORD *)(a1 + 12) - quote.YPos);
  if ( v7 >= *(_DWORD *)(a1 + 108) )
  {
    if ( v7 - *(_DWORD *)(a1 + 108) >= 128 )
      v2 = *(_DWORD *)(a1 + 108) - 1;
    else
      v2 = *(_DWORD *)(a1 + 108) + 1;
    *(_DWORD *)(a1 + 108) = v2;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 108) - v7 >= 128 )
      v1 = *(_DWORD *)(a1 + 108) + 1;
    else
      v1 = *(_DWORD *)(a1 + 108) - 1;
    *(_DWORD *)(a1 + 108) = v1;
  }
  if ( *(_DWORD *)(a1 + 108) > 255 )
    *(_DWORD *)(a1 + 108) -= 256;
  if ( *(_DWORD *)(a1 + 108) < 0 )
    *(_DWORD *)(a1 + 108) += 256;
LABEL_18:
  if ( ++*(_DWORD *)(a1 + 100) > 2 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectDrownedQuote, (Directions)4);
  }
  *(_DWORD *)(a1 + 104) = (*(_DWORD *)(a1 + 108) + 16) / 32;
  if ( *(_DWORD *)(a1 + 104) > 7 )
    *(_DWORD *)(a1 + 104) = 7;
  v3 = &v8 + 4 * *(_DWORD *)(a1 + 104);
  v4 = (int *)(a1 + 84);
  *v4 = *v3;
  v4[1] = v3[1];
  v4[2] = v3[2];
  result = v3[3];
  v4[3] = result;
  return result;
}

//----- (00462890) --------------------------------------------------------
void __cdecl NPC302(NPC *npc)
{
  signed int i; // [esp+8h] [ebp-4h]

  switch ( npc->currentState )
  {
    case 10:
      npc->XPos = quote.XPos;
      npc->YPos = quote.YPos - 16384;
      break;
    case 20:
      switch ( npc->direction )
      {
        case 0:
          npc->XPos -= 1024;
          break;
        case 1:
          npc->YPos -= 1024;
          break;
        case 2:
          npc->XPos += 1024;
          break;
        case 3:
          npc->YPos += 1024;
          break;
        default:
          break;
      }
      quote.XPos = npc->XPos;
      quote.YPos = npc->YPos;
      break;
    case 30:
      npc->XPos = quote.XPos;
      npc->YPos = quote.YPos + 40960;
      break;
    case 100:
      npc->currentState = 101;
      if ( !npc->direction )
      {
        npc->parentNPC = bossObjects;
        goto LABEL_21;
      }
      for ( i = 170; i < 512; ++i )
      {
        if ( NPCObjects[i].isAlive & 0x80 && NPCObjects[i].entityEventNum == npc->direction )
        {
          npc->parentNPC = &NPCObjects[i];
          break;
        }
      }
      if ( i != 512 )
        goto LABEL_21;
      npc->isAlive = 0;
      break;
    case 101:
LABEL_21:
      npc->XPos = (npc->parentNPC->XPos + quote.XPos) / 2;
      npc->YPos = (npc->parentNPC->YPos + quote.YPos) / 2;
      break;
    default:
      return;
  }
}

//----- (00462AF0) --------------------------------------------------------
int __cdecl NPC303(int a1)
{
  int result; // eax
  int *v2; // ecx
  int *v3; // edx
  int v4; // [esp+0h] [ebp-40h]
  int v5; // [esp+4h] [ebp-3Ch]
  int v6; // [esp+8h] [ebp-38h]
  int v7; // [esp+Ch] [ebp-34h]
  int v8; // [esp+10h] [ebp-30h]
  int v9; // [esp+14h] [ebp-2Ch]
  int v10; // [esp+18h] [ebp-28h]
  int v11; // [esp+1Ch] [ebp-24h]
  int v12; // [esp+20h] [ebp-20h]
  int v13; // [esp+24h] [ebp-1Ch]
  int v14; // [esp+28h] [ebp-18h]
  int v15; // [esp+2Ch] [ebp-14h]
  int v16; // [esp+30h] [ebp-10h]
  int v17; // [esp+34h] [ebp-Ch]
  int v18; // [esp+38h] [ebp-8h]
  int v19; // [esp+3Ch] [ebp-4h]

  v12 = 216;
  v13 = 152;
  v14 = 232;
  v15 = 168;
  v16 = 232;
  v17 = 152;
  v18 = 248;
  v19 = 168;
  v4 = 216;
  v5 = 168;
  v6 = 232;
  v7 = 184;
  v8 = 232;
  v9 = 168;
  v10 = 248;
  v11 = 184;
  result = a1;
  if ( *(_DWORD *)(a1 + 168) )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 76) )
    {
      *(_DWORD *)(a1 + 76) = 2;
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) + 4096;
    }
    else
    {
      *(_DWORD *)(a1 + 76) = 0;
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) - 4096;
    }
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12);
    *(_DWORD *)(a1 + 104) = 0;
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 104) == 3 || *(_DWORD *)(*(_DWORD *)(a1 + 168) + 104) == 5 )
      *(_DWORD *)(a1 + 12) -= 512;
    if ( *(_DWORD *)(a1 + 76) )
      v2 = &v4 + 4 * *(_DWORD *)(a1 + 104);
    else
      v2 = &v12 + 4 * *(_DWORD *)(a1 + 104);
    v3 = (int *)(a1 + 84);
    *v3 = *v2;
    v3[1] = v2[1];
    result = v2[2];
    v3[2] = result;
    v3[3] = v2[3];
  }
  return result;
}

//----- (00462C80) --------------------------------------------------------
int __cdecl NPC304(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+4h] [ebp-40h]
  int v5; // [esp+8h] [ebp-3Ch]
  int v6; // [esp+Ch] [ebp-38h]
  int v7; // [esp+10h] [ebp-34h]
  int v8; // [esp+14h] [ebp-30h]
  int v9; // [esp+18h] [ebp-2Ch]
  int v10; // [esp+1Ch] [ebp-28h]
  int v11; // [esp+20h] [ebp-24h]
  int v12; // [esp+24h] [ebp-20h]
  int v13; // [esp+28h] [ebp-1Ch]
  int v14; // [esp+2Ch] [ebp-18h]
  int v15; // [esp+30h] [ebp-14h]
  int v16; // [esp+34h] [ebp-10h]
  int v17; // [esp+38h] [ebp-Ch]
  int v18; // [esp+3Ch] [ebp-8h]
  int v19; // [esp+40h] [ebp-4h]

  v4 = 0;
  v5 = 176;
  v6 = 24;
  v7 = 192;
  v8 = 24;
  v9 = 176;
  v10 = 48;
  v11 = 192;
  v12 = 48;
  v13 = 176;
  v14 = 72;
  v15 = 192;
  v16 = 72;
  v17 = 176;
  v18 = 96;
  v19 = 192;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 12) += 5120;
      goto LABEL_3;
    case 1:
LABEL_3:
      *(_DWORD *)(a1 + 104) = 0;
      break;
    case 0xA:
      *(_DWORD *)(a1 + 104) = 1;
      break;
    case 0x14:
      *(_DWORD *)(a1 + 116) = 21;
      *(_DWORD *)(a1 + 104) = 2;
      goto LABEL_6;
    case 0x15:
LABEL_6:
      if ( ++*(_DWORD *)(a1 + 100) > 10 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 3 )
        *(_DWORD *)(a1 + 104) = 2;
      break;
    default:
      break;
  }
  v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (00462E00) --------------------------------------------------------
int __cdecl NPC305(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+0h] [ebp-44h]
  int v5; // [esp+4h] [ebp-40h]
  int v6; // [esp+8h] [ebp-3Ch]
  int v7; // [esp+Ch] [ebp-38h]
  int v8; // [esp+10h] [ebp-34h]
  int v9; // [esp+14h] [ebp-30h]
  int v10; // [esp+18h] [ebp-2Ch]
  int v11; // [esp+1Ch] [ebp-28h]
  int v12; // [esp+20h] [ebp-24h]
  int v13; // [esp+24h] [ebp-20h]
  int v14; // [esp+28h] [ebp-1Ch]
  int v15; // [esp+2Ch] [ebp-18h]
  int v16; // [esp+30h] [ebp-14h]
  int v17; // [esp+34h] [ebp-10h]
  int v18; // [esp+38h] [ebp-Ch]
  int v19; // [esp+3Ch] [ebp-8h]
  int v20; // [esp+40h] [ebp-4h]

  v13 = 160;
  v14 = 144;
  v15 = 176;
  v16 = 160;
  v17 = 176;
  v18 = 144;
  v19 = 192;
  v20 = 160;
  v5 = 160;
  v6 = 160;
  v7 = 176;
  v8 = 176;
  v9 = 176;
  v10 = 160;
  v11 = 192;
  v12 = 176;
  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 != 1 )
      goto LABEL_9;
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 12) -= 0x2000;
    *(_DWORD *)(a1 + 100) = random(0, 6);
  }
  if ( ++*(_DWORD *)(a1 + 100) > 6 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 1 )
    *(_DWORD *)(a1 + 104) = 0;
LABEL_9:
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v13 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (00462F60) --------------------------------------------------------
int *__cdecl NPC306(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+0h] [ebp-44h]
  int v4; // [esp+4h] [ebp-40h]
  int v5; // [esp+8h] [ebp-3Ch]
  int v6; // [esp+Ch] [ebp-38h]
  int v7; // [esp+10h] [ebp-34h]
  int v8; // [esp+14h] [ebp-30h]
  int v9; // [esp+18h] [ebp-2Ch]
  int v10; // [esp+1Ch] [ebp-28h]
  int v11; // [esp+20h] [ebp-24h]
  int v12; // [esp+24h] [ebp-20h]
  int v13; // [esp+28h] [ebp-1Ch]
  int v14; // [esp+2Ch] [ebp-18h]
  int v15; // [esp+30h] [ebp-14h]
  int v16; // [esp+34h] [ebp-10h]
  int v17; // [esp+38h] [ebp-Ch]
  int v18; // [esp+3Ch] [ebp-8h]
  int v19; // [esp+40h] [ebp-4h]

  v12 = 240;
  v13 = 96;
  v14 = 280;
  v15 = 128;
  v16 = 280;
  v17 = 96;
  v18 = 320;
  v19 = 128;
  v4 = 160;
  v5 = 152;
  v6 = 200;
  v7 = 184;
  v8 = 200;
  v9 = 152;
  v10 = 240;
  v11 = 184;
  v3 = *(_DWORD *)(a1 + 116);
  if ( v3 )
  {
    if ( v3 != 1 )
    {
      if ( v3 == 2 && ++*(_DWORD *)(a1 + 120) > 8 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      goto LABEL_11;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 100) = 0;
    *(_DWORD *)(a1 + 12) += 2048;
  }
  if ( random(0, 120) == 10 )
  {
    *(_DWORD *)(a1 + 116) = 2;
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 104) = 1;
  }
LABEL_11:
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v12 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (004630F0) --------------------------------------------------------
int __cdecl NPC307(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+0h] [ebp-44h]
  int v5; // [esp+4h] [ebp-40h]
  int v6; // [esp+8h] [ebp-3Ch]
  int v7; // [esp+Ch] [ebp-38h]
  int v8; // [esp+10h] [ebp-34h]
  int v9; // [esp+14h] [ebp-30h]
  int v10; // [esp+18h] [ebp-2Ch]
  int v11; // [esp+1Ch] [ebp-28h]
  int v12; // [esp+20h] [ebp-24h]
  int v13; // [esp+24h] [ebp-20h]
  int v14; // [esp+28h] [ebp-1Ch]
  int v15; // [esp+2Ch] [ebp-18h]
  int v16; // [esp+30h] [ebp-14h]
  int v17; // [esp+34h] [ebp-10h]
  int v18; // [esp+38h] [ebp-Ch]
  int v19; // [esp+3Ch] [ebp-8h]
  int v20; // [esp+40h] [ebp-4h]

  v13 = 0;
  v14 = 32;
  v15 = 16;
  v16 = 48;
  v17 = 16;
  v18 = 32;
  v19 = 32;
  v20 = 48;
  v5 = 0;
  v6 = 48;
  v7 = 16;
  v8 = 64;
  v9 = 16;
  v10 = 48;
  v11 = 32;
  v12 = 64;
  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      if ( v4 == 2 && ++*(_DWORD *)(a1 + 120) > 12 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 104) = 0;
      }
      goto LABEL_11;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 8) += 512;
    *(_DWORD *)(a1 + 12) -= 1024;
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 100) = 0;
  }
  if ( random(0, 160) == 1 )
  {
    *(_DWORD *)(a1 + 116) = 2;
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 104) = 1;
  }
LABEL_11:
  if ( quote.XPos >= *(_DWORD *)(a1 + 8) )
    *(_DWORD *)(a1 + 76) = 2;
  else
    *(_DWORD *)(a1 + 76) = 0;
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v13 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (004632B0) --------------------------------------------------------
int __cdecl NPC308(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  int v4; // [esp+4h] [ebp-44h]
  int v5; // [esp+8h] [ebp-40h]
  int v6; // [esp+Ch] [ebp-3Ch]
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  int v9; // [esp+18h] [ebp-30h]
  int v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  int v13; // [esp+28h] [ebp-20h]
  int v14; // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+30h] [ebp-18h]
  int v16; // [esp+34h] [ebp-14h]
  int v17; // [esp+38h] [ebp-10h]
  int v18; // [esp+3Ch] [ebp-Ch]
  int v19; // [esp+40h] [ebp-8h]
  unsigned __int8 v20; // [esp+47h] [ebp-1h]

  v12 = 128;
  v13 = 112;
  v14 = 144;
  v15 = 128;
  v16 = 144;
  v17 = 112;
  v18 = 160;
  v19 = 128;
  v4 = 128;
  v5 = 128;
  v6 = 144;
  v7 = 144;
  v8 = 144;
  v9 = 128;
  v10 = 160;
  v11 = 144;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( quote.XPos < *(_DWORD *)(a1 + 8) + 122880
        && quote.XPos > *(_DWORD *)(a1 + 8) - 122880
        && quote.YPos < *(_DWORD *)(a1 + 12) + 98304
        && quote.YPos > *(_DWORD *)(a1 + 12) - 98304 )
      {
        *(_DWORD *)(a1 + 116) = 10;
      }
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 24) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      goto LABEL_12;
    case 0xB:
LABEL_12:
      if ( ++*(_DWORD *)(a1 + 120) > 50 )
        *(_DWORD *)(a1 + 116) = 20;
      ++*(_DWORD *)(a1 + 100);
      if ( *(_DWORD *)(a1 + 120) > 1 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        if ( ++*(_DWORD *)(a1 + 104) > 1 )
          *(_DWORD *)(a1 + 104) = 0;
      }
      if ( quote.XPos > *(_DWORD *)(a1 + 8) + 163840
        || quote.XPos < *(_DWORD *)(a1 + 8) - 163840
        || quote.YPos > *(_DWORD *)(a1 + 12) + 122880
        || quote.YPos < *(_DWORD *)(a1 + 12) - 122880 )
      {
        *(_DWORD *)(a1 + 116) = 0;
      }
      break;
    case 0x14:
      *(_DWORD *)(a1 + 116) = 21;
      *(_DWORD *)(a1 + 120) = 0;
      v20 = getArcTan(*(_DWORD *)(a1 + 8) - quote.XPos, *(_DWORD *)(a1 + 12) - quote.YPos);
      v20 += random(-3, 3);
      *(_DWORD *)(a1 + 28) = 2 * getSin(v20);
      *(_DWORD *)(a1 + 24) = 2 * getCos(v20);
      if ( *(_DWORD *)(a1 + 24) >= 0 )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      goto LABEL_26;
    case 0x15:
LABEL_26:
      if ( *(_DWORD *)(a1 + 24) < 0 && *(_DWORD *)(a1 + 4) & 1 )
      {
        *(_DWORD *)(a1 + 76) = 2;
        *(_DWORD *)(a1 + 24) = -*(_DWORD *)(a1 + 24);
      }
      if ( *(_DWORD *)(a1 + 24) > 0 && *(_DWORD *)(a1 + 4) & 4 )
      {
        *(_DWORD *)(a1 + 76) = 0;
        *(_DWORD *)(a1 + 24) = -*(_DWORD *)(a1 + 24);
      }
      if ( *(_DWORD *)(a1 + 28) < 0 && *(_DWORD *)(a1 + 4) & 2 )
        *(_DWORD *)(a1 + 28) = -*(_DWORD *)(a1 + 28);
      if ( *(_DWORD *)(a1 + 28) > 0 && *(_DWORD *)(a1 + 4) & 8 )
        *(_DWORD *)(a1 + 28) = -*(_DWORD *)(a1 + 28);
      if ( *(_DWORD *)(a1 + 4) & 0x100 )
        *(_DWORD *)(a1 + 28) = -512;
      *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 24);
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 28);
      if ( ++*(_DWORD *)(a1 + 120) > 50 )
        *(_DWORD *)(a1 + 116) = 10;
      if ( ++*(_DWORD *)(a1 + 104) > 1 )
        *(_DWORD *)(a1 + 104) = 0;
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v12 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}

//----- (00463710) --------------------------------------------------------
int __cdecl NPC309(int a1)
{
  int result; // eax
  int v2; // eax
  int v3; // edx
  int *v4; // eax
  int *v5; // ecx
  int v6; // [esp+4h] [ebp-40h]
  int v7; // [esp+8h] [ebp-3Ch]
  int v8; // [esp+Ch] [ebp-38h]
  int v9; // [esp+10h] [ebp-34h]
  int v10; // [esp+14h] [ebp-30h]
  int v11; // [esp+18h] [ebp-2Ch]
  int v12; // [esp+1Ch] [ebp-28h]
  int v13; // [esp+20h] [ebp-24h]
  int v14; // [esp+24h] [ebp-20h]
  int v15; // [esp+28h] [ebp-1Ch]
  int v16; // [esp+2Ch] [ebp-18h]
  int v17; // [esp+30h] [ebp-14h]
  int v18; // [esp+34h] [ebp-10h]
  int v19; // [esp+38h] [ebp-Ch]
  int v20; // [esp+3Ch] [ebp-8h]
  int v21; // [esp+40h] [ebp-4h]

  v14 = 0;
  v15 = 0;
  v16 = 16;
  v17 = 16;
  v18 = 16;
  v19 = 0;
  v20 = 32;
  v21 = 16;
  v6 = 0;
  v7 = 16;
  v8 = 16;
  v9 = 32;
  v10 = 16;
  v11 = 16;
  v12 = 32;
  v13 = 32;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( *(_DWORD *)(a1 + 76) )
      {
        result = *(_DWORD *)(a1 + 8) + 147456;
        if ( quote.XPos >= result || quote.XPos <= *(_DWORD *)(a1 + 8) + 139264 )
          return result;
        *(_DWORD *)(a1 + 116) = 10;
      }
      else
      {
        result = a1;
        if ( quote.XPos <= *(_DWORD *)(a1 + 8) - 147456 )
          return result;
        result = *(_DWORD *)(a1 + 8) - 139264;
        if ( quote.XPos >= result )
          return result;
        *(_DWORD *)(a1 + 116) = 10;
      }
LABEL_46:
      if ( *(_DWORD *)(a1 + 76) )
        v4 = &v6 + 4 * *(_DWORD *)(a1 + 104);
      else
        v4 = &v14 + 4 * *(_DWORD *)(a1 + 104);
      v5 = (int *)(a1 + 84);
      *v5 = *v4;
      v5[1] = v4[1];
      v5[2] = v4[2];
      result = v4[3];
      v5[3] = result;
      if ( *(_DWORD *)(a1 + 64) <= 996 )
      {
        *(_DWORD *)(a1 + 40) = 316;
        result = a1;
        *(_DWORD *)(a1 + 116) = 0;
      }
      return result;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_WORD *)(a1 + 80) |= 0x20u;
      *(_DWORD *)(a1 + 164) = 5;
      goto LABEL_13;
    case 0xB:
LABEL_13:
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      if ( *(_DWORD *)(a1 + 76) )
        v2 = *(_DWORD *)(a1 + 24) + 16;
      else
        v2 = *(_DWORD *)(a1 + 24) - 16;
      *(_DWORD *)(a1 + 24) = v2;
      if ( *(_DWORD *)(a1 + 12) <= quote.YPos )
        v3 = *(_DWORD *)(a1 + 28) + 16;
      else
        v3 = *(_DWORD *)(a1 + 28) - 16;
      *(_DWORD *)(a1 + 28) = v3;
      if ( *(_DWORD *)(a1 + 24) < 0 && *(_DWORD *)(a1 + 4) & 1 )
        *(_DWORD *)(a1 + 24) = -*(_DWORD *)(a1 + 24);
      if ( *(_DWORD *)(a1 + 24) > 0 && *(_DWORD *)(a1 + 4) & 4 )
        *(_DWORD *)(a1 + 24) = -*(_DWORD *)(a1 + 24);
      if ( *(_DWORD *)(a1 + 28) < 0 && *(_DWORD *)(a1 + 4) & 2 )
        *(_DWORD *)(a1 + 28) = -*(_DWORD *)(a1 + 28);
      if ( *(_DWORD *)(a1 + 28) > 0 && *(_DWORD *)(a1 + 4) & 8 )
        *(_DWORD *)(a1 + 28) = -*(_DWORD *)(a1 + 28);
      if ( *(_DWORD *)(a1 + 24) < -1535 )
        *(_DWORD *)(a1 + 24) = -1535;
      if ( *(_DWORD *)(a1 + 24) > 1535 )
        *(_DWORD *)(a1 + 24) = 1535;
      if ( *(_DWORD *)(a1 + 28) < -1535 )
        *(_DWORD *)(a1 + 28) = -1535;
      if ( *(_DWORD *)(a1 + 28) > 1535 )
        *(_DWORD *)(a1 + 28) = 1535;
      *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 24);
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 28);
      if ( ++*(_DWORD *)(a1 + 100) > 1 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 1 )
        *(_DWORD *)(a1 + 104) = 0;
      goto LABEL_46;
    default:
      goto LABEL_46;
  }
}

//----- (00463AC0) --------------------------------------------------------
int __cdecl NPC310(int a1)
{
  int *v1; // edx
  int *v2; // eax
  int result; // eax
  int v4; // [esp+4h] [ebp-A0h]
  int v5; // [esp+8h] [ebp-9Ch]
  int v6; // [esp+Ch] [ebp-98h]
  int v7; // [esp+10h] [ebp-94h]
  int v8; // [esp+14h] [ebp-90h]
  int v9; // [esp+18h] [ebp-8Ch]
  int v10; // [esp+1Ch] [ebp-88h]
  int v11; // [esp+20h] [ebp-84h]
  int v12; // [esp+24h] [ebp-80h]
  int v13; // [esp+28h] [ebp-7Ch]
  int v14; // [esp+2Ch] [ebp-78h]
  int v15; // [esp+30h] [ebp-74h]
  int v16; // [esp+34h] [ebp-70h]
  int v17; // [esp+38h] [ebp-6Ch]
  int v18; // [esp+3Ch] [ebp-68h]
  int v19; // [esp+40h] [ebp-64h]
  int v20; // [esp+44h] [ebp-60h]
  int v21; // [esp+48h] [ebp-5Ch]
  int v22; // [esp+4Ch] [ebp-58h]
  int v23; // [esp+50h] [ebp-54h]
  int v24; // [esp+54h] [ebp-50h]
  int v25; // [esp+58h] [ebp-4Ch]
  int v26; // [esp+5Ch] [ebp-48h]
  int v27; // [esp+60h] [ebp-44h]
  int v28; // [esp+64h] [ebp-40h]
  int v29; // [esp+68h] [ebp-3Ch]
  int v30; // [esp+6Ch] [ebp-38h]
  int v31; // [esp+70h] [ebp-34h]
  int v32; // [esp+74h] [ebp-30h]
  int v33; // [esp+78h] [ebp-2Ch]
  int v34; // [esp+7Ch] [ebp-28h]
  int v35; // [esp+80h] [ebp-24h]
  int v36; // [esp+84h] [ebp-20h]
  int v37; // [esp+88h] [ebp-1Ch]
  int v38; // [esp+8Ch] [ebp-18h]
  int v39; // [esp+90h] [ebp-14h]
  int v40; // [esp+94h] [ebp-10h]
  int v41; // [esp+98h] [ebp-Ch]
  int v42; // [esp+9Ch] [ebp-8h]
  int v43; // [esp+A0h] [ebp-4h]

  v24 = 32;
  v25 = 0;
  v26 = 56;
  v27 = 16;
  v28 = 56;
  v29 = 0;
  v30 = 80;
  v31 = 16;
  v32 = 80;
  v33 = 0;
  v34 = 104;
  v35 = 16;
  v36 = 104;
  v37 = 0;
  v38 = 128;
  v39 = 16;
  v40 = 128;
  v41 = 0;
  v42 = 152;
  v43 = 16;
  v4 = 32;
  v5 = 16;
  v6 = 56;
  v7 = 32;
  v8 = 56;
  v9 = 16;
  v10 = 80;
  v11 = 32;
  v12 = 80;
  v13 = 16;
  v14 = 104;
  v15 = 32;
  v16 = 104;
  v17 = 16;
  v18 = 128;
  v19 = 32;
  v20 = 128;
  v21 = 16;
  v22 = 152;
  v23 = 32;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_WORD *)(a1 + 80) &= 0xFFDFu;
      *(_WORD *)(a1 + 80) |= 4u;
      *(_DWORD *)(a1 + 164) = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      *(_DWORD *)(a1 + 104) = 0;
      if ( quote.XPos > *(_DWORD *)(a1 + 8) - 0x10000
        && quote.XPos < *(_DWORD *)(a1 + 8) + 0x10000
        && quote.YPos > *(_DWORD *)(a1 + 12) - 0x10000
        && quote.YPos < *(_DWORD *)(a1 + 12) + 0x2000 )
      {
        *(_DWORD *)(a1 + 116) = 10;
      }
      break;
    case 0xA:
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 120) = 0;
      *(_WORD *)(a1 + 80) &= 0xFFDFu;
      *(_WORD *)(a1 + 80) |= 4u;
      *(_DWORD *)(a1 + 164) = 0;
      *(_DWORD *)(a1 + 104) = 0;
      goto LABEL_13;
    case 0xB:
LABEL_13:
      if ( ++*(_DWORD *)(a1 + 120) > 30 )
        *(_DWORD *)(a1 + 116) = 20;
      break;
    case 0x14:
      *(_DWORD *)(a1 + 116) = 21;
      *(_DWORD *)(a1 + 120) = 0;
      *(_WORD *)(a1 + 80) &= 0xFFFBu;
      *(_WORD *)(a1 + 80) |= 0x20u;
      *(_DWORD *)(a1 + 164) = 0;
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      goto LABEL_19;
    case 0x15:
LABEL_19:
      if ( *(_DWORD *)(a1 + 76) )
        *(_DWORD *)(a1 + 16) = 1024;
      else
        *(_DWORD *)(a1 + 16) = -1024;
      if ( ++*(_DWORD *)(a1 + 100) > 3 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 1 )
        *(_DWORD *)(a1 + 104) = 0;
      if ( ++*(_DWORD *)(a1 + 120) > 50 )
        *(_DWORD *)(a1 + 116) = 10;
      if ( *(_DWORD *)(a1 + 8) < quote.XPos + 20480 && *(_DWORD *)(a1 + 8) > quote.XPos - 20480 )
      {
        *(_DWORD *)(a1 + 20) = -768;
        *(_DWORD *)(a1 + 16) /= 2;
        *(_DWORD *)(a1 + 104) = 2;
        *(_DWORD *)(a1 + 116) = 30;
        playSoundEffect(SFXCritterHop, 1);
      }
      break;
    case 0x1E:
      if ( *(_DWORD *)(a1 + 20) > -128 )
      {
        *(_DWORD *)(a1 + 116) = 31;
        *(_DWORD *)(a1 + 100) = 0;
        *(_DWORD *)(a1 + 104) = 3;
        *(_DWORD *)(a1 + 164) = 9;
      }
      break;
    case 0x1F:
      if ( ++*(_DWORD *)(a1 + 100) > 2 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        *(_DWORD *)(a1 + 104) = 4;
      }
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 116) = 32;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 16) = 0;
        *(_DWORD *)(a1 + 164) = 3;
      }
      break;
    case 0x20:
      if ( ++*(_DWORD *)(a1 + 120) > 30 )
      {
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 164) = 0;
      }
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 20) += 32;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v24 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  v2[3] = v1[3];
  result = a1;
  if ( *(_DWORD *)(a1 + 64) <= 996 )
  {
    *(_DWORD *)(a1 + 40) = 316;
    *(_DWORD *)(a1 + 116) = 0;
  }
  return result;
}

//----- (00464090) --------------------------------------------------------
int __cdecl NPC311(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+4h] [ebp-E0h]
  int v5; // [esp+8h] [ebp-DCh]
  int v6; // [esp+Ch] [ebp-D8h]
  int v7; // [esp+10h] [ebp-D4h]
  int v8; // [esp+14h] [ebp-D0h]
  int v9; // [esp+18h] [ebp-CCh]
  int v10; // [esp+1Ch] [ebp-C8h]
  int v11; // [esp+20h] [ebp-C4h]
  int v12; // [esp+24h] [ebp-C0h]
  int v13; // [esp+28h] [ebp-BCh]
  int v14; // [esp+2Ch] [ebp-B8h]
  int v15; // [esp+30h] [ebp-B4h]
  int v16; // [esp+34h] [ebp-B0h]
  int v17; // [esp+38h] [ebp-ACh]
  int v18; // [esp+3Ch] [ebp-A8h]
  int v19; // [esp+40h] [ebp-A4h]
  int v20; // [esp+44h] [ebp-A0h]
  int v21; // [esp+48h] [ebp-9Ch]
  int v22; // [esp+4Ch] [ebp-98h]
  int v23; // [esp+50h] [ebp-94h]
  int v24; // [esp+54h] [ebp-90h]
  int v25; // [esp+58h] [ebp-8Ch]
  int v26; // [esp+5Ch] [ebp-88h]
  int v27; // [esp+60h] [ebp-84h]
  int v28; // [esp+64h] [ebp-80h]
  int v29; // [esp+68h] [ebp-7Ch]
  int v30; // [esp+6Ch] [ebp-78h]
  int v31; // [esp+70h] [ebp-74h]
  int v32; // [esp+74h] [ebp-70h]
  int v33; // [esp+78h] [ebp-6Ch]
  int v34; // [esp+7Ch] [ebp-68h]
  int v35; // [esp+80h] [ebp-64h]
  int v36; // [esp+84h] [ebp-60h]
  int v37; // [esp+88h] [ebp-5Ch]
  int v38; // [esp+8Ch] [ebp-58h]
  int v39; // [esp+90h] [ebp-54h]
  int v40; // [esp+94h] [ebp-50h]
  int v41; // [esp+98h] [ebp-4Ch]
  int v42; // [esp+9Ch] [ebp-48h]
  int v43; // [esp+A0h] [ebp-44h]
  int v44; // [esp+A4h] [ebp-40h]
  int v45; // [esp+A8h] [ebp-3Ch]
  int v46; // [esp+ACh] [ebp-38h]
  int v47; // [esp+B0h] [ebp-34h]
  int v48; // [esp+B4h] [ebp-30h]
  int v49; // [esp+B8h] [ebp-2Ch]
  int v50; // [esp+BCh] [ebp-28h]
  int v51; // [esp+C0h] [ebp-24h]
  int v52; // [esp+C4h] [ebp-20h]
  int v53; // [esp+C8h] [ebp-1Ch]
  int v54; // [esp+CCh] [ebp-18h]
  int v55; // [esp+D0h] [ebp-14h]
  int v56; // [esp+D4h] [ebp-10h]
  int v57; // [esp+D8h] [ebp-Ch]
  int v58; // [esp+DCh] [ebp-8h]
  int v59; // [esp+E0h] [ebp-4h]

  v32 = 0;
  v33 = 32;
  v34 = 24;
  v35 = 56;
  v36 = 24;
  v37 = 32;
  v38 = 48;
  v39 = 56;
  v40 = 48;
  v41 = 32;
  v42 = 72;
  v43 = 56;
  v44 = 72;
  v45 = 32;
  v46 = 96;
  v47 = 56;
  v48 = 96;
  v49 = 32;
  v50 = 120;
  v51 = 56;
  v52 = 120;
  v53 = 32;
  v54 = 144;
  v55 = 56;
  v56 = 144;
  v57 = 32;
  v58 = 168;
  v59 = 56;
  v4 = 0;
  v5 = 56;
  v6 = 24;
  v7 = 80;
  v8 = 24;
  v9 = 56;
  v10 = 48;
  v11 = 80;
  v12 = 48;
  v13 = 56;
  v14 = 72;
  v15 = 80;
  v16 = 72;
  v17 = 56;
  v18 = 96;
  v19 = 80;
  v20 = 96;
  v21 = 56;
  v22 = 120;
  v23 = 80;
  v24 = 120;
  v25 = 56;
  v26 = 144;
  v27 = 80;
  v28 = 144;
  v29 = 56;
  v30 = 168;
  v31 = 80;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( *(_DWORD *)(a1 + 76) )
      {
        if ( quote.XPos > *(_DWORD *)(a1 + 8)
          && quote.XPos < *(_DWORD *)(a1 + 8) + 163840
          && quote.YPos > *(_DWORD *)(a1 + 12) - 81920
          && quote.YPos < *(_DWORD *)(a1 + 12) + 81920 )
        {
          *(_DWORD *)(a1 + 116) = 10;
        }
      }
      else if ( quote.XPos > *(_DWORD *)(a1 + 8) - 163840
             && quote.XPos < *(_DWORD *)(a1 + 8)
             && quote.YPos > *(_DWORD *)(a1 + 12) - 81920
             && quote.YPos < *(_DWORD *)(a1 + 12) + 81920 )
      {
        *(_DWORD *)(a1 + 116) = 10;
      }
      break;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      goto LABEL_17;
    case 0xB:
LABEL_17:
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      if ( quote.XPos <= *(_DWORD *)(a1 + 8) - 114688
        || quote.XPos >= *(_DWORD *)(a1 + 8) + 114688
        || quote.YPos <= *(_DWORD *)(a1 + 12) - 4096 )
      {
        *(_DWORD *)(a1 + 104) = 4;
        *(_DWORD *)(a1 + 108) = 1;
      }
      else
      {
        *(_DWORD *)(a1 + 104) = 1;
        *(_DWORD *)(a1 + 108) = 0;
      }
      if ( ++*(_DWORD *)(a1 + 120) > 10 )
        *(_DWORD *)(a1 + 116) = 20;
      break;
    case 0x14:
      *(_DWORD *)(a1 + 116) = 21;
      *(_DWORD *)(a1 + 120) = 0;
      goto LABEL_29;
    case 0x15:
LABEL_29:
      if ( *(_DWORD *)(a1 + 108) )
      {
        if ( ++*(_DWORD *)(a1 + 104) > 5 )
          *(_DWORD *)(a1 + 104) = 4;
      }
      else if ( ++*(_DWORD *)(a1 + 104) > 2 )
      {
        *(_DWORD *)(a1 + 104) = 1;
      }
      if ( ++*(_DWORD *)(a1 + 120) > 30 )
        *(_DWORD *)(a1 + 116) = 30;
      break;
    case 0x1E:
      *(_DWORD *)(a1 + 116) = 31;
      *(_DWORD *)(a1 + 120) = 0;
      if ( *(_DWORD *)(a1 + 108) )
      {
        if ( *(_DWORD *)(a1 + 76) )
          createNPC((NPCNames)312, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 1536, -1536, right, 0, 256);
        else
          createNPC((NPCNames)312, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), -1536, -1536, 0, 0, 256);
        *(_DWORD *)(a1 + 104) = 6;
      }
      else
      {
        if ( *(_DWORD *)(a1 + 76) )
          createNPC((NPCNames)312, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 1536, 0, right, 0, 256);
        else
          createNPC((NPCNames)312, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), -1536, 0, 0, 0, 256);
        *(_DWORD *)(a1 + 104) = 3;
      }
      goto LABEL_47;
    case 0x1F:
LABEL_47:
      if ( ++*(_DWORD *)(a1 + 120) > 30 )
      {
        *(_DWORD *)(a1 + 116) = 40;
        *(_DWORD *)(a1 + 120) = random(0, 100);
      }
      break;
    case 0x28:
      *(_DWORD *)(a1 + 104) = 0;
      if ( ++*(_DWORD *)(a1 + 120) > 150 )
        *(_DWORD *)(a1 + 116) = 10;
      if ( quote.XPos < *(_DWORD *)(a1 + 8) - 180224
        || quote.XPos > *(_DWORD *)(a1 + 8) + 180224
        || quote.YPos < *(_DWORD *)(a1 + 12) - 122880
        || quote.YPos > *(_DWORD *)(a1 + 12) + 122880 )
      {
        *(_DWORD *)(a1 + 116) = 40;
        *(_DWORD *)(a1 + 120) = 0;
      }
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v32 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  if ( *(_DWORD *)(a1 + 64) <= 992 )
  {
    *(_DWORD *)(a1 + 40) = 316;
    result = a1;
    *(_DWORD *)(a1 + 116) = 0;
  }
  return result;
}

//----- (00464740) --------------------------------------------------------
int __cdecl NPC312(int a1)
{
  int result; // eax
  int *v2; // eax
  int *v3; // ecx
  int v4; // [esp+4h] [ebp-A0h]
  int v5; // [esp+8h] [ebp-9Ch]
  int v6; // [esp+Ch] [ebp-98h]
  int v7; // [esp+10h] [ebp-94h]
  int v8; // [esp+14h] [ebp-90h]
  int v9; // [esp+18h] [ebp-8Ch]
  int v10; // [esp+1Ch] [ebp-88h]
  int v11; // [esp+20h] [ebp-84h]
  int v12; // [esp+24h] [ebp-80h]
  int v13; // [esp+28h] [ebp-7Ch]
  int v14; // [esp+2Ch] [ebp-78h]
  int v15; // [esp+30h] [ebp-74h]
  int v16; // [esp+34h] [ebp-70h]
  int v17; // [esp+38h] [ebp-6Ch]
  int v18; // [esp+3Ch] [ebp-68h]
  int v19; // [esp+40h] [ebp-64h]
  int v20; // [esp+44h] [ebp-60h]
  int v21; // [esp+48h] [ebp-5Ch]
  int v22; // [esp+4Ch] [ebp-58h]
  int v23; // [esp+50h] [ebp-54h]
  int v24; // [esp+54h] [ebp-50h]
  int v25; // [esp+58h] [ebp-4Ch]
  int v26; // [esp+5Ch] [ebp-48h]
  int v27; // [esp+60h] [ebp-44h]
  int v28; // [esp+64h] [ebp-40h]
  int v29; // [esp+68h] [ebp-3Ch]
  int v30; // [esp+6Ch] [ebp-38h]
  int v31; // [esp+70h] [ebp-34h]
  int v32; // [esp+74h] [ebp-30h]
  int v33; // [esp+78h] [ebp-2Ch]
  int v34; // [esp+7Ch] [ebp-28h]
  int v35; // [esp+80h] [ebp-24h]
  int v36; // [esp+84h] [ebp-20h]
  int v37; // [esp+88h] [ebp-1Ch]
  int v38; // [esp+8Ch] [ebp-18h]
  int v39; // [esp+90h] [ebp-14h]
  int v40; // [esp+94h] [ebp-10h]
  int v41; // [esp+98h] [ebp-Ch]
  int v42; // [esp+9Ch] [ebp-8h]
  int v43; // [esp+A0h] [ebp-4h]

  v24 = 0;
  v25 = 160;
  v26 = 16;
  v27 = 176;
  v28 = 16;
  v29 = 160;
  v30 = 32;
  v31 = 176;
  v32 = 32;
  v33 = 160;
  v34 = 48;
  v35 = 176;
  v36 = 48;
  v37 = 160;
  v38 = 64;
  v39 = 176;
  v40 = 64;
  v41 = 160;
  v42 = 80;
  v43 = 176;
  v4 = 0;
  v5 = 176;
  v6 = 16;
  v7 = 192;
  v8 = 16;
  v9 = 176;
  v10 = 32;
  v11 = 192;
  v12 = 32;
  v13 = 176;
  v14 = 48;
  v15 = 192;
  v16 = 48;
  v17 = 176;
  v18 = 64;
  v19 = 192;
  v20 = 64;
  v21 = 176;
  v22 = 80;
  v23 = 192;
  if ( *(_DWORD *)(a1 + 116) > 0 && *(_DWORD *)(a1 + 116) < 20 && *(_DWORD *)(a1 + 4) & 0xFF )
    *(_DWORD *)(a1 + 116) = 20;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 120) = 0;
      if ( *(_DWORD *)(a1 + 16) >= 0 )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      if ( *(_DWORD *)(a1 + 20) >= 0 )
        *(_DWORD *)(a1 + 104) = 2;
      else
        *(_DWORD *)(a1 + 104) = 0;
      goto LABEL_12;
    case 1:
LABEL_12:
      if ( ++*(_DWORD *)(a1 + 120) == 4 )
        *(_WORD *)(a1 + 80) &= 0xFFF7u;
      if ( *(_DWORD *)(a1 + 120) > 10 )
        *(_DWORD *)(a1 + 116) = 10;
      goto LABEL_30;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 100) = 0;
      *(_DWORD *)(a1 + 16) = 3 * *(_DWORD *)(a1 + 16) / 4;
      *(_DWORD *)(a1 + 20) = 3 * *(_DWORD *)(a1 + 20) / 4;
      goto LABEL_18;
    case 0xB:
LABEL_18:
      *(_DWORD *)(a1 + 20) += 32;
      if ( ++*(_DWORD *)(a1 + 100) > 10 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 4 )
        *(_DWORD *)(a1 + 104) = 4;
      goto LABEL_30;
    case 0x14:
      *(_DWORD *)(a1 + 116) = 21;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 20) = 0;
      *(_DWORD *)(a1 + 164) = 0;
      goto LABEL_24;
    case 0x15:
LABEL_24:
      if ( ++*(_DWORD *)(a1 + 120) > 30 )
        *(_DWORD *)(a1 + 116) = 30;
      goto LABEL_30;
    case 0x1E:
      *(_DWORD *)(a1 + 116) = 31;
      *(_DWORD *)(a1 + 120) = 0;
      goto LABEL_28;
    case 0x1F:
LABEL_28:
      ++*(_DWORD *)(a1 + 120);
      result = a1;
      if ( *(_DWORD *)(a1 + 120) <= 30 )
        goto LABEL_30;
      *(_BYTE *)a1 = 0;
      break;
    default:
LABEL_30:
      if ( *(_DWORD *)(a1 + 20) > 1535 )
        *(_DWORD *)(a1 + 20) = 1535;
      *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
      if ( *(_DWORD *)(a1 + 76) )
        v2 = &v4 + 4 * *(_DWORD *)(a1 + 104);
      else
        v2 = &v24 + 4 * *(_DWORD *)(a1 + 104);
      v3 = (int *)(a1 + 84);
      *v3 = *v2;
      v3[1] = v2[1];
      v3[2] = v2[2];
      result = v2[3];
      v3[3] = result;
      if ( *(_DWORD *)(a1 + 116) == 31 )
      {
        result = *(_DWORD *)(a1 + 120) / 2 % 2;
        if ( result )
        {
          result = a1;
          *(_DWORD *)(a1 + 84) = 0;
          *(_DWORD *)(a1 + 92) = 0;
        }
      }
      break;
  }
  return result;
}

//----- (00464BB0) --------------------------------------------------------
void __cdecl NPC313(NPC *npc)
{
  int v1; // eax
  int v2; // eax
  unsigned __int16 v3; // dx
  int *v4; // edx
  RECT *v5; // eax
  int v6; // [esp+0h] [ebp-1C4h]
  int v7; // [esp+4h] [ebp-1C0h]
  int v8; // [esp+8h] [ebp-1BCh]
  int v9; // [esp+Ch] [ebp-1B8h]
  int v10; // [esp+10h] [ebp-1B4h]
  int v11; // [esp+14h] [ebp-1B0h]
  int v12; // [esp+18h] [ebp-1ACh]
  int v13; // [esp+1Ch] [ebp-1A8h]
  int v14; // [esp+20h] [ebp-1A4h]
  int v15; // [esp+24h] [ebp-1A0h]
  int v16; // [esp+28h] [ebp-19Ch]
  int v17; // [esp+2Ch] [ebp-198h]
  int v18; // [esp+30h] [ebp-194h]
  int v19; // [esp+34h] [ebp-190h]
  int v20; // [esp+38h] [ebp-18Ch]
  int v21; // [esp+3Ch] [ebp-188h]
  int v22; // [esp+40h] [ebp-184h]
  int v23; // [esp+44h] [ebp-180h]
  int v24; // [esp+48h] [ebp-17Ch]
  int v25; // [esp+4Ch] [ebp-178h]
  int v26; // [esp+50h] [ebp-174h]
  int v27; // [esp+54h] [ebp-170h]
  int v28; // [esp+58h] [ebp-16Ch]
  int v29; // [esp+5Ch] [ebp-168h]
  int v30; // [esp+60h] [ebp-164h]
  int v31; // [esp+64h] [ebp-160h]
  int v32; // [esp+68h] [ebp-15Ch]
  int v33; // [esp+6Ch] [ebp-158h]
  int v34; // [esp+70h] [ebp-154h]
  int v35; // [esp+74h] [ebp-150h]
  int v36; // [esp+78h] [ebp-14Ch]
  int v37; // [esp+7Ch] [ebp-148h]
  int v38; // [esp+80h] [ebp-144h]
  int v39; // [esp+84h] [ebp-140h]
  int v40; // [esp+88h] [ebp-13Ch]
  int v41; // [esp+8Ch] [ebp-138h]
  int v42; // [esp+90h] [ebp-134h]
  int v43; // [esp+94h] [ebp-130h]
  int v44; // [esp+98h] [ebp-12Ch]
  int v45; // [esp+9Ch] [ebp-128h]
  int v46; // [esp+A0h] [ebp-124h]
  int v47; // [esp+A4h] [ebp-120h]
  int v48; // [esp+A8h] [ebp-11Ch]
  int v49; // [esp+ACh] [ebp-118h]
  int v50; // [esp+B0h] [ebp-114h]
  int v51; // [esp+B4h] [ebp-110h]
  int v52; // [esp+B8h] [ebp-10Ch]
  int v53; // [esp+BCh] [ebp-108h]
  int v54; // [esp+C0h] [ebp-104h]
  int v55; // [esp+C4h] [ebp-100h]
  int v56; // [esp+C8h] [ebp-FCh]
  int v57; // [esp+CCh] [ebp-F8h]
  int v58; // [esp+D0h] [ebp-F4h]
  int v59; // [esp+D4h] [ebp-F0h]
  int v60; // [esp+D8h] [ebp-ECh]
  int v61; // [esp+DCh] [ebp-E8h]
  int v62; // [esp+E0h] [ebp-E4h]
  int v63; // [esp+E4h] [ebp-E0h]
  int v64; // [esp+E8h] [ebp-DCh]
  int v65; // [esp+ECh] [ebp-D8h]
  int v66; // [esp+F0h] [ebp-D4h]
  int v67; // [esp+F4h] [ebp-D0h]
  int v68; // [esp+F8h] [ebp-CCh]
  int v69; // [esp+FCh] [ebp-C8h]
  int v70; // [esp+100h] [ebp-C4h]
  int v71; // [esp+104h] [ebp-C0h]
  int v72; // [esp+108h] [ebp-BCh]
  int v73; // [esp+10Ch] [ebp-B8h]
  int v74; // [esp+110h] [ebp-B4h]
  int v75; // [esp+114h] [ebp-B0h]
  int v76; // [esp+118h] [ebp-ACh]
  int v77; // [esp+11Ch] [ebp-A8h]
  int v78; // [esp+120h] [ebp-A4h]
  int v79; // [esp+124h] [ebp-A0h]
  int v80; // [esp+128h] [ebp-9Ch]
  int v81; // [esp+12Ch] [ebp-98h]
  int v82; // [esp+130h] [ebp-94h]
  int v83; // [esp+134h] [ebp-90h]
  int v84; // [esp+138h] [ebp-8Ch]
  int v85; // [esp+13Ch] [ebp-88h]
  int v86; // [esp+140h] [ebp-84h]
  int v87; // [esp+144h] [ebp-80h]
  int v88; // [esp+148h] [ebp-7Ch]
  int v89; // [esp+14Ch] [ebp-78h]
  int v90; // [esp+150h] [ebp-74h]
  int v91; // [esp+154h] [ebp-70h]
  int v92; // [esp+158h] [ebp-6Ch]
  int v93; // [esp+15Ch] [ebp-68h]
  int v94; // [esp+160h] [ebp-64h]
  int v95; // [esp+164h] [ebp-60h]
  int v96; // [esp+168h] [ebp-5Ch]
  int v97; // [esp+16Ch] [ebp-58h]
  int v98; // [esp+170h] [ebp-54h]
  int v99; // [esp+174h] [ebp-50h]
  int v100; // [esp+178h] [ebp-4Ch]
  int v101; // [esp+17Ch] [ebp-48h]
  int v102; // [esp+180h] [ebp-44h]
  int v103; // [esp+184h] [ebp-40h]
  int v104; // [esp+188h] [ebp-3Ch]
  int v105; // [esp+18Ch] [ebp-38h]
  int v106; // [esp+190h] [ebp-34h]
  int v107; // [esp+194h] [ebp-30h]
  int v108; // [esp+198h] [ebp-2Ch]
  int v109; // [esp+19Ch] [ebp-28h]
  int v110; // [esp+1A0h] [ebp-24h]
  int v111; // [esp+1A4h] [ebp-20h]
  int v112; // [esp+1A8h] [ebp-1Ch]
  int v113; // [esp+1ACh] [ebp-18h]
  int v114; // [esp+1B0h] [ebp-14h]
  int v115; // [esp+1B4h] [ebp-10h]
  int v116; // [esp+1B8h] [ebp-Ch]
  int v117; // [esp+1BCh] [ebp-8h]
  int v118; // [esp+1C0h] [ebp-4h]

  v63 = 128;
  v64 = 0;
  v65 = 144;
  v66 = 16;
  v67 = 144;
  v68 = 0;
  v69 = 160;
  v70 = 16;
  v71 = 160;
  v72 = 0;
  v73 = 176;
  v74 = 16;
  v75 = 176;
  v76 = 0;
  v77 = 192;
  v78 = 16;
  v79 = 192;
  v80 = 0;
  v81 = 208;
  v82 = 16;
  v83 = 208;
  v84 = 0;
  v85 = 224;
  v86 = 16;
  v87 = 224;
  v88 = 0;
  v89 = 240;
  v90 = 16;
  v91 = 240;
  v92 = 0;
  v93 = 256;
  v94 = 16;
  v95 = 256;
  v96 = 0;
  v97 = 272;
  v98 = 16;
  v99 = 272;
  v100 = 0;
  v101 = 288;
  v102 = 16;
  v103 = 288;
  v104 = 0;
  v105 = 304;
  v106 = 16;
  v107 = 128;
  v108 = 0;
  v109 = 144;
  v110 = 16;
  v111 = 176;
  v112 = 0;
  v113 = 192;
  v114 = 16;
  v115 = 304;
  v116 = 0;
  v117 = 320;
  v118 = 16;
  v7 = 128;
  v8 = 16;
  v9 = 144;
  v10 = 32;
  v11 = 144;
  v12 = 16;
  v13 = 160;
  v14 = 32;
  v15 = 160;
  v16 = 16;
  v17 = 176;
  v18 = 32;
  v19 = 176;
  v20 = 16;
  v21 = 192;
  v22 = 32;
  v23 = 192;
  v24 = 16;
  v25 = 208;
  v26 = 32;
  v27 = 208;
  v28 = 16;
  v29 = 224;
  v30 = 32;
  v31 = 224;
  v32 = 16;
  v33 = 240;
  v34 = 32;
  v35 = 240;
  v36 = 16;
  v37 = 256;
  v38 = 32;
  v39 = 256;
  v40 = 16;
  v41 = 272;
  v42 = 32;
  v43 = 272;
  v44 = 16;
  v45 = 288;
  v46 = 32;
  v47 = 288;
  v48 = 16;
  v49 = 304;
  v50 = 32;
  v51 = 128;
  v52 = 16;
  v53 = 144;
  v54 = 32;
  v55 = 176;
  v56 = 16;
  v57 = 192;
  v58 = 32;
  v59 = 304;
  v60 = 16;
  v61 = 320;
  v62 = 32;
  v6 = npc->currentState;
  if ( v6 > 220 )
  {
    if ( v6 > 320 )
    {
      switch ( v6 )
      {
        case 330:
          npc->YVel = 0;
          npc->currentState = 331;
          npc->waitTimer = 0;
          setQuake(16);
          playSoundEffect(SFXLargeObjectHitGround, 1);
          goto LABEL_100;
        case 331:
LABEL_100:
          if ( ++npc->animationNumber > 13 )
            npc->animationNumber = 12;
          if ( !(++npc->waitTimer % 6) )
          {
            v2 = random(4, 16);
            createNPC((NPCNames)315, v2 << 13, 0, 0, 0, 0, 0, 256);
          }
          if ( npc->waitTimer > 30 )
          {
            npc->count1 = 0;
            npc->currentState = 130;
            npc->entityFlags |= 0x20u;
            npc->entityFlags &= 0xFFFBu;
            npc->damage = 3;
          }
          break;
        case 500:
          npc->entityFlags &= 0xFFDFu;
          npc->currentState = 501;
          npc->waitTimer = 0;
          npc->animationNumber = 8;
          npc->curlyTargetX = npc->XPos;
          npc->damage = 0;
          killNPC(315, 1);
          goto LABEL_108;
        case 501:
LABEL_108:
          npc->YVel += 32;
          if ( ++npc->waitTimer % 2 )
            npc->XPos = npc->curlyTargetX;
          else
            npc->XPos = npc->curlyTargetX + 512;
          break;
        default:
          break;
      }
    }
    else if ( v6 == 320 )
    {
      if ( ++npc->animationNumber > 13 )
        npc->animationNumber = 12;
      if ( npc->YPos < 0x2000 )
        npc->currentState = 330;
    }
    else
    {
      switch ( v6 )
      {
        case 221:
          goto LABEL_72;
        case 300:
          npc->currentState = 301;
          npc->animationNumber = 9;
          if ( npc->XPos <= quote.XPos )
            npc->direction = 2;
          else
            npc->direction = 0;
          goto LABEL_82;
        case 301:
LABEL_82:
          if ( ++npc->animationNumber > 11 )
            npc->animationNumber = 9;
          if ( npc->direction )
            npc->XVel = 1024;
          else
            npc->XVel = -1024;
          if ( quote.XPos > npc->XPos - 2048 && quote.XPos < npc->XPos + 2048 )
          {
            npc->currentState = 310;
            npc->waitTimer = 0;
            npc->animationNumber = 2;
            npc->XVel = 0;
          }
          break;
        case 310:
          npc->animationNumber = 2;
          if ( ++npc->waitTimer > 4 )
          {
            npc->currentState = 320;
            npc->animationNumber = 12;
            npc->YVel = -2048;
            playSoundEffect(SFXSillyExplosion, 1);
            npc->entityFlags |= 8u;
            npc->entityFlags &= 0xFFDFu;
            npc->entityFlags |= 4u;
            npc->damage = 10;
          }
          break;
        default:
          break;
      }
    }
  }
  else if ( v6 == 220 )
  {
    npc->currentState = 221;
    npc->waitTimer = 0;
    setQuake(16);
    playSoundEffect(SFXLargeObjectHitGround, 1);
    npc->damage = 4;
LABEL_72:
    if ( ++npc->animationNumber > 7 )
      npc->animationNumber = 6;
    if ( !(++npc->waitTimer % 6) )
    {
      v1 = random(4, 16);
      createNPC((NPCNames)314, v1 << 13, 0x2000, 0, 0, 0, 0, 256);
    }
    if ( npc->waitTimer > 30 )
    {
      npc->count1 = 0;
      npc->currentState = 130;
      npc->entityFlags |= 0x20u;
      npc->entityFlags &= 0xFFFBu;
      npc->damage = 3;
    }
  }
  else
  {
    switch ( v6 )
    {
      case 0:
        npc->currentState = 1;
        npc->animationNumber = 0;
        npc->animationTimer = 0;
        npc->YPos += 2048;
        goto LABEL_9;
      case 1:
LABEL_9:
        npc->YVel += 64;
        if ( random(0, 120) == 10 )
        {
          npc->currentState = 2;
          npc->waitTimer = 0;
          npc->animationNumber = 1;
        }
        if ( npc->XPos - 0x4000 < quote.XPos && npc->XPos + 0x4000 > quote.XPos )
        {
          if ( npc->XPos <= quote.XPos )
            npc->direction = 2;
          else
            npc->direction = 0;
        }
        break;
      case 2:
        if ( ++npc->waitTimer > 8 )
        {
          npc->currentState = 1;
          npc->animationNumber = 0;
        }
        break;
      case 100:
        npc->currentState = 110;
        npc->waitTimer = 0;
        npc->count1 = 0;
        npc->entityFlags |= 0x20u;
        goto LABEL_21;
      case 110:
LABEL_21:
        npc->damage = 1;
        if ( npc->XPos <= quote.XPos )
          npc->direction = 2;
        else
          npc->direction = 0;
        npc->animationNumber = 0;
        if ( ++npc->waitTimer > 4 )
        {
          npc->waitTimer = 0;
          npc->currentState = 120;
          if ( ++npc->count2 > 12 )
          {
            npc->count2 = 0;
            npc->currentState = 300;
          }
        }
        break;
      case 120:
        npc->animationNumber = 2;
        if ( ++npc->waitTimer > 4 )
        {
          npc->currentState = 130;
          npc->animationNumber = 3;
          npc->XVel = 2 * random(-512, 512);
          npc->YVel = -2048;
          playSoundEffect(SFXCritterHop, 1);
          ++npc->count1;
        }
        break;
      case 130:
        npc->YVel += 128;
        if ( npc->YPos > 0x10000 )
          npc->entityFlags &= 0xFFF7u;
        if ( npc->XVel < 0 && npc->collisionFlags & 1 )
          npc->XVel = -npc->XVel;
        if ( npc->XVel > 0 && npc->collisionFlags & 4 )
          npc->XVel = -npc->XVel;
        if ( npc->XPos <= quote.XPos )
          npc->direction = 2;
        else
          npc->direction = 0;
        if ( npc->YVel >= -512 )
        {
          if ( npc->YVel <= 512 )
            npc->animationNumber = 0;
          else
            npc->animationNumber = 4;
        }
        else
        {
          npc->animationNumber = 3;
        }
        if ( npc->collisionFlags & 8 )
        {
          npc->currentState = 140;
          npc->waitTimer = 0;
          npc->animationNumber = 2;
          npc->XVel = 0;
        }
        if ( npc->count1 > 4 && quote.YPos < npc->YPos + 2048 )
        {
          npc->currentState = 200;
          npc->waitTimer = 0;
          npc->XVel = 0;
          npc->YVel = 0;
        }
        break;
      case 140:
        npc->animationNumber = 2;
        if ( ++npc->waitTimer > 4 )
          npc->currentState = 110;
        break;
      case 200:
        npc->animationNumber = 5;
        if ( ++npc->waitTimer > 10 )
        {
          npc->currentState = 210;
          npc->animationNumber = 6;
          if ( npc->direction )
            npc->XVel = 1535;
          else
            npc->XVel = -1535;
          playSoundEffect(SFXSillyExplosion, 1);
          npc->entityFlags &= 0xFFDFu;
          npc->entityFlags |= 4u;
          npc->damage = 10;
        }
        break;
      case 210:
        if ( ++npc->animationNumber > 7 )
          npc->animationNumber = 6;
        if ( npc->XVel < 0 && npc->collisionFlags & 1 )
          npc->currentState = 220;
        if ( npc->XVel > 0 && npc->collisionFlags & 4 )
          npc->currentState = 220;
        break;
      default:
        break;
    }
  }
  if ( npc->currentState > 100 && npc->currentState < 500 && npc->currentState != 210 && npc->currentState != 320 )
  {
    if ( isSomeBulletActive() )
    {
      npc->entityFlags &= 0xFFDFu;
      v3 = npc->entityFlags | 4;
    }
    else
    {
      npc->entityFlags |= 0x20u;
      v3 = npc->entityFlags & 0xFFFB;
    }
    npc->entityFlags = v3;
  }
  if ( npc->YVel > 1535 )
    npc->YVel = 1535;
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  if ( npc->direction )
    v4 = &v7 + 4 * npc->animationNumber;
  else
    v4 = &v63 + 4 * npc->animationNumber;
  v5 = &npc->rect;
  v5->left = *v4;
  v5->top = v4[1];
  v5->right = v4[2];
  v5->bottom = v4[3];
}

//----- (00465CC0) --------------------------------------------------------
int __cdecl NPC314(int a1)
{
  int v1; // ST10_4
  int v2; // ST0C_4
  int v3; // ST08_4
  int v4; // eax
  int result; // eax
  int *v6; // eax
  int *v7; // ecx
  int v8; // [esp+0h] [ebp-38h]
  signed int i; // [esp+4h] [ebp-34h]
  int v10; // [esp+8h] [ebp-30h]
  int v11; // [esp+Ch] [ebp-2Ch]
  int v12; // [esp+10h] [ebp-28h]
  int v13; // [esp+14h] [ebp-24h]
  int v14; // [esp+18h] [ebp-20h]
  int v15; // [esp+1Ch] [ebp-1Ch]
  int v16; // [esp+20h] [ebp-18h]
  int v17; // [esp+24h] [ebp-14h]
  int v18; // [esp+28h] [ebp-10h]
  int v19; // [esp+2Ch] [ebp-Ch]
  int v20; // [esp+30h] [ebp-8h]
  int v21; // [esp+34h] [ebp-4h]

  v10 = 64;
  v11 = 64;
  v12 = 80;
  v13 = 80;
  v14 = 80;
  v15 = 64;
  v16 = 96;
  v17 = 80;
  v18 = 96;
  v19 = 64;
  v20 = 112;
  v21 = 80;
  v8 = *(_DWORD *)(a1 + 116);
  switch ( v8 )
  {
    case 0:
      *(_DWORD *)(a1 + 112) = 0;
      *(_DWORD *)(a1 + 116) = 100;
      *(_WORD *)(a1 + 80) |= 4u;
      *(_DWORD *)(a1 + 104) = random(0, 2);
      goto LABEL_6;
    case 100:
LABEL_6:
      *(_DWORD *)(a1 + 20) += 64;
      if ( *(_DWORD *)(a1 + 20) > 1792 )
        *(_DWORD *)(a1 + 20) = 1792;
      if ( *(_DWORD *)(a1 + 12) > 0x10000 )
        *(_WORD *)(a1 + 80) &= 0xFFF7u;
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 20) = -512;
        *(_DWORD *)(a1 + 116) = 110;
        *(_WORD *)(a1 + 80) |= 8u;
        playSoundEffect(SFXDestroyBreakableBlock, 1);
        setQuake(10);
        for ( i = 0; i < 2; ++i )
        {
          v1 = random(-1536, 0);
          v2 = random(-341, 341);
          v3 = *(_DWORD *)(a1 + 0xC) + 0x2000;
          v4 = random(-12, 12);
          createNPC(NPCSmoke, *(_DWORD *)(a1 + 8) + (v4 << 9), v3, v2, v1, 0, 0, 256);
        }
      }
      break;
    case 110:
      *(_DWORD *)(a1 + 20) += 64;
      result = a1;
      if ( *(_DWORD *)(a1 + 12) > (currentMap.length << 13) + 0x4000 )
      {
        *(_BYTE *)a1 = 0;
        return result;
      }
      break;
  }
  if ( ++*(_DWORD *)(a1 + 100) > 6 )
  {
    ++*(_DWORD *)(a1 + 100);
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 2 )
    *(_DWORD *)(a1 + 104) = 0;
  if ( quote.YPos <= *(_DWORD *)(a1 + 12) )
    *(_DWORD *)(a1 + 164) = 0;
  else
    *(_DWORD *)(a1 + 164) = 10;
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v6 = &v10 + 4 * *(_DWORD *)(a1 + 104);
  v7 = (int *)(a1 + 84);
  *v7 = *v6;
  v7[1] = v6[1];
  v7[2] = v6[2];
  result = v6[3];
  v7[3] = result;
  return result;
}

//----- (00465F60) --------------------------------------------------------
void __cdecl NPC315(void *npc)
{
  __int16 v1; // dx
  int *v2; // ecx
  int *v3; // edx
  int v4; // [esp+4h] [ebp-80h]
  int v5; // [esp+8h] [ebp-7Ch]
  int v6; // [esp+Ch] [ebp-78h]
  int v7; // [esp+10h] [ebp-74h]
  int v8; // [esp+14h] [ebp-70h]
  int v9; // [esp+18h] [ebp-6Ch]
  int v10; // [esp+1Ch] [ebp-68h]
  int v11; // [esp+20h] [ebp-64h]
  int v12; // [esp+24h] [ebp-60h]
  int v13; // [esp+28h] [ebp-5Ch]
  int v14; // [esp+2Ch] [ebp-58h]
  int v15; // [esp+30h] [ebp-54h]
  int v16; // [esp+34h] [ebp-50h]
  int v17; // [esp+38h] [ebp-4Ch]
  int v18; // [esp+3Ch] [ebp-48h]
  int v19; // [esp+40h] [ebp-44h]
  int v20; // [esp+44h] [ebp-40h]
  int v21; // [esp+48h] [ebp-3Ch]
  int v22; // [esp+4Ch] [ebp-38h]
  int v23; // [esp+50h] [ebp-34h]
  int v24; // [esp+54h] [ebp-30h]
  int v25; // [esp+58h] [ebp-2Ch]
  int v26; // [esp+5Ch] [ebp-28h]
  int v27; // [esp+60h] [ebp-24h]
  int v28; // [esp+64h] [ebp-20h]
  int v29; // [esp+68h] [ebp-1Ch]
  int v30; // [esp+6Ch] [ebp-18h]
  int v31; // [esp+70h] [ebp-14h]
  int v32; // [esp+74h] [ebp-10h]
  int v33; // [esp+78h] [ebp-Ch]
  int v34; // [esp+7Ch] [ebp-8h]
  int v35; // [esp+80h] [ebp-4h]

  v20 = 128;
  v21 = 0;
  v22 = 144;
  v23 = 16;
  v24 = 160;
  v25 = 0;
  v26 = 176;
  v27 = 16;
  v28 = 176;
  v29 = 0;
  v30 = 192;
  v31 = 16;
  v32 = 192;
  v33 = 0;
  v34 = 208;
  v35 = 16;
  v4 = 128;
  v5 = 16;
  v6 = 144;
  v7 = 32;
  v8 = 160;
  v9 = 16;
  v10 = 176;
  v11 = 32;
  v12 = 176;
  v13 = 16;
  v14 = 192;
  v15 = 32;
  v16 = 192;
  v17 = 16;
  v18 = 208;
  v19 = 32;
  switch ( *((_DWORD *)npc + 29) )
  {
    case 0:
      *((_DWORD *)npc + 26) = 3;
      *((_DWORD *)npc + 5) += 128;
      if ( *((_DWORD *)npc + 3) > 0x10000 )
      {
        *((_DWORD *)npc + 29) = 130;
        *((_WORD *)npc + 40) &= 0xFFF7u;
      }
      break;
    case 0x64:
      *((_DWORD *)npc + 29) = 110;
      *((_DWORD *)npc + 30) = 0;
      *((_DWORD *)npc + 27) = 0;
      *((_WORD *)npc + 40) |= 0x20u;
      goto LABEL_6;
    case 0x6E:
LABEL_6:
      if ( *((_DWORD *)npc + 2) <= quote.XPos )
        *((_DWORD *)npc + 19) = 2;
      else
        *((_DWORD *)npc + 19) = 0;
      *((_DWORD *)npc + 26) = 0;
      if ( ++*((_DWORD *)npc + 30) > 4 )
      {
        *((_DWORD *)npc + 30) = 0;
        *((_DWORD *)npc + 29) = 120;
      }
      break;
    case 0x78:
      *((_DWORD *)npc + 26) = 1;
      if ( ++*((_DWORD *)npc + 30) > 4 )
      {
        *((_DWORD *)npc + 29) = 130;
        *((_DWORD *)npc + 26) = 3;
        *((_DWORD *)npc + 4) = 2 * random(-512, 512);
        *((_DWORD *)npc + 5) = -2048;
        playSoundEffect(SFXCritterHop, 1);
      }
      break;
    case 0x82:
      *((_DWORD *)npc + 5) += 128;
      if ( *((_DWORD *)npc + 4) < 0 && *((_DWORD *)npc + 1) & 1 )
        *((_DWORD *)npc + 4) = -*((_DWORD *)npc + 4);
      if ( *((_DWORD *)npc + 4) > 0 && *((_DWORD *)npc + 1) & 4 )
        *((_DWORD *)npc + 4) = -*((_DWORD *)npc + 4);
      if ( *((_DWORD *)npc + 2) <= quote.XPos )
        *((_DWORD *)npc + 19) = 2;
      else
        *((_DWORD *)npc + 19) = 0;
      if ( *((_DWORD *)npc + 5) >= -512 )
      {
        if ( *((_DWORD *)npc + 5) <= 512 )
          *((_DWORD *)npc + 26) = 3;
        else
          *((_DWORD *)npc + 26) = 0;
      }
      else
      {
        *((_DWORD *)npc + 26) = 2;
      }
      if ( *((_DWORD *)npc + 1) & 8 )
      {
        *((_DWORD *)npc + 29) = 140;
        *((_DWORD *)npc + 30) = 0;
        *((_DWORD *)npc + 26) = 1;
        *((_DWORD *)npc + 4) = 0;
      }
      break;
    case 0x8C:
      *((_DWORD *)npc + 26) = 1;
      if ( ++*((_DWORD *)npc + 30) > 4 )
      {
        *((_DWORD *)npc + 29) = 110;
        *((_WORD *)npc + 40) |= 0x20u;
      }
      break;
    default:
      break;
  }
  if ( *((_DWORD *)npc + 29) > 100 )
  {
    if ( isSomeBulletActive() )
    {
      *((_WORD *)npc + 40) &= 0xFFDFu;
      v1 = *((_WORD *)npc + 40) | 4;
    }
    else
    {
      *((_WORD *)npc + 40) |= 0x20u;
      v1 = *((_WORD *)npc + 40) & 0xFFFB;
    }
    *((_WORD *)npc + 40) = v1;
  }
  if ( ++*((_DWORD *)npc + 28) <= 300 )
  {
    if ( *((_DWORD *)npc + 5) > 1535 )
      *((_DWORD *)npc + 5) = 1535;
    *((_DWORD *)npc + 2) += *((_DWORD *)npc + 4);
    *((_DWORD *)npc + 3) += *((_DWORD *)npc + 5);
    if ( *((_DWORD *)npc + 19) )
      v2 = &v4 + 4 * *((_DWORD *)npc + 26);
    else
      v2 = &v20 + 4 * *((_DWORD *)npc + 26);
    v3 = (int *)((char *)npc + 84);
    *v3 = *v2;
    v3[1] = v2[1];
    v3[2] = v2[2];
    v3[3] = v2[3];
  }
  else
  {
    Vanish_NPC((NPC *)npc);
  }
}

//----- (004664B0) --------------------------------------------------------
int __cdecl NPC316(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+0h] [ebp-64h]
  int v5; // [esp+4h] [ebp-60h]
  int v6; // [esp+8h] [ebp-5Ch]
  int v7; // [esp+Ch] [ebp-58h]
  int v8; // [esp+10h] [ebp-54h]
  int v9; // [esp+14h] [ebp-50h]
  int v10; // [esp+18h] [ebp-4Ch]
  int v11; // [esp+1Ch] [ebp-48h]
  int v12; // [esp+20h] [ebp-44h]
  int v13; // [esp+24h] [ebp-40h]
  int v14; // [esp+28h] [ebp-3Ch]
  int v15; // [esp+2Ch] [ebp-38h]
  int v16; // [esp+30h] [ebp-34h]
  int v17; // [esp+34h] [ebp-30h]
  int v18; // [esp+38h] [ebp-2Ch]
  int v19; // [esp+3Ch] [ebp-28h]
  int v20; // [esp+40h] [ebp-24h]
  int v21; // [esp+44h] [ebp-20h]
  int v22; // [esp+48h] [ebp-1Ch]
  int v23; // [esp+4Ch] [ebp-18h]
  int v24; // [esp+50h] [ebp-14h]
  int v25; // [esp+54h] [ebp-10h]
  int v26; // [esp+58h] [ebp-Ch]
  int v27; // [esp+5Ch] [ebp-8h]
  int v28; // [esp+60h] [ebp-4h]

  v17 = 248;
  v18 = 32;
  v19 = 272;
  v20 = 56;
  v21 = 272;
  v22 = 32;
  v23 = 296;
  v24 = 56;
  v25 = 296;
  v26 = 32;
  v27 = 320;
  v28 = 56;
  v5 = 248;
  v6 = 56;
  v7 = 272;
  v8 = 80;
  v9 = 272;
  v10 = 56;
  v11 = 296;
  v12 = 80;
  v13 = 296;
  v14 = 56;
  v15 = 320;
  v16 = 80;
  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 == 1 )
    {
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 104) = 1;
        *(_DWORD *)(a1 + 100) = 0;
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 120) = 0;
      }
    }
    else if ( v4 == 2 )
    {
      *(_DWORD *)(a1 + 16) = 8 * *(_DWORD *)(a1 + 16) / 9;
      if ( ++*(_DWORD *)(a1 + 100) > 3 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 2 )
        *(_DWORD *)(a1 + 104) = 1;
      if ( ++*(_DWORD *)(a1 + 120) > 50 )
        *(_BYTE *)a1 |= 8u;
    }
  }
  else
  {
    *(_WORD *)(a1 + 80) &= 0xFFDFu;
    *(_WORD *)(a1 + 80) &= 0xFFF7u;
    *(_DWORD *)(a1 + 164) = 0;
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 140) = 6144;
    *(_DWORD *)(a1 + 148) = 6144;
    *(_DWORD *)(a1 + 144) = 6144;
    *(_DWORD *)(a1 + 20) = -512;
    if ( *(_DWORD *)(a1 + 76) )
      *(_DWORD *)(a1 + 16) = -256;
    else
      *(_DWORD *)(a1 + 16) = 256;
    playSoundEffect(SFXTorokoEnemySqueal, 1);
  }
  *(_DWORD *)(a1 + 20) += 32;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v17 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (00466790) --------------------------------------------------------
NPC *__cdecl NPC317(NPC *a1)
{
  int *v1; // eax
  RECT *v2; // ecx
  NPC *result; // eax
  int v4; // [esp+4h] [ebp-80h]
  int v5; // [esp+8h] [ebp-7Ch]
  int v6; // [esp+Ch] [ebp-78h]
  int v7; // [esp+10h] [ebp-74h]
  int v8; // [esp+14h] [ebp-70h]
  int v9; // [esp+18h] [ebp-6Ch]
  int v10; // [esp+1Ch] [ebp-68h]
  int v11; // [esp+20h] [ebp-64h]
  int v12; // [esp+24h] [ebp-60h]
  int v13; // [esp+28h] [ebp-5Ch]
  int v14; // [esp+2Ch] [ebp-58h]
  int v15; // [esp+30h] [ebp-54h]
  int v16; // [esp+34h] [ebp-50h]
  int v17; // [esp+38h] [ebp-4Ch]
  int v18; // [esp+3Ch] [ebp-48h]
  int v19; // [esp+40h] [ebp-44h]
  int v20; // [esp+44h] [ebp-40h]
  int v21; // [esp+48h] [ebp-3Ch]
  int v22; // [esp+4Ch] [ebp-38h]
  int v23; // [esp+50h] [ebp-34h]
  int v24; // [esp+54h] [ebp-30h]
  int v25; // [esp+58h] [ebp-2Ch]
  int v26; // [esp+5Ch] [ebp-28h]
  int v27; // [esp+60h] [ebp-24h]
  int v28; // [esp+64h] [ebp-20h]
  int v29; // [esp+68h] [ebp-1Ch]
  int v30; // [esp+6Ch] [ebp-18h]
  int v31; // [esp+70h] [ebp-14h]
  int v32; // [esp+74h] [ebp-10h]
  int v33; // [esp+78h] [ebp-Ch]
  int v34; // [esp+7Ch] [ebp-8h]
  int v35; // [esp+80h] [ebp-4h]

  v20 = 0;
  v21 = 80;
  v22 = 32;
  v23 = 120;
  v24 = 32;
  v25 = 80;
  v26 = 64;
  v27 = 120;
  v28 = 64;
  v29 = 80;
  v30 = 96;
  v31 = 120;
  v32 = 96;
  v33 = 80;
  v34 = 128;
  v35 = 120;
  v4 = 0;
  v5 = 120;
  v6 = 32;
  v7 = 160;
  v8 = 32;
  v9 = 120;
  v10 = 64;
  v11 = 160;
  v12 = 64;
  v13 = 120;
  v14 = 96;
  v15 = 160;
  v16 = 96;
  v17 = 120;
  v18 = 128;
  v19 = 160;
  switch ( a1->currentState )
  {
    case 0:
      a1->currentState = 1;
      a1->YPos -= 4096;
      a1->curlyTargetX = a1->XPos;
      goto LABEL_3;
    case 1:
LABEL_3:
      a1->XVel = 0;
      a1->currentState = 2;
      a1->animationNumber = 0;
      a1->count1 = 0;
      goto LABEL_4;
    case 2:
LABEL_4:
      if ( a1->XPos <= quote.XPos )
        a1->direction = 2;
      else
        a1->direction = 0;
      if ( ++a1->animationTimer > 40 )
      {
        a1->animationTimer = 0;
        ++a1->animationNumber;
      }
      if ( a1->animationNumber > 1 )
        a1->animationNumber = 0;
      if ( quote.XPos > a1->XPos - 163840
        && quote.XPos < a1->XPos + 163840
        && quote.YPos > a1->YPos - 81920
        && quote.YPos < a1->YPos + 81920
        && ++a1->count1 > 50 )
      {
        a1->currentState = 10;
      }
      break;
    case 0xA:
      a1->currentState = 11;
      a1->waitTimer = 0;
      a1->animationNumber = 2;
      createNPC(NPCTreasureChestClosed|0x130, a1->XPos, a1->YPos, 0, 0, 0, a1, 256);
      goto LABEL_19;
    case 0xB:
LABEL_19:
      if ( ++a1->waitTimer > 50 )
      {
        a1->waitTimer = 0;
        a1->currentState = 12;
        a1->animationNumber = 3;
        playSoundEffect(SFXEnemyShootProjectile, 1);
      }
      break;
    case 0xC:
      if ( ++a1->waitTimer > 20 )
        a1->currentState = 1;
      break;
    default:
      break;
  }
  a1->YVel += 85;
  if ( a1->YVel > 1535 )
    a1->YVel = 1535;
  a1->XPos += a1->XVel;
  a1->YPos += a1->YVel;
  if ( a1->direction )
    v1 = &v4 + 4 * a1->animationNumber;
  else
    v1 = &v20 + 4 * a1->animationNumber;
  v2 = &a1->rect;
  v2->left = *v1;
  v2->top = v1[1];
  v2->right = v1[2];
  result = (NPC *)v1[3];
  v2->bottom = (LONG)result;
  if ( a1->life <= 936 )
  {
    a1->entityType = 318;
    result = a1;
    a1->currentState = 0;
  }
  return result;
}

//----- (00466B80) --------------------------------------------------------
int __cdecl NPC318(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+0h] [ebp-64h]
  int v5; // [esp+4h] [ebp-60h]
  int v6; // [esp+8h] [ebp-5Ch]
  int v7; // [esp+Ch] [ebp-58h]
  int v8; // [esp+10h] [ebp-54h]
  int v9; // [esp+14h] [ebp-50h]
  int v10; // [esp+18h] [ebp-4Ch]
  int v11; // [esp+1Ch] [ebp-48h]
  int v12; // [esp+20h] [ebp-44h]
  int v13; // [esp+24h] [ebp-40h]
  int v14; // [esp+28h] [ebp-3Ch]
  int v15; // [esp+2Ch] [ebp-38h]
  int v16; // [esp+30h] [ebp-34h]
  int v17; // [esp+34h] [ebp-30h]
  int v18; // [esp+38h] [ebp-2Ch]
  int v19; // [esp+3Ch] [ebp-28h]
  int v20; // [esp+40h] [ebp-24h]
  int v21; // [esp+44h] [ebp-20h]
  int v22; // [esp+48h] [ebp-1Ch]
  int v23; // [esp+4Ch] [ebp-18h]
  int v24; // [esp+50h] [ebp-14h]
  int v25; // [esp+54h] [ebp-10h]
  int v26; // [esp+58h] [ebp-Ch]
  int v27; // [esp+5Ch] [ebp-8h]
  int v28; // [esp+60h] [ebp-4h]

  v17 = 224;
  v18 = 80;
  v19 = 256;
  v20 = 120;
  v21 = 256;
  v22 = 80;
  v23 = 288;
  v24 = 120;
  v25 = 288;
  v26 = 80;
  v27 = 320;
  v28 = 120;
  v5 = 224;
  v6 = 120;
  v7 = 256;
  v8 = 160;
  v9 = 256;
  v10 = 120;
  v11 = 288;
  v12 = 160;
  v13 = 288;
  v14 = 120;
  v15 = 320;
  v16 = 160;
  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 == 1 )
    {
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 104) = 1;
        *(_DWORD *)(a1 + 100) = 0;
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 120) = 0;
      }
    }
    else if ( v4 == 2 )
    {
      *(_DWORD *)(a1 + 16) = 8 * *(_DWORD *)(a1 + 16) / 9;
      if ( ++*(_DWORD *)(a1 + 100) > 3 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 2 )
        *(_DWORD *)(a1 + 104) = 1;
      if ( ++*(_DWORD *)(a1 + 120) > 50 )
        *(_BYTE *)a1 |= 8u;
    }
  }
  else
  {
    *(_WORD *)(a1 + 80) &= 0xFFDFu;
    *(_WORD *)(a1 + 80) &= 0xFFF7u;
    *(_WORD *)(a1 + 80) &= 0xFFFEu;
    *(_DWORD *)(a1 + 164) = 0;
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 20) = -512;
    if ( *(_DWORD *)(a1 + 76) )
      *(_DWORD *)(a1 + 16) = -64;
    else
      *(_DWORD *)(a1 + 16) = 64;
    playSoundEffect(SFXHeavyPressLargeObjectHurt, 1);
  }
  *(_DWORD *)(a1 + 20) += 32;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v17 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (00466E50) --------------------------------------------------------
void __cdecl NPC319(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int v3; // [esp+0h] [ebp-34h]
  int v4; // [esp+4h] [ebp-30h]
  int v5; // [esp+8h] [ebp-2Ch]
  int v6; // [esp+Ch] [ebp-28h]
  int v7; // [esp+10h] [ebp-24h]
  int v8; // [esp+14h] [ebp-20h]
  int v9; // [esp+18h] [ebp-1Ch]
  int v10; // [esp+1Ch] [ebp-18h]
  int v11; // [esp+20h] [ebp-14h]
  int v12; // [esp+24h] [ebp-10h]
  int v13; // [esp+28h] [ebp-Ch]
  int v14; // [esp+2Ch] [ebp-8h]
  int v15; // [esp+30h] [ebp-4h]

  v4 = 16;
  v5 = 0;
  v6 = 32;
  v7 = 16;
  v8 = 16;
  v9 = 0;
  v10 = 32;
  v11 = 16;
  v12 = 96;
  v13 = 80;
  v14 = 112;
  v15 = 96;
  v3 = *(_DWORD *)(a1 + 116);
  if ( v3 )
  {
    if ( v3 == 2 )
    {
      if ( ++*(_DWORD *)(a1 + 120) == 4 )
        *(_WORD *)(a1 + 80) &= 0xFFF7u;
      *(_DWORD *)(a1 + 20) += 42;
      if ( *(_DWORD *)(a1 + 20) > 1535 )
        *(_DWORD *)(a1 + 20) = 1535;
      *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        playSoundEffect(SFXDestroyBreakableBlock, 1);
        createDustClouds(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 0, 3);
        *(_BYTE *)a1 = 0;
      }
    }
  }
  else
  {
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12) + 5120;
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 76) )
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) - 3584;
    else
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) + 3584;
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 40) == 318 )
    {
      createDustClouds(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 0, 3);
      *(_BYTE *)a1 = 0;
      return;
    }
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 104) != 2 )
    {
      *(_DWORD *)(a1 + 116) = 2;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 20) = -1024;
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12) - 2048;
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 76) )
        *(_DWORD *)(a1 + 16) = 1024;
      else
        *(_DWORD *)(a1 + 16) = -1024;
    }
  }
  if ( ++*(_DWORD *)(a1 + 104) > 2 )
    *(_DWORD *)(a1 + 104) = 0;
  v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  v2[3] = v1[3];
}

//----- (004670C0) --------------------------------------------------------
RECT *__cdecl NPC320(NPC *a1)
{
  int *v1; // edx
  RECT *result; // eax
  int v3; // [esp+0h] [ebp-60h]
  int v4; // [esp+4h] [ebp-5Ch]
  int v5; // [esp+8h] [ebp-58h]
  int v6; // [esp+Ch] [ebp-54h]
  int v7; // [esp+10h] [ebp-50h]
  int v8; // [esp+14h] [ebp-4Ch]
  int v9; // [esp+18h] [ebp-48h]
  int v10; // [esp+1Ch] [ebp-44h]
  int v11; // [esp+20h] [ebp-40h]
  int v12; // [esp+24h] [ebp-3Ch]
  int v13; // [esp+28h] [ebp-38h]
  int v14; // [esp+2Ch] [ebp-34h]
  int v15; // [esp+30h] [ebp-30h]
  int v16; // [esp+34h] [ebp-2Ch]
  int v17; // [esp+38h] [ebp-28h]
  int v18; // [esp+3Ch] [ebp-24h]
  int v19; // [esp+40h] [ebp-20h]
  int v20; // [esp+44h] [ebp-1Ch]
  int v21; // [esp+48h] [ebp-18h]
  int v22; // [esp+4Ch] [ebp-14h]
  int v23; // [esp+50h] [ebp-10h]
  int v24; // [esp+54h] [ebp-Ch]
  int v25; // [esp+58h] [ebp-8h]
  int v26; // [esp+5Ch] [ebp-4h]

  v15 = 16;
  v16 = 96;
  v17 = 32;
  v18 = 112;
  v19 = 48;
  v20 = 96;
  v21 = 64;
  v22 = 112;
  v23 = 96;
  v24 = 96;
  v25 = 112;
  v26 = 112;
  v3 = 16;
  v4 = 112;
  v5 = 32;
  v6 = 128;
  v7 = 48;
  v8 = 112;
  v9 = 64;
  v10 = 128;
  v11 = 96;
  v12 = 112;
  v13 = 112;
  v14 = 128;
  if ( !a1->currentState )
  {
    a1->currentState = 1;
    a1->XPos = quote.XPos;
    a1->YPos = quote.YPos;
    createNPC((NPCNames)321, 0, 0, 0, 0, 0, a1, 256);
  }
  if ( quote.collisionFlags & 8 )
  {
    if ( quote.isFacingUp )
    {
      a1->curlyTargetX = quote.XPos;
      a1->curlyTargetY = quote.YPos - 5120;
      a1->animationNumber = 1;
    }
    else
    {
      a1->animationNumber = 0;
      if ( quote.direction )
        a1->curlyTargetX = quote.XPos - 3584;
      else
        a1->curlyTargetX = quote.XPos + 3584;
      a1->curlyTargetY = quote.YPos - 1536;
    }
  }
  else if ( quote.isFacingUp )
  {
    a1->curlyTargetX = quote.XPos;
    a1->curlyTargetY = quote.YPos + 4096;
    a1->animationNumber = 2;
  }
  else if ( quote.isFacingDown )
  {
    a1->curlyTargetX = quote.XPos;
    a1->curlyTargetY = quote.YPos - 4096;
    a1->animationNumber = 1;
  }
  else
  {
    a1->animationNumber = 0;
    if ( quote.direction )
      a1->curlyTargetX = quote.XPos - 3584;
    else
      a1->curlyTargetX = quote.XPos + 3584;
    a1->curlyTargetY = quote.YPos - 1536;
  }
  a1->XPos += (a1->curlyTargetX - a1->XPos) / 2;
  a1->YPos += (a1->curlyTargetY - a1->YPos) / 2;
  if ( quote.animationNumber % 2 )
    a1->YPos -= 512;
  if ( quote.direction )
    v1 = &v15 + 4 * a1->animationNumber;
  else
    v1 = &v3 + 4 * a1->animationNumber;
  result = &a1->rect;
  result->left = *v1;
  result->top = v1[1];
  result->right = v1[2];
  result->bottom = v1[3];
  return result;
}

//----- (004673F0) --------------------------------------------------------
int __cdecl NPC321(int a1)
{
  int result; // eax
  int *v2; // ecx
  int *v3; // edx
  int v4; // [esp+0h] [ebp-68h]
  Directions Direction; // [esp+4h] [ebp-64h]
  int v6; // [esp+8h] [ebp-60h]
  int v7; // [esp+Ch] [ebp-5Ch]
  int v8; // [esp+10h] [ebp-58h]
  int v9; // [esp+14h] [ebp-54h]
  int v10; // [esp+18h] [ebp-50h]
  int v11; // [esp+1Ch] [ebp-4Ch]
  int v12; // [esp+20h] [ebp-48h]
  int v13; // [esp+24h] [ebp-44h]
  int v14; // [esp+28h] [ebp-40h]
  int v15; // [esp+2Ch] [ebp-3Ch]
  int v16; // [esp+30h] [ebp-38h]
  int v17; // [esp+34h] [ebp-34h]
  int v18; // [esp+38h] [ebp-30h]
  int v19; // [esp+3Ch] [ebp-2Ch]
  int v20; // [esp+40h] [ebp-28h]
  int v21; // [esp+44h] [ebp-24h]
  int v22; // [esp+48h] [ebp-20h]
  int v23; // [esp+4Ch] [ebp-1Ch]
  int v24; // [esp+50h] [ebp-18h]
  int v25; // [esp+54h] [ebp-14h]
  int v26; // [esp+58h] [ebp-10h]
  int v27; // [esp+5Ch] [ebp-Ch]
  int v28; // [esp+60h] [ebp-8h]
  int v29; // [esp+64h] [ebp-4h]

  v18 = 136;
  v19 = 152;
  v20 = 152;
  v21 = 168;
  v22 = 152;
  v23 = 152;
  v24 = 168;
  v25 = 168;
  v26 = 168;
  v27 = 152;
  v28 = 184;
  v29 = 168;
  v6 = 136;
  v7 = 168;
  v8 = 152;
  v9 = 184;
  v10 = 152;
  v11 = 168;
  v12 = 168;
  v13 = 184;
  v14 = 168;
  v15 = 168;
  v16 = 184;
  v17 = 184;
  result = a1;
  if ( *(_DWORD *)(a1 + 168) )
  {
    v4 = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 104);
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8);
        Direction = 1;
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12) - 5120;
      }
      else if ( v4 == 2 )
      {
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8);
        Direction = 3;
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12) + 5120;
      }
    }
    else
    {
      if ( quote.direction )
      {
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) - 4096;
        Direction = 0;
      }
      else
      {
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) + 4096;
        Direction = 2;
      }
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12);
    }
    *(_DWORD *)(a1 + 104) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 104);
    if ( gameFlags & 2 && countShots(43) < 2 && keyShoot & keyPressed )
    {
      createBullet(
        bulletNemesisRelated,
        *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8),
        *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12),
        Direction);
      createEffect(*(_DWORD *)(*(_DWORD *)(a1 + 168) + 8), *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12), effectStar, 0);
      playSoundEffect(SFXNemesisShot, 1);
    }
    if ( quote.direction )
      v2 = &v18 + 4 * *(_DWORD *)(a1 + 104);
    else
      v2 = &v6 + 4 * *(_DWORD *)(a1 + 104);
    v3 = (int *)(a1 + 84);
    *v3 = *v2;
    v3[1] = v2[1];
    result = v2[2];
    v3[2] = result;
    v3[3] = v2[3];
  }
  return result;
}
// 493614: using guessed type int keyShoot;
// 49E1E8: using guessed type int gameFlags;
// 49E214: using guessed type int keyPressed;

//----- (004676D0) --------------------------------------------------------
int __cdecl NPC322(int a1)
{
  int result; // eax
  int *v2; // eax
  int *v3; // ecx
  _DWORD *v4; // edx
  int v5; // [esp+4h] [ebp-34h]
  int v6; // [esp+8h] [ebp-30h]
  int v7; // [esp+Ch] [ebp-2Ch]
  int v8; // [esp+10h] [ebp-28h]
  int v9; // [esp+14h] [ebp-24h]
  int v10; // [esp+18h] [ebp-20h]
  int v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+20h] [ebp-18h]
  int v13; // [esp+24h] [ebp-14h]
  int v14; // [esp+28h] [ebp-10h]
  int v15; // [esp+2Ch] [ebp-Ch]
  int v16; // [esp+30h] [ebp-8h]
  int v17; // [esp+34h] [ebp-4h]

  v6 = 272;
  v7 = 216;
  v8 = 296;
  v9 = 240;
  v10 = 296;
  v11 = 216;
  v12 = 320;
  v13 = 240;
  v14 = 160;
  v15 = 216;
  v16 = 184;
  v17 = 240;
  result = a1;
  if ( *(_DWORD *)(a1 + 116) < 2 && *(_DWORD *)(a1 + 64) <= 968 )
  {
    *(_DWORD *)(a1 + 116) = 2;
    *(_DWORD *)(a1 + 120) = 0;
    *(_WORD *)(a1 + 80) &= 0xFFDFu;
    *(_WORD *)(a1 + 80) |= 4u;
    playSoundEffect(SFXChestOpen, 1);
  }
  v5 = *(_DWORD *)(a1 + 116);
  switch ( v5 )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      if ( *(_DWORD *)(a1 + 76) )
        *(_DWORD *)(a1 + 8) += 4096;
      else
        *(_DWORD *)(a1 + 12) += 4096;
LABEL_11:
      if ( *(_BYTE *)(a1 + 156) )
        ++*(_DWORD *)(a1 + 108);
      else
        *(_DWORD *)(a1 + 108) = 0;
      v2 = &v6 + 4 * (*(_DWORD *)(a1 + 108) / 2 % 2);
      v3 = (int *)(a1 + 84);
      *v3 = *v2;
      v3[1] = v2[1];
      v3[2] = v2[2];
      result = v2[3];
      v3[3] = result;
      return result;
    case 1:
      goto LABEL_11;
    case 2:
      *(_DWORD *)(a1 + 104) = 2;
      switch ( *(_DWORD *)(a1 + 120) )
      {
        case 0:
          createNPC(NPCTreasureChestClosed|0xC0, *(_DWORD *)(a1 + 8) + 2048, *(_DWORD *)(a1 + 12), 0, 0, 0, 0, 384);
          break;
        case 0x32:
          createNPC(NPCTreasureChestClosed|0xC0, *(_DWORD *)(a1 + 8) + 2048, *(_DWORD *)(a1 + 12), 0, 0, up, 0, 384);
          break;
        case 0x64:
          createNPC(NPCTreasureChestClosed|0xC0, *(_DWORD *)(a1 + 8) + 2048, *(_DWORD *)(a1 + 12), 0, 0, right, 0, 384);
          break;
        case 0x96:
          createNPC(NPCTreasureChestClosed|0xC0, *(_DWORD *)(a1 + 8) + 2048, *(_DWORD *)(a1 + 12), 0, 0, down, 0, 384);
          break;
        case 0xC8:
          createNPC(
            NPCTreasureChestClosed|0xC0,
            *(_DWORD *)(a1 + 8) + 2048,
            *(_DWORD *)(a1 + 12),
            0,
            0,
            (Directions)4,
            0,
            384);
          break;
        case 0xFA:
          *(_DWORD *)(a1 + 132) = 24576;
          *(_DWORD *)(a1 + 124) = 24576;
          *(_DWORD *)(a1 + 128) = 24576;
          *(_DWORD *)(a1 + 136) = 24576;
          *(_DWORD *)(a1 + 164) = 12;
          playSoundEffect(SFXLargeObjectHitGround, 1);
          createDustClouds(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 24576, 40);
          setQuake(10);
          if ( *(_DWORD *)(a1 + 76) )
          {
            deleteTile((*(_DWORD *)(a1 + 8) - 4096) / 512 / 16, *(_DWORD *)(a1 + 12) / 512 / 16);
            deleteTile((*(_DWORD *)(a1 + 8) + 4096) / 512 / 16, *(_DWORD *)(a1 + 12) / 512 / 16);
          }
          else
          {
            deleteTile(*(_DWORD *)(a1 + 8) / 512 / 16, (*(_DWORD *)(a1 + 12) - 4096) / 512 / 16);
            deleteTile(*(_DWORD *)(a1 + 8) / 512 / 16, (*(_DWORD *)(a1 + 12) + 4096) / 512 / 16);
          }
          *(_BYTE *)a1 |= 8u;
          break;
        default:
          break;
      }
      ++*(_DWORD *)(a1 + 120);
      v4 = (_DWORD *)(a1 + 84);
      *v4 = v14;
      v4[1] = v15;
      result = v16;
      v4[2] = v16;
      v4[3] = v17;
      break;
  }
  return result;
}

//----- (00467C60) --------------------------------------------------------
int *__cdecl NPC323(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+8h] [ebp-44h]
  int v4; // [esp+Ch] [ebp-40h]
  int v5; // [esp+10h] [ebp-3Ch]
  int v6; // [esp+14h] [ebp-38h]
  int v7; // [esp+18h] [ebp-34h]
  int v8; // [esp+1Ch] [ebp-30h]
  int v9; // [esp+20h] [ebp-2Ch]
  int v10; // [esp+24h] [ebp-28h]
  int v11; // [esp+28h] [ebp-24h]
  int v12; // [esp+2Ch] [ebp-20h]
  int v13; // [esp+30h] [ebp-1Ch]
  int v14; // [esp+34h] [ebp-18h]
  int v15; // [esp+38h] [ebp-14h]
  int v16; // [esp+3Ch] [ebp-10h]
  int v17; // [esp+40h] [ebp-Ch]
  int v18; // [esp+44h] [ebp-8h]
  int v19; // [esp+48h] [ebp-4h]

  v4 = 216;
  v5 = 32;
  v6 = 232;
  v7 = 56;
  v8 = 232;
  v9 = 32;
  v10 = 248;
  v11 = 56;
  v12 = 216;
  v13 = 56;
  v14 = 232;
  v15 = 80;
  v16 = 232;
  v17 = 56;
  v18 = 248;
  v19 = 80;
  if ( ++*(_DWORD *)(a1 + 100) > 3 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    if ( ++*(_DWORD *)(a1 + 104) > 3 )
      *(_DWORD *)(a1 + 104) = 0;
  }
  v3 = *(_DWORD *)(a1 + 116);
  if ( v3 )
  {
    if ( v3 != 1 )
      goto LABEL_29;
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    switch ( *(_DWORD *)(a1 + 76) )
    {
      case 0:
        *(_DWORD *)(a1 + 16) = -1536;
        break;
      case 1:
        *(_DWORD *)(a1 + 20) = -1536;
        break;
      case 2:
        *(_DWORD *)(a1 + 16) = 1536;
        break;
      case 3:
        *(_DWORD *)(a1 + 20) = 1536;
        break;
      default:
        break;
    }
  }
  if ( ++*(_DWORD *)(a1 + 120) == 16 )
    *(_WORD *)(a1 + 80) &= 0xFFF7u;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(a1 + 4) & 0xFF )
    *(_DWORD *)(a1 + 116) = 10;
  if ( *(_DWORD *)(a1 + 120) > 20 )
  {
    switch ( *(_DWORD *)(a1 + 76) )
    {
      case 0:
        if ( *(_DWORD *)(a1 + 8) <= quote.XPos + 0x4000 )
          *(_DWORD *)(a1 + 116) = 10;
        break;
      case 1:
        if ( *(_DWORD *)(a1 + 12) <= quote.YPos + 0x4000 )
          *(_DWORD *)(a1 + 116) = 10;
        break;
      case 2:
        if ( *(_DWORD *)(a1 + 8) >= quote.XPos - 0x4000 )
          *(_DWORD *)(a1 + 116) = 10;
        break;
      case 3:
        if ( *(_DWORD *)(a1 + 12) >= quote.YPos - 0x4000 )
          *(_DWORD *)(a1 + 116) = 10;
        break;
      default:
        break;
    }
  }
LABEL_29:
  if ( *(_DWORD *)(a1 + 116) == 10 )
  {
    *(_DWORD *)(a1 + 40) = 309;
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 116) = 11;
    *(_WORD *)(a1 + 80) |= 0x20u;
    *(_WORD *)(a1 + 80) &= 0xFFF7u;
    *(_DWORD *)(a1 + 164) = 5;
    *(_DWORD *)(a1 + 144) = 4096;
  }
  v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (00467F40) --------------------------------------------------------
void __cdecl NPC324(int a1)
{
  int v1; // [esp+0h] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 116);
  if ( v1 == 10 )
  {
    *(_DWORD *)(a1 + 116) = 11;
    *(_DWORD *)(a1 + 120) = 0;
  }
  else if ( v1 != 11 )
  {
    return;
  }
  if ( ++*(_DWORD *)(a1 + 120) % 50 == 1 )
    createNPC((NPCNames)323, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 0, 0, *(Directions *)(a1 + 76), 0, 256);
  if ( *(_DWORD *)(a1 + 120) > 351 )
    *(_DWORD *)(a1 + 116) = 0;
}

//----- (00467FE0) --------------------------------------------------------
int __cdecl NPC325(int a1)
{
  int result; // eax
  int *v2; // eax
  int *v3; // ecx
  int v4; // [esp+0h] [ebp-74h]
  int v5; // [esp+4h] [ebp-70h]
  int v6; // [esp+8h] [ebp-6Ch]
  int v7; // [esp+Ch] [ebp-68h]
  int v8; // [esp+10h] [ebp-64h]
  int v9; // [esp+14h] [ebp-60h]
  int v10; // [esp+18h] [ebp-5Ch]
  int v11; // [esp+1Ch] [ebp-58h]
  int v12; // [esp+20h] [ebp-54h]
  int v13; // [esp+24h] [ebp-50h]
  int v14; // [esp+28h] [ebp-4Ch]
  int v15; // [esp+2Ch] [ebp-48h]
  int v16; // [esp+30h] [ebp-44h]
  int v17; // [esp+34h] [ebp-40h]
  int v18; // [esp+38h] [ebp-3Ch]
  int v19; // [esp+3Ch] [ebp-38h]
  int v20; // [esp+40h] [ebp-34h]
  int v21; // [esp+44h] [ebp-30h]
  int v22; // [esp+48h] [ebp-2Ch]
  int v23; // [esp+4Ch] [ebp-28h]
  int v24; // [esp+50h] [ebp-24h]
  int v25; // [esp+54h] [ebp-20h]
  int v26; // [esp+58h] [ebp-1Ch]
  int v27; // [esp+5Ch] [ebp-18h]
  int v28; // [esp+60h] [ebp-14h]
  int v29; // [esp+64h] [ebp-10h]
  int v30; // [esp+68h] [ebp-Ch]
  int v31; // [esp+6Ch] [ebp-8h]
  int v32; // [esp+70h] [ebp-4h]

  v5 = 240;
  v6 = 96;
  v7 = 272;
  v8 = 128;
  v9 = 272;
  v10 = 96;
  v11 = 304;
  v12 = 128;
  v13 = 240;
  v14 = 128;
  v15 = 272;
  v16 = 160;
  v17 = 240;
  v18 = 0;
  v19 = 256;
  v20 = 96;
  v21 = 256;
  v22 = 0;
  v23 = 272;
  v24 = 96;
  v25 = 272;
  v26 = 0;
  v27 = 288;
  v28 = 96;
  v29 = 288;
  v30 = 0;
  v31 = 304;
  v32 = 96;
  v4 = *(_DWORD *)(a1 + 116);
  switch ( v4 )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      playSoundEffect(SFXTeleport, 1);
      goto LABEL_6;
    case 1:
LABEL_6:
      if ( ++*(_DWORD *)(a1 + 100) > 0 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 2 )
        *(_DWORD *)(a1 + 104) = 0;
      if ( ++*(_DWORD *)(a1 + 120) > 50 )
      {
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 100) = 0;
        *(_DWORD *)(a1 + 104) = 3;
        *(_DWORD *)(a1 + 164) = 10;
        *(_DWORD *)(a1 + 140) = 4096;
        *(_DWORD *)(a1 + 144) = 6144;
        playSoundEffect(SFXLightning, 1);
        createDustClouds(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12) + 43008, 0, 3);
      }
      break;
    case 10:
      if ( ++*(_DWORD *)(a1 + 100) > 2 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 6 )
      {
        result = a1;
        *(_BYTE *)a1 = 0;
        return result;
      }
      break;
  }
  v2 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  v3 = (int *)(a1 + 84);
  *v3 = *v2;
  v3[1] = v2[1];
  v3[2] = v2[2];
  result = v2[3];
  v3[3] = result;
  return result;
}

//----- (00468230) --------------------------------------------------------
RECT *__cdecl NPC326(NPC *a1)
{
  int *v1; // edx
  RECT *result; // eax
  int v3; // [esp+4h] [ebp-100h]
  int v4; // [esp+8h] [ebp-FCh]
  int v5; // [esp+Ch] [ebp-F8h]
  int v6; // [esp+10h] [ebp-F4h]
  int v7; // [esp+14h] [ebp-F0h]
  int v8; // [esp+18h] [ebp-ECh]
  int v9; // [esp+1Ch] [ebp-E8h]
  int v10; // [esp+20h] [ebp-E4h]
  int v11; // [esp+24h] [ebp-E0h]
  int v12; // [esp+28h] [ebp-DCh]
  int v13; // [esp+2Ch] [ebp-D8h]
  int v14; // [esp+30h] [ebp-D4h]
  int v15; // [esp+34h] [ebp-D0h]
  int v16; // [esp+38h] [ebp-CCh]
  int v17; // [esp+3Ch] [ebp-C8h]
  int v18; // [esp+40h] [ebp-C4h]
  int v19; // [esp+44h] [ebp-C0h]
  int v20; // [esp+48h] [ebp-BCh]
  int v21; // [esp+4Ch] [ebp-B8h]
  int v22; // [esp+50h] [ebp-B4h]
  int v23; // [esp+54h] [ebp-B0h]
  int v24; // [esp+58h] [ebp-ACh]
  int v25; // [esp+5Ch] [ebp-A8h]
  int v26; // [esp+60h] [ebp-A4h]
  int v27; // [esp+64h] [ebp-A0h]
  int v28; // [esp+68h] [ebp-9Ch]
  int v29; // [esp+6Ch] [ebp-98h]
  int v30; // [esp+70h] [ebp-94h]
  int v31; // [esp+74h] [ebp-90h]
  int v32; // [esp+78h] [ebp-8Ch]
  int v33; // [esp+7Ch] [ebp-88h]
  int v34; // [esp+80h] [ebp-84h]
  int v35; // [esp+84h] [ebp-80h]
  int v36; // [esp+88h] [ebp-7Ch]
  int v37; // [esp+8Ch] [ebp-78h]
  int v38; // [esp+90h] [ebp-74h]
  int v39; // [esp+94h] [ebp-70h]
  int v40; // [esp+98h] [ebp-6Ch]
  int v41; // [esp+9Ch] [ebp-68h]
  int v42; // [esp+A0h] [ebp-64h]
  int v43; // [esp+A4h] [ebp-60h]
  int v44; // [esp+A8h] [ebp-5Ch]
  int v45; // [esp+ACh] [ebp-58h]
  int v46; // [esp+B0h] [ebp-54h]
  int v47; // [esp+B4h] [ebp-50h]
  int v48; // [esp+B8h] [ebp-4Ch]
  int v49; // [esp+BCh] [ebp-48h]
  int v50; // [esp+C0h] [ebp-44h]
  int v51; // [esp+C4h] [ebp-40h]
  int v52; // [esp+C8h] [ebp-3Ch]
  int v53; // [esp+CCh] [ebp-38h]
  int v54; // [esp+D0h] [ebp-34h]
  int v55; // [esp+D4h] [ebp-30h]
  int v56; // [esp+D8h] [ebp-2Ch]
  int v57; // [esp+DCh] [ebp-28h]
  int v58; // [esp+E0h] [ebp-24h]
  int v59; // [esp+E4h] [ebp-20h]
  int v60; // [esp+E8h] [ebp-1Ch]
  int v61; // [esp+ECh] [ebp-18h]
  int v62; // [esp+F0h] [ebp-14h]
  int v63; // [esp+F4h] [ebp-10h]
  int v64; // [esp+F8h] [ebp-Ch]
  int v65; // [esp+FCh] [ebp-8h]
  int v66; // [esp+100h] [ebp-4h]

  switch ( a1->currentState )
  {
    case 0:
      a1->currentState = 1;
      a1->YPos -= 4096;
      a1->XPos += 0x2000;
      a1->animationNumber = 0;
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( ++a1->waitTimer <= 80 )
      {
        if ( a1->direction )
        {
          if ( a1->waitTimer == 50 )
            a1->animationNumber = 1;
          if ( a1->waitTimer == 60 )
            a1->animationNumber = 0;
        }
        else
        {
          if ( a1->waitTimer == 30 )
            a1->animationNumber = 1;
          if ( a1->waitTimer == 40 )
            a1->animationNumber = 0;
        }
      }
      else
      {
        a1->currentState = 10;
        a1->waitTimer = 0;
      }
      break;
    case 0xA:
      if ( ++a1->waitTimer <= 50 )
      {
        if ( a1->waitTimer / 2 % 2 )
          a1->animationNumber = 2;
        else
          a1->animationNumber = 3;
      }
      else
      {
        a1->currentState = 15;
        a1->animationNumber = 4;
        if ( a1->direction )
          a1->waitTimer = -20;
        else
          a1->waitTimer = 0;
      }
      break;
    case 0xF:
      if ( ++a1->waitTimer > 40 )
      {
        a1->waitTimer = 0;
        a1->currentState = 20;
      }
      break;
    case 0x14:
      a1->YVel += 64;
      if ( a1->YVel > 1535 )
        a1->YVel = 1535;
      a1->YPos += a1->YVel;
      if ( ++a1->waitTimer > 50 )
      {
        a1->currentState = 30;
        a1->waitTimer = 0;
        a1->animationNumber = 6;
        if ( a1->direction )
          createNPC(NPCEnemyBasil|0x140, a1->XPos, a1->YPos - 4096, 0, 0, 0, a1, 256);
        else
          createNPC(NPCEnemyBasil|0x140, a1->XPos, a1->YPos - 0x2000, 0, 0, 0, a1, 256);
      }
      break;
    case 0x1E:
      if ( ++a1->waitTimer == 30 )
        a1->animationNumber = 7;
      if ( a1->waitTimer == 40 )
        a1->currentState = 40;
      break;
    case 0x28:
      a1->currentState = 41;
      a1->waitTimer = 0;
      a1->animationNumber = 0;
      goto LABEL_42;
    case 0x29:
LABEL_42:
      if ( ++a1->waitTimer == 30 )
        a1->animationNumber = 1;
      if ( a1->waitTimer == 40 )
        a1->animationNumber = 0;
      break;
    default:
      break;
  }
  v35 = 0;
  v36 = 128;
  v37 = 16;
  v38 = 152;
  v39 = 16;
  v40 = 128;
  v41 = 32;
  v42 = 152;
  v43 = 32;
  v44 = 128;
  v45 = 48;
  v46 = 152;
  v47 = 48;
  v48 = 128;
  v49 = 64;
  v50 = 152;
  v51 = 64;
  v52 = 128;
  v53 = 80;
  v54 = 152;
  v55 = 80;
  v56 = 128;
  v57 = 96;
  v58 = 152;
  v59 = 96;
  v60 = 128;
  v61 = 112;
  v62 = 152;
  v63 = 112;
  v64 = 128;
  v65 = 128;
  v66 = 152;
  v3 = 128;
  v4 = 128;
  v5 = 144;
  v6 = 152;
  v7 = 144;
  v8 = 128;
  v9 = 160;
  v10 = 152;
  v11 = 160;
  v12 = 128;
  v13 = 176;
  v14 = 152;
  v15 = 176;
  v16 = 128;
  v17 = 192;
  v18 = 152;
  v19 = 192;
  v20 = 128;
  v21 = 208;
  v22 = 152;
  v23 = 208;
  v24 = 128;
  v25 = 224;
  v26 = 152;
  v27 = 224;
  v28 = 128;
  v29 = 240;
  v30 = 152;
  v31 = 32;
  v32 = 152;
  v33 = 48;
  v34 = 176;
  if ( a1->direction )
    v1 = &v3 + 4 * a1->animationNumber;
  else
    v1 = &v35 + 4 * a1->animationNumber;
  result = &a1->rect;
  result->left = *v1;
  result->top = v1[1];
  result->right = v1[2];
  result->bottom = v1[3];
  return result;
}

//----- (00468830) --------------------------------------------------------
int __cdecl NPC327(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+0h] [ebp-24h]
  int v5; // [esp+4h] [ebp-20h]
  int v6; // [esp+8h] [ebp-1Ch]
  int v7; // [esp+Ch] [ebp-18h]
  int v8; // [esp+10h] [ebp-14h]
  int v9; // [esp+14h] [ebp-10h]
  int v10; // [esp+18h] [ebp-Ch]
  int v11; // [esp+1Ch] [ebp-8h]
  int v12; // [esp+20h] [ebp-4h]

  v5 = 240;
  v6 = 80;
  v7 = 256;
  v8 = 96;
  v9 = 256;
  v10 = 80;
  v11 = 272;
  v12 = 96;
  ++*(_DWORD *)(a1 + 120);
  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 == 1 )
    {
      if ( *(_DWORD *)(a1 + 120) >= 48 )
      {
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 32);
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 36);
      }
      else
      {
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 32) + (random(-1, 1) << 9);
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 36) + (random(-1, 1) << 9);
      }
    }
  }
  else
  {
    if ( *(_DWORD *)(a1 + 120) < 4 )
      *(_DWORD *)(a1 + 12) -= 1024;
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 104) == 7 )
    {
      *(_DWORD *)(a1 + 104) = 1;
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 12);
    }
  }
  if ( *(_DWORD *)(a1 + 120) > 70 )
    *(_BYTE *)a1 = 0;
  v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (00468990) --------------------------------------------------------
_DWORD *__cdecl NPC328(int a1)
{
  _DWORD *result; // eax

  result = (_DWORD *)(a1 + 84);
  *result = 96;
  result[1] = 0;
  result[2] = 128;
  result[3] = 48;
  return result;
}

//----- (004689E0) --------------------------------------------------------
signed int __cdecl NPC329(int a1)
{
  _DWORD *v1; // ecx
  signed int result; // eax

  if ( ++*(_DWORD *)(a1 + 100) / 2 % 2 )
  {
    v1 = (_DWORD *)(a1 + 84);
    *v1 = 48;
    v1[1] = 0;
    v1[2] = 64;
  }
  else
  {
    v1 = (_DWORD *)(a1 + 84);
    *v1 = 64;
    v1[1] = 0;
    v1[2] = 80;
  }
  result = 16;
  v1[3] = 16;
  return result;
}

//----- (00468A90) --------------------------------------------------------
int *__cdecl NPC330(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+4h] [ebp-30h]
  int v4; // [esp+8h] [ebp-2Ch]
  int v5; // [esp+Ch] [ebp-28h]
  int v6; // [esp+10h] [ebp-24h]
  int v7; // [esp+14h] [ebp-20h]
  int v8; // [esp+18h] [ebp-1Ch]
  int v9; // [esp+1Ch] [ebp-18h]
  int v10; // [esp+20h] [ebp-14h]
  int v11; // [esp+24h] [ebp-10h]
  int v12; // [esp+28h] [ebp-Ch]
  int v13; // [esp+2Ch] [ebp-8h]
  int v14; // [esp+30h] [ebp-4h]

  v3 = 144;
  v4 = 136;
  v5 = 160;
  v6 = 152;
  v7 = 160;
  v8 = 136;
  v9 = 176;
  v10 = 152;
  v11 = 176;
  v12 = 136;
  v13 = 192;
  v14 = 152;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      changeMapParts(*(_DWORD *)(a1 + 8) / 512 / 16, *(_DWORD *)(a1 + 12) / 512 / 16, 0);
      if ( *(_DWORD *)(a1 + 76) )
        *(_DWORD *)(a1 + 116) = 30;
      else
        *(_DWORD *)(a1 + 116) = 10;
      break;
    case 0xA:
      *(_DWORD *)(a1 + 16) -= 64;
      *(_DWORD *)(a1 + 20) = 0;
      if ( *(_DWORD *)(a1 + 4) & 1 )
        *(_DWORD *)(a1 + 116) = 20;
      break;
    case 0x14:
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 20) -= 64;
      if ( *(_DWORD *)(a1 + 4) & 2 )
        *(_DWORD *)(a1 + 116) = 30;
      break;
    case 0x1E:
      *(_DWORD *)(a1 + 16) += 64;
      *(_DWORD *)(a1 + 20) = 0;
      if ( *(_DWORD *)(a1 + 4) & 4 )
        *(_DWORD *)(a1 + 116) = 40;
      break;
    case 0x28:
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 20) += 64;
      if ( *(_DWORD *)(a1 + 4) & 8 )
        *(_DWORD *)(a1 + 116) = 10;
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a1 + 16) < -1024 )
    *(_DWORD *)(a1 + 16) = -1024;
  if ( *(_DWORD *)(a1 + 16) > 1024 )
    *(_DWORD *)(a1 + 16) = 1024;
  if ( *(_DWORD *)(a1 + 20) < -1024 )
    *(_DWORD *)(a1 + 20) = -1024;
  if ( *(_DWORD *)(a1 + 20) > 1024 )
    *(_DWORD *)(a1 + 20) = 1024;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  if ( ++*(_DWORD *)(a1 + 100) > 1 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 2 )
    *(_DWORD *)(a1 + 104) = 0;
  v1 = &v3 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (00468D70) --------------------------------------------------------
int __cdecl NPC331(int a1)
{
  int v1; // ecx
  int *v2; // ecx
  int *v3; // edx
  int result; // eax
  int v5; // [esp+0h] [ebp-44h]
  int v6; // [esp+4h] [ebp-40h]
  int v7; // [esp+8h] [ebp-3Ch]
  int v8; // [esp+Ch] [ebp-38h]
  int v9; // [esp+10h] [ebp-34h]
  int v10; // [esp+14h] [ebp-30h]
  int v11; // [esp+18h] [ebp-2Ch]
  int v12; // [esp+1Ch] [ebp-28h]
  int v13; // [esp+20h] [ebp-24h]
  int v14; // [esp+24h] [ebp-20h]
  int v15; // [esp+28h] [ebp-1Ch]
  int v16; // [esp+2Ch] [ebp-18h]
  int v17; // [esp+30h] [ebp-14h]
  int v18; // [esp+34h] [ebp-10h]
  int v19; // [esp+38h] [ebp-Ch]
  int v20; // [esp+3Ch] [ebp-8h]
  int v21; // [esp+40h] [ebp-4h]

  v6 = 288;
  v7 = 80;
  v8 = 304;
  v9 = 96;
  v10 = 304;
  v11 = 80;
  v12 = 320;
  v13 = 96;
  v14 = 288;
  v15 = 96;
  v16 = 304;
  v17 = 112;
  v18 = 304;
  v19 = 96;
  v20 = 320;
  v21 = 112;
  v5 = *(_DWORD *)(a1 + 116);
  if ( v5 )
  {
    if ( v5 != 1 )
    {
      if ( v5 == 10 && *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_BYTE *)a1 = 0;
        createEffect(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), effectRisingDisc, 0);
      }
      goto LABEL_11;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
  }
  if ( *(_DWORD *)(a1 + 4) & 8 )
  {
    *(_DWORD *)(a1 + 0x14) = -512;
    *(_DWORD *)(a1 + 116) = 10;
  }
LABEL_11:
  *(_DWORD *)(a1 + 20) += 64;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  if ( ++*(_DWORD *)(a1 + 100) > 3 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    if ( *(_DWORD *)(a1 + 76) )
      v1 = *(_DWORD *)(a1 + 104) - 1;
    else
      v1 = *(_DWORD *)(a1 + 104) + 1;
    *(_DWORD *)(a1 + 104) = v1;
    if ( *(_DWORD *)(a1 + 104) < 0 )
      *(_DWORD *)(a1 + 104) += 4;
    if ( *(_DWORD *)(a1 + 104) > 3 )
      *(_DWORD *)(a1 + 104) -= 4;
  }
  v2 = &v6 + 4 * *(_DWORD *)(a1 + 104);
  v3 = (int *)(a1 + 84);
  *v3 = *v2;
  v3[1] = v2[1];
  result = v2[2];
  v3[2] = result;
  v3[3] = v2[3];
  return result;
}

//----- (00468F50) --------------------------------------------------------
int *__cdecl NPC332(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+0h] [ebp-38h]
  int X_Vel; // [esp+4h] [ebp-34h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]
  int v15; // [esp+30h] [ebp-8h]
  int v16; // [esp+34h] [ebp-4h]

  v5 = 144;
  v6 = 96;
  v7 = 168;
  v8 = 120;
  v9 = 168;
  v10 = 96;
  v11 = 192;
  v12 = 120;
  v13 = 192;
  v14 = 96;
  v15 = 216;
  v16 = 120;
  v3 = *(_DWORD *)(a1 + 116);
  if ( v3 )
  {
    if ( v3 != 1 )
      goto LABEL_15;
  }
  else
  {
    playSoundEffect(SFXMissileImpact, 1);
    *(_DWORD *)(a1 + 116) = 1;
    if ( *(_DWORD *)(a1 + 76) )
      *(_DWORD *)(a1 + 0x10) = 1024;
    else
      *(_DWORD *)(a1 + 0x10) = -1024;
  }
  if ( ++*(_DWORD *)(a1 + 100) > 1 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    if ( ++*(_DWORD *)(a1 + 104) > 2 )
      *(_DWORD *)(a1 + 104) = 0;
  }
  if ( ++*(_DWORD *)(a1 + 120) % 6 == 1 )
  {
    if ( *(_DWORD *)(a1 + 76) )
      X_Vel = (random(4, 16) << 9) / 8;
    else
      X_Vel = (random(-16, -4) << 9) / 8;
    createNPC(NPCProjectileBalrogEnemyBounce|0x140, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), X_Vel, -1024, 0, 0, 256);
    playSoundEffect(SFXDestroyBreakableBlock, 1);
  }
LABEL_15:
  if ( *(_DWORD *)(a1 + 4) & 1 )
    *(_BYTE *)a1 = 0;
  if ( *(_DWORD *)(a1 + 4) & 4 )
    *(_BYTE *)a1 = 0;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (00469140) --------------------------------------------------------
int __cdecl NPC333(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+0h] [ebp-24h]
  int v5; // [esp+4h] [ebp-20h]
  int v6; // [esp+8h] [ebp-1Ch]
  int v7; // [esp+Ch] [ebp-18h]
  int v8; // [esp+10h] [ebp-14h]
  int v9; // [esp+14h] [ebp-10h]
  int v10; // [esp+18h] [ebp-Ch]
  int v11; // [esp+1Ch] [ebp-8h]
  int v12; // [esp+20h] [ebp-4h]

  v5 = 80;
  v6 = 120;
  v7 = 104;
  v8 = 144;
  v9 = 104;
  v10 = 120;
  v11 = 128;
  v12 = 144;
  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 != 1 )
      goto LABEL_13;
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 12);
    playSoundEffect(SFXBallosBallAndCurlyChargingHerGun, 1);
    *(_DWORD *)(a1 + 12) = quote.YPos;
  }
  if ( ++*(_DWORD *)(a1 + 120) / 2 % 2 )
    *(_DWORD *)(a1 + 104) = 0;
  else
    *(_DWORD *)(a1 + 104) = 1;
  if ( !*(_DWORD *)(a1 + 76) && *(_DWORD *)(a1 + 120) == 20 )
    createNPC((NPCNames)146, *(_DWORD *)(a1 + 32), *(_DWORD *)(a1 + 36), 0, 0, 0, 0, 256);
  if ( *(_DWORD *)(a1 + 120) > 40 )
    *(_BYTE *)a1 = 0;
LABEL_13:
  v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (00469290) --------------------------------------------------------
int __cdecl NPC334(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  int v4; // [esp+0h] [ebp-44h]
  int v5; // [esp+4h] [ebp-40h]
  int v6; // [esp+8h] [ebp-3Ch]
  int v7; // [esp+Ch] [ebp-38h]
  int v8; // [esp+10h] [ebp-34h]
  int v9; // [esp+14h] [ebp-30h]
  int v10; // [esp+18h] [ebp-2Ch]
  int v11; // [esp+1Ch] [ebp-28h]
  int v12; // [esp+20h] [ebp-24h]
  int v13; // [esp+24h] [ebp-20h]
  int v14; // [esp+28h] [ebp-1Ch]
  int v15; // [esp+2Ch] [ebp-18h]
  int v16; // [esp+30h] [ebp-14h]
  int v17; // [esp+34h] [ebp-10h]
  int v18; // [esp+38h] [ebp-Ch]
  int v19; // [esp+3Ch] [ebp-8h]
  int v20; // [esp+40h] [ebp-4h]

  v13 = 160;
  v14 = 184;
  v15 = 168;
  v16 = 200;
  v17 = 168;
  v18 = 184;
  v19 = 176;
  v20 = 200;
  v5 = 176;
  v6 = 184;
  v7 = 184;
  v8 = 200;
  v9 = 184;
  v10 = 184;
  v11 = 192;
  v12 = 200;
  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 != 10 )
      goto LABEL_12;
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 10;
    if ( *(_DWORD *)(a1 + 76) )
    {
      *(_DWORD *)(a1 + 8) = quote.XPos - 5120;
      *(_DWORD *)(a1 + 12) = quote.YPos - 1024;
    }
    else
    {
      *(_DWORD *)(a1 + 8) += 5120;
      *(_DWORD *)(a1 + 12) -= 9216;
    }
  }
  if ( ++*(_DWORD *)(a1 + 120) / 8 % 2 )
    *(_DWORD *)(a1 + 104) = 0;
  else
    *(_DWORD *)(a1 + 104) = 1;
  if ( *(_DWORD *)(a1 + 120) >= 64 )
    *(_BYTE *)a1 = 0;
LABEL_12:
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v13 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}

//----- (00469430) --------------------------------------------------------
int __cdecl NPC335(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  int v4; // [esp+4h] [ebp-30h]
  int v5; // [esp+8h] [ebp-2Ch]
  int v6; // [esp+Ch] [ebp-28h]
  int v7; // [esp+10h] [ebp-24h]
  int v8; // [esp+14h] [ebp-20h]
  int v9; // [esp+18h] [ebp-1Ch]
  int v10; // [esp+1Ch] [ebp-18h]
  int v11; // [esp+20h] [ebp-14h]
  int v12; // [esp+24h] [ebp-10h]
  int v13; // [esp+28h] [ebp-Ch]
  int v14; // [esp+2Ch] [ebp-8h]
  int v15; // [esp+30h] [ebp-4h]

  v4 = 0;
  v5 = 16;
  v6 = 16;
  v7 = 32;
  v8 = 16;
  v9 = 16;
  v10 = 32;
  v11 = 32;
  v12 = 32;
  v13 = 16;
  v14 = 48;
  v15 = 32;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 120) = random(3, 20);
      goto LABEL_3;
    case 1:
LABEL_3:
      if ( --*(_DWORD *)(a1 + 120) <= 0 )
      {
        *(_DWORD *)(a1 + 116) = 2;
        *(_DWORD *)(a1 + 120) = random(10, 50);
        *(_DWORD *)(a1 + 104) = 1;
        *(_DWORD *)(a1 + 16) = 1536;
      }
      break;
    case 2:
      if ( --*(_DWORD *)(a1 + 120) <= 0 )
      {
        *(_DWORD *)(a1 + 116) = 3;
        *(_DWORD *)(a1 + 120) = random(40, 50);
        *(_DWORD *)(a1 + 104) = 2;
        *(_DWORD *)(a1 + 20) = random(-256, 256);
      }
      break;
    case 3:
      if ( --*(_DWORD *)(a1 + 120) <= 0 )
      {
        *(_DWORD *)(a1 + 116) = 1;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 0;
      }
      break;
    default:
      break;
  }
  *(_DWORD *)(a1 + 16) -= 16;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}

//----- (00469610) --------------------------------------------------------
void __cdecl NPC336(int a1)
{
  int v1; // eax
  int v2; // [esp+0h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 116);
  if ( v2 )
  {
    if ( v2 == 10 && ++*(_DWORD *)(a1 + 120) % 4 == 1 )
    {
      v1 = random(0, 13);
      createNPC(NPCTreasureChestClosed|0x140, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12) + (v1 << 13), 0, 0, 0, 0, 0);
    }
  }
  else if ( quote.Invincibility_Timer )
  {
    *(_BYTE *)a1 = 0;
  }
}

//----- (004696B0) --------------------------------------------------------
int __cdecl NPC337(int a1)
{
  int *v1; // ecx
  int *v2; // edx
  int result; // eax
  int v4; // [esp+0h] [ebp-24h]
  int v5; // [esp+4h] [ebp-20h]
  int v6; // [esp+8h] [ebp-1Ch]
  int v7; // [esp+Ch] [ebp-18h]
  int v8; // [esp+10h] [ebp-14h]
  int v9; // [esp+14h] [ebp-10h]
  int v10; // [esp+18h] [ebp-Ch]
  int v11; // [esp+1Ch] [ebp-8h]
  int v12; // [esp+20h] [ebp-4h]

  v5 = 256;
  v6 = 112;
  v7 = 288;
  v8 = 152;
  v9 = 288;
  v10 = 112;
  v11 = 320;
  v12 = 152;
  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      if ( v4 != 2 )
        goto LABEL_11;
      goto LABEL_7;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 12) -= 4096;
  }
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 116) = 2;
  *(_DWORD *)(a1 + 104) = 0;
LABEL_7:
  if ( ++*(_DWORD *)(a1 + 100) > 50 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 1 )
    *(_DWORD *)(a1 + 104) = 0;
LABEL_11:
  *(_DWORD *)(a1 + 20) += 64;
  if ( *(_DWORD *)(a1 + 20) > 1535 )
    *(_DWORD *)(a1 + 20) = 1535;
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  result = v1[2];
  v2[2] = result;
  v2[3] = v1[3];
  return result;
}

//----- (00469800) --------------------------------------------------------
void __cdecl NPC338(void *a1)
{
  int v1; // ecx
  int v2; // edx
  int *v3; // edx
  int *v4; // eax
  int v5; // [esp+0h] [ebp-44h]
  int v6; // [esp+4h] [ebp-40h]
  int v7; // [esp+8h] [ebp-3Ch]
  int v8; // [esp+Ch] [ebp-38h]
  int v9; // [esp+10h] [ebp-34h]
  int v10; // [esp+14h] [ebp-30h]
  int v11; // [esp+18h] [ebp-2Ch]
  int v12; // [esp+1Ch] [ebp-28h]
  int v13; // [esp+20h] [ebp-24h]
  int v14; // [esp+24h] [ebp-20h]
  int v15; // [esp+28h] [ebp-1Ch]
  int v16; // [esp+2Ch] [ebp-18h]
  int v17; // [esp+30h] [ebp-14h]
  int v18; // [esp+34h] [ebp-10h]
  int v19; // [esp+38h] [ebp-Ch]
  int v20; // [esp+3Ch] [ebp-8h]
  int v21; // [esp+40h] [ebp-4h]

  v14 = 288;
  v15 = 0;
  v16 = 304;
  v17 = 16;
  v18 = 304;
  v19 = 0;
  v20 = 320;
  v21 = 16;
  v6 = 288;
  v7 = 16;
  v8 = 304;
  v9 = 32;
  v10 = 304;
  v11 = 16;
  v12 = 320;
  v13 = 32;
  v5 = *((_DWORD *)a1 + 29);
  if ( v5 )
  {
    if ( v5 != 1 )
      goto LABEL_24;
  }
  else
  {
    *((_DWORD *)a1 + 29) = 1;
    *((_DWORD *)a1 + 36) = 4096;
    *((_DWORD *)a1 + 38) = 4096;
    *((_DWORD *)a1 + 41) = 3;
    *((_WORD *)a1 + 40) |= 0x20u;
    *((_DWORD *)a1 + 9) = *((_DWORD *)a1 + 3);
    *((_DWORD *)a1 + 5) = (random(-10, 10) << 9) / 2;
  }
  if ( ++*((_DWORD *)a1 + 25) > 2 )
  {
    *((_DWORD *)a1 + 25) = 0;
    ++*((_DWORD *)a1 + 26);
  }
  if ( *((_DWORD *)a1 + 26) > 1 )
    *((_DWORD *)a1 + 26) = 0;
  if ( *((_DWORD *)a1 + 3) >= *((_DWORD *)a1 + 9) )
    v1 = *((_DWORD *)a1 + 5) - 128;
  else
    v1 = *((_DWORD *)a1 + 5) + 128;
  *((_DWORD *)a1 + 5) = v1;
  if ( *((_DWORD *)a1 + 19) )
    v2 = *((_DWORD *)a1 + 4) + 32;
  else
    v2 = *((_DWORD *)a1 + 4) - 32;
  *((_DWORD *)a1 + 4) = v2;
  if ( *((_DWORD *)a1 + 4) > 1024 )
    *((_DWORD *)a1 + 4) = 1024;
  if ( *((_DWORD *)a1 + 4) < -1024 )
    *((_DWORD *)a1 + 4) = -1024;
  if ( *((_DWORD *)a1 + 2) < 0
    || *((_DWORD *)a1 + 3) < 0
    || *((_DWORD *)a1 + 2) > currentMap.width << 13
    || *((_DWORD *)a1 + 3) > currentMap.length << 13 )
  {
    Vanish_NPC((NPC *)a1);
    return;
  }
LABEL_24:
  *((_DWORD *)a1 + 2) += *((_DWORD *)a1 + 4);
  *((_DWORD *)a1 + 3) += *((_DWORD *)a1 + 5);
  if ( *((_DWORD *)a1 + 19) )
    v3 = &v6 + 4 * *((_DWORD *)a1 + 26);
  else
    v3 = &v14 + 4 * *((_DWORD *)a1 + 26);
  v4 = (int *)((char *)a1 + 84);
  *v4 = *v3;
  v4[1] = v3[1];
  v4[2] = v3[2];
  v4[3] = v3[3];
}

//----- (00469AA0) --------------------------------------------------------
void __cdecl NPC339(int a1)
{
  Directions v1; // ST14_4
  int v2; // eax
  int v3; // [esp+0h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 116);
  if ( v3 )
  {
    if ( v3 != 1 )
      return;
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
    *(_DWORD *)(a1 + 120) = random(0, 40);
  }
  if ( *(_DWORD *)(a1 + 120) )
  {
    --*(_DWORD *)(a1 + 120);
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 0;
    v1 = *(_DWORD *)(a1 + 76);
    v2 = random(-16, 16);
    createNPC((NPCNames)338, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12) + (v2 << 9), 0, 0, v1, 0, 256);
  }
}

//----- (00469B40) --------------------------------------------------------
void __cdecl NPC340(NPC *npc)
{
  int v1; // edx
  int v2; // edx
  int v3; // edx
  int v4; // edx
  int *v5; // ecx
  RECT *v6; // edx
  int v7; // [esp+0h] [ebp-170h]
  int v8; // [esp+4h] [ebp-16Ch]
  int v9; // [esp+8h] [ebp-168h]
  int v10; // [esp+Ch] [ebp-164h]
  int v11; // [esp+10h] [ebp-160h]
  int v12; // [esp+14h] [ebp-15Ch]
  int v13; // [esp+18h] [ebp-158h]
  int v14; // [esp+1Ch] [ebp-154h]
  int v15; // [esp+20h] [ebp-150h]
  int v16; // [esp+24h] [ebp-14Ch]
  int v17; // [esp+28h] [ebp-148h]
  int v18; // [esp+2Ch] [ebp-144h]
  int v19; // [esp+30h] [ebp-140h]
  int v20; // [esp+34h] [ebp-13Ch]
  int v21; // [esp+38h] [ebp-138h]
  int v22; // [esp+3Ch] [ebp-134h]
  int v23; // [esp+40h] [ebp-130h]
  int v24; // [esp+44h] [ebp-12Ch]
  int v25; // [esp+48h] [ebp-128h]
  int v26; // [esp+4Ch] [ebp-124h]
  int v27; // [esp+50h] [ebp-120h]
  int v28; // [esp+54h] [ebp-11Ch]
  int v29; // [esp+58h] [ebp-118h]
  int v30; // [esp+5Ch] [ebp-114h]
  int v31; // [esp+60h] [ebp-110h]
  int v32; // [esp+64h] [ebp-10Ch]
  int v33; // [esp+68h] [ebp-108h]
  int v34; // [esp+6Ch] [ebp-104h]
  int v35; // [esp+70h] [ebp-100h]
  int v36; // [esp+74h] [ebp-FCh]
  int v37; // [esp+78h] [ebp-F8h]
  int v38; // [esp+7Ch] [ebp-F4h]
  int v39; // [esp+80h] [ebp-F0h]
  int v40; // [esp+84h] [ebp-ECh]
  int v41; // [esp+88h] [ebp-E8h]
  int v42; // [esp+8Ch] [ebp-E4h]
  int v43; // [esp+90h] [ebp-E0h]
  int v44; // [esp+94h] [ebp-DCh]
  int v45; // [esp+98h] [ebp-D8h]
  int v46; // [esp+9Ch] [ebp-D4h]
  int v47; // [esp+A0h] [ebp-D0h]
  int v48; // [esp+A4h] [ebp-CCh]
  int v49; // [esp+A8h] [ebp-C8h]
  int v50; // [esp+ACh] [ebp-C4h]
  int v51; // [esp+B0h] [ebp-C0h]
  int v52; // [esp+B4h] [ebp-BCh]
  int i; // [esp+B8h] [ebp-B8h]
  int X_Pos; // [esp+BCh] [ebp-B4h]
  int v55; // [esp+C0h] [ebp-B0h]
  int v56; // [esp+C4h] [ebp-ACh]
  int v57; // [esp+C8h] [ebp-A8h]
  int v58; // [esp+CCh] [ebp-A4h]
  int v59; // [esp+D0h] [ebp-A0h]
  int v60; // [esp+D4h] [ebp-9Ch]
  int v61; // [esp+D8h] [ebp-98h]
  int v62; // [esp+DCh] [ebp-94h]
  int v63; // [esp+E0h] [ebp-90h]
  int v64; // [esp+E4h] [ebp-8Ch]
  int v65; // [esp+E8h] [ebp-88h]
  int v66; // [esp+ECh] [ebp-84h]
  int v67; // [esp+F0h] [ebp-80h]
  int v68; // [esp+F4h] [ebp-7Ch]
  int v69; // [esp+F8h] [ebp-78h]
  int v70; // [esp+FCh] [ebp-74h]
  int v71; // [esp+100h] [ebp-70h]
  int v72; // [esp+104h] [ebp-6Ch]
  int v73; // [esp+108h] [ebp-68h]
  int v74; // [esp+10Ch] [ebp-64h]
  int v75; // [esp+110h] [ebp-60h]
  int v76; // [esp+114h] [ebp-5Ch]
  int v77; // [esp+118h] [ebp-58h]
  int v78; // [esp+11Ch] [ebp-54h]
  int v79; // [esp+120h] [ebp-50h]
  int v80; // [esp+124h] [ebp-4Ch]
  int v81; // [esp+128h] [ebp-48h]
  int v82; // [esp+12Ch] [ebp-44h]
  int v83; // [esp+130h] [ebp-40h]
  int v84; // [esp+134h] [ebp-3Ch]
  int v85; // [esp+138h] [ebp-38h]
  int v86; // [esp+13Ch] [ebp-34h]
  int v87; // [esp+140h] [ebp-30h]
  int v88; // [esp+144h] [ebp-2Ch]
  int v89; // [esp+148h] [ebp-28h]
  int v90; // [esp+14Ch] [ebp-24h]
  int v91; // [esp+150h] [ebp-20h]
  int v92; // [esp+154h] [ebp-1Ch]
  int v93; // [esp+158h] [ebp-18h]
  int v94; // [esp+15Ch] [ebp-14h]
  int v95; // [esp+160h] [ebp-10h]
  int v96; // [esp+164h] [ebp-Ch]
  int v97; // [esp+168h] [ebp-8h]
  int v98; // [esp+16Ch] [ebp-4h]

  v8 = npc->currentState;
  if ( v8 > 222 )
  {
    if ( v8 > 310 )
    {
      if ( v8 > 1002 )
      {
        if ( v8 == 1003 )
        {
          if ( ++npc->waitTimer > 30 )
          {
            npc->waitTimer = 0;
            npc->currentState = 1004;
            npc->animationNumber = 3;
            npc->YVel -= 2560;
            npc->direction = 0;
            npc->entityFlags |= 8u;
          }
        }
        else if ( v8 == 1004 )
        {
          if ( npc->YPos < 0 )
          {
            npc->XVel = 0;
            npc->YVel = 0;
            npc->currentState = 1005;
            npc->waitTimer = 0;
            startFlash(0, 0, 2);
            playSoundEffect(SFXTeleport, 1);
          }
          if ( ++npc->waitTimer / 2 % 2 )
            npc->animationNumber = 8;
          else
            npc->animationNumber = 9;
        }
      }
      else if ( v8 == 1002 )
      {
        if ( ++npc->waitTimer > 150 )
        {
          npc->waitTimer = 0;
          npc->currentState = 1003;
          npc->animationNumber = 3;
        }
        if ( npc->waitTimer / 2 % 2 )
          v4 = npc->curlyTargetX + 512;
        else
          v4 = npc->curlyTargetX - 512;
        npc->XPos = v4;
      }
      else if ( v8 == 320 )
      {
        npc->XVel = 0;
        npc->YVel = 0;
        npc->direction = 2;
        if ( ++npc->waitTimer == 40 )
          startFlash(0, 0, 2);
        if ( npc->waitTimer > 50 && npc->waitTimer % 10 == 1 )
        {
          X_Pos = ((4 * npc->waitTimer - 200) / 10 + 2) << 13;
          createNPC(NPCForcefield|0x140, X_Pos, 155648, 0, 0, 0, 0, 256);
        }
        if ( npc->waitTimer > 140 )
          npc->currentState = 240;
        if ( ++npc->animationTimer / 2 % 2 )
          npc->animationNumber = 4;
        else
          npc->animationNumber = 5;
      }
      else
      {
        if ( v8 == 1000 )
        {
          npc->currentState = 1001;
          npc->waitTimer = 0;
          npc->animationNumber = 10;
          npc->curlyTargetX = npc->XPos;
          npc->XVel = 0;
          npc->entityFlags &= 0xFFDFu;
          createDustClouds(npc->XPos, npc->YPos, 16, 16);
          playSoundEffect(SFXExplosion, 1);
        }
        else if ( v8 != 1001 )
        {
          goto LABEL_202;
        }
        npc->YVel += 32;
        if ( npc->YVel > 1535 )
          npc->YVel = 1535;
        if ( ++npc->waitTimer / 2 % 2 )
          v3 = npc->curlyTargetX + 512;
        else
          v3 = npc->curlyTargetX - 512;
        npc->XPos = v3;
        if ( npc->collisionFlags & 8 )
        {
          npc->currentState = 1002;
          npc->waitTimer = 0;
        }
      }
    }
    else if ( v8 == 310 )
    {
LABEL_141:
      ++npc->animationTimer;
      if ( ++npc->waitTimer <= 200 || npc->animationTimer >= 20 )
        npc->direction = 0;
      else
        npc->direction = 2;
      if ( npc->animationTimer / 2 % 2 )
        npc->animationNumber = 4;
      else
        npc->animationNumber = 5;
      if ( npc->XPos >= npc->curlyTargetX )
        v1 = npc->XVel - 64;
      else
        v1 = npc->XVel + 64;
      npc->XVel = v1;
      if ( npc->YPos >= npc->curlyTargetY )
        v2 = npc->YVel - 64;
      else
        v2 = npc->YVel + 64;
      npc->YVel = v2;
      if ( npc->XVel > 1024 )
        npc->XVel = 1024;
      if ( npc->XVel < -1024 )
        npc->XVel = -1024;
      if ( npc->YVel > 1024 )
        npc->YVel = 1024;
      if ( npc->YVel < -1024 )
        npc->YVel = -1024;
      if ( npc->waitTimer > 200 && npc->waitTimer % 40 == 1 )
      {
        npc->animationTimer = 0;
        createNPC(NPCForcefield|0x140, quote.XPos, 155648, 0, 0, 0, 0, 256);
      }
      if ( npc->waitTimer > 480 )
      {
        npc->currentState = 320;
        npc->waitTimer = 0;
      }
    }
    else
    {
      switch ( v8 )
      {
        case 230:
          npc->currentState = 231;
          npc->waitTimer = 0;
          npc->animationNumber = 8;
          npc->animationTimer = 0;
          npc->XVel = 0;
          npc->damage = 10;
          npc->direction = 2;
          playSoundEffect(SFXSillyExplosion, 1);
          goto LABEL_102;
        case 231:
LABEL_102:
          npc->YVel = 2048;
          if ( ++npc->waitTimer / 2 % 2 )
            npc->animationNumber = 8;
          else
            npc->animationNumber = 9;
          if ( npc->collisionFlags & 8 )
          {
            npc->currentState = 232;
            npc->waitTimer = 0;
            npc->damage = 3;
            if ( quote.XPos >= npc->XPos )
              npc->direction = 2;
            else
              npc->direction = 0;
            for ( i = 0; i < 8; ++i )
            {
              X_Pos = npc->XPos + (random(-16, 16) << 9);
              createNPC(NPCSmoke, X_Pos, npc->YPos + 5120, 0, 0, 0, 0, 256);
            }
            createNPC((NPCNames)332, npc->XPos - 6144, npc->YPos + 6144, 0, 0, 0, 0, 256);
            createNPC((NPCNames)332, npc->XPos + 6144, npc->YPos + 6144, 0, 0, right, 0, 256);
            setHardQuakeDuration(10);
            playSoundEffect(SFXLargeObjectHitGround, 1);
          }
          if ( npc->count1 < 4 && quote.YPos > npc->YPos - 0x2000 && quote.YPos < npc->YPos + 0x2000 )
            npc->currentState = 201;
          break;
        case 232:
          ++npc->waitTimer;
          npc->XVel = 0;
          npc->animationNumber = 3;
          if ( npc->waitTimer > 30 )
          {
            if ( npc->count1 <= 3 )
              npc->currentState = 201;
            else
              npc->currentState = 242;
          }
          break;
        case 240:
          npc->currentState = 241;
          npc->direction = 0;
          goto LABEL_124;
        case 241:
LABEL_124:
          npc->YVel += 128;
          if ( npc->YVel > 1535 )
            npc->YVel = 1535;
          if ( ++npc->animationTimer / 2 % 2 )
            npc->animationNumber = 4;
          else
            npc->animationNumber = 5;
          if ( npc->collisionFlags & 8 )
          {
            npc->currentState = 242;
            npc->waitTimer = 0;
            npc->animationNumber = 3;
            if ( quote.XPos >= npc->XPos )
              npc->direction = 2;
            else
              npc->direction = 0;
          }
          break;
        case 242:
          npc->XVel = 3 * npc->XVel / 4;
          npc->animationNumber = 3;
          if ( ++npc->waitTimer > 10 )
            npc->currentState = 110;
          break;
        case 300:
          npc->currentState = 310;
          npc->waitTimer = 0;
          npc->YVel = -1536;
          if ( npc->XPos <= 163840 )
            npc->direction = 0;
          else
            npc->direction = 2;
          npc->curlyTargetX = quote.XPos;
          npc->curlyTargetY = 90112;
          npc->animationTimer = 0;
          goto LABEL_141;
        default:
          break;
      }
    }
  }
  else if ( v8 == 222 )
  {
    ++npc->waitTimer;
    npc->XVel = 0;
    npc->animationNumber = 8;
    if ( npc->waitTimer > 30 )
    {
      if ( npc->count1 <= 3 )
        npc->currentState = 201;
      else
        npc->currentState = 240;
    }
  }
  else
  {
    switch ( v8 )
    {
      case 0:
        npc->currentState = 1;
        npc->isAlive = -128;
        npc->EXPAmount = 1;
        npc->direction = 0;
        npc->YPos -= 3072;
        npc->damage = 0;
        createNPC((NPCNames)341, npc->XPos, npc->YPos - 0x2000, 0, 0, 0, npc, 256);
        break;
      case 10:
        npc->currentState = 11;
        npc->waitTimer = 0;
        goto LABEL_18;
      case 11:
LABEL_18:
        if ( ++npc->waitTimer > 100 )
          npc->currentState = 100;
        break;
      case 100:
        npc->currentState = 110;
        npc->waitTimer = 0;
        npc->animationNumber = 1;
        npc->animationTimer = 0;
        npc->damage = 4;
        npc->entityFlags |= 0x20u;
        goto LABEL_22;
      case 110:
LABEL_22:
        npc->currentState = 111;
        npc->damage = 3;
        npc->curlyTargetX = npc->life;
        goto LABEL_23;
      case 111:
LABEL_23:
        if ( ++npc->animationTimer > 10 )
        {
          npc->animationTimer = 0;
          ++npc->animationNumber;
        }
        if ( npc->animationNumber > 2 )
          npc->animationNumber = 1;
        ++npc->waitTimer;
        if ( npc->life < npc->curlyTargetX - 50 || npc->waitTimer > 150 )
        {
          v7 = npc->count2 % 5;
          if ( v7 >= 0 )
          {
            if ( v7 <= 3 )
            {
              npc->currentState = 200;
            }
            else if ( v7 == 4 )
            {
              npc->currentState = 300;
            }
          }
          ++npc->count2;
        }
        if ( quote.XPos >= npc->XPos )
          npc->direction = 2;
        else
          npc->direction = 0;
        break;
      case 200:
        npc->currentState = 201;
        npc->count1 = 0;
        goto LABEL_41;
      case 201:
LABEL_41:
        if ( npc->XVel )
          npc->currentState = 203;
        else
          npc->currentState = 202;
        npc->waitTimer = 0;
        npc->animationNumber = 3;
        npc->damage = 3;
        ++npc->count1;
        goto LABEL_45;
      case 202:
LABEL_45:
        if ( quote.XPos >= npc->XPos )
          npc->direction = 2;
        else
          npc->direction = 0;
        npc->XVel = 8 * npc->XVel / 9;
        npc->YVel = 8 * npc->YVel / 9;
        if ( ++npc->waitTimer > 20 )
          npc->currentState = 210;
        break;
      case 203:
        npc->XVel = 8 * npc->XVel / 9;
        npc->YVel = 8 * npc->YVel / 9;
        if ( ++npc->waitTimer > 20 )
        {
          if ( quote.YPos >= npc->YPos + 6144 )
            npc->currentState = 230;
          else
            npc->currentState = 220;
        }
        break;
      case 210:
        npc->currentState = 211;
        npc->waitTimer = 0;
        npc->animationNumber = 6;
        npc->animationTimer = 0;
        npc->YVel = 0;
        npc->damage = 10;
        if ( quote.XPos >= npc->XPos )
          npc->direction = 2;
        else
          npc->direction = 0;
        playSoundEffect(SFXSillyExplosion, 1);
        goto LABEL_60;
      case 211:
LABEL_60:
        if ( npc->direction )
          npc->XVel = 2048;
        else
          npc->XVel = -2048;
        if ( ++npc->waitTimer / 2 % 2 )
          npc->animationNumber = 6;
        else
          npc->animationNumber = 7;
        if ( !npc->direction && npc->collisionFlags & 1 )
        {
          npc->currentState = 212;
          npc->waitTimer = 0;
          npc->damage = 3;
          setHardQuakeDuration(10);
          playSoundEffect(SFXLargeObjectHitGround, 1);
        }
        if ( npc->direction == 2 && npc->collisionFlags & 4 )
        {
          npc->currentState = 212;
          npc->waitTimer = 0;
          npc->damage = 3;
          setHardQuakeDuration(10);
          playSoundEffect(SFXLargeObjectHitGround, 1);
        }
        if ( npc->count1 < 4 && quote.XPos > npc->XPos - 0x2000 && quote.XPos < npc->XPos + 0x2000 )
          npc->currentState = 201;
        break;
      case 212:
        ++npc->waitTimer;
        npc->XVel = 0;
        npc->animationNumber = 6;
        if ( npc->waitTimer > 30 )
        {
          if ( npc->count1 <= 3 )
            npc->currentState = 201;
          else
            npc->currentState = 240;
        }
        break;
      case 220:
        npc->currentState = 221;
        npc->waitTimer = 0;
        npc->animationNumber = 8;
        npc->animationTimer = 0;
        npc->XVel = 0;
        npc->damage = 10;
        npc->direction = 0;
        playSoundEffect(SFXSillyExplosion, 1);
        goto LABEL_83;
      case 221:
LABEL_83:
        npc->YVel = -2048;
        if ( ++npc->waitTimer / 2 % 2 )
          npc->animationNumber = 8;
        else
          npc->animationNumber = 9;
        if ( npc->YPos < 24576 )
        {
          npc->YPos = 24576;
          npc->YVel = 0;
          npc->currentState = 222;
          npc->waitTimer = 0;
          npc->damage = 3;
          for ( i = 0; i < 8; ++i )
          {
            X_Pos = npc->XPos + (random(-16, 16) << 9);
            createNPC(NPCSmoke, X_Pos, npc->YPos - 5120, 0, 0, 0, 0, 256);
          }
          createNPC((NPCNames)332, npc->XPos - 6144, npc->YPos - 6144, 0, 0, 0, 0, 256);
          createNPC((NPCNames)332, npc->XPos + 6144, npc->YPos - 6144, 0, 0, right, 0, 256);
          setHardQuakeDuration(10);
          playSoundEffect(SFXLargeObjectHitGround, 1);
        }
        if ( npc->count1 < 4 && quote.YPos > npc->YPos - 0x2000 && quote.YPos < npc->YPos + 0x2000 )
          npc->currentState = 201;
        break;
      default:
        break;
    }
  }
LABEL_202:
  npc->XPos += npc->XVel;
  npc->YPos += npc->YVel;
  v55 = 0;
  v56 = 0;
  v57 = 48;
  v58 = 40;
  v59 = 48;
  v60 = 0;
  v61 = 96;
  v62 = 40;
  v63 = 96;
  v64 = 0;
  v65 = 144;
  v66 = 40;
  v67 = 144;
  v68 = 0;
  v69 = 192;
  v70 = 40;
  v71 = 192;
  v72 = 0;
  v73 = 240;
  v74 = 40;
  v75 = 240;
  v76 = 0;
  v77 = 288;
  v78 = 40;
  v79 = 0;
  v80 = 80;
  v81 = 48;
  v82 = 120;
  v83 = 48;
  v84 = 80;
  v85 = 96;
  v86 = 120;
  v87 = 96;
  v88 = 80;
  v89 = 144;
  v90 = 120;
  v91 = 144;
  v92 = 80;
  v93 = 192;
  v94 = 120;
  v95 = 192;
  v96 = 80;
  v97 = 240;
  v98 = 120;
  v9 = 0;
  v10 = 40;
  v11 = 48;
  v12 = 80;
  v13 = 48;
  v14 = 40;
  v15 = 96;
  v16 = 80;
  v17 = 96;
  v18 = 40;
  v19 = 144;
  v20 = 80;
  v21 = 144;
  v22 = 40;
  v23 = 192;
  v24 = 80;
  v25 = 192;
  v26 = 40;
  v27 = 240;
  v28 = 80;
  v29 = 240;
  v30 = 40;
  v31 = 288;
  v32 = 80;
  v33 = 0;
  v34 = 120;
  v35 = 48;
  v36 = 160;
  v37 = 48;
  v38 = 120;
  v39 = 96;
  v40 = 160;
  v41 = 96;
  v42 = 120;
  v43 = 144;
  v44 = 160;
  v45 = 144;
  v46 = 120;
  v47 = 192;
  v48 = 160;
  v49 = 192;
  v50 = 120;
  v51 = 240;
  v52 = 160;
  if ( npc->direction )
    v5 = &v9 + 4 * npc->animationNumber;
  else
    v5 = &v55 + 4 * npc->animationNumber;
  v6 = &npc->rect;
  v6->left = *v5;
  v6->top = v5[1];
  v6->right = v5[2];
  v6->bottom = v5[3];
}

//----- (0046B240) --------------------------------------------------------
void __cdecl NPC341(NPC *npc)
{
  int *v1; // eax
  RECT *v2; // ecx
  int v3; // [esp+0h] [ebp-30h]
  int v4; // [esp+4h] [ebp-2Ch]
  int v5; // [esp+8h] [ebp-28h]
  int v6; // [esp+Ch] [ebp-24h]
  int v7; // [esp+10h] [ebp-20h]
  int v8; // [esp+14h] [ebp-1Ch]
  int v9; // [esp+18h] [ebp-18h]
  int v10; // [esp+1Ch] [ebp-14h]
  int v11; // [esp+20h] [ebp-10h]
  int v12; // [esp+24h] [ebp-Ch]
  int v13; // [esp+28h] [ebp-8h]
  int v14; // [esp+2Ch] [ebp-4h]

  v3 = 288;
  v4 = 32;
  v5 = 320;
  v6 = 48;
  v7 = 288;
  v8 = 48;
  v9 = 320;
  v10 = 64;
  v11 = 288;
  v12 = 64;
  v13 = 320;
  v14 = 80;
  if ( npc->parentNPC->currentState == 11 && npc->parentNPC->waitTimer > 50 )
    ++npc->animationTimer;
  if ( npc->animationTimer > 4 )
  {
    npc->animationTimer = 0;
    if ( npc->animationNumber < 2 )
      ++npc->animationNumber;
  }
  if ( npc->parentNPC->animationNumber )
    npc->isAlive = 0;
  v1 = &v3 + 4 * npc->animationNumber;
  v2 = &npc->rect;
  v2->left = *v1;
  v2->top = v1[1];
  v2->right = v1[2];
  v2->bottom = v1[3];
}

//----- (0046B340) --------------------------------------------------------
void __cdecl NPC342(void *a1)
{
  int v1; // esi
  int v2; // esi
  int *v3; // eax
  int *v4; // ecx
  signed int v5; // [esp+4h] [ebp-38h]
  int v6; // [esp+8h] [ebp-34h]
  int v7; // [esp+Ch] [ebp-30h]
  int v8; // [esp+10h] [ebp-2Ch]
  int v9; // [esp+14h] [ebp-28h]
  int v10; // [esp+18h] [ebp-24h]
  int v11; // [esp+1Ch] [ebp-20h]
  int v12; // [esp+20h] [ebp-1Ch]
  int v13; // [esp+24h] [ebp-18h]
  int v14; // [esp+28h] [ebp-14h]
  int v15; // [esp+2Ch] [ebp-10h]
  int v16; // [esp+30h] [ebp-Ch]
  int v17; // [esp+34h] [ebp-8h]
  unsigned __int8 v18; // [esp+3Bh] [ebp-1h]

  v6 = 240;
  v7 = 48;
  v8 = 280;
  v9 = 88;
  v10 = 240;
  v11 = 88;
  v12 = 280;
  v13 = 128;
  v14 = 280;
  v15 = 48;
  v16 = 320;
  v17 = 88;
  if ( *((_DWORD *)a1 + 29) < 1000 && *(_DWORD *)(*((_DWORD *)a1 + 42) + 116) >= 1000 )
    *((_DWORD *)a1 + 29) = 1000;
  v5 = *((_DWORD *)a1 + 29);
  if ( v5 <= 23 )
  {
    if ( v5 == 23 )
    {
      *((_DWORD *)a1 + 26) = 2;
      *((_DWORD *)a1 + 27) -= 4;
      if ( *((_DWORD *)a1 + 27) < 0 )
        *((_DWORD *)a1 + 27) += 512;
      if ( *(_DWORD *)(*((_DWORD *)a1 + 42) + 116) == 420 )
        *((_DWORD *)a1 + 29) = 30;
    }
    else
    {
      switch ( v5 )
      {
        case 0:
          *((_DWORD *)a1 + 29) = 10;
          *((_DWORD *)a1 + 27) = 2 * (*((_DWORD *)a1 + 19) & 0xFF);
          *((_DWORD *)a1 + 19) >>= 8;
          *((_DWORD *)a1 + 28) = 192;
          *((_DWORD *)a1 + 41) = 14;
          goto LABEL_17;
        case 10:
LABEL_17:
          if ( *((_DWORD *)a1 + 28) >= 320 )
            *((_DWORD *)a1 + 29) = 11;
          else
            *((_DWORD *)a1 + 28) += 8;
          goto LABEL_90;
        case 11:
          if ( *((_DWORD *)a1 + 28) <= 304 )
            *((_DWORD *)a1 + 29) = 12;
          else
            *((_DWORD *)a1 + 28) -= 4;
          goto LABEL_90;
        case 12:
          if ( *(_DWORD *)(*((_DWORD *)a1 + 42) + 116) == 311 )
            *((_DWORD *)a1 + 29) = 20;
          goto LABEL_90;
        case 20:
          *((_DWORD *)a1 + 29) = 21;
          *((_WORD *)a1 + 40) |= 0x20u;
          *((_DWORD *)a1 + 16) = 1000;
          goto LABEL_29;
        case 21:
LABEL_29:
          *((_DWORD *)a1 + 27) -= 2;
          if ( *((_DWORD *)a1 + 27) < 0 )
            *((_DWORD *)a1 + 27) += 512;
          if ( *((_BYTE *)a1 + 156) )
          {
            if ( ++dword_4A6218 / 2 % 2 )
              *((_DWORD *)a1 + 26) = 1;
            else
              *((_DWORD *)a1 + 26) = 0;
          }
          else
          {
            *((_DWORD *)a1 + 26) = 0;
          }
          if ( *((_DWORD *)a1 + 16) < 900 )
          {
            *((_DWORD *)a1 + 29) = 22;
            *((_WORD *)a1 + 40) &= 0xFFDFu;
            createDustClouds(*((_DWORD *)a1 + 2), *((_DWORD *)a1 + 3), 0x2000, 32);
            playSoundEffect(SFXQuoteSmashIntoGround, 1);
          }
          *(_DWORD *)(*((_DWORD *)a1 + 42) + 108) = 4;
          if ( *(_DWORD *)(*((_DWORD *)a1 + 42) + 116) == 401 )
            *((_DWORD *)a1 + 29) = 23;
          break;
        case 22:
          *((_DWORD *)a1 + 26) = 2;
          *((_DWORD *)a1 + 27) -= 2;
          if ( *((_DWORD *)a1 + 27) < 0 )
            *((_DWORD *)a1 + 27) += 512;
          if ( *(_DWORD *)(*((_DWORD *)a1 + 42) + 116) == 401 )
            *((_DWORD *)a1 + 29) = 23;
          break;
        default:
          goto LABEL_90;
      }
    }
    goto LABEL_90;
  }
  if ( v5 <= 41 )
  {
    switch ( v5 )
    {
      case 41:
        goto LABEL_70;
      case 30:
        *((_DWORD *)a1 + 29) = 31;
        *((_DWORD *)a1 + 16) = 1000;
        *((_DWORD *)a1 + 41) = 10;
        if ( !*((_DWORD *)a1 + 19) )
          *((_WORD *)a1 + 40) |= 0x20u;
        *((_DWORD *)a1 + 5) = 0;
        break;
      case 31:
        break;
      case 40:
        *((_DWORD *)a1 + 29) = 41;
        *((_DWORD *)a1 + 4) = 0;
        *((_DWORD *)a1 + 5) = 0;
        *((_DWORD *)a1 + 26) = 2;
        *((_DWORD *)a1 + 41) = 5;
        *((_WORD *)a1 + 40) &= 0xFFD7u;
        createDustClouds(*((_DWORD *)a1 + 2), *((_DWORD *)a1 + 3), 0x2000, 32);
        playSoundEffect(SFXQuoteSmashIntoGround, 1);
LABEL_70:
        if ( *((_DWORD *)a1 + 1) & 1 )
          *((_DWORD *)a1 + 4) = 256;
        if ( *((_DWORD *)a1 + 1) & 4 )
          *((_DWORD *)a1 + 4) = -256;
        if ( *((_DWORD *)a1 + 1) & 8 )
        {
          if ( !*((_DWORD *)a1 + 4) )
          {
            if ( quote.XPos >= *((_DWORD *)a1 + 2) )
              *((_DWORD *)a1 + 4) = -256;
            else
              *((_DWORD *)a1 + 4) = 256;
          }
          *((_DWORD *)a1 + 5) = -2048;
          playSoundEffect(SFXLargeObjectHitGround, 1);
        }
        *((_DWORD *)a1 + 5) += 32;
        if ( *((_DWORD *)a1 + 5) > 1535 )
          *((_DWORD *)a1 + 5) = 1535;
        goto LABEL_90;
      default:
        goto LABEL_90;
    }
    ++*((_DWORD *)a1 + 27);
    *((_DWORD *)a1 + 27) %= 512;
    if ( *((_DWORD *)a1 + 28) > 256 )
      --*((_DWORD *)a1 + 28);
    if ( *((_WORD *)a1 + 40) & 0x20 )
    {
      if ( *((_BYTE *)a1 + 156) )
      {
        if ( ++dword_4A6218 / 2 % 2 )
          *((_DWORD *)a1 + 26) = 1;
        else
          *((_DWORD *)a1 + 26) = 0;
      }
      else
      {
        *((_DWORD *)a1 + 26) = 0;
      }
    }
    else
    {
      *((_DWORD *)a1 + 26) = 2;
    }
    if ( *((_DWORD *)a1 + 16) < 900 )
      *((_DWORD *)a1 + 29) = 40;
    goto LABEL_90;
  }
  if ( v5 == 1000 )
  {
    *((_DWORD *)a1 + 29) = 1001;
    *((_DWORD *)a1 + 4) = 0;
    *((_DWORD *)a1 + 5) = 0;
    *((_DWORD *)a1 + 26) = 2;
    *((_WORD *)a1 + 40) &= 0xFFD7u;
    *((_DWORD *)a1 + 41) = 0;
    *((_DWORD *)a1 + 27) /= 4;
    *((_DWORD *)a1 + 17) = 0;
  }
  else if ( v5 != 1001 )
  {
    goto LABEL_90;
  }
  if ( *((_DWORD *)a1 + 27) <= 0 )
  {
    createDustClouds(*((_DWORD *)a1 + 2), *((_DWORD *)a1 + 3), 0x2000, 32);
    playSoundEffect(SFXQuoteSmashIntoGround, 1);
    Vanish_NPC((NPC *)a1);
    return;
  }
  if ( --*((_DWORD *)a1 + 27) / 2 % 2 )
    *((_DWORD *)a1 + 26) = 1;
  else
    *((_DWORD *)a1 + 26) = 0;
LABEL_90:
  if ( *((_DWORD *)a1 + 29) == 21 || *((_DWORD *)a1 + 29) == 22 )
  {
    switch ( *(_DWORD *)(*((_DWORD *)a1 + 42) + 76) )
    {
      case 0:
        if ( *((_DWORD *)a1 + 27) == 140 )
        {
          createNPC(NPCSmoke, *((_DWORD *)a1 + 2) + 4096, *((_DWORD *)a1 + 3) + 6144, 0, 0, 0, 0, 256);
          createNPC(NPCSmoke, *((_DWORD *)a1 + 2) - 4096, *((_DWORD *)a1 + 3) + 6144, 0, 0, 0, 0, 256);
          playSoundEffect(SFXLargeObjectHitGround, 1);
        }
        break;
      case 1:
        if ( *((_DWORD *)a1 + 27) == 268 )
        {
          createNPC(NPCSmoke, *((_DWORD *)a1 + 2) - 6144, *((_DWORD *)a1 + 3) + 4096, 0, 0, 0, 0, 256);
          createNPC(NPCSmoke, *((_DWORD *)a1 + 2) - 6144, *((_DWORD *)a1 + 3) - 4096, 0, 0, 0, 0, 256);
          playSoundEffect(SFXLargeObjectHitGround, 1);
        }
        break;
      case 2:
        if ( *((_DWORD *)a1 + 27) == 396 )
        {
          createNPC(NPCSmoke, *((_DWORD *)a1 + 2) + 4096, *((_DWORD *)a1 + 3) - 6144, 0, 0, 0, 0, 256);
          createNPC(NPCSmoke, *((_DWORD *)a1 + 2) - 4096, *((_DWORD *)a1 + 3) - 6144, 0, 0, 0, 0, 256);
          createNPC((NPCNames)345, *((_DWORD *)a1 + 2) - 4096, *((_DWORD *)a1 + 3) - 6144, 0, 0, 0, 0, 256);
          playSoundEffect(SFXLargeObjectHitGround, 1);
        }
        break;
      case 3:
        if ( *((_DWORD *)a1 + 27) == 12 )
        {
          createNPC(NPCSmoke, *((_DWORD *)a1 + 2) + 6144, *((_DWORD *)a1 + 3) + 4096, 0, 0, 0, 0, 256);
          createNPC(NPCSmoke, *((_DWORD *)a1 + 2) + 6144, *((_DWORD *)a1 + 3) - 4096, 0, 0, 0, 0, 256);
          playSoundEffect(SFXLargeObjectHitGround, 1);
        }
        break;
      default:
        break;
    }
  }
  if ( *((_DWORD *)a1 + 29) < 40 )
  {
    v18 = *((_DWORD *)a1 + 27) / 2;
    v1 = *((_DWORD *)a1 + 42);
    *((_DWORD *)a1 + 8) = *(_DWORD *)(v1 + 8) + *((_DWORD *)a1 + 28) * getCos(v18) / 4;
    v2 = *((_DWORD *)a1 + 42);
    *((_DWORD *)a1 + 9) = *(_DWORD *)(v2 + 12) + *((_DWORD *)a1 + 28) * getSin(v18) / 4;
    *((_DWORD *)a1 + 4) = *((_DWORD *)a1 + 8) - *((_DWORD *)a1 + 2);
    *((_DWORD *)a1 + 5) = *((_DWORD *)a1 + 9) - *((_DWORD *)a1 + 3);
  }
  *((_DWORD *)a1 + 2) += *((_DWORD *)a1 + 4);
  *((_DWORD *)a1 + 3) += *((_DWORD *)a1 + 5);
  v3 = &v6 + 4 * *((_DWORD *)a1 + 26);
  v4 = (int *)((char *)a1 + 84);
  *v4 = *v3;
  v4[1] = v3[1];
  v4[2] = v3[2];
  v4[3] = v3[3];
}
// 4A6218: using guessed type int dword_4A6218;

//----- (0046BD80) --------------------------------------------------------
int __cdecl NPC343(int a1)
{
  _DWORD *v1; // eax
  int result; // eax

  v1 = (_DWORD *)(a1 + 84);
  *v1 = 0;
  v1[1] = 0;
  v1[2] = 120;
  v1[3] = 120;
  if ( ++*(_DWORD *)(a1 + 120) > 100 )
    *(_BYTE *)a1 = 0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8);
  result = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12);
  *(_DWORD *)(a1 + 12) = result;
  return result;
}

//----- (0046BE10) --------------------------------------------------------
int __cdecl NPC344(int a1)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // edx
  int result; // eax

  if ( *(_DWORD *)(a1 + 76) )
  {
    v2 = (_DWORD *)(a1 + 84);
    *v2 = 296;
    v2[1] = 0;
    v2[2] = 320;
    v2[3] = 16;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) + 12288;
  }
  else
  {
    v1 = (_DWORD *)(a1 + 84);
    *v1 = 272;
    v1[1] = 0;
    v1[2] = 296;
    v1[3] = 16;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) - 12288;
  }
  if ( ++*(_DWORD *)(a1 + 120) > 100 )
    *(_BYTE *)a1 = 0;
  result = *(_DWORD *)(a1 + 168);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(result + 12) - 18432;
  return result;
}

//----- (0046BF00) --------------------------------------------------------
int __cdecl NPC345(int a1)
{
  int v1; // eax
  int v2; // ST10_4
  int v3; // ST0C_4
  int v4; // ST08_4
  int v5; // eax
  int result; // eax
  int *v7; // eax
  int *v8; // ecx
  int v9; // [esp+0h] [ebp-48h]
  signed int i; // [esp+4h] [ebp-44h]
  int v11; // [esp+8h] [ebp-40h]
  int v12; // [esp+Ch] [ebp-3Ch]
  int v13; // [esp+10h] [ebp-38h]
  int v14; // [esp+14h] [ebp-34h]
  int v15; // [esp+18h] [ebp-30h]
  int v16; // [esp+1Ch] [ebp-2Ch]
  int v17; // [esp+20h] [ebp-28h]
  int v18; // [esp+24h] [ebp-24h]
  int v19; // [esp+28h] [ebp-20h]
  int v20; // [esp+2Ch] [ebp-1Ch]
  int v21; // [esp+30h] [ebp-18h]
  int v22; // [esp+34h] [ebp-14h]
  int v23; // [esp+38h] [ebp-10h]
  int v24; // [esp+3Ch] [ebp-Ch]
  int v25; // [esp+40h] [ebp-8h]
  int v26; // [esp+44h] [ebp-4h]

  v11 = 128;
  v12 = 176;
  v13 = 144;
  v14 = 192;
  v15 = 144;
  v16 = 176;
  v17 = 160;
  v18 = 192;
  v19 = 160;
  v20 = 176;
  v21 = 176;
  v22 = 192;
  v23 = 176;
  v24 = 176;
  v25 = 192;
  v26 = 192;
  v9 = *(_DWORD *)(a1 + 116);
  switch ( v9 )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 100;
      *(_DWORD *)(a1 + 104) = random(0, 16) % 4;
      goto LABEL_6;
    case 100:
LABEL_6:
      *(_DWORD *)(a1 + 20) += 64;
      if ( *(_DWORD *)(a1 + 20) > 1792 )
        *(_DWORD *)(a1 + 20) = 1792;
      if ( *(_DWORD *)(a1 + 12) > 0x10000 )
        *(_WORD *)(a1 + 80) &= 0xFFF7u;
      v1 = (*(_DWORD *)(a1 + 120))++ / 2 % 2;
      if ( v1 )
        createNPC(NPCSmoke, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 0, 0, 0, 0, 256);
      if ( *(_DWORD *)(a1 + 4) & 8 )
      {
        *(_DWORD *)(a1 + 0x14) = -512;
        *(_DWORD *)(a1 + 116) = 110;
        *(_WORD *)(a1 + 80) |= 8u;
        playSoundEffect(SFXDestroyBreakableBlock, 1);
        setQuake(10);
        for ( i = 0; i < 4; ++i )
        {
          v2 = random(-1536, 0);
          v3 = random(-341, 341);
          v4 = *(_DWORD *)(a1 + 12) + 0x2000;
          v5 = random(-12, 12);
          createNPC(NPCSmoke, *(_DWORD *)(a1 + 8) + (v5 << 9), v4, v3, v2, 0, 0, 256);
        }
      }
      break;
    case 110:
      *(_DWORD *)(a1 + 20) += 64;
      result = a1;
      if ( *(_DWORD *)(a1 + 12) > (currentMap.length << 13) + 0x4000 )
      {
        *(_BYTE *)a1 = 0;
        return result;
      }
      break;
  }
  if ( ++*(_DWORD *)(a1 + 100) > 8 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 3 )
    *(_DWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  v7 = &v11 + 4 * *(_DWORD *)(a1 + 104);
  v8 = (int *)(a1 + 84);
  *v8 = *v7;
  v8[1] = v7[1];
  v8[2] = v7[2];
  result = v7[3];
  v8[3] = result;
  return result;
}

//----- (0046C1D0) --------------------------------------------------------
_DWORD *__cdecl NPC346(int a1)
{
  unsigned __int8 v1; // ST1F_1
  int v2; // esi
  int v3; // esi
  _DWORD *result; // eax
  signed int v5; // [esp+0h] [ebp-18h]

  if ( *(_DWORD *)(a1 + 116) < 1000 && *(_DWORD *)(*(_DWORD *)(a1 + 168) + 116) >= 1000 )
    *(_DWORD *)(a1 + 116) = 1000;
  v5 = *(_DWORD *)(a1 + 116);
  if ( v5 <= 40 )
  {
    if ( v5 == 40 )
    {
      *(_DWORD *)(a1 + 108) -= 2;
      if ( *(_DWORD *)(a1 + 108) < 0 )
        *(_DWORD *)(a1 + 108) += 1024;
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 116) == 422 )
        *(_DWORD *)(a1 + 116) = 20;
    }
    else
    {
      switch ( v5 )
      {
        case 0:
          *(_DWORD *)(a1 + 116) = 10;
          *(_DWORD *)(a1 + 108) = 4 * *(_DWORD *)(a1 + 76);
          *(_DWORD *)(a1 + 112) = 192;
          *(_DWORD *)(a1 + 104) = 0;
          goto LABEL_15;
        case 10:
LABEL_15:
          if ( *(_DWORD *)(a1 + 112) >= 448 )
            *(_DWORD *)(a1 + 116) = 11;
          else
            *(_DWORD *)(a1 + 112) += 8;
          break;
        case 11:
          if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 116) == 411 )
            *(_DWORD *)(a1 + 116) = 20;
          break;
        case 20:
          if ( --*(_DWORD *)(a1 + 108) < 0 )
            *(_DWORD *)(a1 + 108) += 1024;
          if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 116) == 421 )
            *(_DWORD *)(a1 + 116) = 40;
          if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 116) == 423 )
            *(_DWORD *)(a1 + 116) = 100;
          break;
        case 30:
          ++*(_DWORD *)(a1 + 108);
          *(_DWORD *)(a1 + 108) %= 1024;
          if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 116) == 425 )
            *(_DWORD *)(a1 + 116) = 50;
          if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 116) == 427 )
            *(_DWORD *)(a1 + 116) = 100;
          break;
        default:
          goto LABEL_50;
      }
    }
    goto LABEL_50;
  }
  if ( v5 > 1000 )
  {
    if ( v5 != 1001 )
      goto LABEL_50;
  }
  else
  {
    if ( v5 != 1000 )
    {
      if ( v5 == 50 )
      {
        *(_DWORD *)(a1 + 108) += 2;
        *(_DWORD *)(a1 + 108) %= 1024;
        if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 116) == 426 )
          *(_DWORD *)(a1 + 116) = 30;
      }
      else if ( v5 == 100 )
      {
        *(_DWORD *)(a1 + 104) = 0;
        if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 116) == 424 )
          *(_DWORD *)(a1 + 116) = 30;
        if ( *(_DWORD *)(*(_DWORD *)(a1 + 168) + 116) == 428 )
          *(_DWORD *)(a1 + 116) = 20;
      }
      goto LABEL_50;
    }
    *(_DWORD *)(a1 + 116) = 1001;
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_WORD *)(a1 + 80) &= 0xFFBFu;
  }
  *(_DWORD *)(a1 + 20) += 64;
  if ( *(_DWORD *)(a1 + 12) > currentMap.length << 13 )
    *(_BYTE *)a1 = 0;
LABEL_50:
  if ( *(_DWORD *)(a1 + 116) < 1000 )
  {
    if ( quote.YPos <= *(_DWORD *)(a1 + 12) - 4096 || quote.YVel >= 0 )
      *(_WORD *)(a1 + 80) |= 0x40u;
    else
      *(_WORD *)(a1 + 80) &= 0xFFBFu;
    v1 = *(_DWORD *)(a1 + 108) / 4;
    v2 = *(_DWORD *)(a1 + 168);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(v2 + 8) + *(_DWORD *)(a1 + 112) * getCos(v1) / 4;
    v3 = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12);
    *(_DWORD *)(a1 + 36) = v3 + *(_DWORD *)(a1 + 112) * getSin(v1) / 4 + 0x2000;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 8);
    if ( *(_DWORD *)(a1 + 116) != 20 && *(_DWORD *)(a1 + 116) != 30 )
    {
      if ( *(_DWORD *)(a1 + 116) != 40 && *(_DWORD *)(a1 + 116) != 50 )
      {
        *(_DWORD *)(a1 + 104) = *(_DWORD *)(a1 + 36) - *(_DWORD *)(a1 + 12);
      }
      else if ( !(*(_DWORD *)(a1 + 108) / 2 % 2) )
      {
        *(_DWORD *)(a1 + 104) = (*(_DWORD *)(a1 + 36) - *(_DWORD *)(a1 + 12)) / 2;
      }
    }
    else if ( !(*(_DWORD *)(a1 + 108) % 4) )
    {
      *(_DWORD *)(a1 + 104) = (*(_DWORD *)(a1 + 36) - *(_DWORD *)(a1 + 12)) / 4;
    }
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 104);
  }
  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
  result = (_DWORD *)(a1 + 84);
  *result = 240;
  result[1] = 0;
  result[2] = 272;
  result[3] = 16;
  return result;
}

//----- (0046C710) --------------------------------------------------------
int __cdecl NPC347(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+4h] [ebp-40h]
  int v5; // [esp+8h] [ebp-3Ch]
  int v6; // [esp+Ch] [ebp-38h]
  int v7; // [esp+10h] [ebp-34h]
  int v8; // [esp+14h] [ebp-30h]
  int v9; // [esp+18h] [ebp-2Ch]
  int v10; // [esp+1Ch] [ebp-28h]
  int v11; // [esp+20h] [ebp-24h]
  int v12; // [esp+24h] [ebp-20h]
  int v13; // [esp+28h] [ebp-1Ch]
  int v14; // [esp+2Ch] [ebp-18h]
  int v15; // [esp+30h] [ebp-14h]
  int v16; // [esp+34h] [ebp-10h]
  int v17; // [esp+38h] [ebp-Ch]
  int v18; // [esp+3Ch] [ebp-8h]
  int v19; // [esp+40h] [ebp-4h]

  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      goto LABEL_3;
    case 1:
LABEL_3:
      *(_DWORD *)(a1 + 104) = 0;
      if ( quote.YPos < *(_DWORD *)(a1 + 12) + 0x10000 && quote.YPos > *(_DWORD *)(a1 + 12) - 0x10000 )
      {
        *(_DWORD *)(a1 + 116) = 10;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 1;
      }
      break;
    case 0xA:
      if ( ++*(_DWORD *)(a1 + 120) == 4 )
        *(_DWORD *)(a1 + 104) = 2;
      if ( *(_DWORD *)(a1 + 120) > 12 )
      {
        *(_DWORD *)(a1 + 116) = 12;
        *(_DWORD *)(a1 + 16) = 1792;
        playSoundEffect(SFXHighPitchCritterHop, 1);
        *(_DWORD *)(a1 + 104) = 3;
      }
      break;
    case 0xC:
      if ( quote.YPos >= *(_DWORD *)(a1 + 12) )
        *(_DWORD *)(a1 + 20) = 170;
      else
        *(_DWORD *)(a1 + 20) = -170;
      if ( *(_DWORD *)(a1 + 4) & 1 )
      {
        *(_DWORD *)(a1 + 116) = 13;
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 104) = 2;
        *(_DWORD *)(a1 + 16) = 0;
        *(_DWORD *)(a1 + 20) = 0;
      }
      else
      {
        *(_DWORD *)(a1 + 16) -= 42;
        if ( *(_DWORD *)(a1 + 16) < -1535 )
          *(_DWORD *)(a1 + 16) = -1535;
        *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
      }
      break;
    case 0xD:
      if ( ++*(_DWORD *)(a1 + 120) == 2 )
        *(_DWORD *)(a1 + 104) = 1;
      if ( *(_DWORD *)(a1 + 120) == 6 )
        *(_DWORD *)(a1 + 104) = 0;
      if ( *(_DWORD *)(a1 + 120) > 16 )
        *(_DWORD *)(a1 + 116) = 1;
      break;
    default:
      break;
  }
  v4 = 256;
  v5 = 48;
  v6 = 272;
  v7 = 64;
  v8 = 272;
  v9 = 48;
  v10 = 288;
  v11 = 64;
  v12 = 288;
  v13 = 48;
  v14 = 304;
  v15 = 64;
  v16 = 304;
  v17 = 48;
  v18 = 320;
  v19 = 64;
  v1 = &v4 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (0046C9B0) --------------------------------------------------------
int __cdecl NPC348(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+0h] [ebp-24h]
  int v5; // [esp+4h] [ebp-20h]
  int v6; // [esp+8h] [ebp-1Ch]
  int v7; // [esp+Ch] [ebp-18h]
  int v8; // [esp+10h] [ebp-14h]
  int v9; // [esp+14h] [ebp-10h]
  int v10; // [esp+18h] [ebp-Ch]
  int v11; // [esp+1Ch] [ebp-8h]
  int v12; // [esp+20h] [ebp-4h]

  v5 = 128;
  v6 = 152;
  v7 = 160;
  v8 = 176;
  v9 = 160;
  v10 = 152;
  v11 = 192;
  v12 = 176;
  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 != 1 )
      goto LABEL_11;
  }
  else
  {
    *(_DWORD *)(a1 + 116) = 1;
  }
  if ( ++*(_DWORD *)(a1 + 120) >= 128 )
  {
    *(_DWORD *)(a1 + 116) = 10;
    *(_DWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 164) = 2;
  }
  else
  {
    *(_DWORD *)(a1 + 12) -= 128;
    if ( *(_DWORD *)(a1 + 120) / 2 % 2 )
      *(_DWORD *)(a1 + 104) = 1;
    else
      *(_DWORD *)(a1 + 104) = 0;
  }
LABEL_11:
  v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (0046CAC0) --------------------------------------------------------
signed int __cdecl NPC349(int a1)
{
  _DWORD *v1; // ecx
  signed int result; // eax

  if ( !*(_DWORD *)(a1 + 116) )
  {
    *(_DWORD *)(a1 + 116) = 1;
    if ( !*(_DWORD *)(a1 + 76) )
      *(_DWORD *)(a1 + 8) += 4096;
    if ( *(_DWORD *)(a1 + 76) == 2 )
      *(_DWORD *)(a1 + 12) += 0x2000;
  }
  v1 = (_DWORD *)(a1 + 84);
  *v1 = 0;
  v1[1] = 0;
  v1[2] = 16;
  result = 16;
  v1[3] = 16;
  return result;
}

//----- (0046CB50) --------------------------------------------------------
void __cdecl NPC350(void *npc)
{
  int v1; // ecx
  int v2; // edx
  int *v3; // ecx
  int *v4; // edx
  int v5; // [esp+4h] [ebp-E0h]
  int v6; // [esp+8h] [ebp-DCh]
  int v7; // [esp+Ch] [ebp-D8h]
  int v8; // [esp+10h] [ebp-D4h]
  int v9; // [esp+14h] [ebp-D0h]
  int v10; // [esp+18h] [ebp-CCh]
  int v11; // [esp+1Ch] [ebp-C8h]
  int v12; // [esp+20h] [ebp-C4h]
  int v13; // [esp+24h] [ebp-C0h]
  int v14; // [esp+28h] [ebp-BCh]
  int v15; // [esp+2Ch] [ebp-B8h]
  int v16; // [esp+30h] [ebp-B4h]
  int v17; // [esp+34h] [ebp-B0h]
  int v18; // [esp+38h] [ebp-ACh]
  int v19; // [esp+3Ch] [ebp-A8h]
  int v20; // [esp+40h] [ebp-A4h]
  int v21; // [esp+44h] [ebp-A0h]
  int v22; // [esp+48h] [ebp-9Ch]
  int v23; // [esp+4Ch] [ebp-98h]
  int v24; // [esp+50h] [ebp-94h]
  int v25; // [esp+54h] [ebp-90h]
  int v26; // [esp+58h] [ebp-8Ch]
  int v27; // [esp+5Ch] [ebp-88h]
  int v28; // [esp+60h] [ebp-84h]
  int v29; // [esp+64h] [ebp-80h]
  int v30; // [esp+68h] [ebp-7Ch]
  int v31; // [esp+6Ch] [ebp-78h]
  int v32; // [esp+70h] [ebp-74h]
  int v33; // [esp+74h] [ebp-70h]
  int v34; // [esp+78h] [ebp-6Ch]
  int v35; // [esp+7Ch] [ebp-68h]
  int v36; // [esp+80h] [ebp-64h]
  int v37; // [esp+84h] [ebp-60h]
  int v38; // [esp+88h] [ebp-5Ch]
  int v39; // [esp+8Ch] [ebp-58h]
  int v40; // [esp+90h] [ebp-54h]
  int v41; // [esp+94h] [ebp-50h]
  int v42; // [esp+98h] [ebp-4Ch]
  int v43; // [esp+9Ch] [ebp-48h]
  int v44; // [esp+A0h] [ebp-44h]
  int v45; // [esp+A4h] [ebp-40h]
  int v46; // [esp+A8h] [ebp-3Ch]
  int v47; // [esp+ACh] [ebp-38h]
  int v48; // [esp+B0h] [ebp-34h]
  int v49; // [esp+B4h] [ebp-30h]
  int v50; // [esp+B8h] [ebp-2Ch]
  int v51; // [esp+BCh] [ebp-28h]
  int v52; // [esp+C0h] [ebp-24h]
  int v53; // [esp+C4h] [ebp-20h]
  int v54; // [esp+C8h] [ebp-1Ch]
  int v55; // [esp+CCh] [ebp-18h]
  int v56; // [esp+D0h] [ebp-14h]
  int v57; // [esp+D4h] [ebp-10h]
  int v58; // [esp+D8h] [ebp-Ch]
  int v59; // [esp+DCh] [ebp-8h]
  int v60; // [esp+E0h] [ebp-4h]

  v33 = 0;
  v34 = 160;
  v35 = 24;
  v36 = 184;
  v37 = 24;
  v38 = 160;
  v39 = 48;
  v40 = 184;
  v41 = 48;
  v42 = 160;
  v43 = 72;
  v44 = 184;
  v45 = 72;
  v46 = 160;
  v47 = 96;
  v48 = 184;
  v49 = 96;
  v50 = 160;
  v51 = 120;
  v52 = 184;
  v53 = 120;
  v54 = 160;
  v55 = 144;
  v56 = 184;
  v57 = 144;
  v58 = 160;
  v59 = 168;
  v60 = 184;
  v5 = 0;
  v6 = 184;
  v7 = 24;
  v8 = 208;
  v9 = 24;
  v10 = 184;
  v11 = 48;
  v12 = 208;
  v13 = 48;
  v14 = 184;
  v15 = 72;
  v16 = 208;
  v17 = 72;
  v18 = 184;
  v19 = 96;
  v20 = 208;
  v21 = 96;
  v22 = 184;
  v23 = 120;
  v24 = 208;
  v25 = 120;
  v26 = 184;
  v27 = 144;
  v28 = 208;
  v29 = 144;
  v30 = 184;
  v31 = 168;
  v32 = 208;
  switch ( *((_DWORD *)npc + 29) )
  {
    case 0:
      *((_DWORD *)npc + 29) = 1;
      if ( *((_DWORD *)npc + 19) )
        v1 = *((_DWORD *)npc + 2) + 0x10000;
      else
        v1 = *((_DWORD *)npc + 2) - 0x10000;
      *((_DWORD *)npc + 8) = v1;
      *((_DWORD *)npc + 9) = *((_DWORD *)npc + 3);
      *((_DWORD *)npc + 5) = 2 * random(-512, 512);
      *((_DWORD *)npc + 4) = 2 * random(-512, 512);
      goto LABEL_6;
    case 1:
LABEL_6:
      if ( ++*((_DWORD *)npc + 25) > 1 )
      {
        *((_DWORD *)npc + 25) = 0;
        if ( ++*((_DWORD *)npc + 26) > 1 )
          *((_DWORD *)npc + 26) = 0;
      }
      if ( *((_DWORD *)npc + 19) )
      {
        if ( *((_DWORD *)npc + 2) > *((_DWORD *)npc + 8) )
          *((_DWORD *)npc + 29) = 20;
      }
      else if ( *((_DWORD *)npc + 2) < *((_DWORD *)npc + 8) )
      {
        *((_DWORD *)npc + 29) = 20;
      }
      goto LABEL_53;
    case 0x14:
      *((_DWORD *)npc + 29) = 21;
      *((_DWORD *)npc + 30) = random(0, 150);
      *((_DWORD *)npc + 26) = 2;
      *((_DWORD *)npc + 25) = 0;
      goto LABEL_17;
    case 0x15:
LABEL_17:
      if ( ++*((_DWORD *)npc + 25) > 2 )
      {
        *((_DWORD *)npc + 25) = 0;
        if ( ++*((_DWORD *)npc + 26) > 3 )
          *((_DWORD *)npc + 26) = 2;
      }
      if ( ++*((_DWORD *)npc + 30) > 300 )
        *((_DWORD *)npc + 29) = 30;
      if ( quote.XPos < *((_DWORD *)npc + 2) + 57344
        && quote.XPos > *((_DWORD *)npc + 2) - 57344
        && quote.YPos < *((_DWORD *)npc + 3) + 0x2000
        && quote.YPos > *((_DWORD *)npc + 3) - 0x2000 )
      {
        *((_DWORD *)npc + 29) = 30;
      }
      goto LABEL_53;
    case 0x1E:
      *((_DWORD *)npc + 29) = 31;
      *((_DWORD *)npc + 30) = 0;
      *((_DWORD *)npc + 25) = 0;
      goto LABEL_29;
    case 0x1F:
LABEL_29:
      if ( ++*((_DWORD *)npc + 25) / 2 % 2 )
        *((_DWORD *)npc + 26) = 3;
      else
        *((_DWORD *)npc + 26) = 4;
      if ( ++*((_DWORD *)npc + 30) > 30 )
      {
        *((_DWORD *)npc + 29) = 40;
        *((_DWORD *)npc + 26) = 5;
        if ( *((_DWORD *)npc + 19) )
          createNPC((NPCNames)312, *((_DWORD *)npc + 2), *((_DWORD *)npc + 3), 2048, 0, right, 0, 409);
        else
          createNPC((NPCNames)312, *((_DWORD *)npc + 2), *((_DWORD *)npc + 3), -2048, 0, 0, 0, 409);
      }
      goto LABEL_53;
    case 0x28:
      *((_DWORD *)npc + 29) = 41;
      *((_DWORD *)npc + 30) = 0;
      *((_DWORD *)npc + 25) = 0;
      goto LABEL_38;
    case 0x29:
LABEL_38:
      if ( ++*((_DWORD *)npc + 25) > 2 )
      {
        *((_DWORD *)npc + 25) = 0;
        if ( ++*((_DWORD *)npc + 26) > 6 )
          *((_DWORD *)npc + 26) = 5;
      }
      if ( ++*((_DWORD *)npc + 30) > 40 )
      {
        *((_DWORD *)npc + 29) = 50;
        *((_DWORD *)npc + 26) = 0;
        *((_DWORD *)npc + 4) = 0;
        *((_DWORD *)npc + 5) = 0;
      }
      goto LABEL_53;
    case 0x32:
      if ( ++*((_DWORD *)npc + 25) > 1 )
      {
        *((_DWORD *)npc + 25) = 0;
        if ( ++*((_DWORD *)npc + 26) > 1 )
          *((_DWORD *)npc + 26) = 0;
      }
      if ( *((_DWORD *)npc + 19) )
        v2 = *((_DWORD *)npc + 4) + 32;
      else
        v2 = *((_DWORD *)npc + 4) - 32;
      *((_DWORD *)npc + 4) = v2;
      if ( *((_DWORD *)npc + 2) >= 0 && *((_DWORD *)npc + 2) <= currentMap.width << 13 )
        goto LABEL_53;
      Vanish_NPC((NPC *)npc);
      break;
    default:
LABEL_53:
      if ( *((_DWORD *)npc + 29) < 50 )
      {
        if ( *((_DWORD *)npc + 2) < *((_DWORD *)npc + 8) )
          *((_DWORD *)npc + 4) += 42;
        if ( *((_DWORD *)npc + 2) > *((_DWORD *)npc + 8) )
          *((_DWORD *)npc + 4) -= 42;
        if ( *((_DWORD *)npc + 3) < *((_DWORD *)npc + 9) )
          *((_DWORD *)npc + 5) += 42;
        if ( *((_DWORD *)npc + 3) > *((_DWORD *)npc + 9) )
          *((_DWORD *)npc + 5) -= 42;
        if ( *((_DWORD *)npc + 4) > 1024 )
          *((_DWORD *)npc + 4) = 1024;
        if ( *((_DWORD *)npc + 4) < -1024 )
          *((_DWORD *)npc + 4) = -1024;
        if ( *((_DWORD *)npc + 5) > 1024 )
          *((_DWORD *)npc + 5) = 1024;
        if ( *((_DWORD *)npc + 5) < -1024 )
          *((_DWORD *)npc + 5) = -1024;
      }
      *((_DWORD *)npc + 2) += *((_DWORD *)npc + 4);
      *((_DWORD *)npc + 3) += *((_DWORD *)npc + 5);
      if ( *((_DWORD *)npc + 19) )
        v3 = &v5 + 4 * *((_DWORD *)npc + 26);
      else
        v3 = &v33 + 4 * *((_DWORD *)npc + 26);
      v4 = (int *)((char *)npc + 84);
      *v4 = *v3;
      v4[1] = v3[1];
      v4[2] = v3[2];
      v4[3] = v3[3];
      break;
  }
}

//----- (0046D340) --------------------------------------------------------
int *__cdecl NPC351(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+4h] [ebp-90h]
  int v4; // [esp+8h] [ebp-8Ch]
  int v5; // [esp+Ch] [ebp-88h]
  int v6; // [esp+10h] [ebp-84h]
  int v7; // [esp+14h] [ebp-80h]
  int v8; // [esp+18h] [ebp-7Ch]
  int v9; // [esp+1Ch] [ebp-78h]
  int v10; // [esp+20h] [ebp-74h]
  int v11; // [esp+24h] [ebp-70h]
  int v12; // [esp+28h] [ebp-6Ch]
  int v13; // [esp+2Ch] [ebp-68h]
  int v14; // [esp+30h] [ebp-64h]
  int v15; // [esp+34h] [ebp-60h]
  int v16; // [esp+38h] [ebp-5Ch]
  int v17; // [esp+3Ch] [ebp-58h]
  int v18; // [esp+40h] [ebp-54h]
  int v19; // [esp+44h] [ebp-50h]
  int v20; // [esp+48h] [ebp-4Ch]
  int v21; // [esp+4Ch] [ebp-48h]
  int v22; // [esp+50h] [ebp-44h]
  int v23; // [esp+54h] [ebp-40h]
  int v24; // [esp+58h] [ebp-3Ch]
  int v25; // [esp+5Ch] [ebp-38h]
  int v26; // [esp+60h] [ebp-34h]
  int v27; // [esp+64h] [ebp-30h]
  int v28; // [esp+68h] [ebp-2Ch]
  int v29; // [esp+6Ch] [ebp-28h]
  int v30; // [esp+70h] [ebp-24h]
  int v31; // [esp+74h] [ebp-20h]
  int v32; // [esp+78h] [ebp-1Ch]
  int v33; // [esp+7Ch] [ebp-18h]
  int v34; // [esp+80h] [ebp-14h]
  int v35; // [esp+84h] [ebp-10h]
  int v36; // [esp+88h] [ebp-Ch]
  int v37; // [esp+8Ch] [ebp-8h]
  int v38; // [esp+90h] [ebp-4h]

  v3 = 0;
  v4 = 96;
  v5 = 32;
  v6 = 136;
  v7 = 32;
  v8 = 96;
  v9 = 64;
  v10 = 136;
  v11 = 64;
  v12 = 96;
  v13 = 96;
  v14 = 136;
  v15 = 96;
  v16 = 96;
  v17 = 128;
  v18 = 136;
  v19 = 128;
  v20 = 96;
  v21 = 160;
  v22 = 136;
  v23 = 0;
  v24 = 176;
  v25 = 32;
  v26 = 216;
  v27 = 32;
  v28 = 176;
  v29 = 64;
  v30 = 216;
  v31 = 64;
  v32 = 176;
  v33 = 96;
  v34 = 216;
  v35 = 96;
  v36 = 176;
  v37 = 128;
  v38 = 216;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      *(_DWORD *)(a1 + 104) = *(_DWORD *)(a1 + 76) / 10;
      *(_DWORD *)(a1 + 8) += 4096;
      *(_DWORD *)(a1 + 12) += 6144;
      break;
    case 0xA:
      if ( getNPCFlag(*(_DWORD *)(a1 + 44)) )
      {
        *(_DWORD *)(a1 + 116) = 20;
      }
      else
      {
        *(_DWORD *)(a1 + 116) = 11;
        *(_WORD *)(a1 + 80) |= 0x20u;
      }
      goto LABEL_6;
    case 0xB:
LABEL_6:
      if ( *(_DWORD *)(a1 + 64) <= 900 )
      {
        createNPC(
          NPCTreasureChestClosed|0x150,
          *(_DWORD *)(a1 + 8) - 4096,
          *(_DWORD *)(a1 + 12) - 6144,
          0,
          0,
          (Directions)(10 * (*(_DWORD *)(a1 + 104) + 4)),
          0,
          0);
        *(_BYTE *)a1 |= 8u;
      }
      break;
    case 0x14:
      *(_DWORD *)(a1 + 104) += 4;
      *(_DWORD *)(a1 + 116) = 1;
      break;
    default:
      break;
  }
  v1 = &v3 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (0046D5D0) --------------------------------------------------------
LONG __cdecl NPC352(NPC *a1)
{
  int *v1; // ecx
  RECT *v2; // edx
  LONG result; // eax
  int v4; // [esp+8h] [ebp-1C4h]
  int v5; // [esp+Ch] [ebp-1C0h]
  int v6; // [esp+10h] [ebp-1BCh]
  int v7; // [esp+14h] [ebp-1B8h]
  int v8; // [esp+18h] [ebp-1B4h]
  int v9; // [esp+1Ch] [ebp-1B0h]
  int v10; // [esp+20h] [ebp-1ACh]
  int v11; // [esp+24h] [ebp-1A8h]
  int v12; // [esp+28h] [ebp-1A4h]
  int v13; // [esp+2Ch] [ebp-1A0h]
  int v14; // [esp+30h] [ebp-19Ch]
  int v15; // [esp+34h] [ebp-198h]
  int v16; // [esp+38h] [ebp-194h]
  int v17; // [esp+3Ch] [ebp-190h]
  int v18; // [esp+40h] [ebp-18Ch]
  int v19; // [esp+44h] [ebp-188h]
  int v20; // [esp+48h] [ebp-184h]
  int v21; // [esp+4Ch] [ebp-180h]
  int v22; // [esp+50h] [ebp-17Ch]
  int v23; // [esp+54h] [ebp-178h]
  int v24; // [esp+58h] [ebp-174h]
  int v25; // [esp+5Ch] [ebp-170h]
  int v26; // [esp+60h] [ebp-16Ch]
  int v27; // [esp+64h] [ebp-168h]
  int v28; // [esp+68h] [ebp-164h]
  int v29; // [esp+6Ch] [ebp-160h]
  int v30; // [esp+70h] [ebp-15Ch]
  int v31; // [esp+74h] [ebp-158h]
  int v32; // [esp+78h] [ebp-154h]
  int v33; // [esp+7Ch] [ebp-150h]
  int v34; // [esp+80h] [ebp-14Ch]
  int v35; // [esp+84h] [ebp-148h]
  int v36; // [esp+88h] [ebp-144h]
  int v37; // [esp+8Ch] [ebp-140h]
  int v38; // [esp+90h] [ebp-13Ch]
  int v39; // [esp+94h] [ebp-138h]
  int v40; // [esp+98h] [ebp-134h]
  int v41; // [esp+9Ch] [ebp-130h]
  int v42; // [esp+A0h] [ebp-12Ch]
  int v43; // [esp+A4h] [ebp-128h]
  int v44; // [esp+A8h] [ebp-124h]
  int v45; // [esp+ACh] [ebp-120h]
  int v46; // [esp+B0h] [ebp-11Ch]
  int v47; // [esp+B4h] [ebp-118h]
  int v48; // [esp+B8h] [ebp-114h]
  int v49; // [esp+BCh] [ebp-110h]
  int v50; // [esp+C0h] [ebp-10Ch]
  int v51; // [esp+C4h] [ebp-108h]
  int v52; // [esp+C8h] [ebp-104h]
  int v53; // [esp+CCh] [ebp-100h]
  int v54; // [esp+D0h] [ebp-FCh]
  int v55; // [esp+D4h] [ebp-F8h]
  int v56; // [esp+D8h] [ebp-F4h]
  int v57; // [esp+DCh] [ebp-F0h]
  int v58; // [esp+E0h] [ebp-ECh]
  int v59; // [esp+E4h] [ebp-E8h]
  int v60; // [esp+E8h] [ebp-E4h]
  int v61; // [esp+ECh] [ebp-E0h]
  int v62; // [esp+F0h] [ebp-DCh]
  int v63; // [esp+F4h] [ebp-D8h]
  int v64; // [esp+F8h] [ebp-D4h]
  int v65; // [esp+FCh] [ebp-D0h]
  int v66; // [esp+100h] [ebp-CCh]
  int v67; // [esp+104h] [ebp-C8h]
  int v68; // [esp+108h] [ebp-C4h]
  int v69; // [esp+10Ch] [ebp-C0h]
  int v70; // [esp+110h] [ebp-BCh]
  int v71; // [esp+114h] [ebp-B8h]
  int v72; // [esp+118h] [ebp-B4h]
  int v73; // [esp+11Ch] [ebp-B0h]
  int v74; // [esp+120h] [ebp-ACh]
  int v75; // [esp+124h] [ebp-A8h]
  int v76; // [esp+128h] [ebp-A4h]
  int v77; // [esp+12Ch] [ebp-A0h]
  int v78; // [esp+130h] [ebp-9Ch]
  int v79; // [esp+134h] [ebp-98h]
  int v80; // [esp+138h] [ebp-94h]
  int v81; // [esp+13Ch] [ebp-90h]
  int v82; // [esp+140h] [ebp-8Ch]
  int v83; // [esp+144h] [ebp-88h]
  int v84; // [esp+148h] [ebp-84h]
  int v85; // [esp+14Ch] [ebp-80h]
  int v86; // [esp+150h] [ebp-7Ch]
  int v87; // [esp+154h] [ebp-78h]
  int v88; // [esp+158h] [ebp-74h]
  int v89; // [esp+15Ch] [ebp-70h]
  int v90; // [esp+160h] [ebp-6Ch]
  int v91; // [esp+164h] [ebp-68h]
  int v92; // [esp+168h] [ebp-64h]
  int v93; // [esp+16Ch] [ebp-60h]
  int v94; // [esp+170h] [ebp-5Ch]
  int v95; // [esp+174h] [ebp-58h]
  int v96; // [esp+178h] [ebp-54h]
  int v97; // [esp+17Ch] [ebp-50h]
  int v98; // [esp+180h] [ebp-4Ch]
  int v99; // [esp+184h] [ebp-48h]
  int v100; // [esp+188h] [ebp-44h]
  int v101; // [esp+18Ch] [ebp-40h]
  int v102; // [esp+190h] [ebp-3Ch]
  int v103; // [esp+194h] [ebp-38h]
  int v104; // [esp+198h] [ebp-34h]
  int v105; // [esp+19Ch] [ebp-30h]
  int v106; // [esp+1A0h] [ebp-2Ch]
  int v107; // [esp+1A4h] [ebp-28h]
  int v108; // [esp+1A8h] [ebp-24h]
  int v109; // [esp+1ACh] [ebp-20h]
  int v110; // [esp+1B0h] [ebp-1Ch]
  int v111; // [esp+1B4h] [ebp-18h]
  int v112; // [esp+1B8h] [ebp-14h]
  int v113; // [esp+1BCh] [ebp-10h]
  int v114; // [esp+1C0h] [ebp-Ch]
  int v115; // [esp+1C4h] [ebp-8h]
  int v116; // [esp+1C8h] [ebp-4h]

  v4 = a1->currentState;
  if ( v4 )
  {
    if ( v4 != 1 )
      goto LABEL_17;
  }
  else
  {
    a1->currentState = 1;
    a1->animationNumber = 0;
    a1->count1 = a1->direction / 100;
    a1->direction %= 100;
    switch ( a1->count1 )
    {
      case 7:
      case 8:
      case 9:
      case 0xC:
      case 0xD:
        a1->entitySpritesheet = 21;
        break;
      default:
        break;
    }
    switch ( a1->count1 )
    {
      case 2:
      case 4:
      case 9:
      case 0xC:
        a1->view.top = 0x2000;
        break;
      default:
        break;
    }
    if ( a1->count1 == 9 )
    {
      a1->view.back = 10240;
      a1->view.front = 10240;
      a1->XPos -= 512;
    }
    if ( !a1->count1 )
      createNPC((NPCNames)145, 0, 0, 0, 0, right, a1, 256);
  }
  a1->YVel += 64;
  if ( a1->YVel > 1535 )
    a1->YVel = 1535;
  if ( a1->collisionFlags & 8 )
  {
    a1->YVel = 0;
    a1->currentState = 2;
    a1->animationNumber = 1;
  }
  a1->YPos += a1->YVel;
LABEL_17:
  v5 = 304;
  v6 = 48;
  v7 = 320;
  v8 = 64;
  v9 = 224;
  v10 = 48;
  v11 = 240;
  v12 = 64;
  v13 = 32;
  v14 = 80;
  v15 = 48;
  v16 = 96;
  v17 = 0;
  v18 = 80;
  v19 = 16;
  v20 = 96;
  v21 = 224;
  v22 = 216;
  v23 = 240;
  v24 = 240;
  v25 = 192;
  v26 = 216;
  v27 = 208;
  v28 = 240;
  v29 = 48;
  v30 = 16;
  v31 = 64;
  v32 = 32;
  v33 = 0;
  v34 = 16;
  v35 = 16;
  v36 = 32;
  v37 = 112;
  v38 = 192;
  v39 = 128;
  v40 = 216;
  v41 = 80;
  v42 = 192;
  v43 = 96;
  v44 = 216;
  v45 = 304;
  v46 = 0;
  v47 = 320;
  v48 = 16;
  v49 = 224;
  v50 = 0;
  v51 = 240;
  v52 = 16;
  v53 = 176;
  v54 = 32;
  v55 = 192;
  v56 = 48;
  v57 = 176;
  v58 = 32;
  v59 = 192;
  v60 = 48;
  v61 = 240;
  v62 = 16;
  v63 = 256;
  v64 = 32;
  v65 = 224;
  v66 = 16;
  v67 = 240;
  v68 = 32;
  v69 = 208;
  v70 = 16;
  v71 = 224;
  v72 = 32;
  v73 = 192;
  v74 = 16;
  v75 = 208;
  v76 = 32;
  v77 = 280;
  v78 = 128;
  v79 = 320;
  v80 = 152;
  v81 = 280;
  v82 = 152;
  v83 = 320;
  v84 = 176;
  v85 = 32;
  v86 = 112;
  v87 = 48;
  v88 = 128;
  v89 = 0;
  v90 = 112;
  v91 = 16;
  v92 = 128;
  v93 = 80;
  v94 = 0;
  v95 = 96;
  v96 = 16;
  v97 = 112;
  v98 = 0;
  v99 = 128;
  v100 = 16;
  v101 = 16;
  v102 = 152;
  v103 = 32;
  v104 = 176;
  v105 = 0;
  v106 = 152;
  v107 = 16;
  v108 = 176;
  v109 = 48;
  v110 = 16;
  v111 = 64;
  v112 = 32;
  v113 = 48;
  v114 = 0;
  v115 = 64;
  v116 = 16;
  v1 = &v5 + 4 * (a1->animationNumber + 2 * a1->count1);
  v2 = &a1->rect;
  v2->left = *v1;
  v2->top = v1[1];
  result = v1[2];
  v2->right = result;
  v2->bottom = v1[3];
  return result;
}

//----- (0046DBE0) --------------------------------------------------------
int *__cdecl NPC353(int a1)
{
  int *result; // eax
  int *v2; // edx
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  int *v6; // ecx
  int *v7; // edx
  int v8; // [esp+8h] [ebp-80h]
  int v9; // [esp+Ch] [ebp-7Ch]
  int v10; // [esp+10h] [ebp-78h]
  int v11; // [esp+14h] [ebp-74h]
  int v12; // [esp+18h] [ebp-70h]
  int v13; // [esp+1Ch] [ebp-6Ch]
  int v14; // [esp+20h] [ebp-68h]
  int v15; // [esp+24h] [ebp-64h]
  int v16; // [esp+28h] [ebp-60h]
  int v17; // [esp+2Ch] [ebp-5Ch]
  int v18; // [esp+30h] [ebp-58h]
  int v19; // [esp+34h] [ebp-54h]
  int v20; // [esp+38h] [ebp-50h]
  int v21; // [esp+3Ch] [ebp-4Ch]
  int v22; // [esp+40h] [ebp-48h]
  int v23; // [esp+44h] [ebp-44h]
  int v24; // [esp+48h] [ebp-40h]
  int v25; // [esp+4Ch] [ebp-3Ch]
  int v26; // [esp+50h] [ebp-38h]
  int v27; // [esp+54h] [ebp-34h]
  int v28; // [esp+58h] [ebp-30h]
  int v29; // [esp+5Ch] [ebp-2Ch]
  int v30; // [esp+60h] [ebp-28h]
  int v31; // [esp+64h] [ebp-24h]
  int v32; // [esp+68h] [ebp-20h]
  int v33; // [esp+6Ch] [ebp-1Ch]
  int v34; // [esp+70h] [ebp-18h]
  int v35; // [esp+74h] [ebp-14h]
  int v36; // [esp+78h] [ebp-10h]
  int v37; // [esp+7Ch] [ebp-Ch]
  int v38; // [esp+80h] [ebp-8h]
  int v39; // [esp+84h] [ebp-4h]

  v16 = 168;
  v17 = 160;
  v18 = 184;
  v19 = 184;
  v20 = 184;
  v21 = 160;
  v22 = 200;
  v23 = 184;
  v24 = 168;
  v25 = 184;
  v26 = 184;
  v27 = 208;
  v28 = 184;
  v29 = 184;
  v30 = 200;
  v31 = 208;
  v32 = 200;
  v33 = 160;
  v34 = 216;
  v35 = 176;
  v36 = 216;
  v37 = 160;
  v38 = 232;
  v39 = 176;
  v8 = 200;
  v9 = 176;
  v10 = 216;
  v11 = 192;
  v12 = 216;
  v13 = 176;
  v14 = 232;
  v15 = 192;
  result = (int *)a1;
  switch ( *(_DWORD *)(a1 + 116) )
  {
    case 0:
      *(_DWORD *)(a1 + 116) = 1;
      switch ( *(_DWORD *)(a1 + 76) )
      {
        case 0:
          *(_DWORD *)(a1 + 16) = -1536;
          break;
        case 1:
          *(_DWORD *)(a1 + 20) = -1536;
          break;
        case 2:
          *(_DWORD *)(a1 + 16) = 1536;
          break;
        case 3:
          *(_DWORD *)(a1 + 20) = 1536;
          break;
        default:
          goto LABEL_7;
      }
      goto LABEL_7;
    case 1:
LABEL_7:
      if ( ++*(_DWORD *)(a1 + 120) == 8 )
        *(_WORD *)(a1 + 80) &= 0xFFF7u;
      *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 20);
      if ( *(_DWORD *)(a1 + 120) == 16 )
        *(_DWORD *)(a1 + 116) = 10;
      if ( ++*(_DWORD *)(a1 + 100) > 2 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        if ( ++*(_DWORD *)(a1 + 104) > 3 )
          *(_DWORD *)(a1 + 104) = 0;
      }
      v2 = &v16 + 4 * *(_DWORD *)(a1 + 104);
      result = (int *)(a1 + 84);
      *result = *v2;
      result[1] = v2[1];
      result[2] = v2[2];
      result[3] = v2[3];
      return result;
    case 0xA:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 104) = 0;
      *(_WORD *)(a1 + 80) |= 0x20u;
      *(_WORD *)(a1 + 80) &= 0xFFF7u;
      *(_DWORD *)(a1 + 164) = 5;
      *(_DWORD *)(a1 + 144) = 4096;
      goto LABEL_16;
    case 0xB:
LABEL_16:
      if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
        *(_DWORD *)(a1 + 76) = 2;
      else
        *(_DWORD *)(a1 + 76) = 0;
      if ( quote.YPos - 12288 <= *(_DWORD *)(a1 + 12) )
      {
        if ( *(_DWORD *)(a1 + 76) )
          v4 = *(_DWORD *)(a1 + 24) + 16;
        else
          v4 = *(_DWORD *)(a1 + 24) - 16;
        *(_DWORD *)(a1 + 24) = v4;
      }
      else
      {
        if ( *(_DWORD *)(a1 + 76) )
          v3 = *(_DWORD *)(a1 + 24) - 16;
        else
          v3 = *(_DWORD *)(a1 + 24) + 16;
        *(_DWORD *)(a1 + 24) = v3;
      }
      if ( *(_DWORD *)(a1 + 12) <= quote.YPos )
        v5 = *(_DWORD *)(a1 + 28) + 16;
      else
        v5 = *(_DWORD *)(a1 + 28) - 16;
      *(_DWORD *)(a1 + 28) = v5;
      if ( *(_DWORD *)(a1 + 24) < 0 && *(_DWORD *)(a1 + 4) & 1 )
        *(_DWORD *)(a1 + 24) = -*(_DWORD *)(a1 + 24);
      if ( *(_DWORD *)(a1 + 24) > 0 && *(_DWORD *)(a1 + 4) & 4 )
        *(_DWORD *)(a1 + 24) = -*(_DWORD *)(a1 + 24);
      if ( *(_DWORD *)(a1 + 28) < 0 && *(_DWORD *)(a1 + 4) & 2 )
        *(_DWORD *)(a1 + 28) = -*(_DWORD *)(a1 + 28);
      if ( *(_DWORD *)(a1 + 28) > 0 && *(_DWORD *)(a1 + 4) & 8 )
        *(_DWORD *)(a1 + 28) = -*(_DWORD *)(a1 + 28);
      if ( *(_DWORD *)(a1 + 24) < -1535 )
        *(_DWORD *)(a1 + 24) = -1535;
      if ( *(_DWORD *)(a1 + 24) > 1535 )
        *(_DWORD *)(a1 + 24) = 1535;
      if ( *(_DWORD *)(a1 + 28) < -1535 )
        *(_DWORD *)(a1 + 28) = -1535;
      if ( *(_DWORD *)(a1 + 28) > 1535 )
        *(_DWORD *)(a1 + 28) = 1535;
      *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 24);
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(a1 + 28);
      if ( ++*(_DWORD *)(a1 + 100) > 1 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        if ( ++*(_DWORD *)(a1 + 104) > 1 )
          *(_DWORD *)(a1 + 104) = 0;
      }
      if ( *(_DWORD *)(a1 + 76) )
        v6 = &v8 + 4 * *(_DWORD *)(a1 + 104);
      else
        v6 = &v32 + 4 * *(_DWORD *)(a1 + 104);
      v7 = (int *)(a1 + 84);
      *v7 = *v6;
      v7[1] = v6[1];
      result = (int *)v6[2];
      v7[2] = (int)result;
      v7[3] = v6[3];
      break;
    default:
      return result;
  }
  return result;
}

//----- (0046E110) --------------------------------------------------------
int __cdecl NPC354(int a1)
{
  int result; // eax
  int v2; // ecx
  int v3; // ecx
  int v4; // [esp+0h] [ebp-10h]
  signed int i; // [esp+4h] [ebp-Ch]

  result = a1;
  v4 = *(_DWORD *)(a1 + 116);
  switch ( v4 )
  {
    case 0:
      *(_DWORD *)(a1 + 136) = 143360;
      return result;
    case 10:
      *(_DWORD *)(a1 + 116) = 11;
      *(_DWORD *)(a1 + 120) = 0;
      if ( *(_DWORD *)(a1 + 76) )
        v2 = *(_DWORD *)(a1 + 8) - 0x2000;
      else
        v2 = *(_DWORD *)(a1 + 8) + 0x2000;
      *(_DWORD *)(a1 + 8) = v2;
      break;
    case 11:
      break;
    default:
      return result;
  }
  ++*(_DWORD *)(a1 + 120);
  result = a1;
  if ( *(_DWORD *)(a1 + 120) > 100 )
  {
    *(_DWORD *)(a1 + 120) = 0;
    setQuake(20);
    playSoundEffect(SFXLargeObjectHitGround, 1);
    playSoundEffect(SFXDestroyBreakableBlock, 1);
    if ( *(_DWORD *)(a1 + 76) )
    {
      result = a1;
      v3 = *(_DWORD *)(a1 + 8) + 0x2000;
    }
    else
    {
      result = a1;
      v3 = *(_DWORD *)(a1 + 8) - 0x2000;
    }
    *(_DWORD *)(a1 + 8) = v3;
    for ( i = 0; i < 20; ++i )
    {
      changeMapParts(*(_DWORD *)(a1 + 8) / 512 / 16, i + *(_DWORD *)(a1 + 12) / 512 / 16, 0x6Du);
      result = i + 1;
    }
  }
  return result;
}

//----- (0046E280) --------------------------------------------------------
int *__cdecl NPC355(int a1)
{
  int *v1; // edx
  int *result; // eax
  int v3; // [esp+8h] [ebp-40h]
  int v4; // [esp+Ch] [ebp-3Ch]
  int v5; // [esp+10h] [ebp-38h]
  int v6; // [esp+14h] [ebp-34h]
  int v7; // [esp+18h] [ebp-30h]
  int v8; // [esp+1Ch] [ebp-2Ch]
  int v9; // [esp+20h] [ebp-28h]
  int v10; // [esp+24h] [ebp-24h]
  int v11; // [esp+28h] [ebp-20h]
  int v12; // [esp+2Ch] [ebp-1Ch]
  int v13; // [esp+30h] [ebp-18h]
  int v14; // [esp+34h] [ebp-14h]
  int v15; // [esp+38h] [ebp-10h]
  int v16; // [esp+3Ch] [ebp-Ch]
  int v17; // [esp+40h] [ebp-8h]
  int v18; // [esp+44h] [ebp-4h]

  v3 = 80;
  v4 = 16;
  v5 = 96;
  v6 = 32;
  v7 = 80;
  v8 = 96;
  v9 = 96;
  v10 = 112;
  v11 = 128;
  v12 = 16;
  v13 = 144;
  v14 = 32;
  v15 = 208;
  v16 = 96;
  v17 = 224;
  v18 = 112;
  if ( !*(_DWORD *)(a1 + 116) )
  {
    switch ( *(_DWORD *)(a1 + 76) )
    {
      case 0:
        *(_DWORD *)(a1 + 52) = 16;
        *(_DWORD *)(a1 + 104) = 0;
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) - 7168;
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12) + 5120;
        break;
      case 1:
        *(_DWORD *)(a1 + 52) = 23;
        *(_DWORD *)(a1 + 104) = 1;
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) + 7168;
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12) + 5120;
        break;
      case 2:
        *(_DWORD *)(a1 + 52) = 16;
        *(_DWORD *)(a1 + 104) = 2;
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) - 3584;
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12) - 9728;
        break;
      case 3:
        *(_DWORD *)(a1 + 52) = 23;
        *(_DWORD *)(a1 + 104) = 3;
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) + 2048;
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12) - 9728;
        break;
      default:
        break;
    }
  }
  v1 = &v3 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (0046E480) --------------------------------------------------------
RECT *__cdecl NPC356(NPC *a1)
{
  int v1; // ecx
  int v2; // ecx
  int *v3; // edx
  RECT *result; // eax
  int v5; // [esp+4h] [ebp-20h]
  int v6; // [esp+8h] [ebp-1Ch]
  int v7; // [esp+Ch] [ebp-18h]
  int v8; // [esp+10h] [ebp-14h]
  int v9; // [esp+14h] [ebp-10h]
  int v10; // [esp+18h] [ebp-Ch]
  int v11; // [esp+1Ch] [ebp-8h]
  int v12; // [esp+20h] [ebp-4h]

  v5 = 240;
  v6 = 128;
  v7 = 280;
  v8 = 152;
  v9 = 240;
  v10 = 152;
  v11 = 280;
  v12 = 176;
  switch ( a1->currentState )
  {
    case 0:
      a1->currentState = 11;
      a1->animationTimer = 0;
      a1->curlyTargetY = a1->YPos - 0x2000;
      a1->curlyTargetX = a1->XPos - 3072;
      a1->YVel = 0;
      createNPC((NPCNames)355, 0, 0, 0, 0, down, a1, 170);
      createNPC((NPCNames)355, 0, 0, 0, 0, right, a1, 170);
      goto LABEL_3;
    case 0xB:
LABEL_3:
      if ( a1->XPos >= a1->curlyTargetX )
        v1 = a1->XVel - 8;
      else
        v1 = a1->XVel + 8;
      a1->XVel = v1;
      if ( a1->YPos >= a1->curlyTargetY )
        v2 = a1->YVel - 8;
      else
        v2 = a1->YVel + 8;
      a1->YVel = v2;
      a1->XPos += a1->XVel;
      a1->YPos += a1->YVel;
      break;
    case 0x14:
      a1->currentState = 21;
      a1->XVel = -1024;
      a1->YVel = 512;
      goto LABEL_11;
    case 0x15:
LABEL_11:
      ++a1->animationTimer;
      a1->XVel += 16;
      a1->YVel -= 8;
      a1->XPos += a1->XVel;
      a1->YPos += a1->YVel;
      if ( a1->XPos > 491520 )
        a1->currentState = 22;
      break;
    case 0x16:
      a1->XVel = 0;
      a1->YVel = 0;
      break;
    default:
      break;
  }
  if ( ++a1->animationTimer > 4 )
  {
    a1->animationTimer = 0;
    ++a1->animationNumber;
  }
  if ( a1->animationNumber > 1 )
    a1->animationNumber = 0;
  v3 = &v5 + 4 * a1->animationNumber;
  result = &a1->rect;
  result->left = *v3;
  result->top = v3[1];
  result->right = v3[2];
  result->bottom = v3[3];
  return result;
}

//----- (0046E730) --------------------------------------------------------
void __cdecl NPC357(int a1)
{
  _DWORD *v1; // edx
  _DWORD *v2; // ecx
  int v3; // ST08_4
  int v4; // eax
  int v5; // [esp+0h] [ebp-14h]

  v5 = *(_DWORD *)(a1 + 116);
  switch ( v5 )
  {
    case 0:
      v1 = (_DWORD *)(a1 + 84);
      *v1 = 224;
      v1[1] = 136;
      v1[2] = 240;
      v1[3] = 152;
      ++*(_DWORD *)(a1 + 120);
      goto LABEL_11;
    case 10:
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 116) = 11;
      playSoundEffect(SFXTeleport, 1);
      break;
    case 11:
      break;
    default:
      goto LABEL_11;
  }
  ++*(_DWORD *)(a1 + 120);
  v2 = (_DWORD *)(a1 + 84);
  *v2 = 224;
  v2[1] = 136;
  v2[2] = 240;
  v2[3] = 152;
  if ( *(_DWORD *)(a1 + 120) / 2 % 2 )
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 84);
  if ( *(_DWORD *)(a1 + 120) > 50 )
    *(_BYTE *)a1 = 0;
LABEL_11:
  if ( *(_DWORD *)(a1 + 120) % 8 == 1 )
  {
    v3 = *(_DWORD *)(a1 + 12) + 4096;
    v4 = random(-8, 8);
    createEffect(*(_DWORD *)(a1 + 8) + (v4 << 9), v3, effectUnknownUnused, up);
  }
}

//----- (0046E870) --------------------------------------------------------
int __cdecl NPC358(int a1)
{
  int *v1; // eax
  int *v2; // ecx
  int result; // eax
  int v4; // [esp+0h] [ebp-54h]
  int v5; // [esp+4h] [ebp-50h]
  int v6; // [esp+8h] [ebp-4Ch]
  int v7; // [esp+Ch] [ebp-48h]
  int v8; // [esp+10h] [ebp-44h]
  int v9; // [esp+14h] [ebp-40h]
  int v10; // [esp+18h] [ebp-3Ch]
  int v11; // [esp+1Ch] [ebp-38h]
  int v12; // [esp+20h] [ebp-34h]
  int v13; // [esp+24h] [ebp-30h]
  int v14; // [esp+28h] [ebp-2Ch]
  int v15; // [esp+2Ch] [ebp-28h]
  int v16; // [esp+30h] [ebp-24h]
  int v17; // [esp+34h] [ebp-20h]
  int v18; // [esp+38h] [ebp-1Ch]
  int v19; // [esp+3Ch] [ebp-18h]
  int v20; // [esp+40h] [ebp-14h]
  int v21; // [esp+44h] [ebp-10h]
  int v22; // [esp+48h] [ebp-Ch]
  int v23; // [esp+4Ch] [ebp-8h]
  int v24; // [esp+50h] [ebp-4h]

  v5 = 208;
  v6 = 8;
  v7 = 224;
  v8 = 32;
  v9 = 224;
  v10 = 8;
  v11 = 240;
  v12 = 32;
  v13 = 240;
  v14 = 8;
  v15 = 256;
  v16 = 32;
  v17 = 256;
  v18 = 8;
  v19 = 272;
  v20 = 32;
  v21 = 272;
  v22 = 8;
  v23 = 288;
  v24 = 32;
  v4 = *(_DWORD *)(a1 + 116);
  if ( v4 )
  {
    if ( v4 == 10 )
    {
      if ( ++*(_DWORD *)(a1 + 100) > 6 )
      {
        *(_DWORD *)(a1 + 100) = 0;
        ++*(_DWORD *)(a1 + 104);
      }
      if ( *(_DWORD *)(a1 + 104) > 4 )
        *(_DWORD *)(a1 + 104) = 3;
    }
  }
  else
  {
    if ( ++*(_DWORD *)(a1 + 100) > 6 )
    {
      *(_DWORD *)(a1 + 100) = 0;
      ++*(_DWORD *)(a1 + 104);
    }
    if ( *(_DWORD *)(a1 + 104) > 1 )
      *(_DWORD *)(a1 + 104) = 0;
  }
  v1 = &v5 + 4 * *(_DWORD *)(a1 + 104);
  v2 = (int *)(a1 + 84);
  *v2 = *v1;
  v2[1] = v1[1];
  v2[2] = v1[2];
  result = v1[3];
  v2[3] = result;
  return result;
}

//----- (0046E9E0) --------------------------------------------------------
void __cdecl NPC359(int a1)
{
  int v1; // eax

  if ( quote.XPos < *(_DWORD *)(a1 + 8) + 163840
    && quote.XPos > *(_DWORD *)(a1 + 8) - 163840
    && quote.YPos < *(_DWORD *)(a1 + 12) + 163840
    && quote.YPos > *(_DWORD *)(a1 + 12) - 81920
    && random(0, 100) == 2 )
  {
    v1 = random(-6, 6);
    createNPC(NPCBalrogDropIn|0x40, *(_DWORD *)(a1 + 8) + (v1 << 9), *(_DWORD *)(a1 + 12) - 3584, 0, 0, 0, 0, 0);
  }
}

//----- (0046EA90) --------------------------------------------------------
// NPC 360 : Thank you!
// The thank you screen.
signed int __cdecl NPC360_Thank_You(int a1)
{
  _DWORD *v1; // ecx
  signed int result; // eax

  if ( !*(_DWORD *)(a1 + 116) )
  {
    ++*(_DWORD *)(a1 + 116);
    *(_DWORD *)(a1 + 8) -= 4096;
    *(_DWORD *)(a1 + 12) -= 4096;
  }
  v1 = (_DWORD *)(a1 + 84);
  *v1 = 0;
  v1[1] = 176;
  v1[2] = 48;
  result = 184;
  v1[3] = 184;
  if ( quote.equippedItems & 0x80 )
    result = 48;
  return result;
}

//----- (0046EB30) --------------------------------------------------------
void __cdecl initNPCs()
{
  memset(NPCObjects, 0, 0x15800u);
}

//----- (0046EB50) --------------------------------------------------------
#error "46EB50: local variable allocation failed (funcsize=195)"

//----- (0046EE50) --------------------------------------------------------
void __cdecl Set_Unique_Parameter(NPC *npc)
{
  int NPC_Num; // ST00_4

  NPC_Num = npc->entityType;
  npc->entitySpritesheet = (unsigned __int8)NPCTable[NPC_Num].surf;
  npc->hitSound = (unsigned __int8)NPCTable[NPC_Num].soundOnHit;
  npc->deathSound = (unsigned __int8)NPCTable[NPC_Num].soundOnDeath;
  npc->damage = NPCTable[NPC_Num].damage;
  npc->explosionSize = (unsigned __int8)NPCTable[NPC_Num].size;
  npc->life = (unsigned __int16)NPCTable[NPC_Num].life;
  npc->hitbox.front = (unsigned __int8)NPCTable[NPC_Num].hit.front << 9;
  npc->hitbox.back = (unsigned __int8)NPCTable[NPC_Num].hit.back << 9;
  npc->hitbox.top = (unsigned __int8)NPCTable[NPC_Num].hit.top << 9;
  npc->hitbox.bottom = (unsigned __int8)NPCTable[NPC_Num].hit.bottom << 9;
  npc->view.front = (unsigned __int8)NPCTable[NPC_Num].view.front << 9;
  npc->view.back = (unsigned __int8)NPCTable[NPC_Num].view.back << 9;
  npc->view.top = (unsigned __int8)NPCTable[NPC_Num].view.top << 9;
  npc->view.bottom = (unsigned __int8)NPCTable[NPC_Num].view.bottom << 9;
}

//----- (0046EFD0) --------------------------------------------------------
void __cdecl createNPC(NPCNames NPC_Num, int X_Pos, int Y_Pos, int X_Vel, int Y_Vel, Directions Direction, NPC *Parent_NPC, int Start_Index)
{
  int n; // [esp+0h] [ebp-4h]

  for ( n = Start_Index; n < 512 && NPCObjects[n].isAlive; ++n )
    ;                                           // Search for a valid NPC
  if ( n != 512 )
  {
    memset(&NPCObjects[n], 0, 0xACu);           // Clear residual NPC RAM
    NPCObjects[n].isAlive |= 0x80u;             // Set NPC's vars according to args
    NPCObjects[n].direction = Direction;
    NPCObjects[n].entityType = NPC_Num;
    NPCObjects[n].XPos = X_Pos;
    NPCObjects[n].YPos = Y_Pos;
    NPCObjects[n].XVel = X_Vel;
    NPCObjects[n].YVel = Y_Vel;
    NPCObjects[n].parentNPC = Parent_NPC;
    NPCObjects[n].entityFlags = NPCTable[NPCObjects[n].entityType].bits;
    NPCObjects[n].EXPAmount = NPCTable[NPCObjects[n].entityType].exp;
    Set_Unique_Parameter(&NPCObjects[n]);
  }
}

//----- (0046F150) --------------------------------------------------------
void __cdecl createDustClouds(int X_Pos, int Y_Pos, signed int Range, int Num)
{
  int offset_X; // ST24_4
  int offset_Y; // ST20_4
  int i; // [esp+8h] [ebp-4h]
  int Range_By_512; // [esp+1Ch] [ebp+10h]

  Range_By_512 = Range / 512;
  for ( i = 0; i < Num; ++i )
  {
    offset_X = random(-Range_By_512, Range_By_512) << 9;
    offset_Y = random(-Range_By_512, Range_By_512) << 9;
    createNPC(NPCSmoke, offset_X + X_Pos, offset_Y + Y_Pos, 0, 0, left, 0, 256);
  }
  createEffect(X_Pos, Y_Pos, effectHeadbumpSparks, 0);
}

//----- (0046F200) --------------------------------------------------------
void __cdecl createDustCloudsUp(int X_Pos, int Y_Pos, signed int Range, int Num)
{
  int offset_X; // ST24_4
  int offset_Y; // ST20_4
  int i; // [esp+8h] [ebp-4h]
  int Range_By_512; // [esp+1Ch] [ebp+10h]

  Range_By_512 = Range / 512;
  for ( i = 0; i < Num; ++i )
  {
    offset_X = random(-Range_By_512, Range_By_512) << 9;
    offset_Y = random(-Range_By_512, Range_By_512) << 9;
    createNPC(NPCSmoke, offset_X + X_Pos, offset_Y + Y_Pos, 0, 0, up, 0, 256);
  }
  createEffect(X_Pos, Y_Pos, effectHeadbumpSparks, 0);
}

//----- (0046F2B0) --------------------------------------------------------
void __cdecl Spawn_Exp(int X_Position, int Y_Position, signed int EXP_Amount)
{
  int Actual_Exp_Amount; // [esp+0h] [ebp-8h]
  signed int i; // [esp+4h] [ebp-4h]

  for ( i = 256; EXP_Amount; Set_Unique_Parameter(&NPCObjects[i]) )
  {
    while ( i < 512 && NPCObjects[i].isAlive )
      ++i;
    if ( i == 512 )
      break;
    memset(&NPCObjects[i], 0, 0xACu);
    if ( EXP_Amount < 20 )
    {
      if ( EXP_Amount < 5 )
      {
        if ( EXP_Amount >= 1 )
        {
          --EXP_Amount;
          Actual_Exp_Amount = 1;
        }
      }
      else
      {
        EXP_Amount -= 5;
        Actual_Exp_Amount = 5;
      }
    }
    else
    {
      EXP_Amount -= 20;
      Actual_Exp_Amount = 20;
    }
    NPCObjects[i].isAlive |= 0x80u;
    NPCObjects[i].direction = left;
    NPCObjects[i].entityType = 1;
    NPCObjects[i].XPos = X_Position;
    NPCObjects[i].YPos = Y_Position;
    NPCObjects[i].entityFlags = NPCTable[NPCObjects[i].entityType].bits;
    NPCObjects[i].EXPAmount = Actual_Exp_Amount;
  }
}

//----- (0046F430) --------------------------------------------------------
signed int __cdecl Spawn_Missiles(int a1, int a2, int a3)
{
  weapons v4; // [esp+0h] [ebp-38h]
  int v5; // [esp+4h] [ebp-34h]
  int ptr[10]; // [esp+8h] [ebp-30h]
  int v7; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]

  v5 = 0;
  memset(ptr, 0, 0x28u);
  for ( i = 0; i < 8; ++i )
  {
    v4 = gWeapons[i].weaponID;
    if ( v4 == 5 )
    {
      ptr[v5++] = 0;
    }
    else if ( v4 == 10 )
    {
      ptr[v5++] = 1;
    }
    else
    {
      ptr[v5] = 0;
    }
  }
  if ( !v5 )
    return 0;
  i = random(1, 10 * v5);
  v7 = ptr[i % v5];
  for ( i = 256; i < 512 && NPCObjects[i].isAlive; ++i )
    ;
  if ( i == 512 )
    return 0;
  memset(&NPCObjects[i], 0, 0xACu);
  NPCObjects[i].isAlive |= 0x80u;
  NPCObjects[i].direction = 0;
  NPCObjects[i].entityEventNum = v7;
  NPCObjects[i].entityType = 86;
  NPCObjects[i].XPos = a1;
  NPCObjects[i].YPos = a2;
  NPCObjects[i].entityFlags = NPCTable[NPCObjects[i].entityType].bits;
  NPCObjects[i].EXPAmount = a3;
  Set_Unique_Parameter(&NPCObjects[i]);
  return 1;
}
// 46F430: using guessed type int ptr[10];

//----- (0046F630) --------------------------------------------------------
signed int __cdecl Spawn_HP(int a1, int a2, int a3)
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 256; i < 512 && NPCObjects[i].isAlive; ++i )
    ;
  if ( i == 512 )
    return 0;
  memset(&NPCObjects[i], 0, 0xACu);
  NPCObjects[i].isAlive |= 0x80u;
  NPCObjects[i].direction = 0;
  NPCObjects[i].entityType = 87;
  NPCObjects[i].XPos = a1;
  NPCObjects[i].YPos = a2;
  NPCObjects[i].entityFlags = NPCTable[NPCObjects[i].entityType].bits;
  NPCObjects[i].EXPAmount = a3;
  Set_Unique_Parameter(&NPCObjects[i]);
  return 1;
}

//----- (0046F760) --------------------------------------------------------
// Make the NPC disappear
void __cdecl Vanish_NPC(NPC *npc)
{
  int npc_X_Pos; // ST0C_4
  int npc_Y_Pos; // ST10_4

  npc_X_Pos = npc->XPos;
  npc_Y_Pos = npc->YPos;
  memset(npc, 0, 0xACu);
  npc->count1 = 0;
  npc->XPos = npc_X_Pos;
  npc->YPos = npc_Y_Pos;
  npc->isAlive |= 0x80u;
  npc->direction = 0;
  npc->entityType = 3;
  npc->entityFlags = NPCTable[npc->entityType].bits;
  npc->EXPAmount = NPCTable[npc->entityType].exp;
  Set_Unique_Parameter(npc);
}
// 4BBA30: using guessed type int superYPos;

//----- (0046F810) --------------------------------------------------------
void __cdecl drawNPCs(signed int Camera_X, signed int Camera_Y)
{
  int side; // [esp+0h] [ebp-Ch]
  signed int i; // [esp+4h] [ebp-8h]
  char a; // [esp+Bh] [ebp-1h]

  for ( i = 0; i < 512; ++i )
  {
    if ( NPCObjects[i].isAlive & 0x80 )
    {
      if ( NPCObjects[i].isBeingHit )
      {
        a = 2 * (NPCObjects[i].isBeingHit / 2 % 2) - 1;
      }
      else
      {
        a = 0;
        if ( NPCObjects[i].entityFlags & 0x8000 && NPCObjects[i].damage_view )
        {
          setValueView((__int32)&NPCObjects[i].XPos, (__int32)&NPCObjects[i].YPos, NPCObjects[i].damage_view);
          NPCObjects[i].damage_view = 0;
        }
      }
      if ( NPCObjects[i].direction )
        side = NPCObjects[i].view.back;
      else
        side = NPCObjects[i].view.front;
      drawBitmapWithTransparency(
        &gameRect,
        a + (NPCObjects[i].XPos - side) / 512 - Camera_X / 512,
        (NPCObjects[i].YPos - NPCObjects[i].view.top) / 512 - Camera_Y / 512,
        &NPCObjects[i].rect,
        NPCObjects[i].entitySpritesheet);
    }
  }
}

//----- (0046FA00) --------------------------------------------------------
void __cdecl updateNPCs()
{
  signed int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i < 512; ++i )
  {
    if ( NPCObjects[i].isAlive & 0x80 )         // Only run entity's AI if it's alive
    {
      NPC_Function_Table[NPCObjects[i].entityType](&NPCObjects[i]);
      if ( NPCObjects[i].isBeingHit )
        --NPCObjects[i].isBeingHit;
    }
  }
}

//----- (0046FAB0) --------------------------------------------------------
void __cdecl spawnNPC(int Entity_Eve_Num, int Entity_Type, int Direction)
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 512; ++i )
  {
    if ( NPCObjects[i].isAlive & 0x80 && NPCObjects[i].entityEventNum == Entity_Eve_Num )
    {
      NPCObjects[i].entityFlags &= 0x7F00u;
      NPCObjects[i].entityType = Entity_Type;
      NPCObjects[i].entityFlags |= NPCTable[NPCObjects[i].entityType].bits;
      NPCObjects[i].EXPAmount = NPCTable[NPCObjects[i].entityType].exp;
      Set_Unique_Parameter(&NPCObjects[i]);
      NPCObjects[i].isAlive |= 0x80u;
      NPCObjects[i].currentState = 0;
      NPCObjects[i].waitTimer = 0;
      NPCObjects[i].count1 = 0;
      NPCObjects[i].count2 = 0;
      NPCObjects[i].animationNumber = 0;
      NPCObjects[i].animationTimer = 0;
      NPCObjects[i].XVel = 0;
      NPCObjects[i].YVel = 0;
      if ( Direction != 5 )
      {
        if ( Direction == 4 )
        {
          if ( NPCObjects[i].XPos >= quote.XPos )
            NPCObjects[i].direction = 0;
          else
            NPCObjects[i].direction = 2;
        }
        else
        {
          NPCObjects[i].direction = Direction;
        }
      }
      NPC_Function_Table[Entity_Type](&NPCObjects[i]);
    }
  }
}

//----- (0046FD10) --------------------------------------------------------
void __cdecl changeCheckableNPCByEvent(int Entity_Eve_Num, int Entity_Type, char Direction)
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 512; ++i )
  {
    if ( NPCObjects[i].isAlive & 0x80 && NPCObjects[i].entityEventNum == Entity_Eve_Num )
    {
      NPCObjects[i].entityFlags &= 0x7F00u;
      NPCObjects[i].entityFlags |= 0x2000u;
      NPCObjects[i].entityType = Entity_Type;
      NPCObjects[i].entityFlags |= NPCTable[NPCObjects[i].entityType].bits;
      NPCObjects[i].EXPAmount = NPCTable[NPCObjects[i].entityType].exp;
      Set_Unique_Parameter(&NPCObjects[i]);
      NPCObjects[i].isAlive |= 0x80u;
      NPCObjects[i].currentState = 0;
      NPCObjects[i].waitTimer = 0;
      NPCObjects[i].count1 = 0;
      NPCObjects[i].count2 = 0;
      NPCObjects[i].animationNumber = 0;
      NPCObjects[i].animationTimer = 0;
      NPCObjects[i].XVel = 0;
      NPCObjects[i].YVel = 0;
      if ( Direction != 5 )
      {
        if ( Direction == 4 )
        {
          if ( NPCObjects[i].XPos >= quote.XPos )
            NPCObjects[i].direction = 0;
          else
            NPCObjects[i].direction = 2;
        }
        else
        {
          NPCObjects[i].direction = Direction;
        }
      }
      NPC_Function_Table[Entity_Type](&NPCObjects[i]);
    }
  }
}

//----- (0046FF90) --------------------------------------------------------
void __cdecl setNPCState(int Entity_Eve_Num, int NPC_State, int Direction)
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 512 && (!(NPCObjects[i].isAlive & 0x80) || NPCObjects[i].entityEventNum != Entity_Eve_Num); ++i )
    ;
  if ( i != 512 )
  {
    NPCObjects[i].currentState = NPC_State;
    if ( Direction != 5 )
    {
      if ( Direction == 4 )
      {
        if ( NPCObjects[i].XPos >= quote.XPos )
          NPCObjects[i].direction = 0;
        else
          NPCObjects[i].direction = 2;
      }
      else
      {
        NPCObjects[i].direction = Direction;
      }
    }
  }
}

//----- (00470060) --------------------------------------------------------
void __cdecl moveNPC(int Entity_Eve_Num, int X_Pos, int Y_Pos, char Direction)
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 512 && (!(NPCObjects[i].isAlive & 0x80) || NPCObjects[i].entityEventNum != Entity_Eve_Num); ++i )
    ;
  if ( i != 512 )
  {
    NPCObjects[i].XPos = X_Pos;
    NPCObjects[i].YPos = Y_Pos;
    if ( Direction != 5 )
    {
      if ( Direction == 4 )
      {
        if ( NPCObjects[i].XPos >= quote.XPos )
          NPCObjects[i].direction = 0;
        else
          NPCObjects[i].direction = 2;
      }
      else
      {
        NPCObjects[i].direction = Direction;
      }
    }
  }
}

//----- (00470150) --------------------------------------------------------
void __cdecl backStepPlayer(int Entity_Eve_Num)
{
  signed int n; // [esp+0h] [ebp-4h]

  n = 0;
  quote.flags &= 0xFEu;
  quote.YVel = -512;
  if ( Entity_Eve_Num )
  {
    if ( Entity_Eve_Num == 2 )
    {
      quote.direction = 2;
      quote.XVel = -512;
    }
    else
    {
      while ( n < 512 && (!(NPCObjects[n].isAlive & 0x80) || NPCObjects[n].entityEventNum != Entity_Eve_Num) )
        ++n;
      if ( n != 512 )
      {
        if ( NPCObjects[n].XPos >= quote.XPos )
        {
          quote.direction = 2;
          quote.XVel = -512;
        }
        else
        {
          quote.direction = 0;
          quote.XVel = 512;
        }
      }
    }
  }
  else
  {
    quote.direction = 0;
    quote.XVel = 512;
  }
}

//----- (00470250) --------------------------------------------------------
void __cdecl deleteNPCEvent(int Entity_Eve_Num)
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 512; ++i )
  {
    if ( NPCObjects[i].isAlive & 0x80 )
    {
      if ( NPCObjects[i].entityEventNum == Entity_Eve_Num )
      {
        NPCObjects[i].isAlive = 0;
        Set_NPC_Flag(NPCObjects[i].code_flag);
      }
    }
  }
}

//----- (004702D0) --------------------------------------------------------
void __cdecl killNPC(int Number, int bSmoke)
{
  int NPC_Explosion_Size; // [esp+0h] [ebp-8h]
  signed int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i < 512; ++i )
  {
    if ( NPCObjects[i].isAlive & 0x80 )
    {
      if ( NPCObjects[i].entityType == Number )
      {
        NPCObjects[i].isAlive = 0;
        Set_NPC_Flag(NPCObjects[i].code_flag);
        if ( bSmoke )
        {
          playSoundEffect((soundEffects)NPCObjects[i].deathSound, 1);
          NPC_Explosion_Size = NPCObjects[i].explosionSize;
          switch ( NPC_Explosion_Size )
          {
            case 1:
              createDustClouds(NPCObjects[i].XPos, NPCObjects[i].YPos, NPCObjects[i].view.back, 4);
              break;
            case 2:
              createDustClouds(NPCObjects[i].XPos, NPCObjects[i].YPos, NPCObjects[i].view.back, 8);
              break;
            case 3:
              createDustClouds(NPCObjects[i].XPos, NPCObjects[i].YPos, NPCObjects[i].view.back, 16);
              break;
          }
        }
      }
    }
  }
}

//----- (00470460) --------------------------------------------------------
// Unused
void __cdecl getNPCPosition(int *destXPos, int *destYPos, int NPCObjectsIndex)
{
  *destXPos = NPCObjects[NPCObjectsIndex].XPos;
  *destYPos = NPCObjects[NPCObjectsIndex].YPos;
}

//----- (00470490) --------------------------------------------------------
signed int __cdecl isNPCType(int entityType)
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 512; ++i )
  {
    if ( NPCObjects[i].isAlive & 0x80 && NPCObjects[i].entityType == entityType )
      return 1;
  }
  return 0;
}

//----- (004704F0) --------------------------------------------------------
bool __cdecl checkNPCAlive(int code_event)
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 512 && (!(NPCObjects[i].isAlive & 0x80) || NPCObjects[i].entityEventNum != code_event); ++i )
    ;
  return i < 512;
}

//----- (00470560) --------------------------------------------------------
int Count_Live_NPCs()
{
  signed int i; // [esp+0h] [ebp-8h]
  int Live_NPCs_Counter; // [esp+4h] [ebp-4h]

  Live_NPCs_Counter = 0;
  for ( i = 0; i < 512; ++i )
  {
    if ( NPCObjects[i].isAlive & 0x80 )
      ++Live_NPCs_Counter;
  }
  return Live_NPCs_Counter;
}

//----- (004705C0) --------------------------------------------------------
void __cdecl NPC_Collision_Block(NPC *npc, int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0;
  if ( npc->YPos - npc->hitbox.top < (16 * Y_Pos + 5) << 9
    && npc->hitbox.bottom + npc->YPos > (16 * Y_Pos - 5) << 9
    && npc->XPos - npc->hitbox.back < (16 * X_Pos + 8) << 9
    && npc->XPos - npc->hitbox.back > X_Pos << 13 )
  {
    npc->XPos = npc->hitbox.back + ((16 * X_Pos + 8) << 9);
    hit = 1;
  }
  if ( npc->YPos - npc->hitbox.top < (16 * Y_Pos + 5) << 9
    && npc->hitbox.bottom + npc->YPos > (16 * Y_Pos - 5) << 9
    && npc->hitbox.back + npc->XPos > (16 * X_Pos - 8) << 9
    && npc->hitbox.back + npc->XPos < X_Pos << 13 )
  {
    npc->XPos = ((16 * X_Pos - 8) << 9) - npc->hitbox.back;
    hit |= 4u;
  }
  if ( npc->XPos - npc->hitbox.back < (16 * X_Pos + 5) << 9
    && npc->hitbox.back + npc->XPos > (16 * X_Pos - 5) << 9
    && npc->YPos - npc->hitbox.top < (16 * Y_Pos + 8) << 9
    && npc->YPos - npc->hitbox.top > Y_Pos << 13 )
  {
    npc->YPos = npc->hitbox.top + ((16 * Y_Pos + 8) << 9);
    npc->YVel = 0;
    hit |= 2u;
  }
  if ( npc->XPos - npc->hitbox.back < (16 * X_Pos + 5) << 9
    && npc->hitbox.back + npc->XPos > (16 * X_Pos - 5) << 9
    && npc->hitbox.bottom + npc->YPos > (16 * Y_Pos - 8) << 9
    && npc->hitbox.bottom + npc->YPos < Y_Pos << 13 )
  {
    npc->YPos = ((16 * Y_Pos - 8) << 9) - npc->hitbox.bottom;
    npc->YVel = 0;
    hit |= 8u;
  }
  npc->collisionFlags |= hit;
}

//----- (00470870) --------------------------------------------------------
void __cdecl NPC_Collision_Triangle_A(NPC *npc, int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0;
  if ( npc->XPos < (16 * X_Pos + 8) << 9
    && npc->XPos > (16 * X_Pos - 8) << 9
    && npc->YPos - npc->hitbox.top < (Y_Pos << 13) - (npc->XPos - (X_Pos << 13)) / 2 + 2048
    && npc->hitbox.bottom + npc->YPos > (16 * Y_Pos - 8) << 9 )
  {
    npc->YPos = (Y_Pos << 13) - (npc->XPos - (X_Pos << 13)) / 2 + npc->hitbox.top + 2048;
    if ( npc->YVel < 0 )
      npc->YVel = 0;
    hit = 2;
  }
  npc->collisionFlags |= hit;
}

//----- (00470970) --------------------------------------------------------
void __cdecl NPC_Collision_Triangle_B(NPC *npc, int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0;
  if ( npc->XPos < (16 * X_Pos + 8) << 9
    && npc->XPos > (16 * X_Pos - 8) << 9
    && npc->YPos - npc->hitbox.top < (Y_Pos << 13) - (npc->XPos - (X_Pos << 13)) / 2 - 2048
    && npc->hitbox.bottom + npc->YPos > (16 * Y_Pos - 8) << 9 )
  {
    npc->YPos = (Y_Pos << 13) - (npc->XPos - (X_Pos << 13)) / 2 + npc->hitbox.top - 2048;
    if ( npc->YVel < 0 )
      npc->YVel = 0;
    hit = 2;
  }
  npc->collisionFlags |= hit;
}

//----- (00470A70) --------------------------------------------------------
void __cdecl NPC_Collision_Triangle_C(NPC *npc, int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0;
  if ( npc->XPos < (16 * X_Pos + 8) << 9
    && npc->XPos > (16 * X_Pos - 8) << 9
    && npc->YPos - npc->hitbox.top < (Y_Pos << 13) + (npc->XPos - (X_Pos << 13)) / 2 - 2048
    && npc->hitbox.bottom + npc->YPos > (16 * Y_Pos - 8) << 9 )
  {
    npc->YPos = (npc->XPos - (X_Pos << 13)) / 2 + (Y_Pos << 13) + npc->hitbox.top - 2048;
    if ( npc->YVel < 0 )
      npc->YVel = 0;
    hit = 2;
  }
  npc->collisionFlags |= hit;
}

//----- (00470B70) --------------------------------------------------------
void __cdecl NPC_Collision_Triangle_D(NPC *npc, int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0;
  if ( npc->XPos < (16 * X_Pos + 8) << 9
    && npc->XPos > (16 * X_Pos - 8) << 9
    && npc->YPos - npc->hitbox.top < (Y_Pos << 13) + (npc->XPos - (X_Pos << 13)) / 2 + 2048
    && npc->hitbox.bottom + npc->YPos > (16 * Y_Pos - 8) << 9 )
  {
    npc->YPos = (npc->XPos - (X_Pos << 13)) / 2 + (Y_Pos << 13) + npc->hitbox.top + 2048;
    if ( npc->YVel < 0 )
      npc->YVel = 0;
    hit = 2;
  }
  npc->collisionFlags |= hit;
}

//----- (00470C70) --------------------------------------------------------
void __cdecl NPC_Collision_Triangle_E(NPC *npc, int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0x10000;
  if ( npc->XPos < (16 * X_Pos + 8) << 9
    && npc->XPos > (16 * X_Pos - 8) << 9
    && npc->hitbox.bottom + npc->YPos > (Y_Pos << 13) + (npc->XPos - (X_Pos << 13)) / 2 - 2048
    && npc->YPos - npc->hitbox.top < (16 * Y_Pos + 8) << 9 )
  {
    npc->YPos = (Y_Pos << 13) + (npc->XPos - (X_Pos << 13)) / 2 - 2048 - npc->hitbox.bottom;
    if ( npc->YVel > 0 )
      npc->YVel = 0;
    hit = 0x10028;
  }
  npc->collisionFlags |= hit;
}

//----- (00470D80) --------------------------------------------------------
void __cdecl NPC_Collision_Triangle_F(NPC *npc, int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0x20000;
  if ( npc->XPos < (16 * X_Pos + 8) << 9
    && npc->XPos >= (16 * X_Pos - 8) << 9
    && npc->hitbox.bottom + npc->YPos > (Y_Pos << 13) + (npc->XPos - (X_Pos << 13)) / 2 + 2048
    && npc->YPos - npc->hitbox.top < (16 * Y_Pos + 8) << 9 )
  {
    npc->YPos = (Y_Pos << 13) + (npc->XPos - (X_Pos << 13)) / 2 + 2048 - npc->hitbox.bottom;
    if ( npc->YVel > 0 )
      npc->YVel = 0;
    hit = 0x20028;
  }
  npc->collisionFlags |= hit;
}

//----- (00470E90) --------------------------------------------------------
void __cdecl NPC_Collision_Triangle_G(NPC *npc, int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0x40000;
  if ( npc->XPos < (16 * X_Pos + 8) << 9
    && npc->XPos > (16 * X_Pos - 8) << 9
    && npc->hitbox.bottom + npc->YPos > (Y_Pos << 13) - (npc->XPos - (X_Pos << 13)) / 2 + 2048
    && npc->YPos - npc->hitbox.top < (16 * Y_Pos + 8) << 9 )
  {
    npc->YPos = (Y_Pos << 13) - (npc->XPos - (X_Pos << 13)) / 2 + 2048 - npc->hitbox.bottom;
    if ( npc->YVel > 0 )
      npc->YVel = 0;
    hit = 262168;
  }
  npc->collisionFlags |= hit;
}

//----- (00470FA0) --------------------------------------------------------
void __cdecl NPC_Collision_Triangle_H(NPC *npc, int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0x80000;
  if ( npc->XPos < (16 * X_Pos + 8) << 9
    && npc->XPos > (16 * X_Pos - 8) << 9
    && npc->hitbox.bottom + npc->YPos > (Y_Pos << 13) - (npc->XPos - (X_Pos << 13)) / 2 - 2048
    && npc->YPos - npc->hitbox.top < (16 * Y_Pos + 8) << 9 )
  {
    npc->YPos = (Y_Pos << 13) - (npc->XPos - (X_Pos << 13)) / 2 - 2048 - npc->hitbox.bottom;
    if ( npc->YVel > 0 )
      npc->YVel = 0;
    hit = 524312;
  }
  npc->collisionFlags |= hit;
}

//----- (004710B0) --------------------------------------------------------
void __cdecl NPC_Collision_Water(NPC *npc, int X_Pos, int Y_Pos)
{
  signed int hit; // [esp+0h] [ebp-4h]

  hit = 0;
  if ( npc->XPos - npc->hitbox.back < (16 * X_Pos + 6) << 9
    && npc->hitbox.back + npc->XPos > (16 * X_Pos - 6) << 9
    && npc->YPos - npc->hitbox.top < (16 * Y_Pos + 6) << 9
    && npc->hitbox.bottom + npc->YPos > (16 * Y_Pos - 6) << 9 )
  {
    hit = 256;
  }
  npc->collisionFlags |= hit;
}

//----- (00471160) --------------------------------------------------------
void doCollisionCheckNPCsMap()
{
  __int64 v0; // rax
  signed int judg; // [esp+4h] [ebp-5Ch]
  int Off_X[9]; // [esp+8h] [ebp-58h]
  int j; // [esp+2Ch] [ebp-34h]
  int Off_Y[9]; // [esp+30h] [ebp-30h]
  int i; // [esp+54h] [ebp-Ch]
  int X_Pos_Blocks; // [esp+58h] [ebp-8h]
  int Y_Pos_Blocks; // [esp+5Ch] [ebp-4h]

  Off_X[0] = 0;
  Off_X[1] = 1;
  Off_X[2] = 0;
  Off_X[3] = 1;
  Off_X[4] = 2;
  Off_X[5] = 2;
  Off_X[6] = 2;
  Off_X[7] = 0;
  Off_X[8] = 1;
  Off_Y[0] = 0;
  Off_Y[1] = 0;
  Off_Y[2] = 1;
  Off_Y[3] = 1;
  Off_Y[4] = 0;
  Off_Y[5] = 1;
  Off_Y[6] = 2;
  Off_Y[7] = 2;
  Off_Y[8] = 2;
  for ( i = 0; i < 512; ++i )
  {
    if ( NPCObjects[i].isAlive & 0x80 && !(NPCObjects[i].entityFlags & 8) )
    {
      if ( NPCObjects[i].explosionSize < 3 )
      {
        judg = 4;
        X_Pos_Blocks = NPCObjects[i].XPos / 16 / 512;
        v0 = NPCObjects[i].YPos / 16;
      }
      else
      {
        judg = 9;
        X_Pos_Blocks = (NPCObjects[i].XPos - 4096) / 16 / 512;
        v0 = (NPCObjects[i].YPos - 4096) / 16;
      }
      Y_Pos_Blocks = ((WORD2(v0) & 0x1FF) + (signed int)v0) >> 9;
      NPCObjects[i].collisionFlags = 0;
      for ( j = 0; j < judg; ++j )
      {
        switch ( getTileAttributes(Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks) )
        {
          case 2u:
          case 96u:
          case 98u:
            NPC_Collision_Water(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 3u:
          case 5u:
          case 65u:
          case 67u:
            goto case_67;
          case 4u:
          case 97u:
          case 100u:
            NPC_Collision_Block(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            NPC_Collision_Water(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 68u:
            if ( !(NPCObjects[i].entityFlags & 2) )
case_67:
              NPC_Collision_Block(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 80u:
            NPC_Collision_Triangle_A(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 81u:
            NPC_Collision_Triangle_B(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 82u:
            NPC_Collision_Triangle_C(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 83u:
            NPC_Collision_Triangle_D(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 84u:
            NPC_Collision_Triangle_E(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 85u:
            NPC_Collision_Triangle_F(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 86u:
            NPC_Collision_Triangle_G(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 87u:
            NPC_Collision_Triangle_H(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 112u:
            NPC_Collision_Triangle_A(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            NPC_Collision_Water(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 113u:
            NPC_Collision_Triangle_B(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            NPC_Collision_Water(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 114u:
            NPC_Collision_Triangle_C(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            NPC_Collision_Water(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 115u:
            NPC_Collision_Triangle_D(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            NPC_Collision_Water(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 116u:
            NPC_Collision_Triangle_E(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            NPC_Collision_Water(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 117u:
            NPC_Collision_Triangle_F(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            NPC_Collision_Water(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 118u:
            NPC_Collision_Triangle_G(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            NPC_Collision_Water(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 119u:
            NPC_Collision_Triangle_H(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            NPC_Collision_Water(&NPCObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 128u:
            goto case_128;
          case 129u:
            goto case_129;
          case 130u:
            goto case_130;
          case 131u:
            goto case_131;
          case 160u:
            NPCObjects[i].collisionFlags |= 0x100u;
case_128:
            NPCObjects[i].collisionFlags |= 0x1000u;
            break;
          case 161u:
            NPCObjects[i].collisionFlags |= 0x100u;
case_129:
            NPCObjects[i].collisionFlags |= 0x2000u;
            break;
          case 162u:
            NPCObjects[i].collisionFlags |= 0x100u;
case_130:
            NPCObjects[i].collisionFlags |= 0x4000u;
            break;
          case 163u:
            NPCObjects[i].collisionFlags |= 0x100u;
case_131:
            NPCObjects[i].collisionFlags |= 0x8000u;
            break;
          default:
            break;
        }
        if ( NPCObjects[i].YPos > globalWaterDepth + 2048 )
          NPCObjects[i].collisionFlags |= 0x100u;
      }
    }
  }
}
// 499C90: using guessed type int globalWaterDepth;

//----- (00471B80) --------------------------------------------------------
void __cdecl NPC_Death_Maybe(void *Is_NPC_Alive, int a2)
{
  signed int v2; // eax
  int v3; // [esp+0h] [ebp-Ch]
  int v4; // [esp+4h] [ebp-8h]

  playSoundEffect(*((soundEffects *)Is_NPC_Alive + 15), 1);
  v4 = *((_DWORD *)Is_NPC_Alive + 18);
  switch ( v4 )
  {
    case 1:
      createDustClouds(*((_DWORD *)Is_NPC_Alive + 2), *((_DWORD *)Is_NPC_Alive + 3), *((_DWORD *)Is_NPC_Alive + 37), 3);
      break;
    case 2:
      createDustClouds(*((_DWORD *)Is_NPC_Alive + 2), *((_DWORD *)Is_NPC_Alive + 3), *((_DWORD *)Is_NPC_Alive + 37), 7);
      break;
    case 3:
      createDustClouds(*((_DWORD *)Is_NPC_Alive + 2), *((_DWORD *)Is_NPC_Alive + 3), *((_DWORD *)Is_NPC_Alive + 37), 12);
      break;
  }
  if ( *((_DWORD *)Is_NPC_Alive + 17) )
  {
    v3 = random(1, 5);
    if ( v3 == 1 )
    {
      if ( *((_DWORD *)Is_NPC_Alive + 17) <= 6 )
        Spawn_HP(*((_DWORD *)Is_NPC_Alive + 2), *((_DWORD *)Is_NPC_Alive + 3), 2);
      else
        Spawn_HP(*((_DWORD *)Is_NPC_Alive + 2), *((_DWORD *)Is_NPC_Alive + 3), 6);
    }
    else if ( v3 != 2
           || (*((_DWORD *)Is_NPC_Alive + 17) <= 6 ? (v2 = Spawn_Missiles(
                                                             *((_DWORD *)Is_NPC_Alive + 2),
                                                             *((_DWORD *)Is_NPC_Alive + 3),
                                                             1)) : (v2 = Spawn_Missiles(
                                                                           *((_DWORD *)Is_NPC_Alive + 2),
                                                                           *((_DWORD *)Is_NPC_Alive + 3),
                                                                           3)),
               !v2) )
    {
      Spawn_Exp(*((_DWORD *)Is_NPC_Alive + 2), *((_DWORD *)Is_NPC_Alive + 3), *((_DWORD *)Is_NPC_Alive + 17));
    }
  }
  Set_NPC_Flag(*((_DWORD *)Is_NPC_Alive + 11));
  if ( *((_WORD *)Is_NPC_Alive + 40) & 0x8000 )
  {
    if ( *((_WORD *)Is_NPC_Alive + 40) & 0x8000 && *((_DWORD *)Is_NPC_Alive + 40) )
      setValueView((__int32)Is_NPC_Alive + 8, (__int32)Is_NPC_Alive + 12, *((_DWORD *)Is_NPC_Alive + 40));
    if ( a2 )
      Vanish_NPC((NPC *)Is_NPC_Alive);
  }
  else
  {
    *(_BYTE *)Is_NPC_Alive = 0;
  }
}

//----- (00471D50) --------------------------------------------------------
int entityBulletCollision()
{
  int result; // eax
  signed int j; // [esp+0h] [ebp-Ch]
  signed int v2; // [esp+4h] [ebp-8h]
  signed int i; // [esp+8h] [ebp-4h]

  for ( i = 0; i < 512; ++i )
  {
    if ( !(NPCObjects[i].isAlive & 0x80) || NPCObjects[i].entityFlags & 0x20 && NPCObjects[i].entityFlags & 0x2000 )
      goto LABEL_2;
    for ( j = 0; j < 64; ++j )
    {
      if ( bulletObjects[j].isAlive & 0x80 && bulletObjects[j].damage != -1 )
      {
        v2 = 0;
        if ( NPCObjects[i].entityFlags & 0x20
          && NPCObjects[i].XPos - NPCObjects[i].hitbox.back < bulletObjects[j].sizeWidth + bulletObjects[j].XPos
          && NPCObjects[i].hitbox.back + NPCObjects[i].XPos > bulletObjects[j].XPos - bulletObjects[j].sizeWidth
          && NPCObjects[i].YPos - NPCObjects[i].hitbox.top < bulletObjects[j].sizeHeight + bulletObjects[j].YPos
          && NPCObjects[i].hitbox.bottom + NPCObjects[i].YPos > bulletObjects[j].YPos - bulletObjects[j].sizeHeight )
        {
          v2 = 1;
        }
        else if ( NPCObjects[i].entityFlags & 4
               && NPCObjects[i].XPos - NPCObjects[i].hitbox.back < bulletObjects[j].collisionX + bulletObjects[j].XPos
               && NPCObjects[i].hitbox.back + NPCObjects[i].XPos > bulletObjects[j].XPos - bulletObjects[j].collisionX
               && NPCObjects[i].YPos - NPCObjects[i].hitbox.top < bulletObjects[j].collisionY + bulletObjects[j].YPos
               && NPCObjects[i].hitbox.bottom + NPCObjects[i].YPos > bulletObjects[j].YPos - bulletObjects[j].collisionY )
        {
          v2 = 1;
        }
        if ( v2 )
        {
          if ( NPCObjects[i].entityFlags & 0x20 )
          {
            NPCObjects[i].life -= bulletObjects[j].damage;
            if ( NPCObjects[i].life >= 1 )
            {
              if ( (signed int)NPCObjects[i].isBeingHit < 14 )
              {
                createEffect(
                  (NPCObjects[i].XPos + bulletObjects[j].XPos) / 2,
                  (NPCObjects[i].YPos + bulletObjects[j].YPos) / 2,
                  effectBigExplosion,
                  0);
                createEffect(
                  (NPCObjects[i].XPos + bulletObjects[j].XPos) / 2,
                  (NPCObjects[i].YPos + bulletObjects[j].YPos) / 2,
                  effectBigExplosion,
                  0);
                createEffect(
                  (NPCObjects[i].XPos + bulletObjects[j].XPos) / 2,
                  (NPCObjects[i].YPos + bulletObjects[j].YPos) / 2,
                  effectBigExplosion,
                  0);
                playSoundEffect((soundEffects)NPCObjects[i].hitSound, 1);
                NPCObjects[i].isBeingHit = 16;
              }
              if ( NPCObjects[i].entityFlags & 0x8000 )
                NPCObjects[i].damage_view -= bulletObjects[j].damage;
            }
            else
            {
              NPCObjects[i].life = 0;
              if ( NPCObjects[i].entityFlags & 0x8000 )
                NPCObjects[i].damage_view -= bulletObjects[j].damage;
              if ( quote.flags & 0x80 && NPCObjects[i].entityFlags & 0x200 )
                startTSCEvent(NPCObjects[i].entityEventNum);
              else
                NPCObjects[i].isAlive |= 8u;
            }
          }
          else if ( bulletObjects[j].bulletID != 13
                 && bulletObjects[j].bulletID != 14
                 && bulletObjects[j].bulletID != 15
                 && bulletObjects[j].bulletID != 28
                 && bulletObjects[j].bulletID != 29
                 && bulletObjects[j].bulletID != 30
                 && !(bulletObjects[j].flags & 0x10) )
          {
            createEffect(
              (NPCObjects[i].XPos + bulletObjects[j].XPos) / 2,
              (NPCObjects[i].YPos + bulletObjects[j].YPos) / 2,
              effectRisingDisc,
              right);
            playSoundEffect(SFXShotHitInvulnerableEntity, 1);
            bulletObjects[j].numberImpacts = 0;
            continue;
          }
          --bulletObjects[j].numberImpacts;
        }
      }
    }
    if ( NPCObjects[i].isAlive & 8 )
      NPC_Death_Maybe(&NPCObjects[i], 1);
LABEL_2:
    result = i + 1;
  }
  return result;
}

//----- (00472400) --------------------------------------------------------
int __cdecl loadNPCTable(char *path)
{
  int result; // eax
  unsigned int size; // [esp+0h] [ebp-10h]
  FILE *stream; // [esp+4h] [ebp-Ch]
  signed int num; // [esp+8h] [ebp-8h]
  signed int i; // [esp+Ch] [ebp-4h]
  signed int j; // [esp+Ch] [ebp-4h]
  signed int k; // [esp+Ch] [ebp-4h]
  signed int l; // [esp+Ch] [ebp-4h]
  signed int m; // [esp+Ch] [ebp-4h]
  signed int n; // [esp+Ch] [ebp-4h]
  signed int ii; // [esp+Ch] [ebp-4h]
  signed int jj; // [esp+Ch] [ebp-4h]
  signed int kk; // [esp+Ch] [ebp-4h]
  signed int ll; // [esp+Ch] [ebp-4h]

  size = getFileSize(path);
  if ( size == -1 )
    return 0;
  num = size / 0x18;
  NPCTable = (NPCInfo *)malloc(24 * (size / 0x18));
  if ( !NPCTable )
    return 0;
  stream = fopen(path, "rb");
  if ( stream )
  {
    for ( i = 0; i < num; ++i )
      fread(&NPCTable[i], 2u, 1u, stream);
    for ( j = 0; j < num; ++j )
      fread(&NPCTable[j].life, 2u, 1u, stream);
    for ( k = 0; k < num; ++k )
      fread(&NPCTable[k].surf, 1u, 1u, stream);
    for ( l = 0; l < num; ++l )
      fread(&NPCTable[l].soundOnDeath, 1u, 1u, stream);
    for ( m = 0; m < num; ++m )
      fread(&NPCTable[m].soundOnHit, 1u, 1u, stream);
    for ( n = 0; n < num; ++n )
      fread(&NPCTable[n].size, 1u, 1u, stream);
    for ( ii = 0; ii < num; ++ii )
      fread(&NPCTable[ii].exp, 4u, 1u, stream);
    for ( jj = 0; jj < num; ++jj )
      fread(&NPCTable[jj].damage, 4u, 1u, stream);
    for ( kk = 0; kk < num; ++kk )
      fread(&NPCTable[kk].hit, 4u, 1u, stream);
    for ( ll = 0; ll < num; ++ll )
      fread(&NPCTable[ll].view, 4u, 1u, stream);
    fclose(stream);
    result = 1;
  }
  else
  {
    free(NPCTable);
    NPCTable = 0;
    result = 0;
  }
  return result;
}

//----- (00472710) --------------------------------------------------------
void deleteNPCTable()
{
  if ( NPCTable )
  {
    free(NPCTable);
    NPCTable = 0;
  }
}

//----- (00472740) --------------------------------------------------------
void __cdecl initRoomBoss(int bossNumber)
{
  memset(bossObjects, 0, 0xD70u);
  bossObjects[0].isAlive = -128;
  bossObjects[0].entityType = bossNumber;
}

//----- (00472770) --------------------------------------------------------
void __cdecl drawBoss(signed int Camera_X, signed int Camera_Y)
{
  int side; // [esp+0h] [ebp-Ch]
  signed int i; // [esp+4h] [ebp-8h]
  char a; // [esp+Bh] [ebp-1h]

  for ( i = 19; i >= 0; --i )
  {
    if ( bossObjects[i].isAlive & 0x80 )
    {
      if ( bossObjects[i].isBeingHit )
      {
        a = 2 * (bossObjects[i].isBeingHit / 2 % 2) - 1;
      }
      else
      {
        a = 0;
        if ( bossObjects[i].entityFlags & 0x8000 && bossObjects[i].damage_view )
        {
          setValueView((__int32)&bossObjects[i].XPos, (__int32)&bossObjects[i].YPos, bossObjects[i].damage_view);
          bossObjects[i].damage_view = 0;
        }
      }
      if ( bossObjects[i].direction )
        side = bossObjects[i].view.back;
      else
        side = bossObjects[i].view.front;
      drawBitmapWithTransparency(
        &gameRect,
        a + (bossObjects[i].XPos - side) / 512 - Camera_X / 512,
        (bossObjects[i].YPos - bossObjects[i].view.top) / 512 - Camera_Y / 512,
        &bossObjects[i].rect,
        22);
    }
  }
}

//----- (00472940) --------------------------------------------------------
void __cdecl setBossScriptState(int newState)
{
  bossObjects[0].currentState = newState;
}

//----- (00472950) --------------------------------------------------------
void __cdecl doCollisionCheckBossesBullets()
{
  int Boss_Explosion_Size; // [esp+0h] [ebp-14h]
  signed int Bullet; // [esp+4h] [ebp-10h]
  signed int Boss; // [esp+8h] [ebp-Ch]
  signed int bHit; // [esp+Ch] [ebp-8h]
  int Boss_; // [esp+10h] [ebp-4h]

  for ( Boss = 0; Boss < 20; ++Boss )
  {
    if ( bossObjects[Boss].isAlive & 0x80 )
    {
      for ( Bullet = 0; Bullet < 64; ++Bullet )
      {
        if ( bulletObjects[Bullet].isAlive & 0x80 && bulletObjects[Bullet].damage != -1 )
        {
          bHit = 0;
          if ( bossObjects[Boss].entityFlags & 0x20
            && bossObjects[Boss].XPos - bossObjects[Boss].hitbox.back < bulletObjects[Bullet].sizeWidth
                                                                      + bulletObjects[Bullet].XPos
            && bossObjects[Boss].hitbox.back + bossObjects[Boss].XPos > bulletObjects[Bullet].XPos
                                                                      - bulletObjects[Bullet].sizeWidth
            && bossObjects[Boss].YPos - bossObjects[Boss].hitbox.top < bulletObjects[Bullet].sizeHeight
                                                                     + bulletObjects[Bullet].YPos
            && bossObjects[Boss].hitbox.bottom + bossObjects[Boss].YPos > bulletObjects[Bullet].YPos
                                                                        - bulletObjects[Bullet].sizeHeight )
          {
            bHit = 1;
          }
          else if ( bossObjects[Boss].entityFlags & 4
                 && bossObjects[Boss].XPos - bossObjects[Boss].hitbox.back < bulletObjects[Bullet].collisionX
                                                                           + bulletObjects[Bullet].XPos
                 && bossObjects[Boss].hitbox.back + bossObjects[Boss].XPos > bulletObjects[Bullet].XPos
                                                                           - bulletObjects[Bullet].collisionX
                 && bossObjects[Boss].YPos - bossObjects[Boss].hitbox.top < bulletObjects[Bullet].collisionY
                                                                          + bulletObjects[Bullet].YPos
                 && bossObjects[Boss].hitbox.bottom + bossObjects[Boss].YPos > bulletObjects[Bullet].YPos
                                                                             - bulletObjects[Bullet].collisionY )
          {
            bHit = 1;
          }
          if ( bHit )
          {
            if ( bossObjects[Boss].entityFlags & 0x20 )
            {
              if ( bossObjects[Boss].isAlive & 0x10 )
                Boss_ = 0;
              else
                Boss_ = Boss;
              bossObjects[Boss_].life -= bulletObjects[Bullet].damage;
              if ( bossObjects[Boss_].life >= 1 )
              {
                if ( (signed int)bossObjects[Boss].isBeingHit < 14 )
                {
                  createEffect(bulletObjects[Bullet].XPos, bulletObjects[Bullet].YPos, effectBigExplosion, 0);
                  createEffect(bulletObjects[Bullet].XPos, bulletObjects[Bullet].YPos, effectBigExplosion, 0);
                  createEffect(bulletObjects[Bullet].XPos, bulletObjects[Bullet].YPos, effectBigExplosion, 0);
                  playSoundEffect((soundEffects)bossObjects[Boss_].hitSound, 1);
                }
                bossObjects[Boss].isBeingHit = 8;
                bossObjects[Boss_].isBeingHit = 8;
                bossObjects[Boss_].damage_view -= bulletObjects[Bullet].damage;
              }
              else
              {
                bossObjects[Boss_].life = Boss_;
                if ( quote.flags & 0x80 && bossObjects[Boss_].entityFlags & 0x200 )
                {
                  startTSCEvent(bossObjects[Boss_].entityEventNum);
                }
                else
                {
                  playSoundEffect((soundEffects)bossObjects[Boss_].deathSound, 1);
                  Boss_Explosion_Size = bossObjects[Boss_].explosionSize;
                  switch ( Boss_Explosion_Size )
                  {
                    case 1:
                      createDustClouds(
                        bossObjects[Boss_].XPos,
                        bossObjects[Boss_].YPos,
                        bossObjects[Boss_].view.back,
                        4);
                      break;
                    case 2:
                      createDustClouds(
                        bossObjects[Boss_].XPos,
                        bossObjects[Boss_].YPos,
                        bossObjects[Boss_].view.back,
                        8);
                      break;
                    case 3:
                      createDustClouds(
                        bossObjects[Boss_].XPos,
                        bossObjects[Boss_].YPos,
                        bossObjects[Boss_].view.back,
                        16);
                      break;
                  }
                  bossObjects[Boss_].isAlive = 0;
                }
              }
              if ( --bulletObjects[Bullet].numberImpacts < 1 )
                bulletObjects[Bullet].isAlive = 0;
            }
            else if ( bulletObjects[Bullet].bulletID != 13
                   && bulletObjects[Bullet].bulletID != 14
                   && bulletObjects[Bullet].bulletID != 15
                   && bulletObjects[Bullet].bulletID != 28
                   && bulletObjects[Bullet].bulletID != 29
                   && bulletObjects[Bullet].bulletID != 30 )
            {
              if ( !(bulletObjects[Bullet].flags & 0x10) )
              {
                createEffect(bulletObjects[Bullet].XPos, bulletObjects[Bullet].YPos, effectRisingDisc, right);
                playSoundEffect(SFXShotHitInvulnerableEntity, 1);
                bulletObjects[Bullet].isAlive = 0;
              }
            }
            else
            {
              --bulletObjects[Bullet].numberImpacts;
            }
          }
        }
      }
    }
  }
}

//----- (00473000) --------------------------------------------------------
void __cdecl updateBoss()
{
  signed int i; // [esp+4h] [ebp-4h]

  if ( bossObjects[0].isAlive & 0x80 )
  {
    ((void (__cdecl *)())Boss_Function_Table[bossObjects[0].entityType])();
    for ( i = 0; i < 20; ++i )
    {
      if ( bossObjects[i].isBeingHit )
        --bossObjects[i].isBeingHit;
    }
  }
}

//----- (00473080) --------------------------------------------------------
void __cdecl doCollisionCheckBossesMap()
{
  unsigned __int8 v0; // al
  signed int judg; // [esp+4h] [ebp-ACh]
  int Off_X[16]; // [esp+8h] [ebp-A8h]
  int j; // [esp+4Ch] [ebp-64h]
  char Attributes[16]; // [esp+50h] [ebp-60h]
  int i; // [esp+64h] [ebp-4Ch]
  int Off_Y[16]; // [esp+68h] [ebp-48h]
  int X_Pos_Blocks; // [esp+A8h] [ebp-8h]
  int Y_Pos_Blocks; // [esp+ACh] [ebp-4h]

  Off_X[0] = 0;
  Off_X[1] = 1;
  Off_X[2] = 0;
  Off_X[3] = 1;
  Off_X[4] = 2;
  Off_X[5] = 2;
  Off_X[6] = 2;
  Off_X[7] = 0;
  Off_X[8] = 1;
  Off_X[9] = -1;
  Off_X[10] = -1;
  Off_X[11] = -1;
  Off_X[12] = -1;
  Off_X[13] = 0;
  Off_X[14] = 1;
  Off_X[15] = 2;
  Off_Y[0] = 0;
  Off_Y[1] = 0;
  Off_Y[2] = 1;
  Off_Y[3] = 1;
  Off_Y[4] = 0;
  Off_Y[5] = 1;
  Off_Y[6] = 2;
  Off_Y[7] = 2;
  Off_Y[8] = 2;
  Off_Y[9] = -1;
  Off_Y[10] = 0;
  Off_Y[11] = 1;
  Off_Y[12] = 2;
  Off_Y[13] = -1;
  Off_Y[14] = -1;
  Off_Y[15] = -1;
  for ( i = 0; i < 20; ++i )
  {
    if ( bossObjects[i].isAlive & 0x80 && !(bossObjects[i].entityFlags & 8) )
    {
      if ( bossObjects[i].explosionSize < 3 )
        judg = 4;
      else
        judg = 16;
      X_Pos_Blocks = bossObjects[i].XPos / 16 / 512;
      Y_Pos_Blocks = bossObjects[i].YPos / 16 / 512;
      bossObjects[i].collisionFlags = 0;
      for ( j = 0; j < judg; ++j )
      {
        v0 = getTileAttributes(Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
        Attributes[j] = v0;
        switch ( Attributes[j] )
        {
          case 2:
          case 96:
          case 97:
          case 100:
            NPC_Collision_Block(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            NPC_Collision_Water(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 5:
          case 65:
          case 67:
            goto case_67;
          case 68:
            if ( !(bossObjects[i].entityFlags & 2) )
case_67:
              NPC_Collision_Block(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 80:
            NPC_Collision_Triangle_A(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 81:
            NPC_Collision_Triangle_B(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 82:
            NPC_Collision_Triangle_C(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 83:
            NPC_Collision_Triangle_D(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 84:
            NPC_Collision_Triangle_E(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 85:
            NPC_Collision_Triangle_F(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 86:
            NPC_Collision_Triangle_G(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 87:
            NPC_Collision_Triangle_H(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 112:
            NPC_Collision_Triangle_A(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            NPC_Collision_Water(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 113:
            NPC_Collision_Triangle_B(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            NPC_Collision_Water(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 114:
            NPC_Collision_Triangle_C(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            NPC_Collision_Water(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 115:
            NPC_Collision_Triangle_D(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            NPC_Collision_Water(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 116:
            NPC_Collision_Triangle_E(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            NPC_Collision_Water(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 117:
            NPC_Collision_Triangle_F(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            NPC_Collision_Water(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 118:
            NPC_Collision_Triangle_G(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            NPC_Collision_Water(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          case 119:
            NPC_Collision_Triangle_H(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            NPC_Collision_Water(&bossObjects[i], Off_X[j] + X_Pos_Blocks, Off_Y[j] + Y_Pos_Blocks);
            break;
          default:
            continue;
        }
      }
    }
  }
}
// 473080: using guessed type char Attributes[16];

//----- (004739B0) --------------------------------------------------------
void __cdecl coreSubNPCFace(NPC *npc)
{
  int *v1; // edx
  RECT *v2; // eax
  int v3; // [esp+4h] [ebp-40h]
  int v4; // [esp+8h] [ebp-3Ch]
  int v5; // [esp+Ch] [ebp-38h]
  int v6; // [esp+10h] [ebp-34h]
  int v7; // [esp+14h] [ebp-30h]
  int v8; // [esp+18h] [ebp-2Ch]
  int v9; // [esp+1Ch] [ebp-28h]
  int v10; // [esp+20h] [ebp-24h]
  int v11; // [esp+24h] [ebp-20h]
  int v12; // [esp+28h] [ebp-1Ch]
  int v13; // [esp+2Ch] [ebp-18h]
  int v14; // [esp+30h] [ebp-14h]
  int v15; // [esp+34h] [ebp-10h]
  int v16; // [esp+38h] [ebp-Ch]
  int v17; // [esp+3Ch] [ebp-8h]
  int v18; // [esp+40h] [ebp-4h]

  v3 = 0;
  v4 = 0;
  v5 = 72;
  v6 = 112;
  v7 = 0;
  v8 = 112;
  v9 = 72;
  v10 = 224;
  v11 = 160;
  v12 = 0;
  v13 = 232;
  v14 = 112;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  switch ( npc->currentState )
  {
    case 0xA:
      npc->currentState = 11;
      npc->animationNumber = 2;
      npc->entityFlags = 8;
      npc->view.front = 18432;
      npc->view.top = 28672;
      goto LABEL_3;
    case 0xB:
LABEL_3:
      npc->XPos = bossObjects[0].XPos - 18432;
      npc->YPos = bossObjects[0].YPos;
      break;
    case 0x32:
      npc->currentState = 51;
      npc->waitTimer = 112;
      goto LABEL_5;
    case 0x33:
LABEL_5:
      if ( !--npc->waitTimer )
      {
        npc->currentState = 100;
        npc->animationNumber = 3;
      }
      npc->XPos = bossObjects[0].XPos - 18432;
      npc->YPos = bossObjects[0].YPos;
      break;
    case 0x64:
      npc->animationNumber = 3;
      break;
    default:
      break;
  }
  v1 = &v3 + 4 * npc->animationNumber;
  v2 = &npc->rect;
  v2->left = *v1;
  v2->top = v1[1];
  v2->right = v1[2];
  v2->bottom = v1[3];
  if ( npc->currentState == 51 )
    npc->rect.bottom = npc->waitTimer + npc->rect.top;
}

//----- (00473BD0) --------------------------------------------------------
void __cdecl coreSubNPCTail(NPC *npc)
{
  int *v1; // edx
  RECT *v2; // eax
  int v3; // [esp+4h] [ebp-30h]
  int v4; // [esp+8h] [ebp-2Ch]
  int v5; // [esp+Ch] [ebp-28h]
  int v6; // [esp+10h] [ebp-24h]
  int v7; // [esp+14h] [ebp-20h]
  int v8; // [esp+18h] [ebp-1Ch]
  int v9; // [esp+1Ch] [ebp-18h]
  int v10; // [esp+20h] [ebp-14h]
  int v11; // [esp+24h] [ebp-10h]
  int v12; // [esp+28h] [ebp-Ch]
  int v13; // [esp+2Ch] [ebp-8h]
  int v14; // [esp+30h] [ebp-4h]

  v3 = 72;
  v4 = 0;
  v5 = 160;
  v6 = 112;
  v7 = 72;
  v8 = 112;
  v9 = 160;
  v10 = 224;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  switch ( npc->currentState )
  {
    case 0xA:
      npc->currentState = 11;
      npc->animationNumber = 0;
      npc->entityFlags = 8;
      npc->view.front = 22528;
      npc->view.top = 28672;
      goto LABEL_3;
    case 0xB:
LABEL_3:
      npc->XPos = bossObjects[0].XPos + 22528;
      npc->YPos = bossObjects[0].YPos;
      break;
    case 0x32:
      npc->currentState = 51;
      npc->waitTimer = 112;
      goto LABEL_5;
    case 0x33:
LABEL_5:
      if ( !--npc->waitTimer )
      {
        npc->currentState = 100;
        npc->animationNumber = 2;
      }
      npc->XPos = bossObjects[0].XPos + 22528;
      npc->YPos = bossObjects[0].YPos;
      break;
    case 0x64:
      npc->animationNumber = 2;
      break;
    default:
      break;
  }
  v1 = &v3 + 4 * npc->animationNumber;
  v2 = &npc->rect;
  v2->left = *v1;
  v2->top = v1[1];
  v2->right = v1[2];
  v2->bottom = v1[3];
  if ( npc->currentState == 51 )
    npc->rect.bottom = npc->waitTimer + npc->rect.top;
}

//----- (00473DE0) --------------------------------------------------------
void __cdecl coreSubNPCMini(NPC *npc)
{
  int Y_Vel; // ST24_4
  int X_Vel; // ST28_4
  int *v3; // edx
  RECT *v4; // eax
  int v5; // [esp+Ch] [ebp-34h]
  int v6; // [esp+10h] [ebp-30h]
  int v7; // [esp+14h] [ebp-2Ch]
  int v8; // [esp+18h] [ebp-28h]
  int v9; // [esp+1Ch] [ebp-24h]
  int v10; // [esp+20h] [ebp-20h]
  int v11; // [esp+24h] [ebp-1Ch]
  int v12; // [esp+28h] [ebp-18h]
  int v13; // [esp+2Ch] [ebp-14h]
  int v14; // [esp+30h] [ebp-10h]
  int v15; // [esp+34h] [ebp-Ch]
  int v16; // [esp+38h] [ebp-8h]
  unsigned __int8 v17; // [esp+3Fh] [ebp-1h]

  v5 = 256;
  v6 = 0;
  v7 = 320;
  v8 = 40;
  v9 = 256;
  v10 = 40;
  v11 = 320;
  v12 = 80;
  v13 = 256;
  v14 = 80;
  v15 = 320;
  v16 = 120;
  npc->life = 1000;
  switch ( npc->currentState )
  {
    case 0xA:
      npc->animationNumber = 2;
      npc->entityFlags &= 0xFFDFu;
      break;
    case 0x64:
      npc->currentState = 101;
      npc->animationNumber = 2;
      npc->waitTimer = 0;
      npc->curlyTargetX = bossObjects[0].XPos + (random(-128, 32) << 9);
      npc->curlyTargetY = bossObjects[0].YPos + (random(-64, 64) << 9);
      npc->entityFlags |= 0x20u;
      goto LABEL_4;
    case 0x65:
LABEL_4:
      npc->XPos += (npc->curlyTargetX - npc->XPos) / 16;
      npc->YPos += (npc->curlyTargetY - npc->YPos) / 16;
      if ( ++npc->waitTimer > 50 )
        npc->animationNumber = 0;
      break;
    case 0x78:
      npc->currentState = 121;
      npc->waitTimer = 0;
      goto LABEL_8;
    case 0x79:
LABEL_8:
      if ( ++npc->waitTimer / 2 % 2 )
        npc->animationNumber = 0;
      else
        npc->animationNumber = 1;
      if ( npc->waitTimer > 20 )
        npc->currentState = 130;
      break;
    case 0x82:
      npc->currentState = 131;
      npc->animationNumber = 2;
      npc->waitTimer = 0;
      npc->curlyTargetX = npc->XPos + (random(24, 48) << 9);
      npc->curlyTargetY = npc->YPos + (random(-4, 4) << 9);
      goto LABEL_15;
    case 0x83:
LABEL_15:
      npc->XPos += (npc->curlyTargetX - npc->XPos) / 16;
      npc->YPos += (npc->curlyTargetY - npc->YPos) / 16;
      if ( ++npc->waitTimer > 50 )
      {
        npc->currentState = 140;
        npc->animationNumber = 0;
      }
      if ( npc->waitTimer == 1 || npc->waitTimer == 3 )
      {
        v17 = getArcTan(npc->XPos - quote.XPos, npc->YPos - quote.YPos);
        v17 += random(-2, 2);
        Y_Vel = 2 * getSin(v17);
        X_Vel = 2 * getCos(v17);
        createNPC((NPCNames)178, npc->XPos, npc->YPos, X_Vel, Y_Vel, 0, 0, 256);
        playSoundEffect(SFXEnemyShootProjectile, 1);
      }
      break;
    case 0x8C:
      npc->XPos += (npc->curlyTargetX - npc->XPos) / 16;
      npc->YPos += (npc->curlyTargetY - npc->YPos) / 16;
      break;
    case 0xC8:
      npc->currentState = 201;
      npc->animationNumber = 2;
      npc->XVel = 0;
      npc->YVel = 0;
      goto LABEL_23;
    case 0xC9:
LABEL_23:
      npc->XVel += 32;
      npc->XPos += npc->XVel;
      if ( npc->XPos > (currentMap.width << 13) + 0x4000 )
        npc->isAlive = 0;
      break;
    default:
      break;
  }
  if ( npc->isBeingHit )
    npc->curlyTargetX += 1024;
  v3 = &v5 + 4 * npc->animationNumber;
  v4 = &npc->rect;
  v4->left = *v3;
  v4->top = v3[1];
  v4->right = v3[2];
  v4->bottom = v3[3];
}

//----- (00474340) --------------------------------------------------------
void __cdecl coreSubNPCHit(NPC *npc)
{
  switch ( npc->count1 )
  {
    case 0:
      npc->XPos = bossObjects[0].XPos;
      npc->YPos = bossObjects[0].YPos - 0x4000;
      break;
    case 1:
      npc->XPos = bossObjects[0].XPos + 14336;
      npc->YPos = bossObjects[0].YPos;
      break;
    case 2:
      npc->XPos = bossObjects[0].XPos + 2048;
      npc->YPos = bossObjects[0].YPos + 0x4000;
      break;
    case 3:
      npc->XPos = bossObjects[0].XPos - 14336;
      npc->YPos = bossObjects[0].YPos + 2048;
      break;
    default:
      return;
  }
}

//----- (00474400) --------------------------------------------------------
void boss4_Core()
{
  int v0; // ST08_4
  int v1; // eax
  int v2; // ST08_4
  int v3; // eax
  unsigned __int8 v4; // ST47_1
  int Y_Vel; // ST38_4
  int X_Vel; // ST3C_4
  int v7; // ST10_4
  int v8; // ST0C_4
  int v9; // ST08_4
  int v10; // eax
  int v11; // ST10_4
  int v12; // ST0C_4
  int v13; // ST08_4
  int v14; // eax
  int v15; // edx
  int v16; // eax
  int v17; // ecx
  int v18; // ecx
  int v19; // ST10_4
  int v20; // ST0C_4
  int v21; // ST08_4
  int v22; // eax
  int v23; // [esp+4h] [ebp-1Ch]
  signed int v24; // [esp+8h] [ebp-18h]
  signed int i; // [esp+18h] [ebp-8h]
  signed int ia; // [esp+18h] [ebp-8h]
  signed int ib; // [esp+18h] [ebp-8h]

  v24 = 0;
  v23 = bossObjects[0].currentState;
  if ( v23 <= 220 )
  {
    if ( v23 != 220 )
    {
      switch ( v23 )
      {
        case 0:
          bossObjects[0].currentState = 10;
          bossObjects[0].EXPAmount = 1;
          bossObjects[0].isAlive = -128;
          bossObjects[0].entityFlags = -32756;
          bossObjects[0].life = 650;
          bossObjects[0].hitSound = 114;
          bossObjects[0].XPos = 630784;
          bossObjects[0].YPos = 114688;
          bossObjects[0].XVel = 0;
          bossObjects[0].YVel = 0;
          bossObjects[0].entityEventNum = 1000;
          bossObjects[0].entityFlags |= 0x200u;
          bossObjects[4].isAlive = -128;
          bossObjects[4].currentState = 10;
          bossObjects[5].isAlive = -128;
          bossObjects[5].currentState = 10;
          bossObjects[8].isAlive = -128;
          bossObjects[8].entityFlags = 12;
          bossObjects[8].view.front = 0;
          bossObjects[8].view.top = 0;
          bossObjects[8].hitbox.back = 20480;
          bossObjects[8].hitbox.top = 0x2000;
          bossObjects[8].hitbox.bottom = 0x2000;
          bossObjects[8].count1 = 0;
          qmemcpy(&bossObjects[9], &bossObjects[8], sizeof(NPC));
          bossObjects[9].hitbox.back = 18432;
          bossObjects[9].hitbox.top = 12288;
          bossObjects[9].hitbox.bottom = 12288;
          bossObjects[9].count1 = 1;
          qmemcpy(&bossObjects[10], &bossObjects[8], sizeof(NPC));
          bossObjects[10].hitbox.back = 22528;
          bossObjects[10].hitbox.top = 4096;
          bossObjects[10].hitbox.bottom = 4096;
          bossObjects[10].count1 = 2;
          qmemcpy(&bossObjects[11], &bossObjects[8], sizeof(NPC));
          bossObjects[11].isAlive |= 0x10u;
          bossObjects[11].hitbox.back = 10240;
          bossObjects[11].hitbox.top = 10240;
          bossObjects[11].hitbox.bottom = 10240;
          bossObjects[11].count1 = 3;
          bossObjects[1].isAlive = -128;
          bossObjects[1].currentState = 10;
          bossObjects[1].entityFlags = 44;
          bossObjects[1].life = 1000;
          bossObjects[1].hitSound = 54;
          bossObjects[1].hitbox.back = 12288;
          bossObjects[1].hitbox.top = 0x2000;
          bossObjects[1].hitbox.bottom = 0x2000;
          bossObjects[1].view.front = 0x4000;
          bossObjects[1].view.top = 10240;
          bossObjects[1].XPos = bossObjects[0].XPos - 4096;
          bossObjects[1].YPos = bossObjects[0].YPos - 0x8000;
          qmemcpy(&bossObjects[2], &bossObjects[1], sizeof(NPC));
          bossObjects[2].XPos = bossObjects[0].XPos + 0x2000;
          bossObjects[2].YPos = bossObjects[0].YPos;
          qmemcpy(&bossObjects[3], &bossObjects[1], sizeof(NPC));
          bossObjects[3].XPos = bossObjects[0].XPos - 4096;
          bossObjects[3].YPos = bossObjects[0].YPos + 0x8000;
          qmemcpy(&bossObjects[6], &bossObjects[1], sizeof(NPC));
          bossObjects[6].XPos = bossObjects[0].XPos - 24576;
          bossObjects[6].YPos = bossObjects[0].YPos - 0x4000;
          qmemcpy(&bossObjects[7], &bossObjects[1], sizeof(NPC));
          bossObjects[7].XPos = bossObjects[0].XPos - 24576;
          bossObjects[7].YPos = bossObjects[0].YPos + 0x4000;
          goto LABEL_73;
        case 200:
          bossObjects[0].currentState = 201;
          bossObjects[0].waitTimer = 0;
          bossObjects[11].entityFlags &= 0xFFDFu;
          curlyShootY = 0;
          cutNoise();
          goto LABEL_14;
        case 201:
LABEL_14:
          bossObjects[0].curlyTargetX = quote.XPos;
          bossObjects[0].curlyTargetY = quote.YPos;
          if ( ++bossObjects[0].waitTimer > 400 )
          {
            ++bossObjects[0].count1;
            playSoundEffect(SFXCoreThrust, 1);
            if ( bossObjects[0].count1 <= 3 )
            {
              bossObjects[0].currentState = 210;
            }
            else
            {
              bossObjects[0].count1 = 0;
              bossObjects[0].currentState = 220;
            }
            bossObjects[4].animationNumber = 0;
            bossObjects[5].animationNumber = 0;
            v24 = 1;
          }
          goto LABEL_73;
        case 210:
          bossObjects[0].currentState = 211;
          bossObjects[0].waitTimer = 0;
          bossObjects[0].count2 = bossObjects[0].life;
          bossObjects[11].entityFlags |= 0x20u;
          goto LABEL_21;
        case 211:
LABEL_21:
          bossObjects[0].curlyTargetX = quote.XPos;
          bossObjects[0].curlyTargetY = quote.YPos;
          if ( bossObjects[0].isBeingHit )
          {
            ++NPCStruct_Tileset;
            if ( NPCStruct_Tileset / 2 % 2 )
            {
              bossObjects[4].animationNumber = 0;
              bossObjects[5].animationNumber = 0;
            }
            else
            {
              bossObjects[4].animationNumber = 1;
              bossObjects[5].animationNumber = 1;
            }
          }
          else
          {
            bossObjects[4].animationNumber = 0;
            bossObjects[5].animationNumber = 0;
          }
          if ( ++bossObjects[0].waitTimer % 100 == 1 )
          {
            superXPos = random(80, 100);
            curlyShootWait = bossObjects[11].XPos;
            curlyShootX = bossObjects[11].YPos;
          }
          if ( bossObjects[0].waitTimer < 200 && bossObjects[0].waitTimer % 20 == 1 )
          {
            v0 = bossObjects[0].YPos + (random(-64, 64) << 9);
            v1 = random(-48, -16);
            createNPC((NPCNames)179, bossObjects[0].XPos + (v1 << 9), v0, 0, 0, 0, 0, 256);
          }
          if ( bossObjects[0].waitTimer > 400 || bossObjects[0].life < bossObjects[0].count2 - 200 )
          {
            bossObjects[0].currentState = 200;
            bossObjects[4].animationNumber = 2;
            bossObjects[5].animationNumber = 0;
            v24 = 1;
          }
          break;
        default:
          goto LABEL_73;
      }
      goto LABEL_73;
    }
    bossObjects[0].currentState = 221;
    bossObjects[0].waitTimer = 0;
    curlyShootY = 1;
    bossObjects[11].entityFlags |= 0x20u;
    setQuake(100);
    setNoise(1, 1000);
    goto LABEL_37;
  }
  if ( v23 > 501 )
  {
    if ( v23 == 600 )
    {
      bossObjects[0].currentState = 601;
      bossObjects[4].currentState = 50;
      bossObjects[5].currentState = 50;
      bossObjects[8].entityFlags &= 0xFFFBu;
      bossObjects[9].entityFlags &= 0xFFFBu;
      bossObjects[10].entityFlags &= 0xFFFBu;
      bossObjects[11].entityFlags &= 0xFFFBu;
    }
    else if ( v23 != 601 )
    {
      goto LABEL_73;
    }
    if ( ++bossObjects[0].waitTimer / 2 % 2 )
      v18 = bossObjects[0].XPos - 2048;
    else
      v18 = bossObjects[0].XPos + 2048;
    bossObjects[0].XPos = v18;
  }
  else
  {
    if ( v23 != 501 )
    {
      if ( v23 == 221 )
      {
LABEL_37:
        ++bossObjects[0].waitTimer;
        v2 = quote.YPos + (random(-160, 160) << 9);
        v3 = random(-50, 150);
        createNPC(NPCEnemyBasil|0xC0, quote.XPos + (v3 << 10), v2, 0, 0, 0, 0, 256);
        quote.XVel -= 32;
        quote.flags |= 0x20u;
        if ( bossObjects[0].isBeingHit )
        {
          ++NPCStruct_Tileset;
          if ( NPCStruct_Tileset / 2 % 2 )
          {
            bossObjects[4].animationNumber = 0;
            bossObjects[5].animationNumber = 0;
          }
          else
          {
            bossObjects[4].animationNumber = 1;
            bossObjects[5].animationNumber = 1;
          }
        }
        else
        {
          bossObjects[4].animationNumber = 0;
          bossObjects[5].animationNumber = 0;
        }
        if ( bossObjects[0].waitTimer == 300 || bossObjects[0].waitTimer == 350 || bossObjects[0].waitTimer == 400 )
        {
          v4 = getArcTan(bossObjects[0].XPos - quote.XPos, bossObjects[0].YPos - quote.YPos);
          Y_Vel = 3 * getSin(v4);
          X_Vel = 3 * getCos(v4);
          createNPC((NPCNames)218, bossObjects[0].XPos - 20480, bossObjects[0].YPos, X_Vel, Y_Vel, 0, 0, 256);
          playSoundEffect(SFXLightning, 1);
        }
        if ( bossObjects[0].waitTimer > 400 )
        {
          bossObjects[0].currentState = 200;
          bossObjects[4].animationNumber = 2;
          bossObjects[5].animationNumber = 0;
          v24 = 1;
        }
        goto LABEL_73;
      }
      if ( v23 != 500 )
        goto LABEL_73;
      cutNoise();
      bossObjects[0].currentState = 501;
      bossObjects[0].waitTimer = 0;
      bossObjects[0].XVel = 0;
      bossObjects[0].YVel = 0;
      bossObjects[4].animationNumber = 2;
      bossObjects[5].animationNumber = 0;
      bossObjects[1].currentState = 200;
      bossObjects[2].currentState = 200;
      bossObjects[3].currentState = 200;
      bossObjects[6].currentState = 200;
      bossObjects[7].currentState = 200;
      setQuake(20);
      for ( i = 0; i < 32; ++i )
      {
        v7 = random(-128, 128) << 9;
        v8 = random(-128, 128) << 9;
        v9 = bossObjects[0].YPos + (random(-64, 64) << 9);
        v10 = random(-128, 128);
        createNPC(NPCSmoke, bossObjects[0].XPos + (v10 << 9), v9, v8, v7, 0, 0, 256);
      }
      for ( ia = 0; ia < 12; ++ia )
        bossObjects[ia].entityFlags &= 0xFFDBu;
    }
    if ( ++bossObjects[0].waitTimer % 16 )
    {
      v11 = random(-128, 128) << 9;
      v12 = random(-128, 128) << 9;
      v13 = bossObjects[0].YPos + (random(-32, 32) << 9);
      v14 = random(-64, 64);
      createNPC(NPCSmoke, bossObjects[0].XPos + (v14 << 9), v13, v12, v11, 0, 0, 256);
    }
    if ( bossObjects[0].waitTimer / 2 % 2 )
      v15 = bossObjects[0].XPos - 512;
    else
      v15 = bossObjects[0].XPos + 512;
    bossObjects[0].XPos = v15;
    if ( bossObjects[0].XPos >= 516096 )
      v16 = bossObjects[0].XPos - 128;
    else
      v16 = bossObjects[0].XPos + 128;
    bossObjects[0].XPos = v16;
    if ( bossObjects[0].YPos >= 90112 )
      v17 = bossObjects[0].YPos - 128;
    else
      v17 = bossObjects[0].YPos + 128;
    bossObjects[0].YPos = v17;
  }
LABEL_73:
  if ( v24 )
  {
    setQuake(20);
    bossObjects[1].currentState = 100;
    bossObjects[2].currentState = 100;
    bossObjects[3].currentState = 100;
    bossObjects[6].currentState = 100;
    bossObjects[7].currentState = 100;
    playSoundEffect(SFXLargeObjectHitGround, 1);
    for ( ib = 0; ib < 8; ++ib )
    {
      v19 = random(-256, 256);
      v20 = random(-512, 512);
      v21 = bossObjects[4].YPos;
      v22 = random(-32, 16);
      createNPC(NPCSmoke, bossObjects[4].XPos + (v22 << 9), v21, v20, v19, 0, 0, 256);
    }
  }
  if ( bossObjects[0].currentState >= 200 && bossObjects[0].currentState < 300 )
  {
    switch ( bossObjects[0].waitTimer )
    {
      case 0x50:
        bossObjects[1].currentState = 120;
        break;
      case 0x6E:
        bossObjects[2].currentState = 120;
        break;
      case 0x8C:
        bossObjects[3].currentState = 120;
        break;
      case 0xAA:
        bossObjects[6].currentState = 120;
        break;
      case 0xC8:
        bossObjects[7].currentState = 120;
        break;
      default:
        break;
    }
    if ( bossObjects[0].XPos < bossObjects[0].curlyTargetX + 81920 )
      bossObjects[0].XVel += 4;
    if ( bossObjects[0].XPos > bossObjects[0].curlyTargetX + 81920 )
      bossObjects[0].XVel -= 4;
    if ( bossObjects[0].YPos < bossObjects[0].curlyTargetY )
      bossObjects[0].YVel += 4;
    if ( bossObjects[0].YPos > bossObjects[0].curlyTargetY )
      bossObjects[0].YVel -= 4;
  }
  if ( bossObjects[0].XVel > 128 )
    bossObjects[0].XVel = 128;
  if ( bossObjects[0].XVel < -128 )
    bossObjects[0].XVel = -128;
  if ( bossObjects[0].YVel > 128 )
    bossObjects[0].YVel = 128;
  if ( bossObjects[0].YVel < -128 )
    bossObjects[0].YVel = -128;
  bossObjects[0].XPos += bossObjects[0].XVel;
  bossObjects[0].YPos += bossObjects[0].YVel;
  coreSubNPCFace(&bossObjects[4]);
  coreSubNPCTail(&bossObjects[5]);
  coreSubNPCMini(&bossObjects[1]);
  coreSubNPCMini(&bossObjects[2]);
  coreSubNPCMini(&bossObjects[3]);
  coreSubNPCMini(&bossObjects[6]);
  coreSubNPCMini(&bossObjects[7]);
  coreSubNPCHit(&bossObjects[8]);
  coreSubNPCHit(&bossObjects[9]);
  coreSubNPCHit(&bossObjects[10]);
  coreSubNPCHit(&bossObjects[11]);
}
// 4BBA20: using guessed type int curlyShootWait;
// 4BBA24: using guessed type int curlyShootX;
// 4BBA28: using guessed type int curlyShootY;
// 4BBA2C: using guessed type int superXPos;

//----- (004753D0) --------------------------------------------------------
void boss7_UndeadCore()
{
  int v0; // ST10_4
  int v1; // ST0C_4
  int v2; // ST08_4
  int v3; // eax
  int v4; // ST10_4
  int v5; // ST0C_4
  int v6; // ST08_4
  int v7; // eax
  int v8; // ST14_4
  int v9; // eax
  int v10; // ST10_4
  int v11; // ST0C_4
  int v12; // ST08_4
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // [esp+8h] [ebp-18h]
  signed int v18; // [esp+Ch] [ebp-14h]
  signed int i; // [esp+14h] [ebp-Ch]
  signed int ia; // [esp+14h] [ebp-Ch]
  signed int ib; // [esp+14h] [ebp-Ch]
  signed int ic; // [esp+14h] [ebp-Ch]
  int v23; // [esp+18h] [ebp-8h]
  int Y_Pos; // [esp+1Ch] [ebp-4h]

  v18 = 0;
  v17 = bossObjects[0].currentState;
  if ( v17 <= 220 )
  {
    if ( v17 != 220 )
    {
      switch ( v17 )
      {
        case 1:
          bossObjects[0].currentState = 10;
          bossObjects[0].EXPAmount = 1;
          bossObjects[0].isAlive = -128;
          bossObjects[0].entityFlags = -32756;
          bossObjects[0].life = 700;
          bossObjects[0].hitSound = 114;
          bossObjects[0].XPos = 303104;
          bossObjects[0].YPos = 61440;
          bossObjects[0].XVel = 0;
          bossObjects[0].YVel = 0;
          bossObjects[0].entityEventNum = 1000;
          bossObjects[0].entityFlags |= 0x200u;
          bossObjects[3].isAlive = -128;
          bossObjects[3].currentState = 0;
          bossObjects[4].isAlive = -128;
          bossObjects[4].currentState = 10;
          bossObjects[5].isAlive = -128;
          bossObjects[5].currentState = 10;
          bossObjects[8].isAlive = -128;
          bossObjects[8].entityFlags = 8;
          bossObjects[8].view.front = 0;
          bossObjects[8].view.top = 0;
          bossObjects[8].hitbox.back = 20480;
          bossObjects[8].hitbox.top = 0x2000;
          bossObjects[8].hitbox.bottom = 0x2000;
          bossObjects[8].count1 = 0;
          qmemcpy(&bossObjects[9], &bossObjects[8], sizeof(NPC));
          bossObjects[9].hitbox.back = 18432;
          bossObjects[9].hitbox.top = 12288;
          bossObjects[9].hitbox.bottom = 12288;
          bossObjects[9].count1 = 1;
          qmemcpy(&bossObjects[10], &bossObjects[8], sizeof(NPC));
          bossObjects[10].hitbox.back = 22528;
          bossObjects[10].hitbox.top = 4096;
          bossObjects[10].hitbox.bottom = 4096;
          bossObjects[10].count1 = 2;
          qmemcpy(&bossObjects[11], &bossObjects[8], sizeof(NPC));
          bossObjects[11].isAlive |= 0x10u;
          bossObjects[11].hitbox.back = 10240;
          bossObjects[11].hitbox.top = 10240;
          bossObjects[11].hitbox.bottom = 10240;
          bossObjects[11].count1 = 3;
          bossObjects[1].isAlive = -128;
          bossObjects[1].currentState = 0;
          bossObjects[1].entityFlags = 40;
          bossObjects[1].life = 1000;
          bossObjects[1].hitSound = 54;
          bossObjects[1].hitbox.back = 12288;
          bossObjects[1].hitbox.top = 0x2000;
          bossObjects[1].hitbox.bottom = 0x2000;
          bossObjects[1].view.front = 0x4000;
          bossObjects[1].view.top = 10240;
          bossObjects[1].parentNPC = bossObjects;
          qmemcpy(&bossObjects[2], &bossObjects[1], sizeof(NPC));
          bossObjects[2].count2 = 128;
          qmemcpy(&bossObjects[6], &bossObjects[1], sizeof(NPC));
          bossObjects[6].count1 = 1;
          qmemcpy(&bossObjects[7], &bossObjects[1], sizeof(NPC));
          bossObjects[7].count1 = 1;
          bossObjects[7].count2 = 128;
          NPCStructExp = bossObjects[0].life;
          goto LABEL_94;
        case 15:
          bossObjects[0].currentState = 16;
          v18 = 1;
          bossObjects[0].direction = 0;
          bossObjects[3].currentState = 10;
          bossObjects[4].animationNumber = 0;
          goto LABEL_94;
        case 20:
          bossObjects[0].currentState = 210;
          v18 = 1;
          bossObjects[0].direction = 0;
          bossObjects[1].currentState = 5;
          bossObjects[2].currentState = 5;
          bossObjects[6].currentState = 5;
          bossObjects[7].currentState = 5;
          goto LABEL_94;
        case 200:
          bossObjects[0].currentState = 201;
          bossObjects[0].waitTimer = 0;
          bossObjects[3].currentState = 0;
          bossObjects[4].animationNumber = 2;
          bossObjects[5].animationNumber = 0;
          bossObjects[8].entityFlags &= 0xFFFBu;
          bossObjects[9].entityFlags &= 0xFFFBu;
          bossObjects[10].entityFlags &= 0xFFFBu;
          bossObjects[11].entityFlags &= 0xFFDFu;
          curlyShootY = 0;
          cutNoise();
          v18 = 1;
          goto LABEL_18;
        case 201:
LABEL_18:
          ++bossObjects[0].waitTimer;
          if ( (bossObjects[0].direction == 2 || bossObjects[0].animationNumber > 0 || bossObjects[0].life < 200)
            && bossObjects[0].waitTimer > 200 )
          {
            ++bossObjects[0].count1;
            playSoundEffect(SFXCoreThrust, 1);
            if ( bossObjects[0].life >= 200 )
            {
              if ( bossObjects[0].count1 <= 2 )
                bossObjects[0].currentState = 210;
              else
                bossObjects[0].currentState = 220;
            }
            else
            {
              bossObjects[0].currentState = 230;
            }
          }
          goto LABEL_94;
        case 210:
          bossObjects[0].currentState = 211;
          bossObjects[0].waitTimer = 0;
          bossObjects[3].currentState = 10;
          bossObjects[8].entityFlags |= 4u;
          bossObjects[9].entityFlags |= 4u;
          bossObjects[10].entityFlags |= 4u;
          bossObjects[11].entityFlags |= 0x20u;
          NPCStructExp = bossObjects[0].life;
          v18 = 1;
          goto LABEL_29;
        case 211:
LABEL_29:
          ++npcStructDeathSound;
          if ( bossObjects[0].isBeingHit && npcStructDeathSound / 2 % 2 )
          {
            bossObjects[4].animationNumber = 1;
            bossObjects[5].animationNumber = 1;
          }
          else
          {
            bossObjects[4].animationNumber = 0;
            bossObjects[5].animationNumber = 0;
          }
          if ( ++bossObjects[0].waitTimer % 100 == 1 )
          {
            superXPos = random(80, 100);
            curlyShootWait = bossObjects[11].XPos;
            curlyShootX = bossObjects[11].YPos;
          }
          if ( bossObjects[0].waitTimer < 300 )
          {
            if ( bossObjects[0].waitTimer % 120 == 1 )
              createNPC((NPCNames)288, bossObjects[0].XPos - 0x4000, bossObjects[0].YPos - 0x2000, 0, 0, up, 0, 32);
            if ( bossObjects[0].waitTimer % 120 == 61 )
              createNPC((NPCNames)288, bossObjects[0].XPos - 0x4000, bossObjects[0].YPos + 0x2000, 0, 0, down, 0, 32);
          }
          if ( bossObjects[0].life < NPCStructExp - 50 || bossObjects[0].waitTimer > 400 )
            bossObjects[0].currentState = 200;
          break;
        default:
          goto LABEL_94;
      }
      goto LABEL_94;
    }
    bossObjects[0].currentState = 221;
    bossObjects[0].waitTimer = 0;
    bossObjects[0].count1 = 0;
    curlyShootY = 1;
    bossObjects[3].currentState = 20;
    bossObjects[8].entityFlags |= 4u;
    bossObjects[9].entityFlags |= 4u;
    bossObjects[10].entityFlags |= 4u;
    bossObjects[11].entityFlags |= 0x20u;
    setQuake(100);
    NPCStructExp = bossObjects[0].life;
    v18 = 1;
    goto LABEL_45;
  }
  if ( v17 > 500 )
  {
    if ( v17 != 501 )
    {
      if ( v17 == 1000 )
      {
        setQuake(100);
        if ( !(++bossObjects[0].waitTimer % 8) )
          playSoundEffect(SFXMissileImpact, 1);
        v8 = bossObjects[0].YPos + (random(-64, 64) << 9);
        v9 = random(-72, 72);
        createDustClouds(bossObjects[0].XPos + (v9 << 9), v8, 1, 1);
        if ( bossObjects[0].waitTimer > 100 )
        {
          bossObjects[0].waitTimer = 0;
          bossObjects[0].currentState = 1001;
          startFlash(bossObjects[0].XPos, bossObjects[0].YPos, 1);
          playSoundEffect(SFXlargeExplosion, 1);
        }
      }
      else if ( v17 == 1001 )
      {
        setQuake(40);
        if ( ++bossObjects[0].waitTimer > 50 )
        {
          for ( ib = 0; ib < 20; ++ib )
            bossObjects[ib].isAlive = 0;
          killNPC(158, 1);
          killNPC(301, 1);
        }
      }
      goto LABEL_94;
    }
LABEL_79:
    if ( ++bossObjects[0].waitTimer % 16 )
    {
      v4 = random(-128, 128) << 9;
      v5 = random(-128, 128) << 9;
      v6 = bossObjects[0].YPos + (random(-32, 32) << 9);
      v7 = random(-64, 64);
      createNPC(NPCSmoke, bossObjects[0].XPos + (v7 << 9), v6, v5, v4, 0, 0, 256);
    }
    bossObjects[0].XPos += 64;
    bossObjects[0].YPos += 128;
    if ( bossObjects[0].waitTimer > 200 )
    {
      bossObjects[0].waitTimer = 0;
      bossObjects[0].currentState = 1000;
    }
    goto LABEL_94;
  }
  switch ( v17 )
  {
    case 500:
      cutNoise();
      bossObjects[0].currentState = 501;
      bossObjects[0].waitTimer = 0;
      bossObjects[0].XVel = 0;
      bossObjects[0].YVel = 0;
      bossObjects[3].currentState = 0;
      bossObjects[4].animationNumber = 2;
      bossObjects[5].animationNumber = 0;
      bossObjects[1].currentState = 5;
      bossObjects[2].currentState = 5;
      bossObjects[6].currentState = 5;
      bossObjects[7].currentState = 5;
      setQuake(20);
      for ( i = 0; i < 100; ++i )
      {
        v0 = random(-128, 128) << 9;
        v1 = random(-128, 128) << 9;
        v2 = bossObjects[0].YPos + (random(-64, 64) << 9);
        v3 = random(-128, 128);
        createNPC(NPCSmoke, bossObjects[0].XPos + (v3 << 9), v2, v1, v0, 0, 0, 0);
      }
      killNPC(282, 1);
      bossObjects[11].entityFlags &= 0xFFDFu;
      for ( ia = 0; ia < 12; ++ia )
        bossObjects[ia].entityFlags &= 0xFFFBu;
      goto LABEL_79;
    case 221:
LABEL_45:
      if ( ++bossObjects[0].waitTimer % 40 == 1 )
      {
        switch ( random(0, 3) )
        {
          case 0:
            v23 = bossObjects[1].XPos;
            Y_Pos = bossObjects[1].YPos;
            break;
          case 1:
            v23 = bossObjects[2].XPos;
            Y_Pos = bossObjects[2].YPos;
            break;
          case 2:
            v23 = bossObjects[6].XPos;
            Y_Pos = bossObjects[6].YPos;
            break;
          case 3:
            v23 = bossObjects[7].XPos;
            Y_Pos = bossObjects[7].YPos;
            break;
          default:
            break;
        }
        playSoundEffect(SFXSillyExplosion, 1);
        createNPC(NPCForcefield|0x110, v23 - 0x2000, Y_Pos, 0, 0, 0, 0, 256);
        createNPC(NPCForcefield|0x110, v23 - 0x2000, Y_Pos, 0, 0, (Directions)1024, 0, 256);
      }
      ++npcStructDeathSound;
      if ( bossObjects[0].isBeingHit && npcStructDeathSound / 2 % 2 )
      {
        bossObjects[4].animationNumber = 1;
        bossObjects[5].animationNumber = 1;
      }
      else
      {
        bossObjects[4].animationNumber = 0;
        bossObjects[5].animationNumber = 0;
      }
      if ( bossObjects[0].life < NPCStructExp - 150 || bossObjects[0].waitTimer > 400 || bossObjects[0].life < 200 )
        bossObjects[0].currentState = 200;
      goto LABEL_94;
    case 230:
      bossObjects[0].currentState = 231;
      bossObjects[0].waitTimer = 0;
      bossObjects[3].currentState = 30;
      bossObjects[8].entityFlags |= 4u;
      bossObjects[9].entityFlags |= 4u;
      bossObjects[10].entityFlags |= 4u;
      bossObjects[11].entityFlags |= 0x20u;
      playSoundEffect(SFXSillyExplosion, 1);
      createNPC(NPCForcefield|0x110, bossObjects[3].XPos - 0x2000, bossObjects[3].YPos, 0, 0, 0, 0, 256);
      createNPC(NPCForcefield|0x110, bossObjects[3].XPos - 0x2000, bossObjects[3].YPos, 0, 0, (Directions)1024, 0, 256);
      createNPC(NPCForcefield|0x110, bossObjects[3].XPos, bossObjects[3].YPos - 0x2000, 0, 0, 0, 0, 256);
      createNPC(NPCForcefield|0x110, bossObjects[3].XPos, bossObjects[3].YPos - 0x2000, 0, 0, (Directions)1024, 0, 256);
      createNPC(NPCForcefield|0x110, bossObjects[3].XPos, bossObjects[3].YPos + 0x2000, 0, 0, 0, 0, 256);
      createNPC(NPCForcefield|0x110, bossObjects[3].XPos, bossObjects[3].YPos + 0x2000, 0, 0, (Directions)1024, 0, 256);
      NPCStructExp = bossObjects[0].life;
      v18 = 1;
      break;
    case 231:
      break;
    default:
      goto LABEL_94;
  }
  ++npcStructDeathSound;
  if ( bossObjects[0].isBeingHit && npcStructDeathSound / 2 % 2 )
  {
    bossObjects[4].animationNumber = 1;
    bossObjects[5].animationNumber = 1;
  }
  else
  {
    bossObjects[4].animationNumber = 0;
    bossObjects[5].animationNumber = 0;
  }
  if ( ++bossObjects[0].waitTimer % 100 == 1 )
  {
    superXPos = random(80, 100);
    curlyShootWait = bossObjects[11].XPos;
    curlyShootX = bossObjects[11].YPos;
  }
  if ( bossObjects[0].waitTimer % 120 == 1 )
    createNPC((NPCNames)288, bossObjects[0].XPos - 0x4000, bossObjects[0].YPos - 0x2000, 0, 0, up, 0, 32);
  if ( bossObjects[0].waitTimer % 120 == 61 )
    createNPC((NPCNames)288, bossObjects[0].XPos - 0x4000, bossObjects[0].YPos + 0x2000, 0, 0, down, 0, 32);
LABEL_94:
  if ( v18 )
  {
    setQuake(20);
    if ( bossObjects[0].currentState == 201 )
    {
      bossObjects[7].currentState = 10;
      bossObjects[6].currentState = 10;
      bossObjects[2].currentState = 10;
      bossObjects[1].currentState = 10;
    }
    if ( bossObjects[0].currentState == 221 )
    {
      bossObjects[7].currentState = 20;
      bossObjects[6].currentState = 20;
      bossObjects[2].currentState = 20;
      bossObjects[1].currentState = 20;
    }
    if ( bossObjects[0].currentState == 231 )
    {
      bossObjects[7].currentState = 30;
      bossObjects[6].currentState = 30;
      bossObjects[2].currentState = 30;
      bossObjects[1].currentState = 30;
    }
    playSoundEffect(SFXLargeObjectHitGround, 1);
    for ( ic = 0; ic < 8; ++ic )
    {
      v10 = random(-256, 256);
      v11 = random(-512, 512);
      v12 = bossObjects[4].YPos;
      v13 = random(-32, 16);
      createNPC(NPCSmoke, bossObjects[4].XPos + (v13 << 9), v12, v11, v10, 0, 0, 256);
    }
  }
  if ( bossObjects[0].currentState >= 200 && bossObjects[0].currentState < 300 )
  {
    if ( bossObjects[0].XPos < 98304 )
      bossObjects[0].direction = 2;
    if ( bossObjects[0].XPos > (currentMap.width - 4) << 13 )
      bossObjects[0].direction = 0;
    if ( bossObjects[0].direction )
      v14 = bossObjects[0].XVel + 4;
    else
      v14 = bossObjects[0].XVel - 4;
    bossObjects[0].XVel = v14;
  }
  switch ( bossObjects[0].currentState )
  {
    case 0xC9:
    case 0xD3:
    case 0xDD:
    case 0xE7:
      if ( ++bossObjects[0].count2 == 150 )
      {
        bossObjects[0].count2 = 0;
        v15 = random(-1, 3);
        createNPC((NPCNames)282, (currentMap.width << 13) + 64, (v15 + 10) << 13, 0, 0, 0, 0, 48);
      }
      else if ( bossObjects[0].count2 == 75 )
      {
        v16 = random(-3, 0);
        createNPC((NPCNames)282, (currentMap.width << 13) + 64, (v16 + 3) << 13, 0, 0, 0, 0, 48);
      }
      break;
    default:
      break;
  }
  if ( bossObjects[0].XVel > 128 )
    bossObjects[0].XVel = 128;
  if ( bossObjects[0].XVel < -128 )
    bossObjects[0].XVel = -128;
  if ( bossObjects[0].YVel > 128 )
    bossObjects[0].YVel = 128;
  if ( bossObjects[0].YVel < -128 )
    bossObjects[0].YVel = -128;
  bossObjects[0].XPos += bossObjects[0].XVel;
  bossObjects[0].YPos += bossObjects[0].YVel;
  undeadSubNPCFace(&bossObjects[3]);
  undeadSubNPCHead(&bossObjects[4]);
  undeadSubNPCTail(&bossObjects[5]);
  undeadSubNPCMini(&bossObjects[1]);
  undeadSubNPCMini(&bossObjects[2]);
  undeadSubNPCMini(&bossObjects[6]);
  undeadSubNPCMini(&bossObjects[7]);
  undeadSubNPCHit(&bossObjects[8]);
  undeadSubNPCHit(&bossObjects[9]);
  undeadSubNPCHit(&bossObjects[10]);
  undeadSubNPCHit(&bossObjects[11]);
}
// 4BBA20: using guessed type int curlyShootWait;
// 4BBA24: using guessed type int curlyShootX;
// 4BBA28: using guessed type int curlyShootY;
// 4BBA2C: using guessed type int superXPos;

//----- (00476790) --------------------------------------------------------
void __cdecl undeadSubNPCHead(NPC *npc)
{
  int *v1; // ecx
  RECT *v2; // edx
  int v3; // [esp+4h] [ebp-40h]
  int v4; // [esp+8h] [ebp-3Ch]
  int v5; // [esp+Ch] [ebp-38h]
  int v6; // [esp+10h] [ebp-34h]
  int v7; // [esp+14h] [ebp-30h]
  int v8; // [esp+18h] [ebp-2Ch]
  int v9; // [esp+1Ch] [ebp-28h]
  int v10; // [esp+20h] [ebp-24h]
  int v11; // [esp+24h] [ebp-20h]
  int v12; // [esp+28h] [ebp-1Ch]
  int v13; // [esp+2Ch] [ebp-18h]
  int v14; // [esp+30h] [ebp-14h]
  int v15; // [esp+34h] [ebp-10h]
  int v16; // [esp+38h] [ebp-Ch]
  int v17; // [esp+3Ch] [ebp-8h]
  int v18; // [esp+40h] [ebp-4h]

  v3 = 0;
  v4 = 0;
  v5 = 72;
  v6 = 112;
  v7 = 0;
  v8 = 112;
  v9 = 72;
  v10 = 224;
  v11 = 160;
  v12 = 0;
  v13 = 232;
  v14 = 112;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  switch ( npc->currentState )
  {
    case 0xA:
      npc->currentState = 11;
      npc->animationNumber = 2;
      npc->entityFlags = 8;
      npc->view.front = 18432;
      npc->view.top = 28672;
      goto LABEL_3;
    case 0xB:
LABEL_3:
      npc->XPos = bossObjects[0].XPos - 18432;
      npc->YPos = bossObjects[0].YPos;
      break;
    case 0x32:
      npc->currentState = 51;
      npc->waitTimer = 112;
      goto LABEL_5;
    case 0x33:
LABEL_5:
      if ( !--npc->waitTimer )
      {
        npc->currentState = 100;
        npc->animationNumber = 3;
      }
      break;
    case 0x64:
      npc->animationNumber = 3;
      break;
    default:
      break;
  }
  v1 = &v3 + 4 * npc->animationNumber;
  v2 = &npc->rect;
  v2->left = *v1;
  v2->top = v1[1];
  v2->right = v1[2];
  v2->bottom = v1[3];
  if ( npc->currentState == 51 )
    npc->rect.bottom = npc->waitTimer + npc->rect.top;
}

//----- (004769A0) --------------------------------------------------------
void __cdecl undeadSubNPCTail(NPC *npc)
{
  int *v1; // ecx
  RECT *v2; // edx
  int v3; // [esp+4h] [ebp-30h]
  int v4; // [esp+8h] [ebp-2Ch]
  int v5; // [esp+Ch] [ebp-28h]
  int v6; // [esp+10h] [ebp-24h]
  int v7; // [esp+14h] [ebp-20h]
  int v8; // [esp+18h] [ebp-1Ch]
  int v9; // [esp+1Ch] [ebp-18h]
  int v10; // [esp+20h] [ebp-14h]
  int v11; // [esp+24h] [ebp-10h]
  int v12; // [esp+28h] [ebp-Ch]
  int v13; // [esp+2Ch] [ebp-8h]
  int v14; // [esp+30h] [ebp-4h]

  v3 = 72;
  v4 = 0;
  v5 = 160;
  v6 = 112;
  v7 = 72;
  v8 = 112;
  v9 = 160;
  v10 = 224;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  switch ( npc->currentState )
  {
    case 0xA:
      npc->currentState = 11;
      npc->animationNumber = 0;
      npc->entityFlags = 8;
      npc->view.front = 22528;
      npc->view.top = 28672;
      goto LABEL_3;
    case 0xB:
LABEL_3:
      npc->XPos = bossObjects[0].XPos + 22528;
      npc->YPos = bossObjects[0].YPos;
      break;
    case 0x32:
      npc->currentState = 51;
      npc->waitTimer = 112;
      goto LABEL_5;
    case 0x33:
LABEL_5:
      if ( !--npc->waitTimer )
      {
        npc->currentState = 100;
        npc->animationNumber = 2;
      }
      break;
    case 0x64:
      npc->animationNumber = 2;
      break;
    default:
      break;
  }
  v1 = &v3 + 4 * npc->animationNumber;
  v2 = &npc->rect;
  v2->left = *v1;
  v2->top = v1[1];
  v2->right = v1[2];
  v2->bottom = v1[3];
  if ( npc->currentState == 51 )
    npc->rect.bottom = npc->waitTimer + npc->rect.top;
}

//----- (00476B90) --------------------------------------------------------
void __cdecl undeadSubNPCFace(NPC *npc)
{
  int *v1; // edx
  RECT *v2; // eax
  int v3; // [esp+4h] [ebp-50h]
  int v4; // [esp+8h] [ebp-4Ch]
  int v5; // [esp+Ch] [ebp-48h]
  int v6; // [esp+10h] [ebp-44h]
  int v7; // [esp+14h] [ebp-40h]
  int v8; // [esp+18h] [ebp-3Ch]
  int v9; // [esp+1Ch] [ebp-38h]
  int v10; // [esp+20h] [ebp-34h]
  int v11; // [esp+24h] [ebp-30h]
  int v12; // [esp+28h] [ebp-2Ch]
  int v13; // [esp+2Ch] [ebp-28h]
  int v14; // [esp+30h] [ebp-24h]
  int v15; // [esp+34h] [ebp-20h]
  int v16; // [esp+38h] [ebp-1Ch]
  int v17; // [esp+3Ch] [ebp-18h]
  int v18; // [esp+40h] [ebp-14h]
  int v19; // [esp+44h] [ebp-10h]
  int v20; // [esp+48h] [ebp-Ch]
  int v21; // [esp+4Ch] [ebp-8h]
  int v22; // [esp+50h] [ebp-4h]

  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 160;
  v8 = 112;
  v9 = 232;
  v10 = 152;
  v11 = 160;
  v12 = 152;
  v13 = 232;
  v14 = 192;
  v15 = 160;
  v16 = 192;
  v17 = 232;
  v18 = 232;
  v19 = 248;
  v20 = 160;
  v21 = 320;
  v22 = 200;
  switch ( npc->currentState )
  {
    case 0:
      npc->animationNumber = 0;
      break;
    case 0xA:
      npc->animationNumber = 1;
      break;
    case 0x14:
      npc->animationNumber = 2;
      break;
    case 0x1E:
      npc->currentState = 31;
      npc->animationNumber = 3;
      npc->waitTimer = 100;
      goto LABEL_6;
    case 0x1F:
LABEL_6:
      if ( ++npc->waitTimer > 300 )
        npc->waitTimer = 0;
      if ( npc->waitTimer > 250 && npc->waitTimer % 16 == 1 )
        playSoundEffect(SFXLargeObjectHitGround, 1);
      if ( npc->waitTimer > 250 && npc->waitTimer % 16 == 7 )
      {
        createNPC((NPCNames)293, npc->XPos, npc->YPos, 0, 0, 0, 0, 128);
        playSoundEffect(SFXLightning, 1);
      }
      if ( npc->waitTimer == 200 )
        playSoundEffect(SFXCoreCharge, 1);
      if ( npc->waitTimer > 200 && npc->waitTimer % 2 )
        npc->animationNumber = 4;
      else
        npc->animationNumber = 3;
      break;
    default:
      break;
  }
  npc->view.back = 18432;
  npc->view.front = 18432;
  npc->view.top = 10240;
  npc->XPos = bossObjects[0].XPos - 18432;
  npc->YPos = bossObjects[0].YPos + 2048;
  npc->entityFlags = 8;
  v1 = &v3 + 4 * npc->animationNumber;
  v2 = &npc->rect;
  v2->left = *v1;
  v2->top = v1[1];
  v2->right = v1[2];
  v2->bottom = v1[3];
}

//----- (00476E50) --------------------------------------------------------
void __cdecl undeadSubNPCMini(NPC *npc)
{
  int v1; // esi
  NPC *v2; // esi
  int *v3; // ecx
  RECT *v4; // edx
  int v5; // [esp+4h] [ebp-34h]
  int v6; // [esp+8h] [ebp-30h]
  int v7; // [esp+Ch] [ebp-2Ch]
  int v8; // [esp+10h] [ebp-28h]
  int v9; // [esp+14h] [ebp-24h]
  int v10; // [esp+18h] [ebp-20h]
  int v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+20h] [ebp-18h]
  int v13; // [esp+24h] [ebp-14h]
  int v14; // [esp+28h] [ebp-10h]
  int v15; // [esp+2Ch] [ebp-Ch]
  int v16; // [esp+30h] [ebp-8h]
  int v17; // [esp+34h] [ebp-4h]

  v5 = 256;
  v6 = 0;
  v7 = 320;
  v8 = 40;
  v9 = 256;
  v10 = 40;
  v11 = 320;
  v12 = 80;
  v13 = 256;
  v14 = 80;
  v15 = 320;
  v16 = 120;
  if ( npc->isAlive )
  {
    npc->life = 1000;
    switch ( npc->currentState )
    {
      case 0:
        npc->entityFlags &= 0xFFDFu;
        break;
      case 5:
        npc->animationNumber = 0;
        npc->entityFlags &= 0xFFDFu;
        ++npc->count2;
        npc->count2 %= 256;
        break;
      case 0xA:
        npc->animationNumber = 0;
        npc->entityFlags &= 0xFFDFu;
        npc->count2 += 2;
        npc->count2 %= 256;
        break;
      case 0x14:
        npc->animationNumber = 1;
        npc->entityFlags &= 0xFFDFu;
        npc->count2 += 2;
        npc->count2 %= 256;
        break;
      case 0x1E:
        npc->animationNumber = 0;
        npc->entityFlags &= 0xFFDFu;
        npc->count2 += 4;
        npc->count2 %= 256;
        break;
      case 0xC8:
        npc->currentState = 201;
        npc->animationNumber = 2;
        npc->XVel = 0;
        npc->YVel = 0;
        goto LABEL_9;
      case 0xC9:
LABEL_9:
        npc->XVel += 32;
        npc->XPos += npc->XVel;
        if ( npc->XPos > (currentMap.width << 13) + 0x4000 )
          npc->isAlive = 0;
        break;
      default:
        break;
    }
    if ( npc->currentState < 50 )
    {
      if ( npc->count1 )
        v17 = npc->count2 + 128;
      else
        v17 = npc->count2 + 384;
      v1 = npc->parentNPC->XPos;
      npc->XPos = v1 + 48 * getCos(v17 / 2) - 4096;
      v2 = npc->parentNPC;
      npc->YPos = v2->YPos + 80 * getSin(v17 / 2);
    }
    v3 = &v5 + 4 * npc->animationNumber;
    v4 = &npc->rect;
    v4->left = *v3;
    v4->top = v3[1];
    v4->right = v3[2];
    v4->bottom = v3[3];
  }
}

//----- (00477230) --------------------------------------------------------
void __cdecl undeadSubNPCHit(NPC *npc)
{
  switch ( npc->count1 )
  {
    case 0:
      npc->XPos = bossObjects[0].XPos;
      npc->YPos = bossObjects[0].YPos - 0x4000;
      break;
    case 1:
      npc->XPos = bossObjects[0].XPos + 14336;
      npc->YPos = bossObjects[0].YPos;
      break;
    case 2:
      npc->XPos = bossObjects[0].XPos + 2048;
      npc->YPos = bossObjects[0].YPos + 0x4000;
      break;
    case 3:
      npc->XPos = bossObjects[0].XPos - 14336;
      npc->YPos = bossObjects[0].YPos + 2048;
      break;
    default:
      return;
  }
}

//----- (004772F0) --------------------------------------------------------
void __cdecl boss9_BallosBall()
{
  int v0; // eax
  int v1; // eax
  int v2; // eax
  int X_Pos; // ST34_4
  int v4; // eax
  int v5; // ST14_4
  int v6; // eax
  int v7; // ST34_4
  int YPos; // ST38_4
  int v9; // ST34_4
  int v10; // ST38_4
  int v11; // ST34_4
  int v12; // eax
  int v13; // ST34_4
  int v14; // eax
  int v15; // [esp+0h] [ebp-14h]
  int i; // [esp+8h] [ebp-Ch]
  int ia; // [esp+8h] [ebp-Ch]
  int ib; // [esp+8h] [ebp-Ch]
  int ic; // [esp+8h] [ebp-Ch]
  int id; // [esp+8h] [ebp-Ch]
  int ie; // [esp+8h] [ebp-Ch]
  int ig; // [esp+8h] [ebp-Ch]
  int ih; // [esp+8h] [ebp-Ch]
  int ii; // [esp+8h] [ebp-Ch]

  v15 = bossObjects[0].currentState;
  if ( v15 <= 314 )
  {
    if ( v15 == 314 )
    {
      bossObjects[0].direction = 3;
      bossObjects[0].YVel = 938;
      bossObjects[0].XVel = 0;
      bossObjects[0].YPos += bossObjects[0].YVel;
      if ( bossObjects[0].YPos > 115200 )
      {
        bossObjects[0].YPos = 115200;
        bossObjects[0].currentState = 311;
      }
    }
    else if ( v15 > 204 )
    {
      switch ( v15 )
      {
        case 220:
          bossObjects[0].currentState = 221;
          bossObjects[0].life = 1200;
          bossObjects[1].currentState = 200;
          bossObjects[2].currentState = 200;
          bossObjects[0].XVel = 0;
          bossObjects[0].animationNumber = 0;
          bossObjects[0].isBeingHit = 0;
          NPCStructDamage = 0;
          goto LABEL_66;
        case 221:
LABEL_66:
          bossObjects[0].YVel += 64;
          if ( bossObjects[0].YVel > 3072 )
            bossObjects[0].YVel = 3072;
          bossObjects[0].YPos += bossObjects[0].YVel;
          if ( bossObjects[0].YPos > 155648 - bossObjects[0].hitbox.bottom )
          {
            bossObjects[0].YPos = 155648 - bossObjects[0].hitbox.bottom;
            bossObjects[0].YVel = 0;
            bossObjects[0].currentState = 222;
            bossObjects[0].waitTimer = 0;
            setHardQuakeDuration(30);
            playSoundEffect(SFXLargeObjectHitGround, 1);
            for ( ib = 0; ib < 16; ++ib )
            {
              v2 = random(-40, 40);
              createNPC(NPCSmoke, bossObjects[0].XPos + (v2 << 9), bossObjects[0].YPos + 20480, 0, 0, 0, 0, 256);
            }
            if ( quote.collisionFlags & 8 )
              quote.YVel = -512;
          }
          goto LABEL_152;
        case 300:
          bossObjects[0].currentState = 301;
          bossObjects[0].waitTimer = 0;
          for ( ic = 0; ic < 256; ic += 64 )
          {
            createNPC((NPCNames)342, bossObjects[0].XPos, bossObjects[0].YPos, 0, 0, (Directions)ic, bossObjects, 90);
            createNPC(
              (NPCNames)342,
              bossObjects[0].XPos,
              bossObjects[0].YPos,
              0,
              0,
              (Directions)(ic + 544),
              bossObjects,
              90);
          }
          createNPC((NPCNames)343, bossObjects[0].XPos, bossObjects[0].YPos, 0, 0, 0, bossObjects, 24);
          createNPC((NPCNames)344, bossObjects[0].XPos - 12288, bossObjects[0].YPos - 18432, 0, 0, 0, bossObjects, 32);
          createNPC(
            (NPCNames)344,
            bossObjects[0].XPos + 12288,
            bossObjects[0].YPos - 18432,
            0,
            0,
            right,
            bossObjects,
            32);
          goto LABEL_79;
        case 301:
LABEL_79:
          bossObjects[0].YPos += (115200 - bossObjects[0].YPos) / 8;
          if ( ++bossObjects[0].waitTimer > 50 )
          {
            bossObjects[0].currentState = 310;
            bossObjects[0].waitTimer = 0;
          }
          break;
        case 311:
          bossObjects[0].direction = 0;
          bossObjects[0].XVel = -938;
          bossObjects[0].YVel = 0;
          bossObjects[0].XPos += bossObjects[0].XVel;
          if ( bossObjects[0].XPos < 56832 )
          {
            bossObjects[0].XPos = 56832;
            bossObjects[0].currentState = 312;
          }
          break;
        case 312:
          bossObjects[0].direction = 1;
          bossObjects[0].YVel = -938;
          bossObjects[0].XVel = 0;
          bossObjects[0].YPos += bossObjects[0].YVel;
          if ( bossObjects[0].YPos < 56832 )
          {
            bossObjects[0].YPos = 56832;
            bossObjects[0].currentState = 313;
          }
          break;
        case 313:
          bossObjects[0].direction = 2;
          bossObjects[0].XVel = 938;
          bossObjects[0].YVel = 0;
          bossObjects[0].XPos += bossObjects[0].XVel;
          if ( bossObjects[0].XPos > 262656 )
          {
            bossObjects[0].XPos = 262656;
            bossObjects[0].currentState = 314;
          }
          if ( bossObjects[0].count1 )
            --bossObjects[0].count1;
          if ( !bossObjects[0].count1 && bossObjects[0].XPos > 155648 && bossObjects[0].XPos < 172032 )
            bossObjects[0].currentState = 400;
          break;
        default:
          goto LABEL_152;
      }
    }
    else if ( v15 == 204 )
    {
      if ( bossObjects[0].XPos < 40960 )
        bossObjects[0].XVel = 512;
      if ( bossObjects[0].XPos > 278528 )
        bossObjects[0].XVel = -512;
      bossObjects[0].YVel += 85;
      if ( bossObjects[0].YVel > 3072 )
        bossObjects[0].YVel = 3072;
      bossObjects[0].XPos += bossObjects[0].XVel;
      bossObjects[0].YPos += bossObjects[0].YVel;
      if ( bossObjects[0].YPos > 155648 - bossObjects[0].hitbox.bottom )
      {
        bossObjects[0].YPos = 155648 - bossObjects[0].hitbox.bottom;
        bossObjects[0].YVel = 0;
        bossObjects[0].currentState = 201;
        bossObjects[0].waitTimer = 0;
        if ( quote.YPos > bossObjects[0].YPos + 28672 )
          damagePlayer(16);
        if ( quote.collisionFlags & 8 )
          quote.YVel = -512;
        setHardQuakeDuration(30);
        playSoundEffect(SFXLargeObjectHitGround, 1);
        createNPC((NPCNames)332, bossObjects[0].XPos - 6144, bossObjects[0].YPos + 26624, 0, 0, 0, 0, 256);
        createNPC((NPCNames)332, bossObjects[0].XPos + 6144, bossObjects[0].YPos + 26624, 0, 0, right, 0, 256);
        playSoundEffect(SFXMissileImpact, 1);
        for ( ia = 0; ia < 16; ++ia )
        {
          v1 = random(-40, 40);
          createNPC(NPCSmoke, bossObjects[0].XPos + (v1 << 9), bossObjects[0].YPos + 20480, 0, 0, 0, 0, 256);
        }
      }
    }
    else
    {
      switch ( v15 )
      {
        case 0:
          bossObjects[0].currentState = 1;
          bossObjects[0].isAlive = -128;
          bossObjects[0].EXPAmount = 1;
          bossObjects[0].direction = 0;
          bossObjects[0].XPos = 163840;
          bossObjects[0].YPos = -32768;
          bossObjects[0].hitSound = 54;
          bossObjects[0].hitbox.front = 0x4000;
          bossObjects[0].hitbox.top = 24576;
          bossObjects[0].hitbox.back = 0x4000;
          bossObjects[0].hitbox.bottom = 24576;
          bossObjects[0].entityFlags = -32184;
          bossObjects[0].explosionSize = 3;
          bossObjects[0].damage = 0;
          bossObjects[0].entityEventNum = 1000;
          bossObjects[0].life = 800;
          bossObjects[1].isAlive = -112;
          bossObjects[1].direction = 0;
          bossObjects[1].entityFlags = 8;
          bossObjects[1].life = 10000;
          bossObjects[1].view.front = 6144;
          bossObjects[1].view.top = 0;
          bossObjects[1].view.back = 6144;
          bossObjects[1].view.bottom = 0x2000;
          bossObjects[1].hitbox.front = 6144;
          bossObjects[1].hitbox.top = 0;
          bossObjects[1].hitbox.back = 6144;
          bossObjects[1].hitbox.bottom = 0x2000;
          qmemcpy(&bossObjects[2], &bossObjects[1], sizeof(NPC));
          bossObjects[2].direction = 2;
          bossObjects[3].isAlive = -112;
          bossObjects[3].entityFlags = 13;
          bossObjects[3].view.front = 30720;
          bossObjects[3].view.top = 30720;
          bossObjects[3].view.back = 30720;
          bossObjects[3].view.bottom = 30720;
          bossObjects[3].hitbox.front = 24576;
          bossObjects[3].hitbox.top = 12288;
          bossObjects[3].hitbox.back = 24576;
          bossObjects[3].hitbox.bottom = 0x4000;
          bossObjects[4].isAlive = -112;
          bossObjects[4].entityFlags = 13;
          bossObjects[4].hitbox.front = 0x4000;
          bossObjects[4].hitbox.top = 4096;
          bossObjects[4].hitbox.back = 0x4000;
          bossObjects[4].hitbox.bottom = 4096;
          bossObjects[5].isAlive = -112;
          bossObjects[5].entityFlags = 76;
          bossObjects[5].hitbox.front = 0x4000;
          bossObjects[5].hitbox.top = 0;
          bossObjects[5].hitbox.back = 0x4000;
          bossObjects[5].hitbox.bottom = 24576;
          goto LABEL_152;
        case 100:
          bossObjects[0].currentState = 101;
          bossObjects[0].animationNumber = 0;
          bossObjects[0].XPos = quote.XPos;
          createNPC(NPCForcefield|0x140, quote.XPos, 155648, 0, 0, right, 0, 256);
          bossObjects[0].waitTimer = 0;
          goto LABEL_22;
        case 101:
LABEL_22:
          if ( ++bossObjects[0].waitTimer > 30 )
            bossObjects[0].currentState = 102;
          goto LABEL_152;
        case 102:
          bossObjects[0].YVel += 64;
          if ( bossObjects[0].YVel > 3072 )
            bossObjects[0].YVel = 3072;
          bossObjects[0].YPos += bossObjects[0].YVel;
          if ( bossObjects[0].YPos > 155648 - bossObjects[0].hitbox.bottom )
          {
            bossObjects[0].YPos = 155648 - bossObjects[0].hitbox.bottom;
            bossObjects[0].YVel = 0;
            bossObjects[0].currentState = 103;
            bossObjects[0].waitTimer = 0;
            setHardQuakeDuration(30);
            playSoundEffect(SFXMissileImpact, 1);
            if ( quote.YPos > bossObjects[0].YPos + 24576
              && quote.XPos < bossObjects[0].XPos + 12288
              && quote.XPos > bossObjects[0].XPos - 12288 )
            {
              damagePlayer(16);
            }
            for ( i = 0; i < 16; ++i )
            {
              v0 = random(-40, 40);
              createNPC(NPCSmoke, bossObjects[0].XPos + (v0 << 9), bossObjects[0].YPos + 20480, 0, 0, 0, 0, 256);
            }
            if ( quote.collisionFlags & 8 )
              quote.YVel = -512;
          }
          goto LABEL_152;
        case 103:
          if ( ++bossObjects[0].waitTimer == 50 )
          {
            bossObjects[0].currentState = 104;
            bossObjects[1].currentState = 100;
            bossObjects[2].currentState = 100;
          }
          goto LABEL_152;
        case 200:
          bossObjects[0].currentState = 201;
          bossObjects[0].count1 = 0;
          goto LABEL_42;
        case 201:
LABEL_42:
          bossObjects[0].currentState = 203;
          bossObjects[0].XVel = 0;
          ++bossObjects[0].count1;
          bossObjects[0].hitbox.bottom = 24576;
          bossObjects[0].damage = 0;
          if ( bossObjects[0].count1 % 3 )
            bossObjects[0].waitTimer = 50;
          else
            bossObjects[0].waitTimer = 150;
          goto LABEL_45;
        case 203:
LABEL_45:
          if ( --bossObjects[0].waitTimer <= 0 )
          {
            bossObjects[0].currentState = 204;
            bossObjects[0].YVel = -3072;
            if ( bossObjects[0].XPos >= quote.XPos )
              bossObjects[0].XVel = -512;
            else
              bossObjects[0].XVel = 512;
          }
          break;
        default:
          goto LABEL_152;
      }
    }
    goto LABEL_152;
  }
  if ( v15 <= 424 )
  {
    if ( v15 == 424 )
    {
      if ( ++bossObjects[0].animationTimer > 200 )
      {
        bossObjects[0].animationTimer = 0;
        bossObjects[0].currentState = 425;
      }
    }
    else
    {
      switch ( v15 )
      {
        case 400:
          bossObjects[0].currentState = 401;
          bossObjects[0].waitTimer = 0;
          bossObjects[0].XVel = 0;
          bossObjects[0].YVel = 0;
          killNPC(339, 0);
          goto LABEL_101;
        case 401:
LABEL_101:
          bossObjects[0].YPos += (81408 - bossObjects[0].YPos) / 8;
          if ( ++bossObjects[0].waitTimer > 50 )
          {
            bossObjects[0].waitTimer = 0;
            bossObjects[0].currentState = 410;
            for ( id = 0; id < 256; id += 32 )
              createNPC((NPCNames)346, bossObjects[0].XPos, bossObjects[0].YPos, 0, 0, (Directions)id, bossObjects, 80);
            createNPC((NPCNames)343, bossObjects[0].XPos, bossObjects[0].YPos, 0, 0, 0, bossObjects, 24);
            createNPC((NPCNames)344, bossObjects[0].XPos - 12288, bossObjects[0].YPos - 18432, 0, 0, 0, bossObjects, 32);
            createNPC(
              (NPCNames)344,
              bossObjects[0].XPos + 12288,
              bossObjects[0].YPos - 18432,
              0,
              0,
              right,
              bossObjects,
              32);
          }
          goto LABEL_152;
        case 410:
          if ( ++bossObjects[0].waitTimer > 50 )
          {
            bossObjects[0].waitTimer = 0;
            bossObjects[0].currentState = 411;
          }
          goto LABEL_152;
        case 411:
          if ( ++bossObjects[0].waitTimer % 30 == 1 )
            createNPC((NPCNames)348, (2 * (bossObjects[0].waitTimer / 30) + 2) << 13, 172032, 0, 0, 0, 0, 384);
          if ( bossObjects[0].waitTimer / 3 % 2 )
            playSoundEffect(SFXLargeObjectHitGround, 1);
          if ( bossObjects[0].waitTimer > 540 )
            bossObjects[0].currentState = 420;
          goto LABEL_152;
        case 420:
          bossObjects[0].currentState = 421;
          bossObjects[0].waitTimer = 0;
          bossObjects[0].animationTimer = 0;
          setHardQuakeDuration(30);
          playSoundEffect(SFXlargeExplosion, 1);
          bossObjects[1].currentState = 102;
          bossObjects[2].currentState = 102;
          for ( ie = 0; ie < 256; ++ie )
          {
            X_Pos = bossObjects[0].XPos + (random(-60, 60) << 9);
            v4 = random(-60, 60);
            createNPC(NPCSmoke, X_Pos, bossObjects[0].YPos + (v4 << 9), 0, 0, 0, 0, 0);
          }
          goto LABEL_120;
        case 421:
LABEL_120:
          if ( ++bossObjects[0].animationTimer > 500 )
          {
            bossObjects[0].animationTimer = 0;
            bossObjects[0].currentState = 422;
          }
          break;
        case 422:
          if ( ++bossObjects[0].animationTimer > 200 )
          {
            bossObjects[0].animationTimer = 0;
            bossObjects[0].currentState = 423;
          }
          break;
        case 423:
          if ( ++bossObjects[0].animationTimer > 20 )
          {
            bossObjects[0].animationTimer = 0;
            bossObjects[0].currentState = 424;
          }
          break;
        default:
          goto LABEL_152;
      }
    }
    goto LABEL_152;
  }
  if ( v15 <= 428 )
  {
    switch ( v15 )
    {
      case 428:
        if ( ++bossObjects[0].animationTimer > 200 )
        {
          bossObjects[0].animationTimer = 0;
          bossObjects[0].currentState = 421;
        }
        break;
      case 425:
        if ( ++bossObjects[0].animationTimer > 500 )
        {
          bossObjects[0].animationTimer = 0;
          bossObjects[0].currentState = 426;
        }
        break;
      case 426:
        if ( ++bossObjects[0].animationTimer > 200 )
        {
          bossObjects[0].animationTimer = 0;
          bossObjects[0].currentState = 427;
        }
        break;
      default:
        if ( v15 == 427 && ++bossObjects[0].animationTimer > 20 )
        {
          bossObjects[0].animationTimer = 0;
          bossObjects[0].currentState = 428;
        }
        break;
    }
    goto LABEL_152;
  }
  if ( v15 == 1000 )
  {
    bossObjects[0].currentState = 1001;
    bossObjects[0].waitTimer = 0;
    bossObjects[1].currentState = 300;
    bossObjects[2].currentState = 300;
    bossObjects[0].entityFlags &= 0xFFBEu;
    bossObjects[3].entityFlags &= 0xFFBEu;
    bossObjects[4].entityFlags &= 0xFFBEu;
    bossObjects[5].entityFlags &= 0xFFBEu;
  }
  else if ( v15 != 1001 )
  {
    if ( v15 == 1002 )
    {
      setHardQuakeDuration(40);
      if ( ++bossObjects[0].waitTimer == 50 )
      {
        bossObjects[0].isAlive = 0;
        bossObjects[1].isAlive = 0;
        bossObjects[2].isAlive = 0;
        bossObjects[3].isAlive = 0;
        bossObjects[4].isAlive = 0;
        bossObjects[5].isAlive = 0;
        killNPC(350, 1);
        killNPC(348, 1);
      }
    }
    goto LABEL_152;
  }
  if ( !(++bossObjects[0].waitTimer % 12) )
    playSoundEffect(SFXMissileImpact, 1);
  v5 = bossObjects[0].YPos + (random(-60, 60) << 9);
  v6 = random(-60, 60);
  createDustClouds(bossObjects[0].XPos + (v6 << 9), v5, 1, 1);
  if ( bossObjects[0].waitTimer > 150 )
  {
    bossObjects[0].waitTimer = 0;
    bossObjects[0].currentState = 1002;
    startFlash(bossObjects[0].XPos, bossObjects[0].YPos, 1);
    playSoundEffect(SFXlargeExplosion, 1);
  }
LABEL_152:
  if ( bossObjects[0].currentState > 420 && bossObjects[0].currentState < 500 )
  {
    bossObjects[3].entityFlags |= 0x20u;
    bossObjects[4].entityFlags |= 0x20u;
    bossObjects[5].entityFlags |= 0x20u;
    if ( ++bossObjects[0].waitTimer > 300 )
    {
      bossObjects[0].waitTimer = 0;
      if ( quote.XPos <= bossObjects[0].XPos )
      {
        for ( ih = 0; ih < 8; ++ih )
        {
          v9 = (random(-4, 4) << 13) / 4;
          v10 = (random(8, 68) << 13) / 4;
          createNPC((NPCNames)350, v9, v10, 0, 0, right, 0, 256);
        }
      }
      else
      {
        for ( ig = 0; ig < 8; ++ig )
        {
          v7 = ((random(-4, 4) + 156) << 13) / 4;
          YPos = (random(8, 68) << 13) / 4;
          createNPC((NPCNames)350, v7, YPos, 0, 0, 0, 0, 256);
        }
      }
    }
    if ( bossObjects[0].waitTimer == 270 || bossObjects[0].waitTimer == 280 || bossObjects[0].waitTimer == 290 )
    {
      createNPC((NPCNames)353, bossObjects[0].XPos, bossObjects[0].YPos - 26624, 0, 0, up, 0, 256);
      playSoundEffect(SFXEnemyShootProjectile, 1);
      for ( ii = 0; ii < 4; ++ii )
        createNPC(NPCSmoke, bossObjects[0].XPos, bossObjects[0].YPos - 26624, 0, 0, 0, 0, 256);
    }
    if ( bossObjects[0].life <= 500 )
    {
      if ( random(0, 4) == 2 )
      {
        v13 = bossObjects[0].XPos + (random(-40, 40) << 9);
        v14 = random(0, 40);
        createNPC(NPCSantasKey|0x100, v13, bossObjects[0].YPos + (v14 << 9), 0, 0, down, 0, 0);
      }
    }
    else if ( random(0, 10) == 2 )
    {
      v11 = bossObjects[0].XPos + (random(-40, 40) << 9);
      v12 = random(0, 40);
      createNPC(NPCSantasKey|0x100, v11, bossObjects[0].YPos + (v12 << 9), 0, 0, down, 0, 0);
    }
  }
  if ( bossObjects[0].isBeingHit )
  {
    ++NPCStructDamage;
    bossObjects[3].animationNumber = NPCStructDamage / 2 % 2 != 0;
  }
  else
  {
    bossObjects[3].animationNumber = 0;
  }
  if ( bossObjects[0].currentState > 420 )
    bossObjects[3].animationNumber += 2;
  ballosSubNPCEye(&bossObjects[1]);
  ballosSubNPCEye(&bossObjects[2]);
  ballosSubNPCBody(&bossObjects[3]);
  ballosSubNPCHITAI(&bossObjects[4]);
  ballosSubNPCHARA(&bossObjects[5]);
}

//----- (00478AA0) --------------------------------------------------------
int __cdecl ballosSubNPCEye(NPC *npc)
{
  unsigned __int16 v1; // ax
  int *v2; // edx
  int result; // eax
  int v4; // [esp+4h] [ebp-A0h]
  int v5; // [esp+8h] [ebp-9Ch]
  int v6; // [esp+Ch] [ebp-98h]
  int v7; // [esp+10h] [ebp-94h]
  int v8; // [esp+14h] [ebp-90h]
  int v9; // [esp+18h] [ebp-8Ch]
  int v10; // [esp+1Ch] [ebp-88h]
  int v11; // [esp+20h] [ebp-84h]
  int v12; // [esp+24h] [ebp-80h]
  int v13; // [esp+28h] [ebp-7Ch]
  int v14; // [esp+2Ch] [ebp-78h]
  int v15; // [esp+30h] [ebp-74h]
  int v16; // [esp+34h] [ebp-70h]
  int v17; // [esp+38h] [ebp-6Ch]
  int v18; // [esp+3Ch] [ebp-68h]
  int v19; // [esp+40h] [ebp-64h]
  int v20; // [esp+44h] [ebp-60h]
  int v21; // [esp+48h] [ebp-5Ch]
  int v22; // [esp+4Ch] [ebp-58h]
  int v23; // [esp+50h] [ebp-54h]
  int v24; // [esp+54h] [ebp-50h]
  int v25; // [esp+58h] [ebp-4Ch]
  int v26; // [esp+5Ch] [ebp-48h]
  int v27; // [esp+60h] [ebp-44h]
  int v28; // [esp+64h] [ebp-40h]
  int v29; // [esp+68h] [ebp-3Ch]
  int v30; // [esp+6Ch] [ebp-38h]
  int v31; // [esp+70h] [ebp-34h]
  int v32; // [esp+74h] [ebp-30h]
  int v33; // [esp+78h] [ebp-2Ch]
  int v34; // [esp+7Ch] [ebp-28h]
  int v35; // [esp+80h] [ebp-24h]
  int v36; // [esp+84h] [ebp-20h]
  int v37; // [esp+88h] [ebp-1Ch]
  int v38; // [esp+8Ch] [ebp-18h]
  int v39; // [esp+90h] [ebp-14h]
  int v40; // [esp+94h] [ebp-10h]
  int v41; // [esp+98h] [ebp-Ch]
  int v42; // [esp+9Ch] [ebp-8h]
  int v43; // [esp+A0h] [ebp-4h]

  v24 = 272;
  v25 = 0;
  v26 = 296;
  v27 = 16;
  v28 = 272;
  v29 = 16;
  v30 = 296;
  v31 = 32;
  v32 = 272;
  v33 = 32;
  v34 = 296;
  v35 = 48;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 240;
  v41 = 16;
  v42 = 264;
  v43 = 32;
  v4 = 296;
  v5 = 0;
  v6 = 320;
  v7 = 16;
  v8 = 296;
  v9 = 16;
  v10 = 320;
  v11 = 32;
  v12 = 296;
  v13 = 32;
  v14 = 320;
  v15 = 48;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 240;
  v21 = 32;
  v22 = 264;
  v23 = 48;
  switch ( npc->currentState )
  {
    case 0x64:
      npc->currentState = 101;
      npc->animationNumber = 0;
      npc->animationTimer = 0;
      goto LABEL_3;
    case 0x65:
LABEL_3:
      if ( ++npc->animationTimer > 2 )
      {
        npc->animationTimer = 0;
        ++npc->animationNumber;
      }
      if ( npc->animationNumber > 2 )
        npc->currentState = 102;
      break;
    case 0x66:
      npc->animationNumber = 3;
      break;
    case 0xC8:
      npc->currentState = 201;
      npc->animationNumber = 3;
      npc->animationTimer = 0;
      goto LABEL_10;
    case 0xC9:
LABEL_10:
      if ( ++npc->animationTimer > 2 )
      {
        npc->animationTimer = 0;
        --npc->animationNumber;
      }
      if ( npc->animationNumber <= 0 )
        npc->currentState = 202;
      break;
    case 0x12C:
      npc->currentState = 301;
      npc->animationNumber = 4;
      if ( npc->direction )
        createDustClouds(npc->XPos + 2048, npc->YPos, 2048, 10);
      else
        createDustClouds(npc->XPos - 2048, npc->YPos, 2048, 10);
      break;
    default:
      break;
  }
  if ( npc->direction )
    npc->XPos = bossObjects[0].XPos + 12288;
  else
    npc->XPos = bossObjects[0].XPos - 12288;
  npc->YPos = bossObjects[0].YPos - 18432;
  if ( npc->currentState >= 0 && npc->currentState < 300 )
  {
    if ( npc->animationNumber == 3 )
      v1 = npc->entityFlags | 0x20;
    else
      v1 = npc->entityFlags & 0xFFDF;
    npc->entityFlags = v1;
  }
  if ( npc->direction )
    v2 = &v4 + 4 * npc->animationNumber;
  else
    v2 = &v24 + 4 * npc->animationNumber;
  result = (int)&npc->rect;
  *(_DWORD *)result = *v2;
  *(_DWORD *)(result + 4) = v2[1];
  *(_DWORD *)(result + 8) = v2[2];
  *(_DWORD *)(result + 12) = v2[3];
  return result;
}

//----- (00478F20) --------------------------------------------------------
int __cdecl ballosSubNPCBody(NPC *npc)
{
  int *v1; // eax
  RECT *v2; // ecx
  int result; // eax
  int v4; // [esp+0h] [ebp-40h]
  int v5; // [esp+4h] [ebp-3Ch]
  int v6; // [esp+8h] [ebp-38h]
  int v7; // [esp+Ch] [ebp-34h]
  int v8; // [esp+10h] [ebp-30h]
  int v9; // [esp+14h] [ebp-2Ch]
  int v10; // [esp+18h] [ebp-28h]
  int v11; // [esp+1Ch] [ebp-24h]
  int v12; // [esp+20h] [ebp-20h]
  int v13; // [esp+24h] [ebp-1Ch]
  int v14; // [esp+28h] [ebp-18h]
  int v15; // [esp+2Ch] [ebp-14h]
  int v16; // [esp+30h] [ebp-10h]
  int v17; // [esp+34h] [ebp-Ch]
  int v18; // [esp+38h] [ebp-8h]
  int v19; // [esp+3Ch] [ebp-4h]

  v4 = 0;
  v5 = 0;
  v6 = 120;
  v7 = 120;
  v8 = 120;
  v9 = 0;
  v10 = 240;
  v11 = 120;
  v12 = 0;
  v13 = 120;
  v14 = 120;
  v15 = 240;
  v16 = 120;
  v17 = 120;
  v18 = 240;
  v19 = 240;
  npc->XPos = bossObjects[0].XPos;
  npc->YPos = bossObjects[0].YPos;
  v1 = &v4 + 4 * npc->animationNumber;
  v2 = &npc->rect;
  v2->left = *v1;
  v2->top = v1[1];
  v2->right = v1[2];
  result = v1[3];
  v2->bottom = result;
  return result;
}

//----- (00478FE0) --------------------------------------------------------
int __cdecl ballosSubNPCHITAI(NPC *npc)
{
  int result; // eax

  npc->XPos = bossObjects[0].XPos;
  result = (int)npc;
  npc->YPos = bossObjects[0].YPos - 22528;
  return result;
}

//----- (00479010) --------------------------------------------------------
int __cdecl ballosSubNPCHARA(NPC *npc)
{
  int result; // eax

  npc->XPos = bossObjects[0].XPos;
  result = bossObjects[0].YPos;
  npc->YPos = bossObjects[0].YPos;
  return result;
}

//----- (00479030) --------------------------------------------------------
void boss2_Balfrog()
{
  RECT *v0; // edx
  int v1; // ST10_4
  int v2; // ST0C_4
  int v3; // ST08_4
  int v4; // eax
  int v5; // ST08_4
  int v6; // eax
  int v7; // ST10_4
  int v8; // ST0C_4
  int v9; // ST08_4
  int v10; // eax
  int v11; // eax
  int v12; // ST08_4
  int v13; // eax
  int v14; // ST08_4
  int v15; // eax
  int v16; // ST10_4
  int v17; // ST0C_4
  int v18; // ST08_4
  int v19; // eax
  int v20; // ST10_4
  int v21; // ST0C_4
  int v22; // ST08_4
  int v23; // eax
  int v24; // ST10_4
  int v25; // ST0C_4
  int v26; // ST08_4
  int v27; // eax
  int v28; // ecx
  int v29; // ST10_4
  int v30; // ST0C_4
  int v31; // ST08_4
  int v32; // eax
  int *v33; // ecx
  RECT *v34; // edx
  int Y_Vel; // [esp+4h] [ebp-13Ch]
  LONG v36; // [esp+8h] [ebp-138h]
  LONG v37; // [esp+Ch] [ebp-134h]
  LONG v38; // [esp+10h] [ebp-130h]
  LONG v39; // [esp+14h] [ebp-12Ch]
  int v40; // [esp+18h] [ebp-128h]
  int v41; // [esp+1Ch] [ebp-124h]
  int v42; // [esp+20h] [ebp-120h]
  int v43; // [esp+24h] [ebp-11Ch]
  int v44; // [esp+28h] [ebp-118h]
  int v45; // [esp+2Ch] [ebp-114h]
  int v46; // [esp+30h] [ebp-110h]
  int v47; // [esp+34h] [ebp-10Ch]
  int v48; // [esp+38h] [ebp-108h]
  int v49; // [esp+3Ch] [ebp-104h]
  int v50; // [esp+40h] [ebp-100h]
  int v51; // [esp+44h] [ebp-FCh]
  int v52; // [esp+48h] [ebp-F8h]
  int v53; // [esp+4Ch] [ebp-F4h]
  int v54; // [esp+50h] [ebp-F0h]
  int v55; // [esp+54h] [ebp-ECh]
  int v56; // [esp+58h] [ebp-E8h]
  int v57; // [esp+5Ch] [ebp-E4h]
  int v58; // [esp+60h] [ebp-E0h]
  int v59; // [esp+64h] [ebp-DCh]
  int v60; // [esp+68h] [ebp-D8h]
  int v61; // [esp+6Ch] [ebp-D4h]
  int v62; // [esp+70h] [ebp-D0h]
  int v63; // [esp+74h] [ebp-CCh]
  int v64; // [esp+78h] [ebp-C8h]
  int v65; // [esp+7Ch] [ebp-C4h]
  int v66; // [esp+80h] [ebp-C0h]
  int v67; // [esp+84h] [ebp-BCh]
  int v68; // [esp+88h] [ebp-B8h]
  int v69; // [esp+8Ch] [ebp-B4h]
  int v70; // [esp+90h] [ebp-B0h]
  int v71; // [esp+94h] [ebp-ACh]
  int X_Vel; // [esp+9Ch] [ebp-A4h]
  int i; // [esp+A0h] [ebp-A0h]
  NPC *v74; // [esp+A4h] [ebp-9Ch]
  int v75; // [esp+A8h] [ebp-98h]
  int v76; // [esp+ACh] [ebp-94h]
  int v77; // [esp+B0h] [ebp-90h]
  int v78; // [esp+B4h] [ebp-8Ch]
  int v79; // [esp+B8h] [ebp-88h]
  int v80; // [esp+BCh] [ebp-84h]
  int v81; // [esp+C0h] [ebp-80h]
  int v82; // [esp+C4h] [ebp-7Ch]
  int v83; // [esp+C8h] [ebp-78h]
  int v84; // [esp+CCh] [ebp-74h]
  int v85; // [esp+D0h] [ebp-70h]
  int v86; // [esp+D4h] [ebp-6Ch]
  int v87; // [esp+D8h] [ebp-68h]
  int v88; // [esp+DCh] [ebp-64h]
  int v89; // [esp+E0h] [ebp-60h]
  int v90; // [esp+E4h] [ebp-5Ch]
  int v91; // [esp+E8h] [ebp-58h]
  int v92; // [esp+ECh] [ebp-54h]
  int v93; // [esp+F0h] [ebp-50h]
  int v94; // [esp+F4h] [ebp-4Ch]
  int v95; // [esp+F8h] [ebp-48h]
  int v96; // [esp+FCh] [ebp-44h]
  int v97; // [esp+100h] [ebp-40h]
  int v98; // [esp+104h] [ebp-3Ch]
  int v99; // [esp+108h] [ebp-38h]
  int v100; // [esp+10Ch] [ebp-34h]
  int v101; // [esp+110h] [ebp-30h]
  int v102; // [esp+114h] [ebp-2Ch]
  int v103; // [esp+118h] [ebp-28h]
  int v104; // [esp+11Ch] [ebp-24h]
  int v105; // [esp+120h] [ebp-20h]
  int v106; // [esp+124h] [ebp-1Ch]
  int v107; // [esp+128h] [ebp-18h]
  int v108; // [esp+12Ch] [ebp-14h]
  int v109; // [esp+130h] [ebp-10h]
  int v110; // [esp+134h] [ebp-Ch]
  unsigned __int8 v111; // [esp+13Fh] [ebp-1h]

  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 48;
  v81 = 80;
  v82 = 112;
  v83 = 0;
  v84 = 112;
  v85 = 80;
  v86 = 176;
  v87 = 0;
  v88 = 176;
  v89 = 80;
  v90 = 240;
  v91 = 160;
  v92 = 48;
  v93 = 240;
  v94 = 112;
  v95 = 160;
  v96 = 112;
  v97 = 240;
  v98 = 200;
  v99 = 200;
  v100 = 0;
  v101 = 240;
  v102 = 24;
  v103 = 80;
  v104 = 0;
  v105 = 120;
  v106 = 24;
  v107 = 120;
  v108 = 0;
  v109 = 160;
  v110 = 24;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 80;
  v41 = 48;
  v42 = 160;
  v43 = 112;
  v44 = 80;
  v45 = 112;
  v46 = 160;
  v47 = 176;
  v48 = 80;
  v49 = 176;
  v50 = 160;
  v51 = 240;
  v52 = 240;
  v53 = 48;
  v54 = 320;
  v55 = 112;
  v56 = 240;
  v57 = 112;
  v58 = 320;
  v59 = 200;
  v60 = 200;
  v61 = 24;
  v62 = 240;
  v63 = 48;
  v64 = 80;
  v65 = 24;
  v66 = 120;
  v67 = 48;
  v68 = 120;
  v69 = 24;
  v70 = 160;
  v71 = 48;
  v74 = bossObjects;
  switch ( bossObjects[0].currentState )
  {
    case 0:
      v74->XPos = 49152;
      v74->YPos = 102400;
      v74->direction = 2;
      v74->view.front = 24576;
      v74->view.top = 24576;
      v74->view.back = 0x4000;
      v74->view.bottom = 0x2000;
      v74->hitSound = 52;
      v74->hitbox.front = 12288;
      v74->hitbox.top = 0x2000;
      v74->hitbox.back = 12288;
      v74->hitbox.bottom = 0x2000;
      v74->explosionSize = 3;
      v74->EXPAmount = 1;
      v74->entityEventNum = 1000;
      v74->entityFlags |= 0x8200u;
      v74->life = 300;
      break;
    case 0xA:
      v74->currentState = 11;
      v74->animationNumber = 3;
      v74->isAlive = -128;
      v0 = &v74->rect;
      v0->left = v36;
      v0->top = v37;
      v0->right = v38;
      v0->bottom = v39;
      bossObjects[1].isAlive = -112;
      bossObjects[1].entityEventNum = 1000;
      bossObjects[2].isAlive = -128;
      bossObjects[1].damage = 5;
      bossObjects[2].damage = 5;
      for ( i = 0; i < 8; ++i )
      {
        v1 = random(-1536, 0);
        v2 = random(-341, 341);
        v3 = v74->YPos + (random(-12, 12) << 9);
        v4 = random(-12, 12);
        createNPC(NPCSmoke, v74->XPos + (v4 << 9), v3, v2, v1, 0, 0, 256);
      }
      break;
    case 0x14:
      v74->currentState = 21;
      v74->waitTimer = 0;
      goto LABEL_8;
    case 0x15:
LABEL_8:
      if ( ++v74->waitTimer / 2 % 2 )
        v74->animationNumber = 3;
      else
        v74->animationNumber = 0;
      break;
    case 0x64:
      v74->currentState = 101;
      v74->waitTimer = 0;
      v74->animationNumber = 1;
      v74->XVel = 0;
      goto LABEL_13;
    case 0x65:
LABEL_13:
      if ( ++v74->waitTimer > 50 )
      {
        v74->currentState = 102;
        v74->animationTimer = 0;
        v74->animationNumber = 2;
      }
      break;
    case 0x66:
      if ( ++v74->animationTimer > 10 )
      {
        v74->currentState = 103;
        v74->animationTimer = 0;
        v74->animationNumber = 1;
      }
      break;
    case 0x67:
      if ( ++v74->animationTimer > 4 )
      {
        v74->currentState = 104;
        v74->animationNumber = 5;
        v74->YVel = -1024;
        playSoundEffect(SFXSillyExplosion, 1);
        if ( v74->direction )
          v74->XVel = 512;
        else
          v74->XVel = -512;
        v74->view.top = 0x8000;
        v74->view.bottom = 12288;
      }
      break;
    case 0x68:
      if ( !v74->direction && v74->collisionFlags & 1 )
      {
        v74->direction = 2;
        v74->XVel = 512;
      }
      if ( v74->direction == 2 && v74->collisionFlags & 4 )
      {
        v74->direction = 0;
        v74->XVel = -512;
      }
      if ( v74->collisionFlags & 8 )
      {
        playSoundEffect(SFXLargeObjectHitGround, 1);
        setQuake(30);
        v74->currentState = 100;
        v74->animationNumber = 1;
        v74->view.top = 24576;
        v74->view.bottom = 0x2000;
        if ( !v74->direction && v74->XPos < quote.XPos )
        {
          v74->direction = 2;
          v74->currentState = 110;
        }
        if ( v74->direction == 2 && v74->XPos > quote.XPos )
        {
          v74->direction = 0;
          v74->currentState = 110;
        }
        v5 = random(0, 4) << 13;
        v6 = random(4, 16);
        createNPC(NPCSantasKey|0x60, v6 << 13, v5, 0, 0, (Directions)4, 0, 128);
        for ( i = 0; i < 4; ++i )
        {
          v7 = random(-1536, 0);
          v8 = random(-341, 341);
          v9 = v74->hitbox.bottom + v74->YPos;
          v10 = random(-12, 12);
          createNPC(NPCSmoke, v74->XPos + (v10 << 9), v9, v8, v7, 0, 0, 256);
        }
      }
      break;
    case 0x6E:
      v74->animationNumber = 1;
      v74->waitTimer = 0;
      v74->currentState = 111;
      goto LABEL_43;
    case 0x6F:
LABEL_43:
      ++v74->waitTimer;
      v74->XVel = 8 * v74->XVel / 9;
      if ( v74->waitTimer > 50 )
      {
        v74->animationNumber = 2;
        v74->animationTimer = 0;
        v74->currentState = 112;
      }
      break;
    case 0x70:
      if ( ++v74->animationTimer > 4 )
      {
        v74->currentState = 113;
        v74->waitTimer = 0;
        v74->animationNumber = 3;
        v74->count1 = 16;
        bossObjects[1].entityFlags |= 0x20u;
        v74->curlyTargetX = v74->life;
      }
      break;
    case 0x71:
      if ( v74->isBeingHit )
      {
        v11 = v74->count2++ / 2 % 2;
        if ( v11 )
          v74->animationNumber = 4;
        else
          v74->animationNumber = 3;
      }
      else
      {
        v74->count2 = 0;
        v74->animationNumber = 3;
      }
      v74->XVel = 10 * v74->XVel / 11;
      if ( ++v74->waitTimer > 16 )
      {
        v74->waitTimer = 0;
        --v74->count1;
        v111 = v74->direction ? getArcTan(v74->XPos + 0x4000 - quote.XPos, v74->YPos - 4096 - quote.YPos) : getArcTan(v74->XPos - 0x4000 - quote.XPos, v74->YPos - 4096 - quote.YPos);
        v111 += random(-16, 16);
        Y_Vel = getSin(v111);
        X_Vel = getCos(v111);
        if ( v74->direction )
          createNPC((NPCNames)108, v74->XPos + 0x4000, v74->YPos - 4096, X_Vel, Y_Vel, 0, 0, 256);
        else
          createNPC((NPCNames)108, v74->XPos - 0x4000, v74->YPos - 4096, X_Vel, Y_Vel, 0, 0, 256);
        playSoundEffect(SFXEnemyShootProjectile, 1);
        if ( !v74->count1 || v74->life < v74->curlyTargetX - 90 )
        {
          v74->currentState = 114;
          v74->waitTimer = 0;
          v74->animationNumber = 2;
          v74->animationTimer = 0;
          bossObjects[1].entityFlags &= 0xFFDFu;
        }
      }
      break;
    case 0x72:
      if ( ++v74->animationTimer > 10 )
      {
        if ( ++bossObjects[1].count1 <= 2 )
        {
          v74->currentState = 100;
        }
        else
        {
          bossObjects[1].count1 = 0;
          v74->currentState = 120;
        }
        v74->animationTimer = 0;
        v74->animationNumber = 1;
      }
      break;
    case 0x78:
      v74->currentState = 121;
      v74->waitTimer = 0;
      v74->animationNumber = 1;
      v74->XVel = 0;
      goto LABEL_73;
    case 0x79:
LABEL_73:
      if ( ++v74->waitTimer > 50 )
      {
        v74->currentState = 122;
        v74->animationTimer = 0;
        v74->animationNumber = 2;
      }
      break;
    case 0x7A:
      if ( ++v74->animationTimer > 20 )
      {
        v74->currentState = 123;
        v74->animationTimer = 0;
        v74->animationNumber = 1;
      }
      break;
    case 0x7B:
      if ( ++v74->animationTimer > 4 )
      {
        v74->currentState = 124;
        v74->animationNumber = 5;
        v74->YVel = -2560;
        v74->view.top = 0x8000;
        v74->view.bottom = 12288;
        playSoundEffect(SFXSillyExplosion, 1);
      }
      break;
    case 0x7C:
      if ( v74->collisionFlags & 8 )
      {
        playSoundEffect(SFXLargeObjectHitGround, 1);
        setQuake(60);
        v74->currentState = 100;
        v74->animationNumber = 1;
        v74->view.top = 24576;
        v74->view.bottom = 0x2000;
        for ( i = 0; i < 2; ++i )
        {
          v12 = random(0, 4) << 13;
          v13 = random(4, 16);
          createNPC((NPCNames)104, v13 << 13, v12, 0, 0, (Directions)4, 0, 128);
        }
        for ( i = 0; i < 6; ++i )
        {
          v14 = random(0, 4) << 13;
          v15 = random(4, 16);
          createNPC(NPCSantasKey|0x60, v15 << 13, v14, 0, 0, (Directions)4, 0, 128);
        }
        for ( i = 0; i < 8; ++i )
        {
          v16 = random(-1536, 0);
          v17 = random(-341, 341);
          v18 = v74->hitbox.bottom + v74->YPos;
          v19 = random(-12, 12);
          createNPC(NPCSmoke, v74->XPos + (v19 << 9), v18, v17, v16, 0, 0, 256);
        }
        if ( !v74->direction && v74->XPos < quote.XPos )
        {
          v74->direction = 2;
          v74->currentState = 110;
        }
        if ( v74->direction == 2 && v74->XPos > quote.XPos )
        {
          v74->direction = 0;
          v74->currentState = 110;
        }
      }
      break;
    case 0x82:
      v74->currentState = 131;
      v74->animationNumber = 3;
      v74->waitTimer = 0;
      v74->XVel = 0;
      playSoundEffect(SFXExplosion, 1);
      for ( i = 0; i < 8; ++i )
      {
        v20 = random(-1536, 0);
        v21 = random(-341, 341);
        v22 = v74->YPos + (random(-12, 12) << 9);
        v23 = random(-12, 12);
        createNPC(NPCSmoke, v74->XPos + (v23 << 9), v22, v21, v20, 0, 0, 256);
      }
      bossObjects[1].isAlive = 0;
      bossObjects[2].isAlive = 0;
      goto LABEL_103;
    case 0x83:
LABEL_103:
      if ( !(++v74->waitTimer % 5) )
      {
        v24 = random(-1536, 0);
        v25 = random(-341, 341);
        v26 = v74->YPos + (random(-12, 12) << 9);
        v27 = random(-12, 12);
        createNPC(NPCSmoke, v74->XPos + (v27 << 9), v26, v25, v24, 0, 0, 256);
      }
      if ( v74->waitTimer / 2 % 2 )
        v28 = v74->XPos - 512;
      else
        v28 = v74->XPos + 512;
      v74->XPos = v28;
      if ( v74->waitTimer > 100 )
      {
        v74->waitTimer = 0;
        v74->currentState = 132;
      }
      break;
    case 0x84:
      if ( ++v74->waitTimer / 2 % 2 )
      {
        v74->view.front = 10240;
        v74->view.top = 6144;
        v74->view.back = 10240;
        v74->view.bottom = 6144;
        v74->animationNumber = 6;
      }
      else
      {
        v74->view.front = 24576;
        v74->view.top = 24576;
        v74->view.back = 0x4000;
        v74->view.bottom = 0x2000;
        v74->animationNumber = 3;
      }
      if ( !(v74->waitTimer % 9) )
      {
        v29 = random(-1536, 0);
        v30 = random(-341, 341);
        v31 = v74->YPos + (random(-12, 12) << 9);
        v32 = random(-12, 12);
        createNPC(NPCSmoke, v74->XPos + (v32 << 9), v31, v30, v29, 0, 0, 256);
      }
      if ( v74->waitTimer > 150 )
      {
        v74->currentState = 140;
        v74->hitbox.bottom = 6144;
      }
      break;
    case 0x8C:
      v74->currentState = 141;
      goto LABEL_120;
    case 0x8D:
LABEL_120:
      if ( v74->collisionFlags & 8 )
      {
        v74->currentState = 142;
        v74->waitTimer = 0;
        v74->animationNumber = 7;
      }
      break;
    case 0x8E:
      if ( ++v74->waitTimer > 30 )
      {
        v74->animationNumber = 8;
        v74->YVel = -2560;
        v74->entityFlags |= 8u;
        v74->currentState = 143;
      }
      break;
    case 0x8F:
      v74->YVel = -2560;
      if ( v74->YPos < 0 )
      {
        v74->isAlive = 0;
        playSoundEffect(SFXLargeObjectHitGround, 1);
        setQuake(30);
      }
      break;
    default:
      break;
  }
  v74->YVel += 64;
  if ( v74->YVel > 1535 )
    v74->YVel = 1535;
  v74->XPos += v74->XVel;
  v74->YPos += v74->YVel;
  if ( v74->direction )
    v33 = &v36 + 4 * v74->animationNumber;
  else
    v33 = &v75 + 4 * v74->animationNumber;
  v34 = &v74->rect;
  v34->left = *v33;
  v34->top = v33[1];
  v34->right = v33[2];
  v34->bottom = v33[3];
  balfrogSubNPC1();
  balfrogSubNPC2();
}

//----- (0047A6A0) --------------------------------------------------------
void __cdecl balfrogSubNPC1()
{
  signed int Dir; // [esp+8h] [ebp-4h]

  if ( bossObjects[0].direction )
    Dir = -1;
  else
    Dir = 1;
  switch ( bossObjects[0].animationNumber )
  {
    case 0:
      bossObjects[1].hitSound = 52;
      bossObjects[1].hitbox.front = 0x2000;
      bossObjects[1].hitbox.top = 0x2000;
      bossObjects[1].hitbox.back = 0x2000;
      bossObjects[1].hitbox.bottom = 0x2000;
      bossObjects[1].explosionSize = 3;
      bossObjects[1].entityFlags = 4;
      break;
    case 1:
      bossObjects[1].XPos = bossObjects[0].XPos - 12288 * Dir;
      bossObjects[1].YPos = bossObjects[0].YPos - 12288;
      break;
    case 2:
      bossObjects[1].XPos = bossObjects[0].XPos - 12288 * Dir;
      bossObjects[1].YPos = bossObjects[0].YPos - 10240;
      break;
    case 3:
    case 4:
      bossObjects[1].XPos = bossObjects[0].XPos - 12288 * Dir;
      bossObjects[1].YPos = bossObjects[0].YPos - 0x2000;
      break;
    case 5:
      bossObjects[1].XPos = bossObjects[0].XPos - 12288 * Dir;
      bossObjects[1].YPos = bossObjects[0].YPos - 22016;
      break;
    default:
      return;
  }
}

//----- (0047A800) --------------------------------------------------------
void __cdecl balfrogSubNPC2()
{
  if ( bossObjects[0].animationNumber )
  {
    if ( bossObjects[0].animationNumber > 0 && bossObjects[0].animationNumber <= 5 )
    {
      bossObjects[2].XPos = bossObjects[0].XPos;
      bossObjects[2].YPos = bossObjects[0].YPos;
    }
  }
  else
  {
    bossObjects[2].hitSound = 52;
    bossObjects[2].hitbox.front = 12288;
    bossObjects[2].hitbox.top = 0x2000;
    bossObjects[2].hitbox.back = 12288;
    bossObjects[2].hitbox.bottom = 0x2000;
    bossObjects[2].explosionSize = 3;
    bossObjects[2].entityFlags = 4;
  }
}

//----- (0047A8A0) --------------------------------------------------------
RECT *Boss_5_Ironhead()
{
  int v0; // ST08_4
  int v1; // eax
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  int v5; // ST10_4
  int v6; // eax
  int v7; // ST10_4
  int v8; // ST0C_4
  int v9; // ST08_4
  int v10; // eax
  int v11; // ST10_4
  int v12; // ST0C_4
  int v13; // ST08_4
  int v14; // eax
  int *v15; // edx
  RECT *result; // eax
  int *v17; // edx
  int v18; // [esp+0h] [ebp-12Ch]
  signed int i; // [esp+8h] [ebp-124h]
  int v20; // [esp+Ch] [ebp-120h]
  int v21; // [esp+10h] [ebp-11Ch]
  int v22; // [esp+14h] [ebp-118h]
  int v23; // [esp+18h] [ebp-114h]
  int v24; // [esp+1Ch] [ebp-110h]
  int v25; // [esp+20h] [ebp-10Ch]
  int v26; // [esp+24h] [ebp-108h]
  int v27; // [esp+28h] [ebp-104h]
  int v28; // [esp+2Ch] [ebp-100h]
  int v29; // [esp+30h] [ebp-FCh]
  int v30; // [esp+34h] [ebp-F8h]
  int v31; // [esp+38h] [ebp-F4h]
  int v32; // [esp+3Ch] [ebp-F0h]
  int v33; // [esp+40h] [ebp-ECh]
  int v34; // [esp+44h] [ebp-E8h]
  int v35; // [esp+48h] [ebp-E4h]
  int v36; // [esp+4Ch] [ebp-E0h]
  int v37; // [esp+50h] [ebp-DCh]
  int v38; // [esp+54h] [ebp-D8h]
  int v39; // [esp+58h] [ebp-D4h]
  int v40; // [esp+5Ch] [ebp-D0h]
  int v41; // [esp+60h] [ebp-CCh]
  int v42; // [esp+64h] [ebp-C8h]
  int v43; // [esp+68h] [ebp-C4h]
  int v44; // [esp+6Ch] [ebp-C0h]
  int v45; // [esp+70h] [ebp-BCh]
  int v46; // [esp+74h] [ebp-B8h]
  int v47; // [esp+78h] [ebp-B4h]
  int v48; // [esp+7Ch] [ebp-B0h]
  int v49; // [esp+80h] [ebp-ACh]
  int v50; // [esp+84h] [ebp-A8h]
  int v51; // [esp+88h] [ebp-A4h]
  int v52; // [esp+8Ch] [ebp-A0h]
  int v53; // [esp+90h] [ebp-9Ch]
  int v54; // [esp+94h] [ebp-98h]
  int v55; // [esp+98h] [ebp-94h]
  int v56; // [esp+9Ch] [ebp-90h]
  int v57; // [esp+A0h] [ebp-8Ch]
  int v58; // [esp+A4h] [ebp-88h]
  int v59; // [esp+A8h] [ebp-84h]
  int v60; // [esp+ACh] [ebp-80h]
  int v61; // [esp+B0h] [ebp-7Ch]
  int v62; // [esp+B4h] [ebp-78h]
  int v63; // [esp+B8h] [ebp-74h]
  int v64; // [esp+BCh] [ebp-70h]
  int v65; // [esp+C0h] [ebp-6Ch]
  int v66; // [esp+C4h] [ebp-68h]
  int v67; // [esp+C8h] [ebp-64h]
  int v68; // [esp+CCh] [ebp-60h]
  int v69; // [esp+D0h] [ebp-5Ch]
  int v70; // [esp+D4h] [ebp-58h]
  int v71; // [esp+D8h] [ebp-54h]
  int v72; // [esp+DCh] [ebp-50h]
  int v73; // [esp+E0h] [ebp-4Ch]
  int v74; // [esp+E4h] [ebp-48h]
  int v75; // [esp+E8h] [ebp-44h]
  int v76; // [esp+ECh] [ebp-40h]
  int v77; // [esp+F0h] [ebp-3Ch]
  int v78; // [esp+F4h] [ebp-38h]
  int v79; // [esp+F8h] [ebp-34h]
  int v80; // [esp+FCh] [ebp-30h]
  int v81; // [esp+100h] [ebp-2Ch]
  int v82; // [esp+104h] [ebp-28h]
  int v83; // [esp+108h] [ebp-24h]
  int v84; // [esp+10Ch] [ebp-20h]
  int v85; // [esp+110h] [ebp-1Ch]
  int v86; // [esp+114h] [ebp-18h]
  int v87; // [esp+118h] [ebp-14h]
  int v88; // [esp+11Ch] [ebp-10h]
  int v89; // [esp+120h] [ebp-Ch]
  int v90; // [esp+124h] [ebp-8h]
  int v91; // [esp+128h] [ebp-4h]

  v18 = bossObjects[0].currentState;
  if ( v18 <= 250 )
  {
    if ( v18 != 250 )
    {
      switch ( v18 )
      {
        case 0:
          bossObjects[0].isAlive = -128;
          bossObjects[0].EXPAmount = 1;
          bossObjects[0].direction = 2;
          bossObjects[0].currentState = 100;
          bossObjects[0].XPos = 81920;
          bossObjects[0].YPos = 0x10000;
          bossObjects[0].view.front = 20480;
          bossObjects[0].view.top = 6144;
          bossObjects[0].view.back = 12288;
          bossObjects[0].view.bottom = 6144;
          bossObjects[0].hitSound = 54;
          bossObjects[0].hitbox.front = 0x2000;
          bossObjects[0].hitbox.top = 5120;
          bossObjects[0].hitbox.back = 0x2000;
          bossObjects[0].hitbox.bottom = 5120;
          bossObjects[0].entityFlags = -32216;
          bossObjects[0].explosionSize = 3;
          bossObjects[0].damage = 10;
          bossObjects[0].entityEventNum = 1000;
          bossObjects[0].life = 400;
          goto LABEL_60;
        case 100:
          bossObjects[0].currentState = 101;
          bossObjects[0].entityFlags &= 0xFFDFu;
          bossObjects[0].waitTimer = 0;
          break;
        case 101:
          break;
        default:
          goto LABEL_60;
      }
      if ( ++bossObjects[0].waitTimer > 50 )
      {
        bossObjects[0].currentState = 250;
        bossObjects[0].waitTimer = 0;
      }
      if ( !(bossObjects[0].waitTimer % 4) )
      {
        v0 = random(2, 13) << 13;
        v1 = random(15, 18);
        createNPC((NPCNames)197, v1 << 13, v0, 0, 0, 0, 0, 256);
      }
      goto LABEL_60;
    }
    bossObjects[0].currentState = 251;
    if ( bossObjects[0].direction == 2 )
    {
      bossObjects[0].XPos = 122880;
      bossObjects[0].YPos = quote.YPos;
    }
    else
    {
      bossObjects[0].XPos = 368640;
      bossObjects[0].YPos = random(2, 13) << 13;
    }
    bossObjects[0].curlyTargetX = bossObjects[0].XPos;
    bossObjects[0].curlyTargetY = bossObjects[0].YPos;
    bossObjects[0].YVel = random(-512, 512);
    bossObjects[0].XVel = random(-512, 512);
    bossObjects[0].entityFlags |= 0x20u;
LABEL_22:
    if ( bossObjects[0].direction == 2 )
    {
      bossObjects[0].curlyTargetX += 1024;
    }
    else
    {
      bossObjects[0].curlyTargetX -= 512;
      if ( bossObjects[0].curlyTargetY >= quote.YPos )
        v2 = bossObjects[0].curlyTargetY - 512;
      else
        v2 = bossObjects[0].curlyTargetY + 512;
      bossObjects[0].curlyTargetY = v2;
    }
    if ( bossObjects[0].XPos >= bossObjects[0].curlyTargetX )
      v3 = bossObjects[0].XVel - 8;
    else
      v3 = bossObjects[0].XVel + 8;
    bossObjects[0].XVel = v3;
    if ( bossObjects[0].YPos >= bossObjects[0].curlyTargetY )
      v4 = bossObjects[0].YVel - 8;
    else
      v4 = bossObjects[0].YVel + 8;
    bossObjects[0].YVel = v4;
    if ( bossObjects[0].YVel > 512 )
      bossObjects[0].YVel = 512;
    if ( bossObjects[0].YVel < -512 )
      bossObjects[0].YVel = -512;
    bossObjects[0].XPos += bossObjects[0].XVel;
    bossObjects[0].YPos += bossObjects[0].YVel;
    if ( bossObjects[0].direction == 2 )
    {
      if ( bossObjects[0].XPos > 368640 )
      {
        bossObjects[0].direction = 0;
        bossObjects[0].currentState = 100;
      }
    }
    else if ( bossObjects[0].XPos < 139264 )
    {
      bossObjects[0].direction = 2;
      bossObjects[0].currentState = 100;
    }
    if ( !bossObjects[0].direction
      && (++bossObjects[0].waitTimer == 300 || bossObjects[0].waitTimer == 310 || bossObjects[0].waitTimer == 320) )
    {
      playSoundEffect(SFXEnemyShootProjectile, 1);
      v5 = random(-3, 3) << 9;
      v6 = random(-3, 0);
      createNPC((NPCNames)198, bossObjects[0].XPos + 5120, bossObjects[0].YPos + 512, v6 << 9, v5, right, 0, 256);
    }
    if ( ++bossObjects[0].animationTimer > 2 )
    {
      bossObjects[0].animationTimer = 0;
      ++bossObjects[0].animationNumber;
    }
    if ( bossObjects[0].animationNumber > 7 )
      bossObjects[0].animationNumber = 0;
    goto LABEL_60;
  }
  switch ( v18 )
  {
    case 251:
      goto LABEL_22;
    case 1000:
      bossObjects[0].entityFlags &= 0xFFDFu;
      bossObjects[0].animationNumber = 8;
      bossObjects[0].damage = 0;
      bossObjects[0].currentState = 1001;
      bossObjects[0].curlyTargetX = bossObjects[0].XPos;
      bossObjects[0].curlyTargetY = bossObjects[0].YPos;
      setQuake(20);
      for ( i = 0; i < 32; ++i )
      {
        v7 = random(-128, 128) << 9;
        v8 = random(-128, 128) << 9;
        v9 = bossObjects[0].YPos + (random(-64, 64) << 9);
        v10 = random(-128, 128);
        createNPC(NPCSmoke, bossObjects[0].XPos + (v10 << 9), v9, v8, v7, 0, 0, 256);
      }
      killNPC(197, 1);
      killNPC(271, 1);
      killNPC(272, 1);
      break;
    case 1001:
      break;
    default:
      goto LABEL_60;
  }
  bossObjects[0].curlyTargetX -= 512;
  bossObjects[0].XPos = bossObjects[0].curlyTargetX + (random(-1, 1) << 9);
  bossObjects[0].YPos = bossObjects[0].curlyTargetY + (random(-1, 1) << 9);
  if ( !(++bossObjects[0].waitTimer % 4) )
  {
    v11 = random(-128, 128) << 9;
    v12 = random(-128, 128) << 9;
    v13 = bossObjects[0].YPos + (random(-64, 64) << 9);
    v14 = random(-128, 128);
    createNPC(NPCSmoke, bossObjects[0].XPos + (v14 << 9), v13, v12, v11, 0, 0, 256);
  }
LABEL_60:
  v20 = 0;
  v21 = 0;
  v22 = 64;
  v23 = 24;
  v24 = 64;
  v25 = 0;
  v26 = 128;
  v27 = 24;
  v28 = 128;
  v29 = 0;
  v30 = 192;
  v31 = 24;
  v32 = 64;
  v33 = 0;
  v34 = 128;
  v35 = 24;
  v36 = 0;
  v37 = 0;
  v38 = 64;
  v39 = 24;
  v40 = 192;
  v41 = 0;
  v42 = 256;
  v43 = 24;
  v44 = 256;
  v45 = 0;
  v46 = 320;
  v47 = 24;
  v48 = 192;
  v49 = 0;
  v50 = 256;
  v51 = 24;
  v52 = 256;
  v53 = 48;
  v54 = 320;
  v55 = 72;
  v56 = 0;
  v57 = 24;
  v58 = 64;
  v59 = 48;
  v60 = 64;
  v61 = 24;
  v62 = 128;
  v63 = 48;
  v64 = 128;
  v65 = 24;
  v66 = 192;
  v67 = 48;
  v68 = 64;
  v69 = 24;
  v70 = 128;
  v71 = 48;
  v72 = 0;
  v73 = 24;
  v74 = 64;
  v75 = 48;
  v76 = 192;
  v77 = 24;
  v78 = 256;
  v79 = 48;
  v80 = 256;
  v81 = 24;
  v82 = 320;
  v83 = 48;
  v84 = 192;
  v85 = 24;
  v86 = 256;
  v87 = 48;
  v88 = 256;
  v89 = 48;
  v90 = 320;
  v91 = 72;
  if ( bossObjects[0].isBeingHit )
  {
    ++byte_4BBA41[0];
    if ( byte_4BBA41[0] / 2 % 2 )
      v15 = &v20 + 4 * bossObjects[0].animationNumber;
    else
      v15 = &v56 + 4 * bossObjects[0].animationNumber;
    result = &bossObjects[0].rect;
    result->left = *v15;
    result->top = v15[1];
    result->right = v15[2];
    result->bottom = v15[3];
  }
  else
  {
    v17 = &v20 + 4 * bossObjects[0].animationNumber;
    result = &bossObjects[0].rect;
    result->left = *v17;
    result->top = v17[1];
    result->right = v17[2];
    result->bottom = v17[3];
  }
  return result;
}

//----- (0047B460) --------------------------------------------------------
signed int __cdecl startBossLife(int Entity_Eve_Num)
{
  signed int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 512 && NPCObjects[i].entityEventNum != Entity_Eve_Num; ++i )
    ;
  if ( i == 512 )
    return 0;
  bossThing.flag = 1;
  bossThing.max = NPCObjects[i].life;
  bossThing.br = NPCObjects[i].life;
  bossThing.pLife = &NPCObjects[i].life;
  return 1;
}

//----- (0047B500) --------------------------------------------------------
signed int startBossLife2()
{
  bossThing.flag = 1;
  bossThing.max = bossObjects[0].life;
  bossThing.br = bossObjects[0].life;
  bossThing.pLife = &bossObjects[0].life;
  return 1;
}

//----- (0047B540) --------------------------------------------------------
void drawBossHealth()
{
  RECT rect; // [esp+0h] [ebp-50h]
  RECT v1; // [esp+10h] [ebp-40h]
  RECT v2; // [esp+20h] [ebp-30h]
  RECT v3; // [esp+30h] [ebp-20h]
  RECT v4; // [esp+40h] [ebp-10h]

  v2.left = 0;
  v2.top = 48;
  v2.right = 32;
  v2.bottom = 56;
  rect.left = 0;
  rect.top = 0;
  rect.right = 244;
  rect.bottom = 8;
  v3.left = 0;
  v3.top = 16;
  v3.right = 244;
  v3.bottom = 24;
  v4.left = 0;
  v4.top = 24;
  v4.right = 0;
  v4.bottom = 32;
  v1.left = 0;
  v1.top = 32;
  v1.right = 232;
  v1.bottom = 40;
  if ( bossThing.flag )
  {
    if ( *bossThing.pLife >= 1 )
    {
      v4.right = 198 * *bossThing.pLife / bossThing.max;
      if ( bossThing.br <= *bossThing.pLife )
      {
        bossThing.count = 0;
      }
      else if ( ++bossThing.count > 30 )
      {
        --bossThing.br;
      }
      v1.right = 198 * bossThing.br / bossThing.max;
      drawBitmapWithTransparency(&gameRect, 32, 220, &rect, 26);
      drawBitmapWithTransparency(&gameRect, 32, 228, &v3, 26);
      drawBitmapWithTransparency(&gameRect, 72, 224, &v1, 26);
      drawBitmapWithTransparency(&gameRect, 72, 224, &v4, 26);
      drawBitmapWithTransparency(&gameRect, 40, 224, &v2, 26);
    }
    else
    {
      bossThing.flag = 0;
    }
  }
}

//----- (0047B6F0) --------------------------------------------------------
// Boss 1 : Omega
// Omega's AI.
void Boss_1_Omega()
{
  int Child_X_Vel; // eax MAPDST
  int Dust_Y_Pos; // ST14_4
  int Dust_X_Pos; // eax
  RECT *Chosen_Rect; // eax
  RECT Rects[4]; // [esp+4h] [ebp-40h]

  switch ( bossObjects[0].currentState )
  {
    case 0:
      bossObjects[0].XPos = 0x1B6000;
      bossObjects[0].YPos = 0x20000;
      bossObjects[0].view.front = 0x5000;
      bossObjects[0].view.top = 0x5000;
      bossObjects[0].view.back = 0x5000;
      bossObjects[0].view.bottom = 0x2000;
      bossObjects[0].curlyTargetX = 0x1B6000;
      bossObjects[0].curlyTargetY = 0x20000;
      bossObjects[0].hitSound = 52;
      bossObjects[0].hitbox.front = 0x1000;
      bossObjects[0].hitbox.top = 0x3000;
      bossObjects[0].hitbox.back = 0x1000;
      bossObjects[0].hitbox.bottom = 0x2000;
      bossObjects[0].entityFlags = -32248;
      bossObjects[0].explosionSize = 3;
      bossObjects[0].EXPAmount = 1;
      bossObjects[0].entityEventNum = 210;
      bossObjects[0].life = 400;
      bossObjects[1].isAlive = 0x80u;
      bossObjects[1].view.front = 0x1800;
      bossObjects[1].view.top = 0x1000;
      bossObjects[1].view.back = 0x1800;
      bossObjects[1].view.bottom = 0x1000;
      bossObjects[1].entityFlags = 8;
      qmemcpy(&bossObjects[2], &bossObjects[1], sizeof(NPC));
      bossObjects[1].direction = 0;
      bossObjects[2].direction = 2;
      bossObjects[3].isAlive = 0x80u;
      bossObjects[3].view.front = 0x3000;
      bossObjects[3].view.top = 0x2000;
      bossObjects[3].view.back = 0x2000;
      bossObjects[3].view.bottom = 0x2000;
      bossObjects[3].hitSound = 52;
      bossObjects[3].hitbox.front = 0x1000;
      bossObjects[3].hitbox.top = 0x1000;
      bossObjects[3].hitbox.back = 0x1000;
      bossObjects[3].hitbox.bottom = 0x1000;
      bossObjects[3].entityFlags = 8;
      bossObjects[3].XPos = 0x1B4000;
      bossObjects[3].YPos = 0x20000;
      bossObjects[3].direction = 0;
      qmemcpy(&bossObjects[4], &bossObjects[3], sizeof(NPC));
      bossObjects[4].direction = 2;
      bossObjects[3].XPos = 0x1B8000;
      bossObjects[5].isAlive = 0x80u;
      break;
    case 20:
      bossObjects[0].currentState = 30;
      bossObjects[0].waitTimer = 0;
      bossObjects[0].animationNumber = 0;
      goto case_30;
    case 30:
case_30:
      setQuake(2);
      bossObjects[0].YPos -= 512;
      if ( !(++bossObjects[0].waitTimer % 4) )
        playSoundEffect(SFXLargeObjectHitGround, 1);
      if ( bossObjects[0].waitTimer == 48 )
      {
        bossObjects[0].waitTimer = 0;
        bossObjects[0].currentState = 40;
        if ( bossObjects[0].life <= 280 )
        {
          bossObjects[0].currentState = 110;
          bossObjects[0].entityFlags |= 0x20u;
          bossObjects[0].entityFlags &= 0xFFF7u;
          bossObjects[3].entityFlags &= 0xFFF7u;
          bossObjects[4].entityFlags &= 0xFFF7u;
          bossObjects[3].currentState = 3;
          bossObjects[4].currentState = 3;
          bossObjects[5].hitbox.top = 0x2000;
        }
      }
      break;
    case 40:
      if ( ++bossObjects[0].waitTimer == 48 )
      {
        bossObjects[0].waitTimer = 0;
        bossObjects[0].currentState = 50;
        bossObjects[0].animationTimer = 0;
        bossObjects[5].hitbox.top = 0x2000;
        playSoundEffect(SFXSandCroc, 1);
      }
      break;
    case 50:
      if ( ++bossObjects[0].animationTimer > 2 )
      {
        bossObjects[0].animationTimer = 0;
        ++bossObjects[0].animationNumber;
      }
      if ( bossObjects[0].animationNumber == 3 )
      {
        bossObjects[0].currentState = 60;
        bossObjects[0].waitTimer = 0;
        bossObjects[0].entityFlags |= 0x20u;
        bossObjects[0].hitbox.front = 0x2000;
        bossObjects[0].hitbox.back = 0x2000;
      }
      break;
    case 60:
      if ( ++bossObjects[0].waitTimer > 20 && bossObjects[0].waitTimer < 80 && !(bossObjects[0].waitTimer % 3) )
      {
        if ( random(0, 9) >= 8 )
        {
          Child_X_Vel = random(-256, 256);
          createNPC((NPCNames)48, bossObjects[0].XPos, bossObjects[0].YPos - 0x2000, Child_X_Vel, -819, right, 0, 256);
        }
        else
        {
          Child_X_Vel = random(-256, 256);
          createNPC((NPCNames)48, bossObjects[0].XPos, bossObjects[0].YPos - 0x2000, Child_X_Vel, -819, 0, 0, 256);
        }
        playSoundEffect(SFXEnemyShootProjectile, 1);
      }
      if ( bossObjects[0].waitTimer == 200 || countBullets(bulletPolarStarLevel3) )
      {
        bossObjects[0].animationTimer = 0;
        bossObjects[0].currentState = 70;
        playSoundEffect(SFXSandCroc, 1);
      }
      break;
    case 70:
      if ( ++bossObjects[0].animationTimer > 2 )
      {
        bossObjects[0].animationTimer = 0;
        --bossObjects[0].animationNumber;
      }
      if ( bossObjects[0].animationNumber == 1 )
        bossObjects[0].damage = 20;
      if ( !bossObjects[0].animationNumber )
      {
        playSoundEffect(SFXSandCroc, 0);
        playSoundEffect(SFXDestroyBreakableBlock, 1);
        bossObjects[0].currentState = 80;
        bossObjects[0].waitTimer = 0;
        bossObjects[0].entityFlags &= 0xFFDFu;
        bossObjects[0].hitbox.front = 12288;
        bossObjects[0].hitbox.back = 12288;
        bossObjects[5].hitbox.top = 18432;
        bossObjects[0].damage = 0;
      }
      break;
    case 80:
      if ( ++bossObjects[0].waitTimer == 48 )
      {
        bossObjects[0].waitTimer = 0;
        bossObjects[0].currentState = 90;
      }
      break;
    case 90:
      setQuake(2);
      bossObjects[0].YPos += 512;
      if ( !(++bossObjects[0].waitTimer % 4) )
        playSoundEffect(SFXLargeObjectHitGround, 1);
      if ( bossObjects[0].waitTimer == 48 )
      {
        bossObjects[0].waitTimer = 0;
        bossObjects[0].currentState = 100;
      }
      break;
    case 100:
      if ( ++bossObjects[0].waitTimer == 120 )
      {
        bossObjects[0].waitTimer = 0;
        bossObjects[0].currentState = 30;
        bossObjects[0].XPos = bossObjects[0].curlyTargetX + (random(-64, 64) << 9);
        bossObjects[0].YPos = bossObjects[0].curlyTargetY;
      }
      break;
    case 110:
      if ( ++bossObjects[0].animationTimer > 2 )
      {
        bossObjects[0].animationTimer = 0;
        ++bossObjects[0].animationNumber;
      }
      if ( bossObjects[0].animationNumber == 3 )
      {
        bossObjects[0].currentState = 120;
        bossObjects[0].waitTimer = 0;
        bossObjects[0].hitbox.front = 0x2000;
        bossObjects[0].hitbox.back = 0x2000;
      }
      break;
    case 120:
      if ( ++bossObjects[0].waitTimer == 50 || countBullets(bulletPolarStarLevel3) )
      {
        bossObjects[0].currentState = 130;
        playSoundEffect(SFXSandCroc, 1);
        bossObjects[0].waitTimer = 0;
        bossObjects[0].animationTimer = 0;
      }
      if ( bossObjects[0].waitTimer < 30 && !(bossObjects[0].waitTimer % 5) )
      {
        Child_X_Vel = random(-341, 341);
        createNPC((NPCNames)48, bossObjects[0].XPos, bossObjects[0].YPos - 0x2000, Child_X_Vel, -819, 0, 0, 256);
        playSoundEffect(SFXEnemyShootProjectile, 1);
      }
      break;
    case 130:
      if ( ++bossObjects[0].animationTimer > 2 )
      {
        bossObjects[0].animationTimer = 0;
        --bossObjects[0].animationNumber;
      }
      if ( bossObjects[0].animationNumber == 1 )
        bossObjects[0].damage = 20;
      if ( !bossObjects[0].animationNumber )
      {
        bossObjects[0].currentState = 140;
        bossObjects[0].entityFlags |= 0x20u;
        bossObjects[0].hitbox.front = 0x2000;
        bossObjects[0].hitbox.back = 0x2000;
        bossObjects[0].YVel = -1535;
        playSoundEffect(SFXSandCroc, 0);
        playSoundEffect(SFXDestroyBreakableBlock, 1);
        playSoundEffect(SFXSillyExplosion, 1);
        if ( bossObjects[0].XPos < quote.XPos )
          bossObjects[0].XVel = 256;
        if ( bossObjects[0].XPos > quote.XPos )
          bossObjects[0].XVel = -256;
        bossObjects[0].damage = 0;
        bossObjects[5].hitbox.top = 18432;
      }
      break;
    case 140:
      if ( quote.collisionFlags & 8 && bossObjects[0].YVel > 0 )
        bossObjects[5].damage = 20;
      else
        bossObjects[5].damage = 0;
      bossObjects[0].YVel += 36;
      if ( bossObjects[0].YVel > 1535 )
        bossObjects[0].YVel = 1535;
      bossObjects[0].YPos += bossObjects[0].YVel;
      bossObjects[0].XPos += bossObjects[0].XVel;
      if ( bossObjects[0].collisionFlags & 8 )
      {
        bossObjects[0].currentState = 110;
        bossObjects[0].waitTimer = 0;
        bossObjects[0].animationTimer = 0;
        bossObjects[5].hitbox.top = 0x2000;
        bossObjects[5].damage = 0;
        playSoundEffect(SFXLargeObjectHitGround, 1);
        playSoundEffect(SFXDestroyBreakableBlock, 1);
        setQuake(30);
      }
      break;
    case 150:
      setQuake(2);
      if ( !(++bossObjects[0].waitTimer % 12) )
        playSoundEffect(SFXBehemothLargeHurt, 1);
      Dust_Y_Pos = bossObjects[0].YPos + (random(-48, 24) << 9);
      Dust_X_Pos = random(-48, 48);
      createDustClouds(bossObjects[0].XPos + (Dust_X_Pos << 9), Dust_Y_Pos, 1, 1);
      if ( bossObjects[0].waitTimer > 100 )
      {
        bossObjects[0].waitTimer = 0;
        bossObjects[0].currentState = 160;
        startFlash(bossObjects[0].XPos, bossObjects[0].YPos, 1);
        playSoundEffect(SFXlargeExplosion, 1);
      }
      break;
    case 160:
      setQuake(40);
      if ( ++bossObjects[0].waitTimer > 50 )
      {
        bossObjects[0].isAlive = 0;
        bossObjects[1].isAlive = 0;
        bossObjects[2].isAlive = 0;
        bossObjects[3].isAlive = 0;
        bossObjects[4].isAlive = 0;
        bossObjects[5].isAlive = 0;
      }
      break;
    default:
      break;
  }
  Rects[0].left = 0;
  Rects[0].top = 0;
  Rects[0].right = 80;
  Rects[0].bottom = 56;
  Rects[1].left = 80;
  Rects[1].top = 0;
  Rects[1].right = 160;
  Rects[1].bottom = 56;
  Rects[2].left = 160;
  Rects[2].top = 0;
  Rects[2].right = 240;
  Rects[2].bottom = 56;
  Rects[3].left = 80;
  Rects[3].top = 0;
  Rects[3].right = 160;
  Rects[3].bottom = 56;
  Chosen_Rect = &Rects[bossObjects[0].animationNumber];
  bossObjects[0].rect.left = Chosen_Rect->left;
  bossObjects[0].rect.top = Chosen_Rect->top;
  bossObjects[0].rect.right = Chosen_Rect->right;
  bossObjects[0].rect.bottom = Chosen_Rect->bottom;
  bossObjects[1].isBeingHit = bossObjects[0].isBeingHit;
  bossObjects[2].isBeingHit = bossObjects[0].isBeingHit;
  bossObjects[3].isBeingHit = bossObjects[0].isBeingHit;
  bossObjects[4].isBeingHit = bossObjects[0].isBeingHit;
  Omega_Sub_NPC_1();
  Omega_Sub_NPC_2();
  Omega_Sub_NPC_3();
  if ( !bossObjects[0].life && bossObjects[0].currentState < 150 )// If boss ded
  {
    bossObjects[0].currentState = 150;
    bossObjects[0].waitTimer = 0;
    bossObjects[0].damage = 0;
    bossObjects[5].damage = 0;
    killNPC(48, 1);
  }
}

//----- (0047C380) --------------------------------------------------------
void __cdecl Omega_Sub_NPC_2()
{
  RECT Rect_Right[1]; // [esp+0h] [ebp-24h]
  int i; // [esp+10h] [ebp-14h]
  RECT Rect_Left[1]; // [esp+14h] [ebp-10h]

  Rect_Left[0].left = 80;
  Rect_Left[0].top = 56;
  Rect_Left[0].right = 104;
  Rect_Left[0].bottom = 72;
  Rect_Right[0].left = 104;
  Rect_Right[0].top = 56;
  Rect_Right[0].right = 128;
  Rect_Right[0].bottom = 72;
  for ( i = 1; i < 3; ++i )
  {
    bossObjects[i].YPos = (bossObjects[0].YPos + bossObjects[i + 2].YPos - 4096) / 2;
    if ( bossObjects[i].direction )
    {
      bossObjects[i].rect = Rect_Right[bossObjects[i].animationNumber];
      bossObjects[i].XPos = bossObjects[0].XPos + 0x2000;
    }
    else
    {
      bossObjects[i].XPos = bossObjects[0].XPos - 0x2000;
      bossObjects[i].rect = Rect_Left[bossObjects[i].animationNumber];
    }
  }
}

//----- (0047C4E0) --------------------------------------------------------
void __cdecl Omega_Sub_NPC_1()
{
  RECT *v0; // eax
  int Boss_Objects_Current_State; // [esp+0h] [ebp-48h]
  RECT Rects_Right[2]; // [esp+4h] [ebp-44h]
  int i; // [esp+24h] [ebp-24h]
  RECT Rects_Left[2]; // [esp+28h] [ebp-20h]

  Rects_Left[0].left = 0;
  Rects_Left[0].top = 56;
  Rects_Left[0].right = 40;
  Rects_Left[0].bottom = 88;
  Rects_Left[1].left = 40;
  Rects_Left[1].top = 56;
  Rects_Left[1].right = 80;
  Rects_Left[1].bottom = 88;
  Rects_Right[0].left = 0;
  Rects_Right[0].top = 88;
  Rects_Right[0].right = 40;
  Rects_Right[0].bottom = 120;
  Rects_Right[1].left = 40;
  Rects_Right[1].top = 88;
  Rects_Right[1].right = 80;
  Rects_Right[1].bottom = 120;
  for ( i = 3; i < 5; ++i )
  {
    Boss_Objects_Current_State = bossObjects[i].currentState;
    if ( Boss_Objects_Current_State )
    {
      if ( Boss_Objects_Current_State != 1 )
      {
        if ( Boss_Objects_Current_State == 3 )
        {
          bossObjects[i].curlyTargetY = bossObjects[0].YPos + 12288;
          if ( i == 3 )
            bossObjects[3].XPos = bossObjects[0].XPos - 0x2000;
          if ( i == 4 )
            bossObjects[4].XPos = bossObjects[0].XPos + 0x2000;
          bossObjects[i].YPos += (bossObjects[i].curlyTargetY - bossObjects[i].YPos) / 2;
        }
        goto LABEL_18;
      }
    }
    else
    {
      bossObjects[i].currentState = 1;
    }
    // Boss_Objects_Current_State == 1
    bossObjects[i].YPos = bossObjects[0].YPos;
    if ( i == 3 )
      bossObjects[3].XPos = bossObjects[0].XPos - 0x2000;
    if ( i == 4 )
      bossObjects[4].XPos = bossObjects[0].XPos + 0x2000;
LABEL_18:
    bossObjects[i].animationNumber = !(bossObjects[i].collisionFlags & 8)
                                  && bossObjects[i].YPos > bossObjects[i].curlyTargetY;
    if ( bossObjects[i].direction )
      v0 = &Rects_Right[bossObjects[i].animationNumber];
    else
      v0 = &Rects_Left[bossObjects[i].animationNumber];
    bossObjects[i].rect = *v0;
  }
}

//----- (0047C7A0) --------------------------------------------------------
void __cdecl Omega_Sub_NPC_3()
{
  if ( !bossObjects[5].currentState )
  {
    bossObjects[5].entityFlags |= 9u;
    bossObjects[5].hitbox.front = 10240;
    bossObjects[5].hitbox.top = 18432;
    bossObjects[5].hitbox.back = 10240;
    bossObjects[5].hitbox.bottom = 0x2000;
    bossObjects[5].currentState = 1;
    goto Current_State_1;
  }
  if ( bossObjects[5].currentState == 1 )
  {
Current_State_1:
    bossObjects[5].XPos = bossObjects[0].XPos;
    bossObjects[5].YPos = bossObjects[0].YPos;
  }
}

//----- (0047C820) --------------------------------------------------------
RECT *Boss_8_Heavy_Press()
{
  int v0; // ST14_4
  int v1; // eax
  int v2; // eax
  int v3; // ST14_4
  int v4; // eax
  int *v5; // edx
  RECT *result; // eax
  int *v7; // edx
  int v8; // [esp+0h] [ebp-70h]
  signed int i; // [esp+8h] [ebp-68h]
  signed int k; // [esp+8h] [ebp-68h]
  signed int j; // [esp+8h] [ebp-68h]
  int v12; // [esp+10h] [ebp-60h]
  int v13; // [esp+14h] [ebp-5Ch]
  int v14; // [esp+18h] [ebp-58h]
  int v15; // [esp+1Ch] [ebp-54h]
  int v16; // [esp+20h] [ebp-50h]
  int v17; // [esp+24h] [ebp-4Ch]
  int v18; // [esp+28h] [ebp-48h]
  int v19; // [esp+2Ch] [ebp-44h]
  int v20; // [esp+30h] [ebp-40h]
  int v21; // [esp+34h] [ebp-3Ch]
  int v22; // [esp+38h] [ebp-38h]
  int v23; // [esp+3Ch] [ebp-34h]
  int v24; // [esp+40h] [ebp-30h]
  int v25; // [esp+44h] [ebp-2Ch]
  int v26; // [esp+48h] [ebp-28h]
  int v27; // [esp+4Ch] [ebp-24h]
  int v28; // [esp+50h] [ebp-20h]
  int v29; // [esp+54h] [ebp-1Ch]
  int v30; // [esp+58h] [ebp-18h]
  int v31; // [esp+5Ch] [ebp-14h]
  int v32; // [esp+60h] [ebp-10h]
  int v33; // [esp+64h] [ebp-Ch]
  int v34; // [esp+68h] [ebp-8h]
  int v35; // [esp+6Ch] [ebp-4h]

  v8 = bossObjects[0].currentState;
  if ( v8 <= 31 )
  {
    if ( v8 == 31 )
    {
LABEL_20:
      bossObjects[0].YPos += 2048;
      if ( bossObjects[0].YPos >= 211456 )
      {
        bossObjects[0].YPos = 211456;
        bossObjects[0].animationNumber = 0;
        bossObjects[0].currentState = 20;
        playSoundEffect(SFXMissileImpact, 1);
        for ( i = 0; i < 5; ++i )
        {
          v2 = random(-40, 40);
          createNPC(NPCSmoke, bossObjects[0].XPos + (v2 << 9), bossObjects[0].YPos + 30720, 0, 0, 0, 0, 256);
        }
      }
    }
    else
    {
      switch ( v8 )
      {
        case 0:
          bossObjects[0].currentState = 10;
          bossObjects[0].isAlive = -128;
          bossObjects[0].EXPAmount = 1;
          bossObjects[0].direction = 2;
          bossObjects[0].XPos = 0;
          bossObjects[0].YPos = 0;
          bossObjects[0].view.front = 20480;
          bossObjects[0].view.top = 30720;
          bossObjects[0].view.back = 20480;
          bossObjects[0].view.bottom = 30720;
          bossObjects[0].hitSound = 54;
          bossObjects[0].hitbox.front = 25088;
          bossObjects[0].hitbox.top = 30720;
          bossObjects[0].hitbox.back = 20480;
          bossObjects[0].hitbox.bottom = 24576;
          bossObjects[0].entityFlags = -32184;
          bossObjects[0].explosionSize = 3;
          bossObjects[0].damage = 10;
          bossObjects[0].entityEventNum = 1000;
          bossObjects[0].life = 700;
          goto LABEL_57;
        case 5:
          bossObjects[0].currentState = 6;
          bossObjects[0].XPos = 0;
          bossObjects[0].YPos = 0;
          bossObjects[1].isAlive = 0;
          bossObjects[2].isAlive = 0;
          goto LABEL_57;
        case 10:
          bossObjects[0].currentState = 11;
          bossObjects[0].XPos = 81920;
          bossObjects[0].YPos = 37888;
          goto LABEL_57;
        case 20:
          bossObjects[0].damage = 0;
          bossObjects[0].currentState = 21;
          bossObjects[0].XPos = 81920;
          bossObjects[0].YPos = 211456;
          bossObjects[0].entityFlags &= 0xFFBFu;
          bossObjects[1].isAlive = 0;
          bossObjects[2].isAlive = 0;
          goto LABEL_16;
        case 21:
LABEL_16:
          if ( !(++bossObjects[0].waitTimer % 16) )
          {
            v0 = bossObjects[0].YPos + (random(-60, 60) << 9);
            v1 = random(-40, 40);
            createDustClouds(bossObjects[0].XPos + (v1 << 9), v0, 1, 1);
          }
          break;
        case 30:
          bossObjects[0].currentState = 31;
          bossObjects[0].animationNumber = 2;
          bossObjects[0].XPos = 81920;
          bossObjects[0].YPos = 0x8000;
          goto LABEL_20;
        default:
          goto LABEL_57;
      }
    }
    goto LABEL_57;
  }
  if ( v8 > 500 )
  {
    if ( v8 != 501 )
    {
      if ( v8 == 510 )
      {
        bossObjects[0].YVel += 64;
        bossObjects[0].damage = 127;
        bossObjects[0].YPos += bossObjects[0].YVel;
        if ( !bossObjects[0].count1 && bossObjects[0].YPos > 81920 )
        {
          bossObjects[0].count1 = 1;
          bossObjects[0].YVel = -512;
          bossObjects[0].damage = 0;
          for ( j = 0; j < 7; ++j )
          {
            changeMapParts(j + 7, 14, 0);
            createDustClouds((j + 7) << 13, 114688, 0, 0);
            playSoundEffect(SFXDestroyBreakableBlock, 1);
          }
        }
        if ( bossObjects[0].YPos > 245760 )
          bossObjects[0].currentState = 520;
      }
      goto LABEL_57;
    }
LABEL_41:
    if ( !(++bossObjects[0].waitTimer % 16) )
    {
      playSoundEffect(SFXDestroyBreakableBlock, 1);
      v3 = bossObjects[0].YPos + (random(-60, 60) << 9);
      v4 = random(-40, 40);
      createDustClouds(bossObjects[0].XPos + (v4 << 9), v3, 1, 1);
    }
    if ( bossObjects[0].waitTimer == 95 )
      bossObjects[0].animationNumber = 1;
    if ( bossObjects[0].waitTimer == 98 )
      bossObjects[0].animationNumber = 2;
    if ( bossObjects[0].waitTimer > 100 )
      bossObjects[0].currentState = 510;
    goto LABEL_57;
  }
  switch ( v8 )
  {
    case 500:
      bossObjects[3].entityFlags &= 0xFFDFu;
      bossObjects[0].currentState = 501;
      bossObjects[0].waitTimer = 0;
      bossObjects[0].count1 = 0;
      killNPC(325, 1);
      killNPC(330, 1);
      goto LABEL_41;
    case 100:
      bossObjects[0].currentState = 101;
      bossObjects[0].count2 = 9;
      bossObjects[0].waitTimer = -100;
      bossObjects[1].isAlive = -128;
      bossObjects[1].hitbox.front = 7168;
      bossObjects[1].hitbox.back = 7168;
      bossObjects[1].hitbox.top = 4096;
      bossObjects[1].hitbox.bottom = 4096;
      bossObjects[1].entityFlags = 12;
      qmemcpy(&bossObjects[2], &bossObjects[1], sizeof(NPC));
      bossObjects[3].isAlive = -112;
      bossObjects[3].entityFlags |= 0x20u;
      bossObjects[3].hitbox.front = 3072;
      bossObjects[3].hitbox.back = 3072;
      bossObjects[3].hitbox.top = 4096;
      bossObjects[3].hitbox.bottom = 4096;
      createNPC((NPCNames)325, bossObjects[0].XPos, bossObjects[0].YPos + 30720, 0, 0, 0, 0, 256);
      break;
    case 101:
      break;
    default:
      goto LABEL_57;
  }
  if ( bossObjects[0].count2 > 1 && bossObjects[0].life < 70 * bossObjects[0].count2 )
  {
    --bossObjects[0].count2;
    for ( k = 0; k < 5; ++k )
    {
      changeMapParts(k + 8, bossObjects[0].count2, 0);
      createDustClouds((k + 8) << 13, bossObjects[0].count2 << 13, 0, 4);
      playSoundEffect(SFXDestroyBreakableBlock, 1);
    }
  }
  if ( ++bossObjects[0].waitTimer == 81 || bossObjects[0].waitTimer == 241 )
    createNPC((NPCNames)323, 24576, 122880, 0, 0, up, 0, 256);
  if ( bossObjects[0].waitTimer == 1 || bossObjects[0].waitTimer == 161 )
    createNPC((NPCNames)323, 139264, 122880, 0, 0, up, 0, 256);
  if ( bossObjects[0].waitTimer >= 300 )
  {
    bossObjects[0].waitTimer = 0;
    createNPC((NPCNames)325, bossObjects[0].XPos, bossObjects[0].YPos + 30720, 0, 0, 0, 0, 256);
  }
LABEL_57:
  bossObjects[1].XPos = bossObjects[0].XPos - 12288;
  bossObjects[1].YPos = bossObjects[0].YPos + 26624;
  bossObjects[2].XPos = bossObjects[0].XPos + 12288;
  bossObjects[2].YPos = bossObjects[0].YPos + 26624;
  bossObjects[3].XPos = bossObjects[0].XPos;
  bossObjects[3].YPos = bossObjects[0].YPos + 20480;
  v12 = 0;
  v13 = 0;
  v14 = 80;
  v15 = 120;
  v16 = 80;
  v17 = 0;
  v18 = 160;
  v19 = 120;
  v20 = 160;
  v21 = 0;
  v22 = 240;
  v23 = 120;
  v24 = 0;
  v25 = 120;
  v26 = 80;
  v27 = 240;
  v28 = 80;
  v29 = 120;
  v30 = 160;
  v31 = 240;
  v32 = 160;
  v33 = 120;
  v34 = 240;
  v35 = 240;
  if ( bossObjects[0].isBeingHit )
  {
    if ( (unsigned __int8)++byte_4BC7C8 / 2 % 2 )
      v5 = &v12 + 4 * bossObjects[0].animationNumber;
    else
      v5 = &v24 + 4 * bossObjects[0].animationNumber;
    result = &bossObjects[0].rect;
    result->left = *v5;
    result->top = v5[1];
    result->right = v5[2];
    result->bottom = v5[3];
  }
  else
  {
    v7 = &v12 + 4 * bossObjects[0].animationNumber;
    result = &bossObjects[0].rect;
    result->left = *v7;
    result->top = v7[1];
    result->right = v7[2];
    result->bottom = v7[3];
  }
  return result;
}
// 4BC7C8: using guessed type char byte_4BC7C8;

//----- (0047D170) --------------------------------------------------------
int Boss_6_Dragon_Sisters()
{
  int v0; // ST08_4
  int v1; // eax
  RECT *v2; // edx
  int result; // eax
  int v4; // [esp+0h] [ebp-18h]

  v4 = bossObjects[0].currentState;
  if ( v4 > 401 )
  {
    switch ( v4 )
    {
      case 1000:
        bossObjects[0].currentState = 1001;
        bossObjects[0].waitTimer = 0;
        bossObjects[2].currentState = 1000;
        bossObjects[3].currentState = 1000;
        bossObjects[4].currentState = 1000;
        bossObjects[5].currentState = 1000;
        createDustClouds(bossObjects[0].XPos, bossObjects[0].YPos, bossObjects[0].view.back, 40);
        goto LABEL_65;
      case 1001:
LABEL_65:
        if ( ++bossObjects[0].waitTimer > 100 )
          bossObjects[0].currentState = 1010;
        v0 = bossObjects[0].YPos + (random(-70, 70) << 9);
        v1 = random(-128, 128);
        createNPC(NPCSmoke, bossObjects[0].XPos + (v1 << 9), v0, 0, 0, 0, 0, 256);
        break;
      case 1010:
        bossObjects[0].count1 += 4;
        if ( bossObjects[0].count1 > 1023 )
          bossObjects[0].count1 -= 1024;
        if ( bossObjects[0].curlyTargetX > 8 )
          --bossObjects[0].curlyTargetX;
        if ( bossObjects[0].curlyTargetY > 0 )
          --bossObjects[0].curlyTargetY;
        if ( bossObjects[0].curlyTargetX < -8 )
          ++bossObjects[0].curlyTargetX;
        if ( bossObjects[0].curlyTargetY < 0 )
          ++bossObjects[0].curlyTargetY;
        if ( !bossObjects[0].curlyTargetY )
        {
          bossObjects[0].currentState = 1020;
          bossObjects[0].waitTimer = 0;
          startFlash(bossObjects[0].XPos, bossObjects[0].YPos, 1);
          playSoundEffect(SFXlargeExplosion, 1);
        }
        break;
      case 1020:
        if ( ++bossObjects[0].waitTimer > 50 )
        {
          killNPC(211, 1);
          bossObjects[0].isAlive = 0;
          bossObjects[1].isAlive = 0;
          bossObjects[2].isAlive = 0;
          bossObjects[3].isAlive = 0;
          bossObjects[4].isAlive = 0;
          bossObjects[5].isAlive = 0;
          bossObjects[0].currentState = 0;
        }
        break;
      default:
        break;
    }
  }
  else if ( v4 == 401 )
  {
    if ( ++bossObjects[0].waitTimer >= 100 )
    {
      if ( bossObjects[0].waitTimer >= 120 )
      {
        if ( bossObjects[0].waitTimer >= 500 )
        {
          if ( bossObjects[0].waitTimer >= 540 )
          {
            if ( bossObjects[0].waitTimer >= 560 )
            {
              bossObjects[0].currentState = 100;
              bossObjects[0].waitTimer = 0;
              bossObjects[2].currentState = 100;
              bossObjects[4].currentState = 100;
              goto Return;
            }
            ++bossObjects[0].count1;
          }
          else
          {
            bossObjects[0].count1 += 2;
          }
        }
        else
        {
          bossObjects[0].count1 += 4;
        }
      }
      else
      {
        bossObjects[0].count1 += 2;
      }
    }
    else
    {
      ++bossObjects[0].count1;
    }
    if ( bossObjects[0].count1 > 1023 )
      bossObjects[0].count1 -= 1024;
  }
  else if ( v4 > 100 )
  {
    if ( v4 == 110 )
    {
      if ( ++bossObjects[0].waitTimer >= 20 )
      {
        if ( bossObjects[0].waitTimer >= 60 )
        {
          if ( bossObjects[0].waitTimer >= bossObjects[0].count2 )
          {
            if ( bossObjects[0].waitTimer >= bossObjects[0].count2 + 40 )
            {
              if ( bossObjects[0].waitTimer >= bossObjects[0].count2 + 60 )
              {
                if ( bossObjects[0].life >= 300 )
                {
                  bossObjects[0].waitTimer = 0;
                  bossObjects[0].currentState = 100;
                  bossObjects[0].count2 = random(400, 700);
                }
                else
                {
                  bossObjects[0].waitTimer = 0;
                  bossObjects[0].currentState = 400;
                  bossObjects[2].currentState = 400;
                  bossObjects[4].currentState = 400;
                }
                goto Return;
              }
              --bossObjects[0].count1;
            }
            else
            {
              bossObjects[0].count1 -= 2;
            }
          }
          else
          {
            bossObjects[0].count1 -= 4;
          }
        }
        else
        {
          bossObjects[0].count1 -= 2;
        }
      }
      else
      {
        --bossObjects[0].count1;
      }
      if ( bossObjects[0].count1 <= 0 )
        bossObjects[0].count1 += 1024;
    }
    else if ( v4 == 400 && ++bossObjects[0].waitTimer > 100 )
    {
      bossObjects[0].waitTimer = 0;
      bossObjects[0].currentState = 401;
    }
  }
  else if ( v4 == 100 )
  {
    if ( ++bossObjects[0].waitTimer >= 100 )
    {
      if ( bossObjects[0].waitTimer >= 120 )
      {
        if ( bossObjects[0].waitTimer >= bossObjects[0].count2 )
        {
          if ( bossObjects[0].waitTimer >= bossObjects[0].count2 + 40 )
          {
            if ( bossObjects[0].waitTimer >= bossObjects[0].count2 + 60 )
            {
              bossObjects[0].waitTimer = 0;
              bossObjects[0].currentState = 110;
              bossObjects[0].count2 = random(400, 700);
              goto Return;
            }
            ++bossObjects[0].count1;
          }
          else
          {
            bossObjects[0].count1 += 2;
          }
        }
        else
        {
          bossObjects[0].count1 += 4;
        }
      }
      else
      {
        bossObjects[0].count1 += 2;
      }
    }
    else
    {
      ++bossObjects[0].count1;
    }
    if ( bossObjects[0].count1 > 1023 )
      bossObjects[0].count1 -= 1024;
  }
  else if ( v4 )
  {
    if ( v4 == 20 && --bossObjects[0].curlyTargetX <= 112 )
    {
      bossObjects[0].currentState = 100;
      bossObjects[0].waitTimer = 0;
      bossObjects[2].currentState = 100;
      bossObjects[4].currentState = 100;
      bossObjects[3].currentState = 100;
      bossObjects[5].currentState = 100;
    }
  }
  else
  {
    bossObjects[0].isAlive = -128;
    bossObjects[0].direction = 0;
    bossObjects[0].currentState = 10;
    bossObjects[0].EXPAmount = 0;
    bossObjects[0].XPos = 81920;
    bossObjects[0].YPos = 0x10000;
    bossObjects[0].view.front = 4096;
    bossObjects[0].view.top = 4096;
    bossObjects[0].view.back = 0x10000;
    bossObjects[0].view.bottom = 4096;
    bossObjects[0].hitSound = 54;
    bossObjects[0].hitbox.front = 4096;
    bossObjects[0].hitbox.top = 4096;
    bossObjects[0].hitbox.back = 4096;
    bossObjects[0].hitbox.bottom = 4096;
    bossObjects[0].entityFlags = 8;
    bossObjects[0].entityFlags |= 0x200u;
    bossObjects[0].explosionSize = 3;
    bossObjects[0].damage = 0;
    bossObjects[0].entityEventNum = 1000;
    bossObjects[0].life = 500;
    bossObjects[0].count2 = random(700, 1200);
    bossObjects[0].curlyTargetX = 180;
    bossObjects[0].curlyTargetY = 61;
    bossObjects[2].view.back = 10240;
    bossObjects[2].view.front = 10240;
    bossObjects[2].view.top = 0x2000;
    bossObjects[2].view.bottom = 0x2000;
    bossObjects[2].hitbox.back = 6144;
    bossObjects[2].hitbox.front = 6144;
    bossObjects[2].hitbox.top = 5120;
    bossObjects[2].hitbox.bottom = 5120;
    bossObjects[2].entityFlags = 12;
    bossObjects[2].parentNPC = &bossObjects[3];
    bossObjects[2].isAlive = -112;
    bossObjects[2].damage = 10;
    bossObjects[3].isAlive = -128;
    bossObjects[3].view.back = 10240;
    bossObjects[3].view.front = 10240;
    bossObjects[3].view.top = 10240;
    bossObjects[3].view.bottom = 10240;
    bossObjects[3].hitbox.back = 6144;
    bossObjects[3].hitbox.front = 6144;
    bossObjects[3].hitbox.top = 1024;
    bossObjects[3].hitbox.bottom = 0x2000;
    bossObjects[3].entityFlags = 8;
    bossObjects[3].parentNPC = bossObjects;
    bossObjects[3].damage = 10;
    qmemcpy(&bossObjects[4], &bossObjects[2], sizeof(NPC));
    bossObjects[4].parentNPC = &bossObjects[5];
    qmemcpy(&bossObjects[5], &bossObjects[3], sizeof(NPC));
    bossObjects[5].count1 = 128;
  }
Return:
  Sisters_Sub_NPC_Dragon_Head((int)&bossObjects[2]);
  Sisters_Sub_NPC_Dragon_Body((int)&bossObjects[3]);
  Sisters_Sub_NPC_Dragon_Head((int)&bossObjects[4]);
  Sisters_Sub_NPC_Dragon_Body((int)&bossObjects[5]);
  v2 = &bossObjects[0].rect;
  v2->left = 0;
  v2->top = 0;
  result = 0;
  v2->right = 0;
  v2->bottom = 0;
  return result;
}

//----- (0047DAA0) --------------------------------------------------------
int __cdecl Sisters_Sub_NPC_Dragon_Body(int a1)
{
  int v1; // esi
  int v2; // esi
  int v3; // esi
  int v4; // esi
  int v5; // esi
  int v6; // esi
  int *v7; // eax
  int *v8; // ecx
  int result; // eax
  signed int v10; // [esp+0h] [ebp-68h]
  int v11; // [esp+4h] [ebp-64h]
  int v12; // [esp+8h] [ebp-60h]
  int v13; // [esp+Ch] [ebp-5Ch]
  int v14; // [esp+10h] [ebp-58h]
  int v15; // [esp+14h] [ebp-54h]
  int v16; // [esp+18h] [ebp-50h]
  int v17; // [esp+1Ch] [ebp-4Ch]
  int v18; // [esp+20h] [ebp-48h]
  int v19; // [esp+24h] [ebp-44h]
  int v20; // [esp+28h] [ebp-40h]
  int v21; // [esp+2Ch] [ebp-3Ch]
  int v22; // [esp+30h] [ebp-38h]
  int v23; // [esp+34h] [ebp-34h]
  int v24; // [esp+38h] [ebp-30h]
  int v25; // [esp+3Ch] [ebp-2Ch]
  int v26; // [esp+40h] [ebp-28h]
  int v27; // [esp+44h] [ebp-24h]
  int v28; // [esp+48h] [ebp-20h]
  int v29; // [esp+4Ch] [ebp-1Ch]
  int v30; // [esp+50h] [ebp-18h]
  int v31; // [esp+54h] [ebp-14h]
  int v32; // [esp+58h] [ebp-10h]
  int v33; // [esp+5Ch] [ebp-Ch]
  int v34; // [esp+60h] [ebp-8h]
  unsigned __int8 v35; // [esp+67h] [ebp-1h]

  v23 = 0;
  v24 = 0;
  v25 = 40;
  v26 = 40;
  v27 = 40;
  v28 = 0;
  v29 = 80;
  v30 = 40;
  v31 = 80;
  v32 = 0;
  v33 = 120;
  v34 = 40;
  v11 = 0;
  v12 = 40;
  v13 = 40;
  v14 = 80;
  v15 = 40;
  v16 = 40;
  v17 = 80;
  v18 = 80;
  v19 = 80;
  v20 = 40;
  v21 = 120;
  v22 = 80;
  v10 = *(_DWORD *)(a1 + 116);
  if ( v10 > 100 )
  {
    if ( v10 == 1000 )
    {
      *(_DWORD *)(a1 + 116) = 1001;
      *(_WORD *)(a1 + 80) &= 0xFFDFu;
    }
    else if ( v10 != 1001 )
    {
      goto LABEL_22;
    }
    v35 = *(_BYTE *)(a1 + 108) + *(_DWORD *)(*(_DWORD *)(a1 + 168) + 108) / 4;
    v5 = *(_DWORD *)(a1 + 168);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(v5 + 8) + *(_DWORD *)(*(_DWORD *)(a1 + 168) + 32) * getCos(v35);
    v6 = *(_DWORD *)(a1 + 168);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(v6 + 12) + *(_DWORD *)(*(_DWORD *)(a1 + 168) + 36) * getSin(v35);
    *(_DWORD *)(a1 + 8) += (*(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 8)) / 8;
    *(_DWORD *)(a1 + 12) += (*(_DWORD *)(a1 + 36) - *(_DWORD *)(a1 + 12)) / 8;
    if ( *(_DWORD *)(a1 + 8) <= *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) )
      *(_DWORD *)(a1 + 76) = 2;
    else
      *(_DWORD *)(a1 + 76) = 0;
  }
  else if ( v10 == 100 )
  {
    v35 = *(_BYTE *)(a1 + 108) + *(_DWORD *)(*(_DWORD *)(a1 + 168) + 108) / 4;
    v3 = *(_DWORD *)(a1 + 168);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(v3 + 8) + *(_DWORD *)(*(_DWORD *)(a1 + 168) + 32) * getCos(v35);
    v4 = *(_DWORD *)(a1 + 168);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(v4 + 12) + *(_DWORD *)(*(_DWORD *)(a1 + 168) + 36) * getSin(v35);
    *(_DWORD *)(a1 + 8) += (*(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 8)) / 8;
    *(_DWORD *)(a1 + 12) += (*(_DWORD *)(a1 + 36) - *(_DWORD *)(a1 + 12)) / 8;
    if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
      *(_DWORD *)(a1 + 76) = 2;
    else
      *(_DWORD *)(a1 + 76) = 0;
  }
  else
  {
    if ( v10 )
    {
      if ( v10 != 10 )
        goto LABEL_22;
    }
    else
    {
      v35 = *(_BYTE *)(a1 + 108) + *(_DWORD *)(*(_DWORD *)(a1 + 168) + 108) / 4;
      *(_DWORD *)(a1 + 116) = 10;
      v1 = *(_DWORD *)(a1 + 168);
      *(_DWORD *)(a1 + 8) += *(_DWORD *)(*(_DWORD *)(a1 + 168) + 32) * getCos(v35) + *(_DWORD *)(v1 + 8);
      v2 = *(_DWORD *)(a1 + 168);
      *(_DWORD *)(a1 + 12) += *(_DWORD *)(*(_DWORD *)(a1 + 168) + 36) * getSin(v35) + *(_DWORD *)(v2 + 12);
    }
    if ( *(_DWORD *)(a1 + 8) <= quote.XPos )
      *(_DWORD *)(a1 + 76) = 2;
    else
      *(_DWORD *)(a1 + 76) = 0;
  }
LABEL_22:
  if ( ++*(_DWORD *)(a1 + 100) > 2 )
  {
    *(_DWORD *)(a1 + 100) = 0;
    ++*(_DWORD *)(a1 + 104);
  }
  if ( *(_DWORD *)(a1 + 104) > 2 )
    *(_DWORD *)(a1 + 104) = 0;
  if ( *(_DWORD *)(a1 + 76) )
    v7 = &v11 + 4 * *(_DWORD *)(a1 + 104);
  else
    v7 = &v23 + 4 * *(_DWORD *)(a1 + 104);
  v8 = (int *)(a1 + 84);
  *v8 = *v7;
  v8[1] = v7[1];
  v8[2] = v7[2];
  result = v7[3];
  v8[3] = result;
  return result;
}

//----- (0047DF10) --------------------------------------------------------
int *__cdecl Sisters_Sub_NPC_Dragon_Head(int a1)
{
  int *v1; // edx
  int *result; // eax
  signed int v3; // [esp+0h] [ebp-98h]
  int Y_Vel; // [esp+4h] [ebp-94h]
  int Y_Vela; // [esp+4h] [ebp-94h]
  int v6; // [esp+8h] [ebp-90h]
  int v7; // [esp+Ch] [ebp-8Ch]
  int v8; // [esp+10h] [ebp-88h]
  int v9; // [esp+14h] [ebp-84h]
  int v10; // [esp+18h] [ebp-80h]
  int v11; // [esp+1Ch] [ebp-7Ch]
  int v12; // [esp+20h] [ebp-78h]
  int v13; // [esp+24h] [ebp-74h]
  int v14; // [esp+28h] [ebp-70h]
  int v15; // [esp+2Ch] [ebp-6Ch]
  int v16; // [esp+30h] [ebp-68h]
  int v17; // [esp+34h] [ebp-64h]
  int v18; // [esp+38h] [ebp-60h]
  int v19; // [esp+3Ch] [ebp-5Ch]
  int v20; // [esp+40h] [ebp-58h]
  int v21; // [esp+44h] [ebp-54h]
  int X_Vel; // [esp+4Ch] [ebp-4Ch]
  int v23; // [esp+50h] [ebp-48h]
  int v24; // [esp+54h] [ebp-44h]
  int v25; // [esp+58h] [ebp-40h]
  int v26; // [esp+5Ch] [ebp-3Ch]
  int v27; // [esp+60h] [ebp-38h]
  int v28; // [esp+64h] [ebp-34h]
  int v29; // [esp+68h] [ebp-30h]
  int v30; // [esp+6Ch] [ebp-2Ch]
  int v31; // [esp+70h] [ebp-28h]
  int v32; // [esp+74h] [ebp-24h]
  int v33; // [esp+78h] [ebp-20h]
  int v34; // [esp+7Ch] [ebp-1Ch]
  int v35; // [esp+80h] [ebp-18h]
  int v36; // [esp+84h] [ebp-14h]
  int v37; // [esp+88h] [ebp-10h]
  int v38; // [esp+8Ch] [ebp-Ch]
  unsigned __int8 v39; // [esp+97h] [ebp-1h]

  v23 = 0;
  v24 = 80;
  v25 = 40;
  v26 = 112;
  v27 = 40;
  v28 = 80;
  v29 = 80;
  v30 = 112;
  v31 = 80;
  v32 = 80;
  v33 = 120;
  v34 = 112;
  v35 = 120;
  v36 = 80;
  v37 = 160;
  v38 = 112;
  v6 = 0;
  v7 = 112;
  v8 = 40;
  v9 = 144;
  v10 = 40;
  v11 = 112;
  v12 = 80;
  v13 = 144;
  v14 = 80;
  v15 = 112;
  v16 = 120;
  v17 = 144;
  v18 = 120;
  v19 = 112;
  v20 = 160;
  v21 = 144;
  v3 = *(_DWORD *)(a1 + 116);
  if ( v3 <= 220 )
  {
    if ( v3 == 220 )
    {
      if ( ++*(_DWORD *)(a1 + 120) % 8 == 1 )
      {
        v39 = getArcTan(*(_DWORD *)(a1 + 8) - quote.XPos, *(_DWORD *)(a1 + 12) - quote.YPos);
        v39 += random(-6, 6);
        Y_Vel = getSin(v39);
        X_Vel = getCos(v39);
        if ( *(_DWORD *)(a1 + 76) )
          createNPC((NPCNames)202, *(_DWORD *)(a1 + 8) + 4096, *(_DWORD *)(a1 + 12), X_Vel, Y_Vel, 0, 0, 256);
        else
          createNPC((NPCNames)202, *(_DWORD *)(a1 + 8) - 4096, *(_DWORD *)(a1 + 12), X_Vel, Y_Vel, 0, 0, 256);
        playSoundEffect(SFXFireballShoot, 1);
      }
      if ( *(_DWORD *)(a1 + 120) > 50 )
        *(_DWORD *)(a1 + 116) = 200;
    }
    else
    {
      switch ( v3 )
      {
        case 0:
          *(_DWORD *)(a1 + 116) = 1;
          goto LABEL_53;
        case 100:
          *(_DWORD *)(a1 + 116) = 200;
          goto LABEL_13;
        case 200:
LABEL_13:
          *(_WORD *)(a1 + 80) &= 0xFFDFu;
          *(_DWORD *)(a1 + 104) = 0;
          *(_DWORD *)(a1 + 124) = 0x2000;
          *(_DWORD *)(a1 + 116) = 201;
          *(_DWORD *)(a1 + 108) = random(100, 200);
          goto LABEL_14;
        case 201:
LABEL_14:
          if ( *(_DWORD *)(a1 + 108) )
          {
            --*(_DWORD *)(a1 + 108);
          }
          else
          {
            *(_DWORD *)(a1 + 116) = 210;
            *(_DWORD *)(a1 + 120) = 0;
            *(_DWORD *)(a1 + 112) = 0;
          }
          break;
        case 210:
          if ( ++*(_DWORD *)(a1 + 120) == 3 )
            *(_DWORD *)(a1 + 104) = 1;
          if ( *(_DWORD *)(a1 + 120) == 6 )
          {
            *(_DWORD *)(a1 + 104) = 2;
            *(_DWORD *)(a1 + 124) = 4096;
            *(_WORD *)(a1 + 80) |= 0x20u;
            *(_DWORD *)(a1 + 112) = 0;
          }
          if ( *(_DWORD *)(a1 + 120) > 150 )
          {
            *(_DWORD *)(a1 + 116) = 220;
            *(_DWORD *)(a1 + 120) = 0;
          }
          if ( *(_BYTE *)(a1 + 156) )
            ++*(_DWORD *)(a1 + 112);
          if ( *(_DWORD *)(a1 + 112) > 10 )
          {
            playSoundEffect(SFXCritterSmallHurt, 1);
            createDustClouds(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 148), 4);
            *(_DWORD *)(a1 + 116) = 300;
            *(_DWORD *)(a1 + 120) = 0;
            *(_DWORD *)(a1 + 104) = 3;
            *(_DWORD *)(a1 + 124) = 0x2000;
          }
          break;
        default:
          goto LABEL_53;
      }
    }
    goto LABEL_53;
  }
  if ( v3 > 401 )
  {
    if ( v3 == 1000 )
    {
      *(_WORD *)(a1 + 80) &= 0xFFDFu;
      *(_DWORD *)(a1 + 104) = 3;
    }
  }
  else
  {
    if ( v3 == 401 )
    {
LABEL_41:
      if ( ++*(_DWORD *)(a1 + 120) == 3 )
        *(_DWORD *)(a1 + 104) = 1;
      if ( *(_DWORD *)(a1 + 120) == 6 )
      {
        *(_DWORD *)(a1 + 104) = 2;
        *(_DWORD *)(a1 + 124) = 4096;
        *(_WORD *)(a1 + 80) |= 0x20u;
        *(_DWORD *)(a1 + 112) = 0;
      }
      if ( *(_DWORD *)(a1 + 120) > 20 && *(_DWORD *)(a1 + 120) % 32 == 1 )
      {
        v39 = getArcTan(*(_DWORD *)(a1 + 8) - quote.XPos, *(_DWORD *)(a1 + 12) - quote.YPos);
        v39 += random(-6, 6);
        Y_Vela = getSin(v39);
        X_Vel = getCos(v39);
        if ( *(_DWORD *)(a1 + 76) )
          createNPC((NPCNames)202, *(_DWORD *)(a1 + 8) + 4096, *(_DWORD *)(a1 + 12), X_Vel, Y_Vela, 0, 0, 256);
        else
          createNPC((NPCNames)202, *(_DWORD *)(a1 + 8) - 4096, *(_DWORD *)(a1 + 12), X_Vel, Y_Vela, 0, 0, 256);
        playSoundEffect(SFXFireballShoot, 1);
      }
      goto LABEL_53;
    }
    if ( v3 != 300 )
    {
      if ( v3 != 400 )
        goto LABEL_53;
      *(_DWORD *)(a1 + 116) = 401;
      *(_DWORD *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 104) = 0;
      *(_DWORD *)(a1 + 124) = 0x2000;
      *(_WORD *)(a1 + 80) &= 0xFFDFu;
      goto LABEL_41;
    }
    if ( ++*(_DWORD *)(a1 + 120) > 100 )
      *(_DWORD *)(a1 + 116) = 200;
  }
LABEL_53:
  *(_DWORD *)(a1 + 76) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 76);
  if ( *(_DWORD *)(a1 + 76) )
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) + 2048;
  else
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 8) - 2048;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(*(_DWORD *)(a1 + 168) + 12) - 4096;
  if ( *(_DWORD *)(a1 + 76) )
    v1 = &v6 + 4 * *(_DWORD *)(a1 + 104);
  else
    v1 = &v23 + 4 * *(_DWORD *)(a1 + 104);
  result = (int *)(a1 + 84);
  *result = *v1;
  result[1] = v1[1];
  result[2] = v1[2];
  result[3] = v1[3];
  return result;
}

//----- (0047E6F0) --------------------------------------------------------
// Boss 3: Monster X
// Monster X's AI.
void __cdecl boss3_MonsterX()
{
  int v0; // ST14_4
  int v1; // eax
  int v2; // [esp+0h] [ebp-Ch]
  signed int i; // [esp+8h] [ebp-4h]

  v2 = bossObjects[0].currentState;
  if ( v2 > 401 )
  {
    if ( v2 > 601 )
    {
      if ( v2 > 1000 )
      {
        if ( v2 == 1001 )
        {
          setQuake(40);
          if ( ++bossObjects[0].waitTimer > 50 )
          {
            for ( i = 0; i < 20; ++i )
              bossObjects[i].isAlive = 0;
            killNPC(158, 1);
            createNPC(NPCTreasureChestClosed|0x90, bossObjects[0].XPos, bossObjects[0].YPos - 12288, 0, 0, 0, 0, 0);
          }
        }
      }
      else if ( v2 == 1000 )
      {
        setQuake(2);
        if ( !(++bossObjects[0].waitTimer % 8) )
          playSoundEffect(SFXBehemothLargeHurt, 1);
        v0 = bossObjects[0].YPos + (random(-64, 64) << 9);
        v1 = random(-72, 72);
        createDustClouds(bossObjects[0].XPos + (v1 << 9), v0, 1, 1);
        if ( bossObjects[0].waitTimer > 100 )
        {
          bossObjects[0].waitTimer = 0;
          bossObjects[0].currentState = 1001;
          startFlash(bossObjects[0].XPos, bossObjects[0].YPos, 1);
          playSoundEffect(SFXlargeExplosion, 1);
        }
      }
      else
      {
        if ( v2 == 602 )
        {
          bossObjects[0].currentState = 603;
          bossObjects[0].waitTimer = 0;
          bossObjects[0].count1 = 0;
          bossObjects[1].currentState = 40;
          bossObjects[2].currentState = 40;
        }
        else if ( v2 != 603 )
        {
          goto LABEL_127;
        }
        if ( ++bossObjects[0].waitTimer > 50 )
        {
          if ( bossObjects[0].XPos <= quote.XPos )
            bossObjects[0].currentState = 200;
          else
            bossObjects[0].currentState = 100;
        }
      }
    }
    else if ( v2 == 601 )
    {
LABEL_107:
      ++bossObjects[0].waitTimer;
      if ( bossObjects[0].life < bossObjects[0].count2 - 200 || bossObjects[0].waitTimer > 300 )
      {
        bossObjects[0].currentState = 602;
        bossObjects[0].waitTimer = 0;
      }
    }
    else
    {
      switch ( v2 )
      {
        case 500:
          bossObjects[0].currentState = 501;
          bossObjects[0].waitTimer = 0;
          bossObjects[1].currentState = 10;
          bossObjects[2].currentState = 10;
          goto LABEL_92;
        case 501:
LABEL_92:
          if ( ++bossObjects[0].waitTimer > 300 )
          {
            bossObjects[0].currentState = 502;
            bossObjects[0].waitTimer = 0;
          }
          if ( !bossObjects[3].isAlive && !bossObjects[4].isAlive && !bossObjects[5].isAlive && !bossObjects[6].isAlive )
          {
            bossObjects[0].currentState = 502;
            bossObjects[0].waitTimer = 0;
          }
          break;
        case 502:
          bossObjects[0].currentState = 503;
          bossObjects[0].waitTimer = 0;
          bossObjects[0].count1 = 0;
          bossObjects[1].currentState = 20;
          bossObjects[2].currentState = 20;
          goto LABEL_101;
        case 503:
LABEL_101:
          if ( ++bossObjects[0].waitTimer > 50 )
          {
            if ( bossObjects[0].XPos <= quote.XPos )
              bossObjects[0].currentState = 200;
            else
              bossObjects[0].currentState = 100;
          }
          break;
        case 600:
          bossObjects[0].currentState = 601;
          bossObjects[0].waitTimer = 0;
          bossObjects[0].count2 = bossObjects[0].life;
          bossObjects[1].currentState = 30;
          bossObjects[2].currentState = 30;
          goto LABEL_107;
        default:
          break;
      }
    }
  }
  else if ( v2 == 401 )
  {
LABEL_75:
    if ( ++bossObjects[0].waitTimer == 4 )
      bossObjects[9].currentState = 400;
    if ( bossObjects[0].waitTimer == 8 )
      bossObjects[10].currentState = 400;
    if ( bossObjects[0].waitTimer == 10 )
      bossObjects[11].currentState = 400;
    if ( bossObjects[0].waitTimer == 12 )
      bossObjects[12].currentState = 400;
    if ( bossObjects[0].waitTimer > 50 )
    {
      if ( bossObjects[3].isAlive || bossObjects[4].isAlive || bossObjects[5].isAlive || bossObjects[6].isAlive )
        bossObjects[0].currentState = 500;
      else
        bossObjects[0].currentState = 600;
    }
  }
  else if ( v2 > 101 )
  {
    switch ( v2 )
    {
      case 200:
        bossObjects[0].waitTimer = 0;
        bossObjects[0].currentState = 201;
        ++bossObjects[0].count1;
        goto LABEL_42;
      case 201:
LABEL_42:
        if ( ++bossObjects[0].waitTimer == 4 )
          bossObjects[9].currentState = 200;
        if ( bossObjects[0].waitTimer == 8 )
          bossObjects[10].currentState = 200;
        if ( bossObjects[0].waitTimer == 10 )
          bossObjects[11].currentState = 200;
        if ( bossObjects[0].waitTimer == 12 )
          bossObjects[12].currentState = 200;
        if ( bossObjects[0].waitTimer > 120 && bossObjects[0].count1 > 2 )
          bossObjects[0].currentState = 400;
        if ( bossObjects[0].waitTimer > 121 && quote.XPos < bossObjects[0].XPos )
          bossObjects[0].currentState = 100;
        break;
      case 300:
        bossObjects[0].waitTimer = 0;
        bossObjects[0].currentState = 301;
        goto LABEL_58;
      case 301:
LABEL_58:
        if ( ++bossObjects[0].waitTimer == 4 )
          bossObjects[9].currentState = 300;
        if ( bossObjects[0].waitTimer == 8 )
          bossObjects[10].currentState = 300;
        if ( bossObjects[0].waitTimer == 10 )
          bossObjects[11].currentState = 300;
        if ( bossObjects[0].waitTimer == 12 )
          bossObjects[12].currentState = 300;
        if ( bossObjects[0].waitTimer > 50 )
        {
          if ( bossObjects[3].isAlive || bossObjects[4].isAlive || bossObjects[5].isAlive || bossObjects[6].isAlive )
            bossObjects[0].currentState = 500;
          else
            bossObjects[0].currentState = 600;
        }
        break;
      case 400:
        bossObjects[0].waitTimer = 0;
        bossObjects[0].currentState = 401;
        goto LABEL_75;
      default:
        break;
    }
  }
  else if ( v2 == 101 )
  {
LABEL_26:
    if ( ++bossObjects[0].waitTimer == 4 )
      bossObjects[9].currentState = 100;
    if ( bossObjects[0].waitTimer == 8 )
      bossObjects[10].currentState = 100;
    if ( bossObjects[0].waitTimer == 10 )
      bossObjects[11].currentState = 100;
    if ( bossObjects[0].waitTimer == 12 )
      bossObjects[12].currentState = 100;
    if ( bossObjects[0].waitTimer > 120 && bossObjects[0].count1 > 2 )
      bossObjects[0].currentState = 300;
    if ( bossObjects[0].waitTimer > 121 && quote.XPos > bossObjects[0].XPos )
      bossObjects[0].currentState = 200;
  }
  else
  {
    switch ( v2 )
    {
      case 0:
        bossObjects[0].life = 1;
        bossObjects[0].XPos = -163840;
        break;
      case 1:
        bossObjects[0].life = 700;
        bossObjects[0].EXPAmount = 1;
        bossObjects[0].currentState = 1;
        bossObjects[0].XPos = 0x100000;
        bossObjects[0].YPos = 102400;
        bossObjects[0].hitSound = 54;
        bossObjects[0].hitbox.front = 12288;
        bossObjects[0].hitbox.top = 12288;
        bossObjects[0].hitbox.back = 12288;
        bossObjects[0].hitbox.bottom = 12288;
        bossObjects[0].entityFlags = -32248;
        bossObjects[0].explosionSize = 3;
        bossObjects[0].entityEventNum = 1000;
        bossObjects[0].animationNumber = 0;
        bossObjects[1].isAlive = -128;
        bossObjects[1].explosionSize = 3;
        bossObjects[1].direction = 0;
        bossObjects[1].view.front = 12288;
        bossObjects[1].view.top = 12288;
        bossObjects[1].view.back = 12288;
        bossObjects[1].view.bottom = 12288;
        bossObjects[1].entityFlags = 8;
        qmemcpy(&bossObjects[2], &bossObjects[1], sizeof(NPC));
        bossObjects[2].direction = 2;
        bossObjects[3].isAlive = -128;
        bossObjects[3].life = 60;
        bossObjects[3].hitSound = 54;
        bossObjects[3].deathSound = 71;
        bossObjects[3].explosionSize = 2;
        bossObjects[3].view.front = 4096;
        bossObjects[3].view.top = 4096;
        bossObjects[3].view.back = 4096;
        bossObjects[3].view.bottom = 4096;
        bossObjects[3].hitbox.front = 2560;
        bossObjects[3].hitbox.back = 2560;
        bossObjects[3].hitbox.top = 2560;
        bossObjects[3].hitbox.bottom = 2560;
        bossObjects[3].entityFlags = 8;
        bossObjects[3].curlyTargetX = 0;
        qmemcpy(&bossObjects[4], &bossObjects[3], sizeof(NPC));
        bossObjects[4].curlyTargetX = 1;
        qmemcpy(&bossObjects[5], &bossObjects[3], sizeof(NPC));
        bossObjects[5].curlyTargetX = 2;
        bossObjects[5].life = 100;
        qmemcpy(&bossObjects[6], &bossObjects[3], sizeof(NPC));
        bossObjects[6].curlyTargetX = 3;
        bossObjects[6].life = 100;
        bossObjects[7].isAlive = -128;
        bossObjects[7].XPos = 0x100000;
        bossObjects[7].YPos = 102400;
        bossObjects[7].view.front = 26624;
        bossObjects[7].view.top = 12288;
        bossObjects[7].view.back = 26624;
        bossObjects[7].view.bottom = 12288;
        bossObjects[7].hitSound = 52;
        bossObjects[7].hitbox.front = 4096;
        bossObjects[7].hitbox.top = 12288;
        bossObjects[7].hitbox.back = 4096;
        bossObjects[7].hitbox.bottom = 0x2000;
        bossObjects[7].entityFlags = 8;
        bossObjects[7].explosionSize = 3;
        bossObjects[7].animationNumber = 0;
        bossObjects[9].isAlive = -128;
        bossObjects[9].currentState = 0;
        bossObjects[9].direction = 1;
        bossObjects[9].XPos = 1015808;
        bossObjects[9].YPos = 73728;
        bossObjects[9].view.front = 18432;
        bossObjects[9].view.top = 4096;
        bossObjects[9].view.back = 18432;
        bossObjects[9].view.bottom = 12288;
        bossObjects[9].hitSound = 52;
        bossObjects[9].hitbox.front = 14336;
        bossObjects[9].hitbox.top = 4096;
        bossObjects[9].hitbox.back = 14336;
        bossObjects[9].hitbox.bottom = 0x2000;
        bossObjects[9].entityFlags = 141;
        bossObjects[9].explosionSize = 3;
        qmemcpy(&bossObjects[10], &bossObjects[9], sizeof(NPC));
        bossObjects[10].XPos = 1081344;
        qmemcpy(&bossObjects[11], &bossObjects[9], sizeof(NPC));
        bossObjects[11].direction = 3;
        bossObjects[11].XPos = 1015808;
        bossObjects[11].YPos = 0x20000;
        bossObjects[11].view.top = 12288;
        bossObjects[11].view.bottom = 4096;
        bossObjects[11].hitbox.top = 0x2000;
        bossObjects[11].hitbox.bottom = 4096;
        qmemcpy(&bossObjects[12], &bossObjects[11], sizeof(NPC));
        bossObjects[12].XPos = 1081344;
        qmemcpy(&bossObjects[13], &bossObjects[9], sizeof(NPC));
        bossObjects[13].isAlive = -128;
        bossObjects[13].view.top = 0x2000;
        bossObjects[13].view.bottom = 0x2000;
        bossObjects[13].view.front = 15360;
        bossObjects[13].view.back = 21504;
        bossObjects[13].count1 = 9;
        bossObjects[13].animationNumber = 0;
        bossObjects[13].entityFlags = 8;
        qmemcpy(&bossObjects[14], &bossObjects[13], sizeof(NPC));
        bossObjects[14].view.front = 21504;
        bossObjects[14].view.back = 15360;
        bossObjects[14].count1 = 10;
        bossObjects[14].animationNumber = 1;
        bossObjects[14].entityFlags = 8;
        qmemcpy(&bossObjects[15], &bossObjects[13], sizeof(NPC));
        bossObjects[15].view.top = 0x2000;
        bossObjects[15].view.bottom = 0x2000;
        bossObjects[15].count1 = 11;
        bossObjects[15].animationNumber = 2;
        bossObjects[15].entityFlags = 8;
        qmemcpy(&bossObjects[16], &bossObjects[15], sizeof(NPC));
        bossObjects[16].view.front = 21504;
        bossObjects[16].view.back = 15360;
        bossObjects[16].count1 = 12;
        bossObjects[16].animationNumber = 3;
        bossObjects[16].entityFlags = 8;
        bossObjects[0].currentState = 2;
        break;
      case 10:
        bossObjects[0].currentState = 11;
        bossObjects[0].waitTimer = 0;
        bossObjects[0].count1 = 0;
        goto LABEL_20;
      case 11:
LABEL_20:
        if ( ++bossObjects[0].waitTimer > 100 )
        {
          bossObjects[0].waitTimer = 0;
          if ( bossObjects[0].XPos <= quote.XPos )
            bossObjects[0].currentState = 200;
          else
            bossObjects[0].currentState = 100;
        }
        break;
      case 100:
        bossObjects[0].waitTimer = 0;
        bossObjects[0].currentState = 101;
        ++bossObjects[0].count1;
        goto LABEL_26;
      default:
        break;
    }
  }
LABEL_127:
  monsterXSubNPC1(&bossObjects[9]);
  monsterXSubNPC1(&bossObjects[10]);
  monsterXSubNPC1(&bossObjects[11]);
  monsterXSubNPC1(&bossObjects[12]);
  bossObjects[0].XPos += ((bossObjects[12].XPos + bossObjects[11].XPos + bossObjects[10].XPos + bossObjects[9].XPos) / 4
                        - bossObjects[0].XPos)
                       / 16;
  monsterXSubNPCHead(&bossObjects[7]);
  monsterXSubNPCFishMissiles(&bossObjects[13]);
  monsterXSubNPCFishMissiles(&bossObjects[14]);
  monsterXSubNPCFishMissiles(&bossObjects[15]);
  monsterXSubNPCFishMissiles(&bossObjects[16]);
  monsterXSubNPC3(&bossObjects[1]);
  monsterXSubNPC3(&bossObjects[2]);
  if ( bossObjects[3].isAlive )
    monsterXSubNPC4(&bossObjects[3]);
  if ( bossObjects[4].isAlive )
    monsterXSubNPC4(&bossObjects[4]);
  if ( bossObjects[5].isAlive )
    monsterXSubNPC4(&bossObjects[5]);
  if ( bossObjects[6].isAlive )
    monsterXSubNPC4(&bossObjects[6]);
  if ( !bossObjects[0].life && bossObjects[0].currentState < 1000 )
  {
    bossObjects[0].currentState = 1000;
    bossObjects[0].waitTimer = 0;
    bossObjects[0].isBeingHit = -106;
    bossObjects[9].currentState = 300;
    bossObjects[10].currentState = 300;
    bossObjects[11].currentState = 300;
    bossObjects[12].currentState = 300;
  }
}

//----- (0047F710) --------------------------------------------------------
void __cdecl monsterXSubNPC1(NPC *npc)
{
  int *v1; // ecx
  RECT *v2; // edx
  int v3; // [esp+0h] [ebp-C4h]
  int v4; // [esp+4h] [ebp-C0h]
  int v5; // [esp+8h] [ebp-BCh]
  int v6; // [esp+Ch] [ebp-B8h]
  int v7; // [esp+10h] [ebp-B4h]
  int v8; // [esp+14h] [ebp-B0h]
  int v9; // [esp+18h] [ebp-ACh]
  int v10; // [esp+1Ch] [ebp-A8h]
  int v11; // [esp+20h] [ebp-A4h]
  int v12; // [esp+24h] [ebp-A0h]
  int v13; // [esp+28h] [ebp-9Ch]
  int v14; // [esp+2Ch] [ebp-98h]
  int v15; // [esp+30h] [ebp-94h]
  int v16; // [esp+34h] [ebp-90h]
  int v17; // [esp+38h] [ebp-8Ch]
  int v18; // [esp+3Ch] [ebp-88h]
  int v19; // [esp+40h] [ebp-84h]
  int v20; // [esp+44h] [ebp-80h]
  int v21; // [esp+48h] [ebp-7Ch]
  int v22; // [esp+4Ch] [ebp-78h]
  int v23; // [esp+50h] [ebp-74h]
  int v24; // [esp+54h] [ebp-70h]
  int v25; // [esp+58h] [ebp-6Ch]
  int v26; // [esp+5Ch] [ebp-68h]
  int v27; // [esp+60h] [ebp-64h]
  int v28; // [esp+64h] [ebp-60h]
  int v29; // [esp+68h] [ebp-5Ch]
  int v30; // [esp+6Ch] [ebp-58h]
  int v31; // [esp+70h] [ebp-54h]
  int v32; // [esp+74h] [ebp-50h]
  int v33; // [esp+78h] [ebp-4Ch]
  int v34; // [esp+7Ch] [ebp-48h]
  int v35; // [esp+80h] [ebp-44h]
  int v36; // [esp+84h] [ebp-40h]
  int v37; // [esp+88h] [ebp-3Ch]
  int v38; // [esp+8Ch] [ebp-38h]
  int v39; // [esp+90h] [ebp-34h]
  int v40; // [esp+94h] [ebp-30h]
  int v41; // [esp+98h] [ebp-2Ch]
  int v42; // [esp+9Ch] [ebp-28h]
  int v43; // [esp+A0h] [ebp-24h]
  int v44; // [esp+A4h] [ebp-20h]
  int v45; // [esp+A8h] [ebp-1Ch]
  int v46; // [esp+ACh] [ebp-18h]
  int v47; // [esp+B0h] [ebp-14h]
  int v48; // [esp+B4h] [ebp-10h]
  int v49; // [esp+B8h] [ebp-Ch]
  int v50; // [esp+BCh] [ebp-8h]
  int v51; // [esp+C0h] [ebp-4h]

  v28 = 0;
  v29 = 0;
  v30 = 72;
  v31 = 32;
  v32 = 0;
  v33 = 32;
  v34 = 72;
  v35 = 64;
  v36 = 72;
  v37 = 0;
  v38 = 144;
  v39 = 32;
  v40 = 144;
  v41 = 0;
  v42 = 216;
  v43 = 32;
  v44 = 72;
  v45 = 32;
  v46 = 144;
  v47 = 64;
  v48 = 144;
  v49 = 32;
  v50 = 216;
  v51 = 64;
  v4 = 0;
  v5 = 64;
  v6 = 72;
  v7 = 96;
  v8 = 0;
  v9 = 96;
  v10 = 72;
  v11 = 128;
  v12 = 72;
  v13 = 64;
  v14 = 144;
  v15 = 96;
  v16 = 144;
  v17 = 64;
  v18 = 216;
  v19 = 96;
  v20 = 72;
  v21 = 96;
  v22 = 144;
  v23 = 128;
  v24 = 144;
  v25 = 96;
  v26 = 216;
  v27 = 128;
  v3 = npc->currentState;
  if ( v3 > 201 )
  {
    switch ( v3 )
    {
      case 202:
        npc->entityFlags &= 0xFFEFu;
        npc->currentState = 203;
        npc->animationNumber = 0;
        npc->animationTimer = 0;
        goto LABEL_29;
      case 203:
LABEL_29:
        ++npc->waitTimer;
        if ( ++npc->animationTimer > 1 )
        {
          npc->animationTimer = 0;
          ++npc->animationNumber;
        }
        if ( npc->animationNumber > 1 )
          npc->animationNumber = 0;
        npc->XVel += 32;
        break;
      case 300:
        npc->currentState = 301;
        npc->animationNumber = 4;
        npc->animationTimer = 0;
        npc->entityFlags |= 0x10u;
        goto LABEL_35;
      case 301:
LABEL_35:
        if ( ++npc->animationTimer > 0 )
        {
          npc->animationTimer = 0;
          ++npc->animationNumber;
        }
        if ( npc->animationNumber > 5 )
          npc->animationNumber = 4;
        npc->XVel += 32;
        if ( npc->XVel > 0 )
        {
          npc->XVel = 0;
          npc->currentState = 10;
        }
        break;
      case 400:
        npc->currentState = 401;
        npc->animationNumber = 2;
        npc->animationTimer = 0;
        npc->entityFlags |= 0x10u;
        goto LABEL_43;
      case 401:
LABEL_43:
        if ( ++npc->animationTimer > 0 )
        {
          npc->animationTimer = 0;
          ++npc->animationNumber;
        }
        if ( npc->animationNumber > 3 )
          npc->animationNumber = 2;
        npc->XVel -= 32;
        if ( npc->XVel < 0 )
        {
          npc->XVel = 0;
          npc->currentState = 10;
        }
        break;
      default:
        break;
    }
  }
  else if ( v3 == 201 )
  {
LABEL_21:
    if ( ++npc->waitTimer > 30 )
      npc->currentState = 202;
    if ( ++npc->animationTimer > 0 )
    {
      npc->animationTimer = 0;
      ++npc->animationNumber;
    }
    if ( npc->animationNumber > 5 )
      npc->animationNumber = 4;
    npc->XVel += 32;
  }
  else
  {
    switch ( v3 )
    {
      case 10:
        npc->animationNumber = 0;
        npc->entityFlags &= 0xFFEFu;
        break;
      case 100:
        npc->entityFlags |= 0x10u;
        npc->currentState = 101;
        npc->waitTimer = 0;
        npc->animationNumber = 2;
        npc->animationTimer = 0;
        goto LABEL_7;
      case 101:
LABEL_7:
        if ( ++npc->waitTimer > 30 )
          npc->currentState = 102;
        if ( ++npc->animationTimer > 0 )
        {
          npc->animationTimer = 0;
          ++npc->animationNumber;
        }
        if ( npc->animationNumber > 3 )
          npc->animationNumber = 2;
        npc->XVel -= 32;
        break;
      case 102:
        npc->entityFlags &= 0xFFEFu;
        npc->currentState = 103;
        npc->animationNumber = 0;
        npc->animationTimer = 0;
        goto LABEL_15;
      case 103:
LABEL_15:
        ++npc->waitTimer;
        if ( ++npc->animationTimer > 1 )
        {
          npc->animationTimer = 0;
          ++npc->animationNumber;
        }
        if ( npc->animationNumber > 1 )
          npc->animationNumber = 0;
        npc->XVel -= 32;
        break;
      case 200:
        npc->entityFlags |= 0x10u;
        npc->entityFlags |= 0x80u;
        npc->currentState = 201;
        npc->waitTimer = 0;
        npc->animationNumber = 4;
        npc->animationTimer = 0;
        goto LABEL_21;
      default:
        break;
    }
  }
  if ( (npc->currentState == 101 || npc->currentState == 201 || npc->currentState == 301 || npc->currentState == 401)
    && npc->waitTimer % 2 == 1 )
  {
    playSoundEffect(SFXLargeThud, 1);
  }
  if ( (npc->currentState == 103 || npc->currentState == 203) && npc->waitTimer % 4 == 1 )
    playSoundEffect(SFXThud, 1);
  if ( npc->currentState < 100 || quote.YPos >= npc->YPos + 2048 || quote.YPos <= npc->YPos - 2048 )
  {
    npc->damage = 0;
    npc->entityFlags &= 0xFF7Fu;
  }
  else
  {
    npc->damage = 10;
    npc->entityFlags |= 0x80u;
  }
  if ( npc->XVel > 1024 )
    npc->XVel = 1024;
  if ( npc->XVel < -1024 )
    npc->XVel = -1024;
  npc->XPos += npc->XVel;
  if ( npc->direction == 1 )
    v1 = &v28 + 4 * npc->animationNumber;
  else
    v1 = &v4 + 4 * npc->animationNumber;
  v2 = &npc->rect;
  v2->left = *v1;
  v2->top = v1[1];
  v2->right = v1[2];
  v2->bottom = v1[3];
}

//----- (00480090) --------------------------------------------------------
void __cdecl monsterXSubNPCFishMissiles(NPC *npc)
{
  int *v1; // edx
  RECT *v2; // eax
  int v3; // [esp+4h] [ebp-50h]
  int Direction; // [esp+8h] [ebp-4Ch]
  int v5; // [esp+Ch] [ebp-48h]
  int v6; // [esp+10h] [ebp-44h]
  int v7; // [esp+14h] [ebp-40h]
  int v8; // [esp+18h] [ebp-3Ch]
  int v9; // [esp+1Ch] [ebp-38h]
  int v10; // [esp+20h] [ebp-34h]
  int v11; // [esp+24h] [ebp-30h]
  int v12; // [esp+28h] [ebp-2Ch]
  int v13; // [esp+2Ch] [ebp-28h]
  int v14; // [esp+30h] [ebp-24h]
  int v15; // [esp+34h] [ebp-20h]
  int v16; // [esp+38h] [ebp-1Ch]
  int v17; // [esp+3Ch] [ebp-18h]
  int v18; // [esp+40h] [ebp-14h]
  int v19; // [esp+44h] [ebp-10h]
  int v20; // [esp+48h] [ebp-Ch]
  int v21; // [esp+4Ch] [ebp-8h]
  int v22; // [esp+50h] [ebp-4h]

  v5 = 0;
  v6 = 128;
  v7 = 72;
  v8 = 160;
  v9 = 72;
  v10 = 128;
  v11 = 144;
  v12 = 160;
  v13 = 0;
  v14 = 160;
  v15 = 72;
  v16 = 192;
  v17 = 72;
  v18 = 160;
  v19 = 144;
  v20 = 192;
  v3 = npc->currentState;
  if ( v3 == 10 )
  {
    npc->currentState = 11;
    npc->waitTimer = 30 * npc->animationNumber + 30;
  }
  else if ( v3 != 11 )
  {
    goto LABEL_13;
  }
  if ( npc->waitTimer )
  {
    --npc->waitTimer;
  }
  else
  {
    switch ( npc->animationNumber )
    {
      case 0:
        Direction = 3;
        v21 = -15360;
        v22 = 3072;
        break;
      case 1:
        Direction = 2;
        v21 = 15360;
        v22 = 3072;
        break;
      case 2:
        Direction = 0;
        v21 = -15360;
        v22 = -3072;
        break;
      case 3:
        Direction = 1;
        v21 = 15360;
        v22 = -3072;
        break;
      default:
        break;
    }
    createNPC(NPCSantasKey|0x90, v21 + npc->XPos, v22 + npc->YPos, 0, 0, (Directions)Direction, 0, 256);
    playSoundEffect(SFXEnemyShootProjectile, 1);
    npc->waitTimer = 120;
  }
LABEL_13:
  npc->XPos = (bossObjects[npc->count1].XPos + bossObjects[0].XPos) / 2;
  npc->YPos = (bossObjects[npc->count1].YPos + bossObjects[0].YPos) / 2;
  v1 = &v5 + 4 * npc->animationNumber;
  v2 = &npc->rect;
  v2->left = *v1;
  v2->top = v1[1];
  v2->right = v1[2];
  v2->bottom = v1[3];
}

//----- (004802A0) --------------------------------------------------------
void __cdecl monsterXSubNPC3(NPC *npc)
{
  RECT *v1; // eax
  RECT *v2; // edx

  switch ( npc->currentState )
  {
    case 0xA:
      npc->curlyTargetX += 512;
      if ( npc->curlyTargetX > 0x4000 )
      {
        npc->curlyTargetX = 0x4000;
        npc->currentState = 0;
        bossObjects[3].currentState = 10;
        bossObjects[4].currentState = 10;
        bossObjects[5].currentState = 10;
        bossObjects[6].currentState = 10;
      }
      break;
    case 0x14:
      npc->curlyTargetX -= 512;
      if ( npc->curlyTargetX < 0 )
      {
        npc->curlyTargetX = 0;
        npc->currentState = 0;
        bossObjects[3].currentState = 0;
        bossObjects[4].currentState = 0;
        bossObjects[5].currentState = 0;
        bossObjects[6].currentState = 0;
      }
      break;
    case 0x1E:
      npc->curlyTargetX += 512;
      if ( npc->curlyTargetX > 10240 )
      {
        npc->curlyTargetX = 10240;
        npc->currentState = 0;
        bossObjects[7].currentState = 10;
        bossObjects[13].currentState = 10;
        bossObjects[14].currentState = 10;
        bossObjects[15].currentState = 10;
        bossObjects[16].currentState = 10;
      }
      break;
    case 0x28:
      npc->curlyTargetX -= 512;
      if ( npc->curlyTargetX < 0 )
      {
        npc->curlyTargetX = 0;
        npc->currentState = 0;
        bossObjects[7].currentState = 0;
        bossObjects[13].currentState = 0;
        bossObjects[14].currentState = 0;
        bossObjects[15].currentState = 0;
        bossObjects[16].currentState = 0;
      }
      break;
    default:
      break;
  }
  if ( npc->direction )
  {
    v2 = &npc->rect;
    v2->left = 264;
    v2->top = 96;
    v2->right = 312;
    v2->bottom = 144;
    npc->XPos = bossObjects[0].XPos + npc->curlyTargetX + 12288;
  }
  else
  {
    v1 = &npc->rect;
    v1->left = 216;
    v1->top = 96;
    v1->right = 264;
    v1->bottom = 144;
    npc->XPos = bossObjects[0].XPos - 12288 - npc->curlyTargetX;
  }
  npc->YPos = bossObjects[0].YPos;
}

//----- (00480550) --------------------------------------------------------
void __cdecl monsterXSubNPC4(NPC *npc)
{
  int Y_Vel; // ST28_4
  int X_Vel; // ST2C_4
  int *v3; // eax
  RECT *v4; // ecx
  int v5; // [esp+4h] [ebp-94h]
  int v6; // [esp+10h] [ebp-88h]
  int v7; // [esp+14h] [ebp-84h]
  int v8; // [esp+18h] [ebp-80h]
  int v9; // [esp+1Ch] [ebp-7Ch]
  int v10; // [esp+20h] [ebp-78h]
  int v11; // [esp+24h] [ebp-74h]
  int v12; // [esp+28h] [ebp-70h]
  int v13; // [esp+2Ch] [ebp-6Ch]
  int v14; // [esp+30h] [ebp-68h]
  int v15; // [esp+34h] [ebp-64h]
  int v16; // [esp+38h] [ebp-60h]
  int v17; // [esp+3Ch] [ebp-5Ch]
  int v18; // [esp+40h] [ebp-58h]
  int v19; // [esp+44h] [ebp-54h]
  int v20; // [esp+48h] [ebp-50h]
  int v21; // [esp+4Ch] [ebp-4Ch]
  int v22; // [esp+50h] [ebp-48h]
  int v23; // [esp+54h] [ebp-44h]
  int v24; // [esp+58h] [ebp-40h]
  int v25; // [esp+5Ch] [ebp-3Ch]
  int v26; // [esp+60h] [ebp-38h]
  int v27; // [esp+64h] [ebp-34h]
  int v28; // [esp+68h] [ebp-30h]
  int v29; // [esp+6Ch] [ebp-2Ch]
  int v30; // [esp+70h] [ebp-28h]
  int v31; // [esp+74h] [ebp-24h]
  int v32; // [esp+78h] [ebp-20h]
  int v33; // [esp+7Ch] [ebp-1Ch]
  int v34; // [esp+80h] [ebp-18h]
  int v35; // [esp+84h] [ebp-14h]
  int v36; // [esp+88h] [ebp-10h]
  int v37; // [esp+8Ch] [ebp-Ch]
  unsigned __int8 v38; // [esp+97h] [ebp-1h]

  v6 = 0;
  v7 = 192;
  v8 = 16;
  v9 = 208;
  v10 = 16;
  v11 = 192;
  v12 = 32;
  v13 = 208;
  v14 = 32;
  v15 = 192;
  v16 = 48;
  v17 = 208;
  v18 = 48;
  v19 = 192;
  v20 = 64;
  v21 = 208;
  v22 = 0;
  v23 = 208;
  v24 = 16;
  v25 = 224;
  v26 = 16;
  v27 = 208;
  v28 = 32;
  v29 = 224;
  v30 = 32;
  v31 = 208;
  v32 = 48;
  v33 = 224;
  v34 = 48;
  v35 = 208;
  v36 = 64;
  v37 = 224;
  v5 = npc->currentState;
  switch ( v5 )
  {
    case 0:
      npc->entityFlags &= 0xFFDFu;
      npc->animationNumber = 0;
      goto LABEL_14;
    case 10:
      npc->currentState = 11;
      npc->waitTimer = 10 * npc->curlyTargetX + 40;
      npc->entityFlags |= 0x20u;
      break;
    case 11:
      break;
    default:
      goto LABEL_14;
  }
  npc->animationNumber = npc->waitTimer < 16 && npc->waitTimer / 2 % 2;
  if ( npc->waitTimer )
  {
    --npc->waitTimer;
  }
  else
  {
    v38 = getArcTan(npc->XPos - quote.XPos, npc->YPos - quote.YPos);
    v38 += random(-2, 2);
    Y_Vel = 3 * getSin(v38);
    X_Vel = 3 * getCos(v38);
    createNPC((NPCNames)156, npc->XPos, npc->YPos, X_Vel, Y_Vel, 0, 0, 256);
    playSoundEffect(SFXEnemyShootProjectile, 1);
    npc->waitTimer = 40;
  }
LABEL_14:
  switch ( npc->curlyTargetX )
  {
    case 0:
      npc->XPos = bossObjects[0].XPos - 11264;
      npc->YPos = bossObjects[0].YPos - 0x2000;
      break;
    case 1:
      npc->XPos = bossObjects[0].XPos + 14336;
      npc->YPos = bossObjects[0].YPos - 0x2000;
      break;
    case 2:
      npc->XPos = bossObjects[0].XPos - 7680;
      npc->YPos = bossObjects[0].YPos + 7168;
      break;
    case 3:
      npc->XPos = bossObjects[0].XPos + 8704;
      npc->YPos = bossObjects[0].YPos + 7168;
      break;
    default:
      break;
  }
  v3 = &v6 + 4 * (npc->curlyTargetX + 4 * npc->animationNumber);
  v4 = &npc->rect;
  v4->left = *v3;
  v4->top = v3[1];
  v4->right = v3[2];
  v4->bottom = v3[3];
}

//----- (004808C0) --------------------------------------------------------
void __cdecl monsterXSubNPCHead(NPC *npc)
{
  int v1; // eax
  int *v2; // ecx
  RECT *v3; // edx
  int v4; // [esp+0h] [ebp-34h]
  int v5; // [esp+4h] [ebp-30h]
  int v6; // [esp+8h] [ebp-2Ch]
  int v7; // [esp+Ch] [ebp-28h]
  int v8; // [esp+10h] [ebp-24h]
  int v9; // [esp+14h] [ebp-20h]
  int v10; // [esp+18h] [ebp-1Ch]
  int v11; // [esp+1Ch] [ebp-18h]
  int v12; // [esp+20h] [ebp-14h]
  int v13; // [esp+24h] [ebp-10h]
  int v14; // [esp+28h] [ebp-Ch]
  int v15; // [esp+2Ch] [ebp-8h]
  int v16; // [esp+30h] [ebp-4h]

  v5 = 216;
  v6 = 0;
  v7 = 320;
  v8 = 48;
  v9 = 216;
  v10 = 48;
  v11 = 320;
  v12 = 96;
  v13 = 216;
  v14 = 144;
  v15 = 320;
  v16 = 192;
  v4 = npc->currentState;
  switch ( v4 )
  {
    case 0:
      bossObjects[0].entityFlags &= 0xFFDFu;
      npc->animationNumber = 0;
      goto LABEL_13;
    case 10:
      npc->currentState = 11;
      npc->waitTimer = 10 * npc->curlyTargetX + 40;
      bossObjects[0].entityFlags |= 0x20u;
      break;
    case 11:
      break;
    default:
      goto LABEL_13;
  }
  if ( bossObjects[0].isBeingHit )
  {
    v1 = (unsigned __int8)byte_4BC7C9++ / 2 % 2;
    if ( v1 )
      npc->animationNumber = 1;
    else
      npc->animationNumber = 0;
  }
  else
  {
    npc->animationNumber = 0;
  }
LABEL_13:
  bossObjects[7].XPos = bossObjects[0].XPos;
  bossObjects[7].YPos = bossObjects[0].YPos;
  if ( bossObjects[0].currentState <= 10 )
    npc->animationNumber = 2;
  v2 = &v5 + 4 * npc->animationNumber;
  v3 = &npc->rect;
  v3->left = *v2;
  v3->top = v2[1];
  v3->right = v2[2];
  v3->bottom = v2[3];
}
// 4BC7C9: using guessed type char byte_4BC7C9;

//----- (00480DAD) --------------------------------------------------------
// return 1
signed int report_failure_Return_1()
{
  return 1;
}

//----- (00480F55) --------------------------------------------------------
size_t __cdecl fread(void *buffer, size_t elementSize, size_t count, FILE *stream)
{
  size_t ret_nolock; // ST0C_4

  VALIDATE_RETURN((int)&stru_48CA78, 12);
  lock_str(stream);
  ret_nolock = fread_nolock(buffer, elementSize, count, stream);
  _unlock_file(stream);
  return ret_nolock;
}
// 48CA78: using guessed type _SCOPETABLE_ENTRY stru_48CA78;

//----- (00481981) --------------------------------------------------------
// Write 'count' items of size 'size' to the specified stream from the specified buffer. 
size_t __cdecl fwrite(const void *buffer, size_t size, size_t count, FILE *stream)
{
  size_t v4; // ST0C_4

  // just checking for stream != NULL here
  // rest of the validation is in _fwrite_nolock()
  VALIDATE_RETURN((int)&stru_48CAC8, 12);
  lock_str(stream);                             // lock stream
  // do the read
  v4 = fwrite_nolock(buffer, size, count, stream);
  _unlock_file(stream);                         // unlock stream
  return v4;
}
// 48CAC8: using guessed type _SCOPETABLE_ENTRY stru_48CAC8;

//----- (00481F9A) --------------------------------------------------------
// return 1
signed int __security_error_handler_return_1()
{
  return 1;
}

//----- (00481F9E) --------------------------------------------------------
#error "481F9E: positive sp value has been found (funcsize=0)"

//----- (00482475) --------------------------------------------------------
// Unused
int __usercall flsall_sub_482475@<eax>(int a1@<esi>)
{
  return _unlock_file2(a1, *(_DWORD *)(dword_4BD034 + 4 * a1));
}
// 4825F1: using guessed type _DWORD __cdecl _unlock_file2(_DWORD, _DWORD);
// 4BD034: using guessed type int dword_4BD034;

//----- (004824A1) --------------------------------------------------------
// Unused
void flsall_sub_4824A1()
{
  _unlock(1);
}

//----- (004824AA) --------------------------------------------------------
// Flushes all the output buffers to the file, clears all input buffers.
// Unused.
int __cdecl flushall()
{
  return flsall(FLUSHALL);
}

//----- (0048451C) --------------------------------------------------------
int __usercall freefls@<eax>(int a1@<ebp>)
{
  int v1; // esi

  v1 = *(_DWORD *)(a1 + 8);
  return freefls();
}
// 484521: using guessed type int freefls(void);

//----- (00486CC0) --------------------------------------------------------
void CrtSetCheckCount()
{
  const char *i; // [esp+Ch] [ebp-1Ch]
  int savedregs; // [esp+28h] [ebp+0h]

  for ( i = ""; i < ""; i += 4 )
  {
    if ( *(_DWORD *)i )
      (*(void (__stdcall **)(_DWORD, int))i)(0, savedregs);
  }
}

//----- (00486D04) --------------------------------------------------------
// Executes on exit
void On_Exit_Function(void)
{
  const char *i; // [esp+Ch] [ebp-1Ch]
  int savedregs; // [esp+28h] [ebp+0h]

  for ( i = ""; i < ""; i += 4 )
  {
    if ( *(_DWORD *)i )
      (*(void (__stdcall **)(_DWORD, int))i)(0, savedregs);
  }
}

//----- (0048759C) --------------------------------------------------------
// Unused
int __usercall Very_Strange_Shit@<eax>(int a1@<ebp>)
{
  int v1; // edi
  int v2; // esi

  v1 = *(_DWORD *)(a1 - 36);
  v2 = *(_DWORD *)(a1 - 32);
  return _alloc_osfhnd_sub_4875A2();
}
// 4875A2: using guessed type int _alloc_osfhnd_sub_4875A2(void);

//----- (0048763C) --------------------------------------------------------
void _alloc_osfhnd_sub_48763C()
{
  _unlock(11);
}

//----- (004876E5) --------------------------------------------------------
// Unused
void commit_call___unlock_fhandle()
{
  signed int v0; // [esp+0h] [ebp-4h]

  unlock_fh(v0);
}

//----- (0048784E) --------------------------------------------------------
// Unused
void _fcloseall_sub_48784E()
{
  _unlock(1);
}

//----- (00488F49) --------------------------------------------------------
int __cdecl _ld12cvt_wrapper(int ld12cut_arg_1, int ld12cut_arg_2)
{
  return _ld12cvt(ld12cut_arg_1, ld12cut_arg_2, &dword_4994F0);
}
// 488DF1: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);
// 4994F0: using guessed type int dword_4994F0;

//----- (00488F5F) --------------------------------------------------------
int __cdecl _fassign_sub_sub_488F5F(int a1, int a2)
{
  return _ld12cvt(a1, a2, &unk_499508);
}
// 488DF1: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (00488F75) --------------------------------------------------------
int __cdecl _fassign_sub_488F75(int ld12cut_arg_2, int a2)
{
  int v3; // [esp+0h] [ebp-14h]
  int ld12cut_arg_1; // [esp+4h] [ebp-10h]

  __strgtold12(&ld12cut_arg_1, &v3, a2, 0, 0, 0, 0);
  return _ld12cvt_wrapper((int)&ld12cut_arg_1, ld12cut_arg_2);
}
// 48A1AB: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00488FB2) --------------------------------------------------------
int __cdecl _fassign_sub_488FB2(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-14h]
  int v4; // [esp+4h] [ebp-10h]

  __strgtold12(&v4, &v3, a2, 0, 0, 0, 0);
  return _fassign_sub_sub_488F5F((int)&v4, a1);
}
// 48A1AB: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0048AD5E) --------------------------------------------------------
// Unused
int Return_0()
{
  return 0;
}

//----- (0048AF52) --------------------------------------------------------
int __usercall realloc_sub_48AF52@<eax>(int a1@<ebp>)
{
  int v1; // esi
  int v2; // edi

  v1 = *(_DWORD *)(a1 + 12);
  v2 = *(_DWORD *)(a1 + 8);
  return realloc_sub_48AF5A();
}
// 48AF5A: using guessed type int realloc_sub_48AF5A(void);

//----- (0048B8F0) --------------------------------------------------------
// Unused
OrgData *Init_OrgData()
{
  return OrgData::OrgData(&orgDataObject);
}

#error "There were 2 decompilation failure(s) on 843 function(s)"
